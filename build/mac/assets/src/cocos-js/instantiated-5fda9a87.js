System.register([], function (exports, module) {
    'use strict';
    return {
        execute: function () {

            exports({
                A: void 0,
                B: void 0,
                C: void 0,
                E: void 0,
                F: void 0,
                H: void 0,
                I: void 0,
                J: void 0,
                K: void 0,
                L: void 0,
                M: void 0,
                N: void 0,
                Q: void 0,
                R: void 0,
                S: void 0,
                U: void 0,
                a: void 0,
                a$: mapBuffer,
                aH: void 0,
                aL: IsPowerOf2,
                aM: FormatSize,
                aN: FormatSurfaceSize,
                aO: GetTypeSize,
                aP: getTypedArrayConstructor,
                bB: assertIsTrue,
                bC: nextPow2,
                bD: log2,
                bI: _applyDecoratedDescriptor,
                bL: _initializerDefineProperty,
                bO: writeBuffer,
                bP: find,
                bR: Enum,
                bS: formerlySerializedAs,
                bU: type,
                bc: isPropertyPath,
                bd: isCustomPath,
                bl: errorID,
                bm: debug,
                bn: error,
                bq: void 0,
                br: void 0,
                bt: warnID,
                bu: warn,
                bv: readBuffer,
                bx: assertIsNonNullable,
                c: void 0,
                c2: void 0,
                c5: void 0,
                c6: void 0,
                c9: void 0,
                cE: void 0,
                cF: void 0,
                cK: createMap,
                cL: _getClassId,
                cN: extname,
                cO: mixin,
                cT: void 0,
                cW: ccenum,
                cj: toRadian,
                cl: genSamplerHash,
                cn: getWorldTransformUntilRoot,
                cq: void 0,
                cs: deleteTransform,
                ct: getTransform,
                cu: getWorldMatrix,
                d: void 0,
                d$: createCommonjsModule,
                d0: clamp,
                d7: void 0,
                d8: void 0,
                dD: toDegree,
                dG: constructLegacyCurveAndConvert,
                dH: void 0,
                dI: repeat,
                dJ: pseudoRandom,
                dL: randomRange,
                dM: randomRangeInt,
                dN: sign,
                dP: pingPong,
                dR: instantiate,
                dT: equals,
                dV: Eventify,
                dY: absMax,
                dZ: fastRemoveAt,
                d_: absMaxComponent,
                dc: clampf,
                dd: addon,
                de: logID,
                df: void 0,
                dm: lerp,
                dn: contains$1,
                dp: void 0,
                dt: clamp01,
                dv: void 0,
                e1: unwrapExports,
                e2: remove,
                e4: property,
                e6: degreesToRadians,
                e7: radiansToDegrees,
                e8: getError,
                eA: v4,
                eB: quat,
                eE: size,
                eF: rect,
                eG: color,
                eI: approx,
                eJ: pseudoRandomRange,
                eK: pseudoRandomRangeInt,
                eL: nextPow2$1,
                eM: inverseLerp,
                eN: enumerableProps,
                eQ: BitMask,
                eW: setDefaultLogTimes,
                eX: WorldNode3DToLocalNodeUI,
                eY: WorldNode3DToWorldNodeUI,
                e_: deserialize,
                eb: changeBasename,
                ee: void 0,
                ef: log,
                eg: mat4,
                em: isValid,
                eq: CCClass,
                et: setClassAlias,
                ey: v2,
                ez: v3,
                f: void 0,
                fV: isPropertyModifier,
                fW: isElementModifier,
                fX: isCustomTargetModifier,
                fZ: bezier,
                f_: bezierByTime,
                fd: assert,
                fe: assertID,
                ff: isDisplayStats,
                fg: setDisplayStats,
                fh: void 0,
                fu: createDefaultPipeline,
                g: void 0,
                g2: sampleAnimationCurve,
                g3: computeRatioByType,
                g5: getPathFromRoot,
                g6: void 0,
                g7: void 0,
                g8: void 0,
                ga: void 0,
                gd: waitForAmmoInstantiation,
                h: void 0,
                i: void 0,
                j: void 0,
                k: void 0,
                l: void 0,
                m: murmurhash2_32_gc,
                n: void 0,
                o: void 0,
                p: void 0,
                q: void 0,
                r: void 0,
                s: void 0,
                t: void 0,
                u: void 0,
                v: void 0,
                w: void 0,
                x: void 0,
                y: void 0,
                z: void 0
            });

            const WECHAT = exports('bs', false);
            const ALIPAY = false;
            const BAIDU = false;
            const XIAOMI = false;
            const BYTEDANCE = false;
            const OPPO = false;
            const VIVO = false;
            const HUAWEI = false;
            const COCOSPLAY = false;
            const EDITOR = exports('dy', false);
            const PREVIEW = false;
            const BUILD = true;
            const TEST = false;
            const DEBUG = true;
            const DEV = false;
            const RUNTIME_BASED = exports('ds', false);
            const MINIGAME = exports('dq', false);
            const JSB = exports('dr', true);
            const SUPPORT_JIT = true;

            const _global = typeof window === 'undefined' ? global : window;

            const legacyCC = exports('a_', {
              _global
            });
            legacyCC.internal = {};

            {
              _global.CC_BUILD = BUILD;
              _global.CC_TEST = TEST;
              _global.CC_EDITOR = EDITOR;
              _global.CC_PREVIEW = PREVIEW;
              _global.CC_DEV = DEV;
              _global.CC_DEBUG = DEBUG;
              _global.CC_JSB = JSB;
              _global.CC_BYTEDANCE = BYTEDANCE;
              _global.CC_WECHAT = WECHAT;
              _global.CC_ALIPAY = ALIPAY;
              _global.CC_XIAOMI = XIAOMI;
              _global.CC_BAIDU = BAIDU;
              _global.CC_COCOSPLAY = COCOSPLAY;
              _global.CC_HUAWEI = HUAWEI;
              _global.CC_OPPO = OPPO;
              _global.CC_VIVO = VIVO;
              _global.CC_MINIGAME = MINIGAME;
              _global.CC_RUNTIME_BASED = RUNTIME_BASED;
              _global.CC_SUPPORT_JIT = SUPPORT_JIT;
            }

            const engineVersion = exports('ej', '3.3.0');
            _global.CocosEngine = legacyCC.ENGINE_VERSION = engineVersion;
            _global.cc = legacyCC;

            var debugInfos = {
            	"1100": "Expected 'data' dict, but not found. Config file: %s",
            	"1101": "Please load the resource first : %s",
            	"1200": "cocos2d: Director: Error in gettimeofday",
            	"1204": "Running scene should not be null",
            	"1205": "The scene should not be null",
            	"1206": "loadScene: The scene index to load (%s) is out of range.",
            	"1207": "loadScene: Unknown name type to load: '%s'",
            	"1208": "loadScene: Failed to load scene '%s' because '%s' is already being loaded.",
            	"1209": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
            	"1210": "Failed to preload '%s', %s",
            	"1211": "loadScene: The scene index to load (%s) is out of range.",
            	"1212": "loadScene: Unknown name type to load: '%s'",
            	"1213": "loadScene: Failed to load scene '%s' because '%s' is already loading",
            	"1214": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
            	"1215": "Failed to preload '%s', %s",
            	"1216": "Director.runSceneImmediate: scene is not valid",
            	"1217": "Director._initOnEngineInitialized: renderer root initialization failed",
            	"1218": "Forward render pipeline initialized.",
            	"1219": "Deferred render pipeline initialized. Note that non-transparent materials with no lighting will not be rendered, such as builtin-unlit.",
            	"1300": "%s is not in the model pool and cannot be destroyed by destroyModel.",
            	"1400": "'%s' is deprecated, please use '%s' instead.",
            	"1404": "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
            	"1406": "'%s.%s' is removed",
            	"1408": "'%s' is removed",
            	"1409": "element type is wrong!",
            	"1502": "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
            	"1503": "cc.Scheduler.pauseTarget():target should be non-null",
            	"1504": "cc.Scheduler.resumeTarget():target should be non-null",
            	"1505": "cc.Scheduler.isTargetPaused():target should be non-null",
            	"1506": "warning: you CANNOT change update priority in scheduled function",
            	"1507": "scheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f",
            	"1508": "Argument callback must not be empty",
            	"1509": "Argument target must be non-nullptr",
            	"1510": "cc.Scheduler: Illegal target which doesn't have id, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
            	"1511": "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
            	"1513": "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
            	"1607": "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
            	"1619": "callback function must be non-null",
            	"1620": "interval must be positive",
            	"1623": "Set '%s' to normal node (not persist root node).",
            	"1624": "Replacing with the same sgNode",
            	"1625": "The replacement sgNode should not contain any child.",
            	"1626": "Should not set alpha via 'color', set 'opacity' please.",
            	"1627": "Not support for asynchronous creating node in SG",
            	"1632": "Node name can not include '/'.",
            	"1633": "Internal error, should not remove unknown node from parent.",
            	"1635": "reorderChild: this child is not in children list.",
            	"1636": "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
            	"1637": "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
            	"1638": "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
            	"1800": "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
            	"1801": "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
            	"1802": "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
            	"1803": "cc._EventListenerAcceleration.checkAvailable():_onAccelerationEvent must be non-nil",
            	"1900": "Invalid parameter.",
            	"2200": "Design resolution not valid",
            	"2201": "should set resolutionPolicy",
            	"2300": "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
            	"2402": "Forward pipeline startup failed!",
            	"3103": "cc.Texture.addImage(): path should be non-null",
            	"3119": "Lazy init texture with image element failed due to image loading failure: %s",
            	"3120": "Loading texture with unsupported type: '%s'. Add '%s' into 'cc.macro.SUPPORT_TEXTURE_FORMATS' please.",
            	"3121": "Can't find a texture format supported by the current platform! Please add a fallback format in the editor.",
            	"3300": "Rect width exceeds maximum margin: %s",
            	"3301": "Rect height exceeds maximum margin: %s",
            	"3500": "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
            	"3501": "Invalid listener type!",
            	"3502": "Can't set fixed priority with scene graph based listener.",
            	"3503": "Invalid parameters.",
            	"3504": "listener must be a cc.EventListener object when adding a fixed priority listener",
            	"3505": "The listener has been registered, please don't register it again.",
            	"3506": "Unsupported listener target.",
            	"3507": "Invalid scene graph priority!",
            	"3508": "If program goes here, there should be event in dispatch.",
            	"3509": "_inDispatch should be 1 here.",
            	"3510": "%s's scene graph node not contains in the parent's children",
            	"3511": "event is undefined",
            	"3512": "Event manager only support scene graph priority for ui nodes which contain UIComponent",
            	"3520": "Device Motion Event request permission: %s",
            	"3521": "Device Motion Event request permission failed: %s",
            	"3601": "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
            	"3602": "Unknown editor property '%s' in class '%s'.",
            	"3603": "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please.",
            	"3604": "Can only indicate one type attribute for %s.",
            	"3605": "The default value of %s is not instance of %s.",
            	"3606": "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
            	"3607": "The default value of %s must be an empty string.",
            	"3608": "The type of %s must be CCString, not String.",
            	"3609": "The type of %s must be CCBoolean, not Boolean.",
            	"3610": "The type of %s must be CCFloat or CCInteger, not Number.",
            	"3611": "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
            	"3612": "%s Just set the default value to 'new %s()' and it will be handled properly.",
            	"3613": "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
            	"3614": "Should not define constructor for cc.Component %s.",
            	"3615": "Each script can have at most one Component.",
            	"3616": "Should not specify class name %s for Component which defines in project.",
            	"3618": "ctor of '%s' can not be another CCClass",
            	"3623": "Can not use 'editor' attribute, '%s' not inherits from Components.",
            	"3625": "[isChildClassOf] superclass should be function type, not",
            	"3626": "Can't remove '%s' because '%s' depends on it.",
            	"3627": "Should not add renderer component (%s) to a Canvas node.",
            	"3628": "Should not add %s to a node which size is already used by its other component.",
            	"3633": "Properties function of '%s' should return an object!",
            	"3634": "Disallow to use '.' in property name",
            	"3637": "Can not declare %s.%s, it is already defined in the prototype of %s",
            	"3639": "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
            	"3640": "'%s': the setter of '%s' is already defined!",
            	"3641": "Can not construct %s because it contains object property.",
            	"3644": "Please define 'type' parameter of %s.%s as the actual constructor.",
            	"3645": "Please define 'type' parameter of %s.%s as the constructor of %s.",
            	"3646": "Unknown 'type' parameter of %s.%s：%s",
            	"3647": "The length of range array must be equal or greater than 2",
            	"3648": "Can not declare %s.%s method, it is already defined in the properties of %s.",
            	"3652": "Failed to `new %s()` under the hood, %s\nIt is used for getting default values declared in TypeScript in the first place.\nPlease ensure the constructor can be called during the script's initialization.",
            	"3653": "Please do not specifiy \"default\" attribute in decorator of \"%s\" property in \"%s\" class.\nDefault value must be initialized at their declaration:\n\n \n// Before:\n@property({\n  type: cc.SpriteFrame\n  default: null  // <--\n})\nmyProp;\n// After:\n@property({\n  type: cc.SpriteFrame\n})\nmyProp = null;   // <--",
            	"3654": "Please specifiy a default value for \"%s.%s\" property at its declaration:\n\n \n// Before:\n@property(...)\nmyProp;\n// After:\n@property(...)\nmyProp = 0;",
            	"3655": "Can not specifiy \"get\" or \"set\"  attribute in decorator for \"%s\" property in \"%s\" class.\nPlease use:\n\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}",
            	"3659": "Violation error: extending enumerations shall have non-overlaped member names or member values",
            	"3660": "You are explicitly specifying `undefined` type to cc property \"%s\" of cc class \"%s\".\nIs this intended? If not, this may indicate a circular reference.\nFor example:\n\n \n// foo.ts\nimport { _decorator } from 'cc';\nimport { Bar } from './bar';  // Given that './bar' also reference 'foo.ts'.\n                              // When importing './bar', execution of './bar' is hung on to wait execution of 'foo.ts',\n                              // the `Bar` imported here is `undefined` until './bar' finish its execution.\n                              // It leads to that\n@_decorator.ccclass           //  ↓\nexport class Foo {            //  ↓\n    @_decorator.type(Bar)     //  → is equivalent to `@_decorator.type(undefined)`\n    public bar: Bar;          // To eliminate this error, either:\n                              // - Refactor your module structure(recommended), or\n                              // - specify the type as cc class name: `@_decorator.type('Bar'/* or any name you specified for `Bar` */)`\n}",
            	"3700": "internal error: _prefab is undefined",
            	"3701": "Failed to load prefab asset for node '%s'",
            	"3800": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
            	"3801": "The node can not be made persist because it's not under root node.",
            	"3802": "The node can not be made persist because it's not in current scene.",
            	"3803": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
            	"3804": "getComponent: Type must be non-nil",
            	"3805": "Can't add component '%s' because %s already contains the same component.",
            	"3806": "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
            	"3807": "addComponent: Failed to get class '%s'",
            	"3808": "addComponent: Should not add component ('%s') when the scripts are still loading.",
            	"3809": "addComponent: The component to add must be a constructor",
            	"3810": "addComponent: The component to add must be child class of cc.Component",
            	"3811": "_addComponentAt: The component to add must be a constructor",
            	"3812": "_addComponentAt: Index out of range",
            	"3813": "removeComponent: Component must be non-nil",
            	"3814": "Argument must be non-nil",
            	"3815": "Component not owned by this entity",
            	"3816": "Node '%s' is already activating",
            	"3817": "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
            	"3818": "Failed to read or parse project.json",
            	"3819": "Warning: target element is not a DIV or CANVAS",
            	"3820": "The renderer doesn't support the renderMode %s",
            	"3821": "Cannot change hierarchy while activating or deactivating the parent.",
            	"3822": "addComponent: Cannot add any component to the scene.",
            	"3900": "Invalid clip to add",
            	"3901": "Invalid clip to remove",
            	"3902": "clip is defaultClip, set force to true to force remove clip and animation state",
            	"3903": "animation state is playing, set force to true to force stop and remove clip and animation state",
            	"3904": "motion path of target [%s] in prop [%s] frame [%s] is not valid",
            	"3905": "sprite frames must be an Array.",
            	"3906": "Can't find easing type [%s]",
            	"3907": "animator not added or already removed",
            	"3912": "already-playing",
            	"3920": "Current context does not allow root motion.",
            	"3921": "You provided a ill-formed track path. The last component of track path should be property key, or the setter should not be empty.",
            	"3923": "Root motion is ignored since root bone could not be located in animation.",
            	"3924": "Root motion is ignored since the root bone could not be located in scene.",
            	"3925": "Target of hierarchy path should be of type Node.",
            	"3926": "Node \"%s\" has no path \"%s\".",
            	"3927": "Target of component path should be of type Node.",
            	"3928": "Node \"%s\" has no component \"%s\".",
            	"3929": "Target object has no property \"%s\".",
            	"3930": "Can not decide type for untyped track: runtime binding does not provide a getter.",
            	"3931": "Can not decide type for untyped track: got a unsupported value from runtime binding.",
            	"3932": "Common targets should only target Vectors/`Size`/`Color`.",
            	"3933": "Each curve that has common target should be numeric curve and targets string property.",
            	"3934": "Misconfigured legacy curve: the first keyframe value is number but others aren't.",
            	"3935": "We don't currently support conversion of \\`CubicSplineQuatValue\\`.",
            	"4003": "Label font size can't be shirnked less than 0!",
            	"4004": "force notify all fonts loaded!",
            	"4011": "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
            	"4012": "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
            	"4013": "Sorry, lineHeight of system font not supported on JSB.",
            	"4200": "MaskType: IMAGE_STENCIL only support WebGL mode.",
            	"4201": "The alphaThreshold invalid in Canvas Mode.",
            	"4202": "The inverted invalid in Canvas Mode.",
            	"4300": "Can not found the %s page.",
            	"4301": "Can not add a page without UITransform.",
            	"4302": "Can not set the scroll view content when it hasn't UITransform or its parent hasn't UITransform.",
            	"4400": "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
            	"4500": "Graphics: There is no model in %s.",
            	"4600": "Script attached to '%s' is missing or invalid.",
            	"4700": "The dom control is not created!",
            	"4800": "unknown asset type",
            	"4901": "loadRes: should not specify the extname in %s %s",
            	"4902": "No need to release non-cached asset.",
            	"4914": "Resources url '%s' does not exist.",
            	"4915": "Pack indices and data do not match in size",
            	"4916": "Failed to download package for %s",
            	"4921": "Invalid pipe or invalid index provided!",
            	"4922": "The pipe to be inserted is already in the pipeline!",
            	"4923": "Uuid Loader: Parse asset [ %s ] failed : %s",
            	"4924": "JSON Loader: Input item doesn't contain string content",
            	"4925": "Uuid Loader: Deserialize asset [ %s ] failed : %s",
            	"4926": "Audio Downloader: no web audio context.",
            	"4927": "Audio Downloader: audio not supported on this browser!",
            	"4928": "Load %s failed!",
            	"4929": "Load Webp ( %s ) failed",
            	"4930": "Load image ( %s ) failed",
            	"4932": "Since v1.10, for any atlas (\"%s\") in the \"resources\" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.",
            	"4933": "Download Font [ %s ] failed, using Arial or system default font instead",
            	"4934": "Please assure that the full path of sub asset is correct!",
            	"4935": "Failed to skip prefab asset while deserializing PrefabInfo",
            	"5000": "You are trying to destroy a object twice or more.",
            	"5001": "object not yet destroyed",
            	"5100": "Not a plist file!",
            	"5200": "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
            	"5201": "browser don't support web audio",
            	"5202": "This feature supports WebGL render mode only.",
            	"5300": "Type of target to deserialize not matched with data: target is %s, data is %s",
            	"5301": "Can not find script '%s'",
            	"5302": "Can not find class '%s'",
            	"5303": "Failed to deserialize %s, missing _deserialize function.",
            	"5304": "Unable to deserialize version %s data.",
            	"5402": "cc.js.addon called on non-object:",
            	"5403": "cc.js.mixin: arguments must be type object:",
            	"5404": "The base class to extend from must be non-nil",
            	"5405": "The class to extend must be non-nil",
            	"5406": "Class should be extended before assigning any prototype members.",
            	"5500": "'notify' can not be used in 'get/set' !",
            	"5501": "'notify' must be used with 'default' !",
            	"5507": "The 'default' attribute of '%s.%s' must be an array",
            	"5508": "Invalid type of %s.%s",
            	"5510": "The 'type' attribute of '%s.%s' can not be 'Number', use cc.Float or cc.Integer instead please.",
            	"5511": "The 'type' attribute of '%s.%s' is undefined when loading script",
            	"5512": "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
            	"5513": "The 'default' value of '%s.%s' should not be used with a 'get' function.",
            	"5514": "The 'default' value of '%s.%s' should not be used with a 'set' function.",
            	"5515": "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
            	"5517": "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
            	"5601": "Can not get current scene.",
            	"5602": "Scene is destroyed",
            	"5603": "reference node is destroyed",
            	"5700": "no %s or %s on %s",
            	"5800": "%s.lerp not yet implemented.",
            	"5801": "%s.clone not yet implemented.",
            	"5802": "%s.equals not yet implemented.",
            	"5900": "MotionStreak only support WebGL mode.",
            	"5901": "cc.MotionStreak.getOpacity has not been supported.",
            	"5902": "cc.MotionStreak.setOpacity has not been supported.",
            	"6000": "Custom should not be false if file is not specified.",
            	"6001": "The new %s must not be NaN",
            	"6017": "Incomplete or corrupt PNG file",
            	"6018": "Invalid filter algorithm: %s",
            	"6019": "Invalid byte order value.",
            	"6020": "You forgot your towel!",
            	"6021": "Unknown Field Tag: %s",
            	"6022": "Too many bits requested",
            	"6023": "No bits requested",
            	"6024": "Cannot recover from missing StripByteCounts",
            	"6025": "Cannot handle sub-byte bits per sample",
            	"6026": "Cannot handle sub-byte bits per pixel",
            	"6027": "Palette image missing color map",
            	"6028": "Unknown Photometric Interpretation: %s",
            	"6029": "Unkown error",
            	"6030": "cc.ParticleSystem: error decoding or ungzipping textureImageData",
            	"6031": "cc.ParticleSystem: unknown image format with Data",
            	"6032": "cc.ParticleSystem.initWithDictionary() : error loading the texture",
            	"6033": "cc.ParticleSystem: not allowing create to be invoked twice with different particle system",
            	"6034": "cc.ParticleSystem: shouldn't be initialized repetitively, otherwise there will be potential leak",
            	"6400": "asset.url is not usable in core process",
            	"6402": "AssetLibrary has already been initialized!",
            	"6500": "Widget target must be one of the parent nodes of it",
            	"6600": "collider not added or already removed",
            	"6601": "Can't find testFunc for (%s, $s).",
            	"6700": "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time.",
            	"6705": "Argument must be non-nil",
            	"6706": "Priority can't be set in RenderRoot2D node",
            	"6800": "Callback of event must be non-nil",
            	"6801": "The message must be provided",
            	"6900": "The thing you want to instantiate must be an object",
            	"6901": "The thing you want to instantiate is nil",
            	"6902": "The thing you want to instantiate is destroyed",
            	"6903": "The instantiate method for given asset do not implemented",
            	"6904": "Can not instantiate array",
            	"6905": "Can not instantiate DOM element",
            	"7100": "%s already defined in Enum.",
            	"7101": "Sorry, 'cc.Enum' not available on this platform, please report this error here: <https://github.com/cocos-creator/engine/issues/new>",
            	"7200": "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
            	"7201": "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
            	"7202": "Add component TiledLayer into node failed.",
            	"7203": "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
            	"7210": "TMX Hexa zOrder not supported",
            	"7211": "TMX invalid value",
            	"7215": "cocos2d: Warning: TMX Layer %s has no tiles",
            	"7216": "cocos2d: TMXFormat: Unsupported TMX version: %s",
            	"7217": "cocos2d: TMXFomat: Unsupported orientation: %s",
            	"7218": "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
            	"7219": "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
            	"7221": "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
            	"7222": "Parse %s failed.",
            	"7236": "cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
            	"7237": "cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
            	"7238": "cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
            	"7239": "cc.TMXLayer.setTileGID(): invalid gid: %s",
            	"7240": "cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
            	"7241": "cc.TiledMap.initWithXML(): Map not found. Please check the filename.",
            	"7401": "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
            	"7402": "Failed to set _animationIndex for '%s' because the index is out of range.",
            	"7501": "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
            	"7502": "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
            	"7503": "Failed to set _animationIndex for '%s' because the index is out of range.",
            	"7504": "Can not render dynamic created SkeletonData",
            	"7506": "Failed to load spine atlas '$s'",
            	"7507": "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
            	"7508": "The atlas asset of '%s' is not exists!",
            	"7509": "Spine: Animation not found: %s",
            	"7510": "Spine: Animation not found: %s",
            	"7600": "The context of RenderTexture is invalid.",
            	"7601": "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
            	"7602": "Could not attach texture to the framebuffer",
            	"7603": "clearDepth isn't supported on Cocos2d-Html5",
            	"7604": "saveToFile isn't supported on Cocos2d-Html5",
            	"7605": "newCCImage isn't supported on Cocos2d-Html5",
            	"7700": "On the web is always keep the aspect ratio",
            	"7701": "Can't know status",
            	"7702": "Video player's duration is not ready to get now!",
            	"7703": "Video Downloader: video not supported on this browser!",
            	"7800": "Web does not support loading",
            	"7801": "Web does not support query history",
            	"7802": "Web does not support query history",
            	"7803": "The current browser does not support the GoBack",
            	"7804": "The current browser does not support the GoForward",
            	"7805": "Web does not support zoom",
            	"7900": "cc.math.Matrix3.assign(): current matrix equals matIn",
            	"7901": "cc.math.mat4Assign(): pOut equals pIn",
            	"7902": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
            	"7903": "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
            	"7904": "cc.math.Matrix4.extractPlane: Invalid plane index",
            	"7905": "cc.math.mat4Assign(): pOut equals pIn",
            	"7906": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
            	"7907": "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
            	"7908": "Invalid matrix mode specified",
            	"7909": "current quaternion is an invalid value",
            	"8000": "Can't handle this field type or size",
            	"8001": "No bytes requested",
            	"8002": "Too many bytes requested",
            	"8003": "Missing StripByteCounts!",
            	"8100": "cocos2d: ERROR: Failed to compile shader:\n %s",
            	"8101": "cocos2d: ERROR: Failed to compile vertex shader",
            	"8102": "cocos2d: ERROR: Failed to compile fragment shader",
            	"8103": "cc.GLProgram.link(): Cannot link invalid program",
            	"8104": "cocos2d: ERROR: Failed to link program: %s",
            	"8105": "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
            	"8106": "Please load the resource firset : %s",
            	"8107": "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
            	"8108": "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
            	"8109": "modelView matrix is undefined.",
            	"8200": "Please set node's active instead of rigidbody's enabled.",
            	"8300": "Should only one camera exists, please check your project.",
            	"8301": "Camera does not support Canvas Mode.",
            	"8400": "Wrong type arguments, 'filePath' must be a String.",
            	"9000": "Stencil manager does not support level bigger than %d in this device.",
            	"9001": "Stencil manager is already empty, cannot pop any mask",
            	"9100": "texture size exceeds current device limits %d/%d",
            	"9300": "The current buffer beyond the limit in ui static component, please reduce the amount",
            	"9301": "The UI has not been initialized",
            	"9302": "Can't getGFXSampler with out device",
            	"9600": "[Physics]: please check to see if physics modules are included",
            	"9610": "[Physics]: cannon.js physics system doesn't support capsule collider",
            	"9611": "[Physics]: builtin physics system doesn't support mesh collider",
            	"9612": "[Physics]: builtin physics system doesn't support cylinder collider",
            	"9620": "[Physics][Ammo]: changing the mesh is not supported after the initialization is completed",
            	"10001": "The sub-mesh contains %d vertices, which beyonds the capability (%d vertices most) of renderer of your platform.",
            	"10002": "Sub-mesh may include at most %d morph targets, but you specified %d.",
            	"11000": "WebGL context lost.",
            	"12001": "BlendFactors are disabled when using custom material, please modify the blend state in the material instead.",
            	"12002": "Can't add renderable component to this node because it already have one.",
            	"12004": "SubModel can only support %d passes.",
            	"12005": "Material already initialized, request aborted.",
            	"12006": "Pass already destroyed.",
            	"12007": "This is old usage, please swap the parameters.",
            	"12100": "The font size is too big to be fitted into texture atlas. Please switch to other label cache modes or choose a smaller font size.",
            	"12101": "The asset %s has been destroyed!",
            	"13100": "Incorrect CCON magic.",
            	"13101": "Unknown CCON version number: %d.",
            	"13102": "CCON Format error.",
            	"13103": "Can not encode CCON binary: lack of text encoder.",
            	"13104": "Can not decode CCON binary: lack of text decoder.",
            	"0100": "%s not yet implemented.",
            	"0200": "You should specify a valid DOM canvas element."
            };

            let logList = null;
            let ccLog = console.log.bind(console);
            let ccWarn = ccLog;
            let ccError = ccLog;

            let ccAssert = (condition, message, ...optionalParams) => {
              if (!condition) {
                console.log(`ASSERT: ${formatString(message, ...optionalParams)}`);
              }
            };

            let ccDebug = ccLog;

            function formatString(message, ...optionalParams) {
              return legacyCC.js.formatStr.apply(null, [message].concat(optionalParams));
            }

            function log(message, ...optionalParams) {
              return ccLog(message, ...optionalParams);
            }
            function warn(message, ...optionalParams) {
              return ccWarn(message, ...optionalParams);
            }
            function error(message, ...optionalParams) {
              return ccError(message, ...optionalParams);
            }
            function assert(value, message, ...optionalParams) {
              return ccAssert(value, message, ...optionalParams);
            }
            function debug(...data) {
              return ccDebug(...data);
            }
            function _resetDebugSetting(mode) {
              ccLog = ccWarn = ccError = ccAssert = ccDebug = () => {};

              if (mode === DebugMode.NONE) {
                return;
              }

              if (mode > DebugMode.ERROR) {
                const logToWebPage = msg => {
                  if (!legacyCC.game.canvas) {
                    return;
                  }

                  if (!logList) {
                    const logDiv = document.createElement('Div');
                    logDiv.setAttribute('id', 'logInfoDiv');
                    logDiv.setAttribute('width', '200');
                    logDiv.setAttribute('height', legacyCC.game.canvas.height);
                    const logDivStyle = logDiv.style;
                    logDivStyle.zIndex = '99999';
                    logDivStyle.position = 'absolute';
                    logDivStyle.top = logDivStyle.left = '0';
                    logList = document.createElement('textarea');
                    logList.setAttribute('rows', '20');
                    logList.setAttribute('cols', '30');
                    logList.setAttribute('disabled', 'true');
                    const logListStyle = logList.style;
                    logListStyle.backgroundColor = 'transparent';
                    logListStyle.borderBottom = '1px solid #cccccc';
                    logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = '0px';
                    logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = 'none';
                    logListStyle.padding = '0px';
                    logListStyle.margin = '0px';
                    logDiv.appendChild(logList);
                    legacyCC.game.canvas.parentNode.appendChild(logDiv);
                  }

                  logList.value = `${logList.value + msg}\r\n`;
                  logList.scrollTop = logList.scrollHeight;
                };

                ccError = (message, ...optionalParams) => {
                  logToWebPage(`ERROR :  ${formatString(message, ...optionalParams)}`);
                };

                ccAssert = (condition, message, ...optionalParams) => {
                  if (!condition) {
                    logToWebPage(`ASSERT: ${formatString(message, ...optionalParams)}`);
                  }
                };

                if (mode !== DebugMode.ERROR_FOR_WEB_PAGE) {
                  ccWarn = (message, ...optionalParams) => {
                    logToWebPage(`WARN :  ${formatString(message, ...optionalParams)}`);
                  };
                }

                if (mode === DebugMode.INFO_FOR_WEB_PAGE) {
                  ccLog = (message, ...optionalParams) => {
                    logToWebPage(formatString(message, ...optionalParams));
                  };
                }
              } else if (console) {
                if (!console.error) {
                  console.error = console.log;
                }

                if (!console.warn) {
                  console.warn = console.log;
                }

                if ( console.error.bind) {
                  ccError = console.error.bind(console);
                } else {
                  ccError =  console.error ;
                }

                ccAssert = (condition, message, ...optionalParams) => {
                  if (!condition) {
                    const errorText = formatString(message, ...optionalParams);

                    {
                      throw new Error(errorText);
                    }
                  }
                };
              }

              if (mode !== DebugMode.ERROR) {
                if (console.warn.bind) {
                  ccWarn = console.warn.bind(console);
                } else {
                  ccWarn =  console.warn ;
                }
              }

              if (mode === DebugMode.INFO) {
                {
                  if (scriptEngineType === 'JavaScriptCore') {
                    ccLog = (message, ...optionalParams) => console.log.apply(console, [message, ...optionalParams]);
                  } else {
                    ccLog = console.log;
                  }
                }
              }

              if (mode <= DebugMode.VERBOSE) {
                if (typeof console.debug === 'function') {
                  const vendorDebug = console.debug.bind(console);

                  ccDebug = (...data) => vendorDebug(...data);
                }
              }
            }
            function _throw(error_) {
              {
                const stack = error_.stack;

                if (stack) {
                  error( `${error_}\n${stack}` );
                } else {
                  error(error_);
                }

                return undefined;
              }
            }

            function getTypedFormatter(type) {
              return (id, ...args) => {
                const msg =  debugInfos[id] || 'unknown id' ;

                if (args.length === 0) {
                  return msg;
                }

                return  formatString(msg, ...args) ;
              };
            }

            const logFormatter = getTypedFormatter();
            function logID(id, ...optionalParams) {
              log(logFormatter(id, ...optionalParams));
            }
            const warnFormatter = getTypedFormatter();
            function warnID(id, ...optionalParams) {
              warn(warnFormatter(id, ...optionalParams));
            }
            const errorFormatter = getTypedFormatter();
            function errorID(id, ...optionalParams) {
              error(errorFormatter(id, ...optionalParams));
            }
            const assertFormatter = getTypedFormatter();
            function assertID(condition, id, ...optionalParams) {
              if (condition) {
                return;
              }

              assert(false, assertFormatter(id, ...optionalParams));
            }
            let DebugMode;

            (function (DebugMode) {
              DebugMode[DebugMode["NONE"] = 0] = "NONE";
              DebugMode[DebugMode["VERBOSE"] = 1] = "VERBOSE";
              DebugMode[DebugMode["INFO"] = 2] = "INFO";
              DebugMode[DebugMode["WARN"] = 3] = "WARN";
              DebugMode[DebugMode["ERROR"] = 4] = "ERROR";
              DebugMode[DebugMode["INFO_FOR_WEB_PAGE"] = 5] = "INFO_FOR_WEB_PAGE";
              DebugMode[DebugMode["WARN_FOR_WEB_PAGE"] = 6] = "WARN_FOR_WEB_PAGE";
              DebugMode[DebugMode["ERROR_FOR_WEB_PAGE"] = 7] = "ERROR_FOR_WEB_PAGE";
            })(DebugMode || (DebugMode = exports('fh', {})));

            function getError(errorId, ...param) {
              return errorFormatter(errorId, ...param);
            }
            function isDisplayStats() {
              return legacyCC.profiler ? legacyCC.profiler.isShowingStats() : false;
            }
            function setDisplayStats(displayStats) {
              if (legacyCC.profiler) {
                displayStats ? legacyCC.profiler.showStats() : legacyCC.profiler.hideStats();
                legacyCC.game.config.showFPS = !!displayStats;
              }
            }

            var debug$1 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                log: log,
                warn: warn,
                error: error,
                assert: assert,
                debug: debug,
                _resetDebugSetting: _resetDebugSetting,
                _throw: _throw,
                logID: logID,
                warnID: warnID,
                errorID: errorID,
                assertID: assertID,
                get DebugMode () { return DebugMode; },
                getError: getError,
                isDisplayStats: isDisplayStats,
                setDisplayStats: setDisplayStats
            });

            let BrowserType;

            (function (BrowserType) {
              BrowserType["UNKNOWN"] = "unknown";
              BrowserType["WECHAT"] = "wechat";
              BrowserType["ANDROID"] = "androidbrowser";
              BrowserType["IE"] = "ie";
              BrowserType["EDGE"] = "edge";
              BrowserType["QQ"] = "qqbrowser";
              BrowserType["MOBILE_QQ"] = "mqqbrowser";
              BrowserType["UC"] = "ucbrowser";
              BrowserType["UCBS"] = "ucbs";
              BrowserType["BROWSER_360"] = "360browser";
              BrowserType["BAIDU_APP"] = "baiduboxapp";
              BrowserType["BAIDU"] = "baidubrowser";
              BrowserType["MAXTHON"] = "maxthon";
              BrowserType["OPERA"] = "opera";
              BrowserType["OUPENG"] = "oupeng";
              BrowserType["MIUI"] = "miuibrowser";
              BrowserType["FIREFOX"] = "firefox";
              BrowserType["SAFARI"] = "safari";
              BrowserType["CHROME"] = "chrome";
              BrowserType["LIEBAO"] = "liebao";
              BrowserType["QZONE"] = "qzone";
              BrowserType["SOUGOU"] = "sogou";
              BrowserType["HUAWEI"] = "huawei";
            })(BrowserType || (BrowserType = exports('br', {})));

            let Language;

            (function (Language) {
              Language["UNKNOWN"] = "unknown";
              Language["ENGLISH"] = "en";
              Language["CHINESE"] = "zh";
              Language["FRENCH"] = "fr";
              Language["ITALIAN"] = "it";
              Language["GERMAN"] = "de";
              Language["SPANISH"] = "es";
              Language["DUTCH"] = "du";
              Language["RUSSIAN"] = "ru";
              Language["KOREAN"] = "ko";
              Language["JAPANESE"] = "ja";
              Language["HUNGARIAN"] = "hu";
              Language["PORTUGUESE"] = "pt";
              Language["ARABIC"] = "ar";
              Language["NORWEGIAN"] = "no";
              Language["POLISH"] = "pl";
              Language["TURKISH"] = "tr";
              Language["UKRAINIAN"] = "uk";
              Language["ROMANIAN"] = "ro";
              Language["BULGARIAN"] = "bg";
            })(Language || (Language = {}));

            let NetworkType;

            (function (NetworkType) {
              NetworkType[NetworkType["NONE"] = 0] = "NONE";
              NetworkType[NetworkType["LAN"] = 1] = "LAN";
              NetworkType[NetworkType["WWAN"] = 2] = "WWAN";
            })(NetworkType || (NetworkType = {}));

            let OS;

            (function (OS) {
              OS["UNKNOWN"] = "Unknown";
              OS["IOS"] = "iOS";
              OS["ANDROID"] = "Android";
              OS["WINDOWS"] = "Windows";
              OS["LINUX"] = "Linux";
              OS["OSX"] = "OS X";
              OS["OHOS"] = "OHOS";
            })(OS || (OS = exports('bq', {})));

            let Platform;

            (function (Platform) {
              Platform["UNKNOWN"] = "UNKNOWN";
              Platform["EDITOR_PAGE"] = "EDITOR_PAGE";
              Platform["EDITOR_CORE"] = "EDITOR_CORE";
              Platform["MOBILE_BROWSER"] = "MOBILE_BROWSER";
              Platform["DESKTOP_BROWSER"] = "DESKTOP_BROWSER";
              Platform["WIN32"] = "WIN32";
              Platform["ANDROID"] = "ANDROID";
              Platform["IOS"] = "IOS";
              Platform["MACOS"] = "MACOS";
              Platform["OHOS"] = "OHOS";
              Platform["WECHAT_GAME"] = "WECHAT_GAME";
              Platform["BAIDU_MINI_GAME"] = "BAIDU_MINI_GAME";
              Platform["XIAOMI_QUICK_GAME"] = "XIAOMI_QUICK_GAME";
              Platform["ALIPAY_MINI_GAME"] = "ALIPAY_MINI_GAME";
              Platform["BYTEDANCE_MINI_GAME"] = "BYTEDANCE_MINI_GAME";
              Platform["OPPO_MINI_GAME"] = "OPPO_MINI_GAME";
              Platform["VIVO_MINI_GAME"] = "VIVO_MINI_GAME";
              Platform["HUAWEI_QUICK_GAME"] = "HUAWEI_QUICK_GAME";
              Platform["COCOSPLAY"] = "COCOSPLAY";
              Platform["LINKSURE_MINI_GAME"] = "LINKSURE_MINI_GAME";
              Platform["QTT_MINI_GAME"] = "QTT_MINI_GAME";
            })(Platform || (Platform = exports('ee', {})));

            class Pool {
              constructor(ctor, elementsPerBatch) {
                this._ctor = void 0;
                this._elementsPerBatch = void 0;
                this._nextAvail = void 0;
                this._freepool = [];
                this._ctor = ctor;
                this._elementsPerBatch = Math.max(elementsPerBatch, 1);
                this._nextAvail = this._elementsPerBatch - 1;

                for (let i = 0; i < this._elementsPerBatch; ++i) {
                  this._freepool.push(ctor());
                }
              }

              alloc() {
                if (this._nextAvail < 0) {
                  const elementsPerBatch = this._elementsPerBatch;

                  for (let i = 0; i < elementsPerBatch; i++) {
                    this._freepool.push(this._ctor());
                  }

                  this._nextAvail = elementsPerBatch - 1;
                }

                const ret = this._freepool[this._nextAvail--];
                this._freepool.length--;
                return ret;
              }

              free(obj) {
                this._freepool.push(obj);

                this._nextAvail++;
              }

              freeArray(objs) {
                Array.prototype.push.apply(this._freepool, objs);
                this._nextAvail += objs.length;
              }

              destroy(dtor) {
                if (dtor) {
                  for (let i = 0; i <= this._nextAvail; i++) {
                    dtor(this._freepool[i]);
                  }
                }

                this._freepool.length = 0;
                this._nextAvail = -1;
              }

            } exports('P', Pool);

            class MutableForwardIterator {
              constructor(array) {
                this.i = 0;
                this.array = array;
              }

              get length() {
                return this.array.length;
              }

              set length(value) {
                this.array.length = value;

                if (this.i >= value) {
                  this.i = value - 1;
                }
              }

              remove(value) {
                const index = this.array.indexOf(value);

                if (index >= 0) {
                  this.removeAt(index);
                }
              }

              removeAt(i) {
                this.array.splice(i, 1);

                if (i <= this.i) {
                  --this.i;
                }
              }

              fastRemove(value) {
                const index = this.array.indexOf(value);

                if (index >= 0) {
                  this.fastRemoveAt(index);
                }
              }

              fastRemoveAt(i) {
                const array = this.array;
                array[i] = array[array.length - 1];
                --array.length;

                if (i <= this.i) {
                  --this.i;
                }
              }

              push(item) {
                this.array.push(item);
              }

            }

            function removeAt(array, index) {
              array.splice(index, 1);
            }
            function fastRemoveAt(array, index) {
              const length = array.length;

              if (index < 0 || index >= length) {
                return;
              }

              array[index] = array[length - 1];
              array.length = length - 1;
            }
            function remove(array, value) {
              const index = array.indexOf(value);

              if (index >= 0) {
                removeAt(array, index);
                return true;
              } else {
                return false;
              }
            }
            function fastRemove(array, value) {
              const index = array.indexOf(value);

              if (index >= 0) {
                array[index] = array[array.length - 1];
                --array.length;
              }
            }
            function removeIf(array, predicate) {
              const index = array.findIndex(predicate);

              if (index >= 0) {
                const value = array[index];
                removeAt(array, index);
                return value;
              }
            }
            function verifyType(array, type) {
              if (array && array.length > 0) {
                for (const item of array) {
                  if (!(item instanceof type)) {
                    logID(1300);
                    return false;
                  }
                }
              }

              return true;
            }
            function removeArray(array, removals) {
              for (let i = 0, l = removals.length; i < l; i++) {
                remove(array, removals[i]);
              }
            }
            function appendObjectsAt(array, objects, index) {
              array.splice.apply(array, [index, 0, ...objects]);
              return array;
            }
            function contains(array, value) {
              return array.indexOf(value) >= 0;
            }
            function copy(array) {
              const len = array.length;
              const cloned = new Array(len);

              for (let i = 0; i < len; i += 1) {
                cloned[i] = array[i];
              }

              return cloned;
            }

            var jsarray = /*#__PURE__*/Object.freeze({
                __proto__: null,
                removeAt: removeAt,
                fastRemoveAt: fastRemoveAt,
                remove: remove,
                fastRemove: fastRemove,
                removeIf: removeIf,
                verifyType: verifyType,
                removeArray: removeArray,
                appendObjectsAt: appendObjectsAt,
                contains: contains,
                copy: copy,
                MutableForwardIterator: MutableForwardIterator
            });

            const NonUuidMark = '.';
            class IDGenerator {
              constructor(category) {
                this.id = void 0;
                this.prefix = void 0;
                this.id = 0 | Math.random() * 998;
                this.prefix = category ? category + NonUuidMark : '';
              }

              getNewId() {

                return this.prefix + ++this.id;
              }

            }
            IDGenerator.global = new IDGenerator('global');

            const tempCIDGenerator = new IDGenerator('TmpCId.');
            const aliasesTag = typeof Symbol === 'undefined' ? '__aliases__' : Symbol('[[Aliases]]');
            const classNameTag = '__classname__';
            const classIdTag = '__cid__';
            function isNumber(object) {
              return typeof object === 'number' || object instanceof Number;
            }
            function isString(object) {
              return typeof object === 'string' || object instanceof String;
            }
            function isEmptyObject(obj) {
              for (const key in obj) {
                return false;
              }

              return true;
            }
            const value = (() => {
              const descriptor = {
                value: undefined,
                enumerable: false,
                writable: false,
                configurable: true
              };
              return (object, propertyName, value_, writable, enumerable) => {
                descriptor.value = value_;
                descriptor.writable = writable;
                descriptor.enumerable = enumerable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.value = undefined;
              };
            })();
            const getset = (() => {
              const descriptor = {
                get: undefined,
                set: undefined,
                enumerable: false
              };
              return (object, propertyName, getter, setter, enumerable = false, configurable = false) => {
                if (typeof setter === 'boolean') {
                  enumerable = setter;
                  setter = undefined;
                }

                descriptor.get = getter;
                descriptor.set = setter;
                descriptor.enumerable = enumerable;
                descriptor.configurable = configurable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.get = undefined;
                descriptor.set = undefined;
              };
            })();
            const get = (() => {
              const descriptor = {
                get: undefined,
                enumerable: false,
                configurable: false
              };
              return (object, propertyName, getter, enumerable, configurable) => {
                descriptor.get = getter;
                descriptor.enumerable = enumerable;
                descriptor.configurable = configurable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.get = undefined;
              };
            })();
            const set = (() => {
              const descriptor = {
                set: undefined,
                enumerable: false,
                configurable: false
              };
              return (object, propertyName, setter, enumerable, configurable) => {
                descriptor.set = setter;
                descriptor.enumerable = enumerable;
                descriptor.configurable = configurable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.set = undefined;
              };
            })();
            function createMap(forceDictMode) {
              const map = Object.create(null);

              if (forceDictMode) {
                const INVALID_IDENTIFIER_1 = '.';
                const INVALID_IDENTIFIER_2 = '/';
                map[INVALID_IDENTIFIER_1] = 1;
                map[INVALID_IDENTIFIER_2] = 1;
                delete map[INVALID_IDENTIFIER_1];
                delete map[INVALID_IDENTIFIER_2];
              }

              return map;
            }
            function getClassName(objOrCtor) {
              if (typeof objOrCtor === 'function') {
                const prototype = objOrCtor.prototype;

                if (prototype && prototype.hasOwnProperty(classNameTag) && prototype[classNameTag]) {
                  return prototype[classNameTag];
                }

                let retval = '';

                if (objOrCtor.name) {
                  retval = objOrCtor.name;
                }

                if (objOrCtor.toString) {
                  let arr;
                  const str = objOrCtor.toString();

                  if (str.charAt(0) === '[') {
                    arr = str.match(/\[\w+\s*(\w+)\]/);
                  } else {
                    arr = str.match(/function\s*(\w+)/);
                  }

                  if (arr && arr.length === 2) {
                    retval = arr[1];
                  }
                }

                return retval !== 'Object' ? retval : '';
              } else if (objOrCtor && objOrCtor.constructor) {
                return getClassName(objOrCtor.constructor);
              }

              return '';
            }
            function obsolete(object, obsoleted, newExpr, writable) {
              const extractPropName = /([^.]+)$/;
              const oldProp = extractPropName.exec(obsoleted)[0];
              const newProp = extractPropName.exec(newExpr)[0];

              function getter() {

                return this[newProp];
              }

              function setter(value_) {

                this[newProp] = value_;
              }

              if (writable) {
                getset(object, oldProp, getter, setter);
              } else {
                get(object, oldProp, getter);
              }
            }
            function obsoletes(obj, objName, props, writable) {
              for (const obsoleted in props) {
                const newName = props[obsoleted];
                obsolete(obj, `${objName}.${obsoleted}`, newName, writable);
              }
            }
            const REGEXP_NUM_OR_STR = /(%d)|(%s)/;
            const REGEXP_STR = /%s/;
            function formatStr(msg, ...subst) {
              if (arguments.length === 0) {
                return '';
              }

              if (subst.length === 0) {
                return `${msg}`;
              }

              const hasSubstitution = typeof msg === 'string' && REGEXP_NUM_OR_STR.test(msg);

              if (hasSubstitution) {
                for (const arg of subst) {
                  const regExpToTest = typeof arg === 'number' ? REGEXP_NUM_OR_STR : REGEXP_STR;

                  if (regExpToTest.test(msg)) {
                    const notReplaceFunction = `${arg}`;
                    msg = msg.replace(regExpToTest, notReplaceFunction);
                  } else {
                    msg += ` ${arg}`;
                  }
                }
              } else {
                for (const arg of subst) {
                  msg += ` ${arg}`;
                }
              }

              return msg;
            }
            function shiftArguments() {
              const len = arguments.length - 1;
              const args = new Array(len);

              for (let i = 0; i < len; ++i) {
                args[i] = arguments[i + 1];
              }

              return args;
            }
            function getPropertyDescriptor(object, propertyName) {
              while (object) {
                const pd = Object.getOwnPropertyDescriptor(object, propertyName);

                if (pd) {
                  return pd;
                }

                object = Object.getPrototypeOf(object);
              }

              return null;
            }

            function _copyprop(name, source, target) {
              const pd = getPropertyDescriptor(source, name);

              if (pd) {
                Object.defineProperty(target, name, pd);
              }
            }

            function addon(object, ...sources) {
              object = object || {};

              for (const source of sources) {
                if (source) {
                  if (typeof source !== 'object') {
                    errorID(5402, source);
                    continue;
                  }

                  for (const name in source) {
                    if (!(name in object)) {
                      _copyprop(name, source, object);
                    }
                  }
                }
              }

              return object;
            }
            function mixin(object, ...sources) {
              object = object || {};

              for (const source of sources) {
                if (source) {
                  if (typeof source !== 'object') {
                    errorID(5403, source);
                    continue;
                  }

                  for (const name in source) {
                    _copyprop(name, source, object);
                  }
                }
              }

              return object;
            }
            function extend(cls, base) {

              for (const p in base) {
                if (base.hasOwnProperty(p)) {
                  cls[p] = base[p];
                }
              }

              cls.prototype = Object.create(base.prototype, {
                constructor: {
                  value: cls,
                  writable: true,
                  configurable: true
                }
              });
              return cls;
            }
            function getSuper(constructor) {
              const proto = constructor.prototype;
              const dunderProto = proto && Object.getPrototypeOf(proto);
              return dunderProto && dunderProto.constructor;
            }
            function isChildClassOf(subclass, superclass) {
              if (subclass && superclass) {
                if (typeof subclass !== 'function') {
                  return false;
                }

                if (typeof superclass !== 'function') {

                  return false;
                }

                if (subclass === superclass) {
                  return true;
                }

                for (;;) {
                  subclass = getSuper(subclass);

                  if (!subclass) {
                    return false;
                  }

                  if (subclass === superclass) {
                    return true;
                  }
                }
              }

              return false;
            }
            function clear(object) {
              for (const key of Object.keys(object)) {
                delete object[key];
              }
            }

            function isTempClassId(id) {
              return typeof id !== 'string' || id.startsWith(tempCIDGenerator.prefix);
            }

            const _idToClass = createMap(true);
            const _nameToClass = createMap(true);

            function setup(tag, table) {
              return function (id, constructor) {
                if (constructor.prototype.hasOwnProperty(tag)) {
                  delete table[constructor.prototype[tag]];
                }

                value(constructor.prototype, tag, id);

                if (id) {
                  const registered = table[id];

                  if (registered && registered !== constructor) {
                    let err = `A Class already exists with the same ${tag} : "${id}".`;

                    error(err);
                  } else {
                    table[id] = constructor;
                  }
                }
              };
            }

            const _setClassId = setup('__cid__', _idToClass);
            const doSetClassName = setup('__classname__', _nameToClass);
            function setClassName(className, constructor) {
              doSetClassName(className, constructor);

              if (!constructor.prototype.hasOwnProperty(classIdTag)) {
                const id = className || tempCIDGenerator.getNewId();

                if (id) {
                  _setClassId(id, constructor);
                }
              }
            }
            function setClassAlias(target, alias) {
              const nameRegistry = _nameToClass[alias];
              const idRegistry = _idToClass[alias];
              let ok = true;

              if (nameRegistry && nameRegistry !== target) {
                error(`"${alias}" has already been set as name or alias of another class.`);
                ok = false;
              }

              if (idRegistry && idRegistry !== target) {
                error(`"${alias}" has already been set as id or alias of another class.`);
                ok = false;
              }

              if (ok) {
                let classAliases = target[aliasesTag];

                if (!classAliases) {
                  classAliases = [];
                  target[aliasesTag] = classAliases;
                }

                classAliases.push(alias);
                _nameToClass[alias] = target;
                _idToClass[alias] = target;
              }
            }
            function unregisterClass(...constructors) {
              for (const constructor of constructors) {
                const p = constructor.prototype;
                const classId = p[classIdTag];

                if (classId) {
                  delete _idToClass[classId];
                }

                const classname = p[classNameTag];

                if (classname) {
                  delete _nameToClass[classname];
                }

                const aliases = p[aliasesTag];

                if (aliases) {
                  for (let iAlias = 0; iAlias < aliases.length; ++iAlias) {
                    const alias = aliases[iAlias];
                    delete _nameToClass[alias];
                    delete _idToClass[alias];
                  }
                }
              }
            }
            function _getClassById(classId) {
              return _idToClass[classId];
            }
            function getClassByName(classname) {
              return _nameToClass[classname];
            }
            function _getClassId(obj, allowTempId) {
              allowTempId = typeof allowTempId !== 'undefined' ? allowTempId : true;
              let res;

              if (typeof obj === 'function' && obj.prototype.hasOwnProperty(classIdTag)) {
                res = obj.prototype[classIdTag];

                if (!allowTempId && ( EDITOR) && isTempClassId(res)) {
                  return '';
                }

                return res;
              }

              if (obj && obj.constructor) {
                const prototype = obj.constructor.prototype;

                if (prototype && prototype.hasOwnProperty(classIdTag)) {
                  res = obj[classIdTag];

                  if (!allowTempId && ( EDITOR) && isTempClassId(res)) {
                    return '';
                  }

                  return res;
                }
              }

              return '';
            }

            class Pool$1 {
              get() {
                return this._get();
              }

              constructor(_0, _1) {
                this.count = void 0;
                this._pool = void 0;
                this._cleanup = void 0;
                const size = _1 === undefined ? _0 : _1;
                const cleanupFunc = _1 === undefined ? null : _0;
                this.count = 0;
                this._pool = new Array(size);
                this._cleanup = cleanupFunc;
              }

              _get() {
                if (this.count > 0) {
                  --this.count;
                  const cache = this._pool[this.count];
                  this._pool[this.count] = null;
                  return cache;
                }

                return null;
              }

              put(obj) {
                const pool = this._pool;

                if (this.count < pool.length) {
                  if (this._cleanup && this._cleanup(obj) === false) {
                    return;
                  }

                  pool[this.count] = obj;
                  ++this.count;
                }
              }

              resize(length) {
                if (length >= 0) {
                  this._pool.length = length;

                  if (this.count > length) {
                    this.count = length;
                  }
                }
              }

            } exports('cP', Pool$1);

            const array = exports('dA', jsarray);
            const js = exports('c8', {
              IDGenerator,
              Pool: Pool$1,
              array: jsarray,
              isNumber,
              isString,
              isEmptyObject,
              getPropertyDescriptor,
              addon,
              mixin,
              extend,
              getSuper,
              isChildClassOf,
              clear,
              value,
              getset,
              get,
              set,
              unregisterClass,
              getClassName,
              setClassName,
              setClassAlias,
              getClassByName,

              get _registeredClassNames() {
                return { ..._nameToClass
                };
              },

              set _registeredClassNames(value) {
                clear(_nameToClass);
                Object.assign(_nameToClass, value);
              },

              get _registeredClassIds() {
                return { ..._idToClass
                };
              },

              set _registeredClassIds(value) {
                clear(_idToClass);
                Object.assign(_idToClass, value);
              },

              _getClassId,
              _setClassId,
              _getClassById,
              obsolete,
              obsoletes,
              formatStr,
              shiftArguments,
              createMap
            });
            legacyCC.js = js;

            var js$1 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                array: array,
                js: js,
                IDGenerator: IDGenerator,
                Pool: Pool$1,
                isNumber: isNumber,
                isString: isString,
                isEmptyObject: isEmptyObject,
                value: value,
                getset: getset,
                get: get,
                set: set,
                createMap: createMap,
                getClassName: getClassName,
                obsolete: obsolete,
                obsoletes: obsoletes,
                formatStr: formatStr,
                shiftArguments: shiftArguments,
                getPropertyDescriptor: getPropertyDescriptor,
                addon: addon,
                mixin: mixin,
                extend: extend,
                getSuper: getSuper,
                isChildClassOf: isChildClassOf,
                clear: clear,
                _idToClass: _idToClass,
                _nameToClass: _nameToClass,
                _setClassId: _setClassId,
                setClassName: setClassName,
                setClassAlias: setClassAlias,
                unregisterClass: unregisterClass,
                _getClassById: _getClassById,
                getClassByName: getClassByName,
                _getClassId: _getClassId
            });
            exports('eS', js$1);

            function BitMask(obj) {
              if ('__bitmask__' in obj) {
                return obj;
              }

              value(obj, '__bitmask__', null, true);
              let lastIndex = -1;
              const keys = Object.keys(obj);

              for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                let val = obj[key];

                if (val === -1) {
                  val = ++lastIndex;
                  obj[key] = val;
                } else if (typeof val === 'number') {
                  lastIndex = val;
                } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
                  continue;
                }

                const reverseKey = `${val}`;

                if (key !== reverseKey) {

                  value(obj, reverseKey, key);
                }
              }

              return obj;
            }

            BitMask.isBitMask = BitMaskType => BitMaskType && BitMaskType.hasOwnProperty('__bitmask__');

            BitMask.getList = BitMaskDef => {
              if (BitMaskDef.__bitmask__) {
                return BitMaskDef.__bitmask__;
              }

              const bitlist = BitMaskDef.__bitmask__ = [];

              for (const name in BitMaskDef) {
                const v = BitMaskDef[name];

                if (Number.isInteger(v)) {
                  bitlist.push({
                    name,
                    value: v
                  });
                }
              }

              bitlist.sort((a, b) => a.value - b.value);
              return bitlist;
            };
            legacyCC.BitMask = BitMask;

            function assertIsNonNullable(expr, message) {
              assertIsTrue(!(expr === null || expr === undefined), message);
            }
            function assertIsTrue(expr, message) {
              if ( !expr) {
                debugger;
                throw new Error(`Assertion failed: ${message !== null && message !== void 0 ? message : '<no-message>'}`);
              }
            }

            function Enum(obj) {
              if ('__enums__' in obj) {
                return obj;
              }

              value(obj, '__enums__', null, true);
              return Enum.update(obj);
            }

            Enum.update = obj => {
              let lastIndex = -1;
              const keys = Object.keys(obj);

              for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                let val = obj[key];

                if (val === -1) {
                  val = ++lastIndex;
                  obj[key] = val;
                } else if (typeof val === 'number') {
                  lastIndex = val;
                } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
                  continue;
                }

                const reverseKey = `${val}`;

                if (key !== reverseKey) {

                  value(obj, reverseKey, key);
                }
              }

              if (Array.isArray(obj.__enums__)) {
                updateList(obj);
              }

              return obj;
            };

            (function (_Enum) {})(Enum || (Enum = exports('bR', {})));

            Enum.isEnum = enumType => enumType && enumType.hasOwnProperty('__enums__');

            function assertIsEnum(enumType) {
              assertIsTrue(enumType.hasOwnProperty('__enums__'));
            }

            Enum.getList = enumType => {
              assertIsEnum(enumType);

              if (enumType.__enums__) {
                return enumType.__enums__;
              }

              return updateList(enumType);
            };

            function updateList(enumType) {
              assertIsEnum(enumType);
              const enums = enumType.__enums__ || [];
              enums.length = 0;

              for (const name in enumType) {
                const v = enumType[name];

                if (Number.isInteger(v)) {
                  enums.push({
                    name,
                    value: v
                  });
                }
              }

              enums.sort((a, b) => a.value - b.value);
              enumType.__enums__ = enums;
              return enums;
            }

            function ccenum(enumType) {
              if (!('__enums__' in enumType)) {
                value(enumType, '__enums__', null, true);
              }
            }
            legacyCC.Enum = Enum;

            class ValueType {
              clone() {
                errorID(100, `${getClassName(this)}.clone`);
                return this;
              }

              equals(other) {
                return false;
              }

              set(other) {
                errorID(100, `${getClassName(this)}.set`);
              }

              toString() {
                return `${{}}`;
              }

            } exports('eR', ValueType);
            setClassName('cc.ValueType', ValueType);
            legacyCC.ValueType = ValueType;

            const SUPPORT_TEXTURE_FORMATS = ['.astc', '.pkm', '.pvr', '.webp', '.jpg', '.jpeg', '.bmp', '.png'];
            const KEY = {
              none: 0,
              back: 6,
              menu: 18,
              backspace: 8,
              tab: 9,
              enter: 13,
              shift: 16,
              ctrl: 17,
              alt: 18,
              pause: 19,
              capslock: 20,
              escape: 27,
              space: 32,
              pageup: 33,
              pagedown: 34,
              end: 35,
              home: 36,
              left: 37,
              up: 38,
              right: 39,
              down: 40,
              select: 41,
              insert: 45,
              Delete: 46,
              0: 48,
              1: 49,
              2: 50,
              3: 51,
              4: 52,
              5: 53,
              6: 54,
              7: 55,
              8: 56,
              9: 57,
              a: 65,
              b: 66,
              c: 67,
              d: 68,
              e: 69,
              f: 70,
              g: 71,
              h: 72,
              i: 73,
              j: 74,
              k: 75,
              l: 76,
              m: 77,
              n: 78,
              o: 79,
              p: 80,
              q: 81,
              r: 82,
              s: 83,
              t: 84,
              u: 85,
              v: 86,
              w: 87,
              x: 88,
              y: 89,
              z: 90,
              num0: 96,
              num1: 97,
              num2: 98,
              num3: 99,
              num4: 100,
              num5: 101,
              num6: 102,
              num7: 103,
              num8: 104,
              num9: 105,
              '*': 106,
              '+': 107,
              '-': 109,
              numdel: 110,
              '/': 111,
              f1: 112,
              f2: 113,
              f3: 114,
              f4: 115,
              f5: 116,
              f6: 117,
              f7: 118,
              f8: 119,
              f9: 120,
              f10: 121,
              f11: 122,
              f12: 123,
              numlock: 144,
              scrolllock: 145,
              ';': 186,
              semicolon: 186,
              equal: 187,
              '=': 187,
              ',': 188,
              comma: 188,
              dash: 189,
              '.': 190,
              period: 190,
              forwardslash: 191,
              grave: 192,
              '[': 219,
              openbracket: 219,
              backslash: 220,
              ']': 221,
              closebracket: 221,
              quote: 222,
              dpadLeft: 1000,
              dpadRight: 1001,
              dpadUp: 1003,
              dpadDown: 1004,
              dpadCenter: 1005
            };
            const macro = exports('bo', {
              SUPPORT_TEXTURE_FORMATS,
              KEY,
              RAD: Math.PI / 180,
              DEG: 180 / Math.PI,
              REPEAT_FOREVER: Number.MAX_VALUE - 1,
              FLT_EPSILON: 0.0000001192092896,
              ORIENTATION_PORTRAIT: 1,
              ORIENTATION_LANDSCAPE: 2,
              ORIENTATION_AUTO: 3,
              ENABLE_TILEDMAP_CULLING: true,
              TOUCH_TIMEOUT: 5000,
              ENABLE_TRANSPARENT_CANVAS: false,
              ENABLE_WEBGL_ANTIALIAS: true,
              CLEANUP_IMAGE_CACHE: false,
              ENABLE_MULTI_TOUCH: true,
              MAX_LABEL_CANVAS_POOL_SIZE: 20
            });
            legacyCC.macro = macro;

            const BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
            const BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            const values = new Array(123);

            for (let i = 0; i < 123; ++i) {
              values[i] = 64;
            }

            for (let i = 0; i < 64; ++i) {
              values[BASE64_KEYS.charCodeAt(i)] = i;
            }

            const BASE64_VALUES = values;
            function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
              function define(np, propName, getter, setter) {
                const pd = Object.getOwnPropertyDescriptor(np, propName);

                if (pd) {
                  if (pd.get) {
                    np[getter] = pd.get;
                  }

                  if (pd.set && setter) {
                    np[setter] = pd.set;
                  }
                } else {
                  const getterFunc = np[getter];

                  {
                    getset(np, propName, getterFunc, np[setter]);
                  }
                }
              }

              let propName;
              const np = ctor.prototype;

              for (let i = 0; i < sameNameGetSets.length; i++) {
                propName = sameNameGetSets[i];
                const suffix = propName[0].toUpperCase() + propName.slice(1);
                define(np, propName, `get${suffix}`, `set${suffix}`);
              }

              for (propName in diffNameGetSets) {
                const gs = diffNameGetSets[propName];
                define(np, propName, gs[0], gs[1]);
              }
            }
            function pushToMap(map, key, value, pushFront) {
              const exists = map[key];

              if (exists) {
                if (Array.isArray(exists)) {
                  if (pushFront) {
                    exists.push(exists[0]);
                    exists[0] = value;
                  } else {
                    exists.push(value);
                  }
                } else {
                  map[key] = pushFront ? [value, exists] : [exists, value];
                }
              } else {
                map[key] = value;
              }
            }
            function contains$1(refNode, otherNode) {
              if (typeof refNode.contains === 'function') {
                return refNode.contains(otherNode);
              } else if (typeof refNode.compareDocumentPosition === 'function') {
                return !!(refNode.compareDocumentPosition(otherNode) & 16);
              } else {
                let node = otherNode.parentNode;

                if (node) {
                  do {
                    if (node === refNode) {
                      return true;
                    } else {
                      node = node.parentNode;
                    }
                  } while (node !== null);
                }

                return false;
              }
            }
            function isDomNode(obj) {
              if (typeof window === 'object' && typeof Node === 'function') {
                return obj instanceof Node;
              } else {
                return obj && typeof obj === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
              }
            }
            function callInNextTick(callback, p1, p2) {
              if (callback) {
                setTimeout(() => {
                  callback(p1, p2);
                }, 0);
              }
            }
            function tryCatchFunctor_EDITOR(funcName) {
              return Function('target', `${'try {\n' + '  target.'}${funcName}();\n` + `}\n` + `catch (e) {\n` + `  cc._throw(e);\n` + `}`);
            }
            function isPlainEmptyObj_DEV(obj) {
              if (!obj || obj.constructor !== Object) {
                return false;
              }

              return isEmptyObject(obj);
            }
            function clampf(value, min_inclusive, max_inclusive) {
              if (min_inclusive > max_inclusive) {
                const temp = min_inclusive;
                min_inclusive = max_inclusive;
                max_inclusive = temp;
              }

              return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
            }
            function degreesToRadians(angle) {
              return angle * macro.RAD;
            }
            function radiansToDegrees(angle) {
              return angle * macro.DEG;
            }
            legacyCC.misc = {
              BUILTIN_CLASSID_RE,
              BASE64_VALUES,
              propertyDefine,
              pushToMap,
              contains: contains$1,
              isDomNode,
              callInNextTick,
              isPlainEmptyObj_DEV,
              clampf,
              degreesToRadians,
              radiansToDegrees
            };

            var misc = /*#__PURE__*/Object.freeze({
                __proto__: null,
                BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
                BASE64_VALUES: BASE64_VALUES,
                propertyDefine: propertyDefine,
                pushToMap: pushToMap,
                contains: contains$1,
                isDomNode: isDomNode,
                callInNextTick: callInNextTick,
                tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
                isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
                clampf: clampf,
                degreesToRadians: degreesToRadians,
                radiansToDegrees: radiansToDegrees
            });
            exports('eT', misc);

            const DELIMETER = '$_$';
            function createAttrsSingle(owner, superAttrs) {
              const attrs = superAttrs ? Object.create(superAttrs) : {};
              value(owner, '__attrs__', attrs);
              return attrs;
            }
            function createAttrs(subclass) {
              if (typeof subclass !== 'function') {
                const instance = subclass;
                return createAttrsSingle(instance, getClassAttrs(instance.constructor));
              }

              let superClass;
              const chains = legacyCC.Class.getInheritanceChain(subclass);

              for (let i = chains.length - 1; i >= 0; i--) {
                const cls = chains[i];

                const attrs = cls.hasOwnProperty('__attrs__') && cls.__attrs__;

                if (!attrs) {
                  superClass = chains[i + 1];
                  createAttrsSingle(cls, superClass && superClass.__attrs__);
                }
              }

              superClass = chains[0];
              createAttrsSingle(subclass, superClass && superClass.__attrs__);
              return subclass.__attrs__;
            }
            function attr(constructor, propertyName) {
              const attrs = getClassAttrs(constructor);
              const prefix = propertyName + DELIMETER;
              const ret = {};

              for (const key in attrs) {
                if (key.startsWith(prefix)) {
                  ret[key.slice(prefix.length)] = attrs[key];
                }
              }

              return ret;
            }
            function getClassAttrs(constructor) {
              return constructor.hasOwnProperty('__attrs__') && constructor.__attrs__ || createAttrs(constructor);
            }
            function setClassAttr(ctor, propName, key, value) {
              getClassAttrs(ctor)[propName + DELIMETER + key] = value;
            }
            class PrimitiveType {
              constructor(name, defaultValue) {
                this.name = void 0;
                this.default = void 0;
                this.name = name;
                this.default = defaultValue;
              }

              toString() {
                return this.name;
              }

            }
            const CCInteger = exports('eo', new PrimitiveType('Integer', 0));
            legacyCC.Integer = CCInteger;
            legacyCC.CCInteger = CCInteger;
            const CCFloat = exports('f0', new PrimitiveType('Float', 0.0));
            legacyCC.Float = CCFloat;
            legacyCC.CCFloat = CCFloat;

            const CCBoolean = exports('el', new PrimitiveType('Boolean', false));
            legacyCC.Boolean = CCBoolean;
            legacyCC.CCBoolean = CCBoolean;
            const CCString = exports('c7', new PrimitiveType('String', ''));
            legacyCC.String = CCString;
            legacyCC.CCString = CCString;
            function getTypeChecker_ET(type, attributeName) {
              return function (constructor, mainPropertyName) {
                const propInfo = `"${getClassName(constructor)}.${mainPropertyName}"`;
                const mainPropAttrs = attr(constructor, mainPropertyName);
                let mainPropAttrsType = mainPropAttrs.type;

                if (mainPropAttrsType === CCInteger || mainPropAttrsType === CCFloat) {
                  mainPropAttrsType = 'Number';
                } else if (mainPropAttrsType === CCString || mainPropAttrsType === CCBoolean) {
                  mainPropAttrsType = `${mainPropAttrsType}`;
                }

                if (mainPropAttrsType !== type) {
                  warnID(3604, propInfo);
                  return;
                }

                if (!mainPropAttrs.hasOwnProperty('default')) {
                  return;
                }

                const defaultVal = mainPropAttrs.default;

                if (typeof defaultVal === 'undefined') {
                  return;
                }

                const isContainer = Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal);

                if (isContainer) {
                  return;
                }

                const defaultType = typeof defaultVal;
                const type_lowerCase = type.toLowerCase();

                if (defaultType === type_lowerCase) {
                  if (type_lowerCase === 'object') {
                    if (defaultVal && !(defaultVal instanceof mainPropAttrs.ctor)) {
                      warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
                    } else {
                      return;
                    }
                  } else if (type !== 'Number') {
                    warnID(3606, attributeName, propInfo, type);
                  }
                } else if (defaultType !== 'function') {
                  if (type === CCString.default && defaultVal == null) {
                    warnID(3607, propInfo);
                  } else {
                    warnID(3611, attributeName, propInfo, defaultType);
                  }
                } else {
                  return;
                }

                delete mainPropAttrs.type;
              };
            }
            function getObjTypeChecker_ET(typeCtor) {
              return function (classCtor, mainPropName) {
                getTypeChecker_ET('Object', 'type')(classCtor, mainPropName);
                const defaultDef = getClassAttrs(classCtor)[`${mainPropName + DELIMETER}default`];
                const defaultVal = legacyCC.Class.getDefault(defaultDef);

                if (!Array.isArray(defaultVal) && isChildClassOf(typeCtor, legacyCC.ValueType)) {
                  const typename = getClassName(typeCtor);
                  const info = formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', getClassName(classCtor), mainPropName, typename);

                  if (defaultDef) {
                    log(info);
                  } else {
                    warnID(3612, info, typename, getClassName(classCtor), mainPropName, typename);
                  }
                }
              };
            }

            var attributeUtils = /*#__PURE__*/Object.freeze({
                __proto__: null,
                DELIMETER: DELIMETER,
                createAttrsSingle: createAttrsSingle,
                createAttrs: createAttrs,
                attr: attr,
                getClassAttrs: getClassAttrs,
                setClassAttr: setClassAttr,
                PrimitiveType: PrimitiveType,
                CCInteger: CCInteger,
                CCFloat: CCFloat,
                CCBoolean: CCBoolean,
                CCString: CCString,
                getTypeChecker_ET: getTypeChecker_ET,
                getObjTypeChecker_ET: getObjTypeChecker_ET
            });

            const SerializableAttrs = {
              default: {},
              serializable: {},
              editorOnly: {},
              formerlySerializedAs: {}
            };

            function parseNotify(val, propName, notify, properties) {
              if (val.get || val.set) {

                return;
              }

              if (val.hasOwnProperty('default')) {
                const newKey = `_N$${propName}`;

                val.get = function () {
                  return this[newKey];
                };

                val.set = function (value) {
                  const oldValue = this[newKey];
                  this[newKey] = value;
                  notify.call(this, oldValue);
                };

                const newValue = {};
                properties[newKey] = newValue;

                for (const attr in SerializableAttrs) {
                  const v = SerializableAttrs[attr];

                  if (val.hasOwnProperty(attr)) {
                    newValue[attr] = val[attr];

                    if (!v.canUsedInGet) {
                      delete val[attr];
                    }
                  }
                }
              }
            }

            function parseType(val, type, className, propName) {

              if (Array.isArray(type)) {

                if (type.length > 0) {
                  val.type = type = type[0];
                } else {
                  return errorID(5508, className, propName);
                }
              }

              if (typeof type === 'function') {
                if (type === String) {
                  val.type = legacyCC.String;
                } else if (type === Boolean) {
                  val.type = legacyCC.Boolean;
                } else if (type === Number) {
                  val.type = legacyCC.Float;
                }
              }
            }

            function _wrapOptions(isGetset, _default, type) {
              const res = isGetset ? {
                _short: true
              } : {
                _short: true,
                default: _default
              };

              if (type) {
                res.type = type;
              }

              return res;
            }

            function getFullFormOfProperty(options, isGetset) {
              const isLiteral = options && options.constructor === Object;

              if (!isLiteral) {
                if (Array.isArray(options) && options.length > 0) {
                  return _wrapOptions(isGetset, [], options);
                } else if (typeof options === 'function') {
                  const type = options;
                  return _wrapOptions(isGetset, isChildClassOf(type, legacyCC.ValueType) ? new type() : null, type);
                } else if (options instanceof PrimitiveType) {
                  return _wrapOptions(isGetset, options.default);
                } else {
                  return _wrapOptions(isGetset, options);
                }
              }

              return null;
            }
            function preprocessAttrs(properties, className, cls) {
              for (const propName in properties) {
                let val = properties[propName];
                const fullForm = getFullFormOfProperty(val, false);

                if (fullForm) {
                  val = properties[propName] = fullForm;
                }

                if (val) {

                  const notify = val.notify;

                  if (notify) {
                    {
                      parseNotify(val, propName, notify, properties);
                    }
                  }

                  if ('type' in val) {
                    parseType(val, val.type, className, propName);
                  }
                }
              }
            }

            let requiringFrames = [];
            function push(module, uuid, script, importMeta) {
              if (script === undefined) {
                script = uuid;
                uuid = '';
              }

              requiringFrames.push({
                uuid,
                script,
                module,
                exports: module.exports,
                beh: null,
                importMeta
              });
            }
            function pop() {
              const frameInfo = requiringFrames.pop();
              const module = frameInfo.module;
              let exports = module.exports;

              if (exports === frameInfo.exports) {
                for (const anykey in exports) {
                  return;
                }

                module.exports = exports = frameInfo.cls;
              }
            }
            function peek() {
              return requiringFrames[requiringFrames.length - 1];
            }
            legacyCC._RF = {
              push,
              pop,
              peek
            };

            const DELIMETER$1 = DELIMETER;

            function pushUnique(array, item) {
              if (array.indexOf(item) < 0) {
                array.push(item);
              }
            }

            const deferredInitializer = {
              datas: null,

              push(data) {
                if (this.datas) {
                  this.datas.push(data);
                } else {
                  this.datas = [data];
                  const self = this;
                  setTimeout(() => {
                    self.init();
                  }, 0);
                }
              },

              init() {
                const datas = this.datas;

                if (datas) {
                  for (let i = 0; i < datas.length; ++i) {
                    const data = datas[i];
                    const cls = data.cls;
                    let properties = data.props;

                    if (typeof properties === 'function') {
                      properties = properties();
                    }

                    const name = getClassName(cls);

                    if (properties) {
                      declareProperties(cls, name, properties, cls.$super, data.mixins);
                    } else {
                      errorID(3633, name);
                    }
                  }

                  this.datas = null;
                }
              }

            };

            function appendProp(cls, name) {

              pushUnique(cls.__props__, name);
            }

            function defineProp(cls, className, propName, val) {

              appendProp(cls, propName);
              parseAttributes(cls, val, className, propName);
            }

            function defineGetSet(cls, name, propName, val) {
              const getter = val.get;
              const setter = val.set;

              if (getter) {
                parseAttributes(cls, val, name, propName);

                setClassAttr(cls, propName, 'serializable', false);
              }
            }

            function getDefault(defaultVal) {
              if (typeof defaultVal === 'function') {
                {
                  return defaultVal();
                }
              }

              return defaultVal;
            }

            function mixinWithInherited(dest, src, filter) {
              for (const prop in src) {
                if (!dest.hasOwnProperty(prop) && (!filter || filter(prop))) {
                  Object.defineProperty(dest, prop, getPropertyDescriptor(src, prop));
                }
              }
            }

            function doDefine(className, baseClass, mixins, options) {
              const ctor = options.ctor;

              const ctors = [ctor];
              const fireClass = ctor;
              value(fireClass, '__ctors__', ctors.length > 0 ? ctors : null, true);
              const prototype = fireClass.prototype;

              if (baseClass) {
                fireClass.$super = baseClass;
              }

              if (mixins) {
                for (let m = mixins.length - 1; m >= 0; m--) {
                  const mixin = mixins[m];
                  mixinWithInherited(prototype, mixin.prototype);

                  if (CCClass._isCCClass(mixin)) {
                    mixinWithInherited(getClassAttrs(fireClass), getClassAttrs(mixin));
                  }
                }

                prototype.constructor = fireClass;
              }

              setClassName(className, fireClass);
              return fireClass;
            }

            function define(className, baseClass, mixins, options) {
              const Component = legacyCC.Component;
              const frame = peek();

              if (frame && isChildClassOf(baseClass, Component)) {
                if (isChildClassOf(frame.cls, Component)) {
                  errorID(3615);
                  return null;
                }

                className = className || frame.script;
              }

              const cls = doDefine(className, baseClass, mixins, options);

              if (frame) {
                if (isChildClassOf(baseClass, Component)) {
                  const uuid = frame.uuid;

                  if (uuid) {
                    _setClassId(uuid, cls);
                  }

                  frame.cls = cls;
                } else if (!isChildClassOf(frame.cls, Component)) {
                  frame.cls = cls;
                }
              }

              return cls;
            }

            function getNewValueTypeCodeJit(value) {
              const clsName = getClassName(value);
              const type = value.constructor;
              let res = `new ${clsName}(`;

              for (let i = 0; i < type.__props__.length; i++) {
                const prop = type.__props__[i];
                const propVal = value[prop];

                res += propVal;

                if (i < type.__props__.length - 1) {
                  res += ',';
                }
              }

              return `${res})`;
            }

            function escapeForJS(s) {
              return JSON.stringify(s).replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
            }

            const IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;

            function declareProperties(cls, className, properties, baseClass, mixins) {
              cls.__props__ = [];

              if (baseClass && baseClass.__props__) {
                cls.__props__ = baseClass.__props__.slice();
              }

              if (mixins) {
                for (let m = 0; m < mixins.length; ++m) {
                  const mixin = mixins[m];

                  if (mixin.__props__) {
                    cls.__props__ = cls.__props__.concat(mixin.__props__.filter(x => cls.__props__.indexOf(x) < 0));
                  }
                }
              }

              if (properties) {
                preprocessAttrs(properties, className);

                for (const propName in properties) {
                  const val = properties[propName];

                  if (!val.get && !val.set) {
                    defineProp(cls, className, propName, val);
                  } else {
                    defineGetSet(cls, className, propName, val);
                  }
                }
              }

              const attrs = getClassAttrs(cls);
              cls.__values__ = cls.__props__.filter(prop => attrs[`${prop + DELIMETER$1}serializable`] !== false);
            }

            function CCClass(options) {
              let name = options.name;
              const base = options.extends;
              const mixins = options.mixins;
              const cls = define(name, base, mixins, options);

              if (!name) {
                name = legacyCC.js.getClassName(cls);
              }

              cls._sealed = true;

              if (base) {
                base._sealed = false;
              }

              const properties = options.properties;

              if (typeof properties === 'function' || base && base.__props__ === null || mixins && mixins.some(x => x.__props__ === null)) {
                {
                  deferredInitializer.push({
                    cls,
                    props: properties,
                    mixins
                  });
                  cls.__props__ = cls.__values__ = null;
                }
              } else {
                declareProperties(cls, name, properties, base, options.mixins);
              }

              const editor = options.editor;

              if (editor) {
                if (isChildClassOf(base, legacyCC.Component)) {
                  legacyCC.Component._registerEditorProps(cls, editor);
                }
              }

              return cls;
            }

            CCClass._isCCClass = function isCCClass(constructor) {
              var _constructor$hasOwnPr;

              return constructor === null || constructor === void 0 ? void 0 : (_constructor$hasOwnPr = constructor.hasOwnProperty) === null || _constructor$hasOwnPr === void 0 ? void 0 : _constructor$hasOwnPr.call(constructor, '__ctors__');
            };

            CCClass.fastDefine = function (className, constructor, serializableFields) {
              setClassName(className, constructor);
              const props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields);
              const attrs = getClassAttrs(constructor);

              for (let i = 0; i < props.length; i++) {
                const key = props[i];
                attrs[`${key + DELIMETER$1}visible`] = false;
                attrs[`${key + DELIMETER$1}default`] = serializableFields[key];
              }
            };

            CCClass.Attr = attributeUtils;
            CCClass.attr = attr;

            function getInheritanceChain(constructor) {
              const chain = [];

              for (;;) {
                constructor = getSuper(constructor);

                if (!constructor) {
                  break;
                }

                if (constructor !== Object) {
                  chain.push(constructor);
                }
              }

              return chain;
            }

            CCClass.getInheritanceChain = getInheritanceChain;
            const PrimitiveTypes = {
              Integer: 'Number',
              Float: 'Number',
              Boolean: 'Boolean',
              String: 'String'
            };

            function parseAttributes(constructor, attributes, className, propertyName, usedInGetter) {
              let attrs = null;
              let propertyNamePrefix = '';

              function initAttrs() {
                propertyNamePrefix = propertyName + DELIMETER$1;
                return attrs = getClassAttrs(constructor);
              }

              if ('type' in attributes && typeof attributes.type === 'undefined') {
                warnID(3660, propertyName, className);
              }
              const type = attributes.type;

              if (type) {
                const primitiveType = PrimitiveTypes[type];

                if (primitiveType) {
                  (attrs || initAttrs())[`${propertyNamePrefix}type`] = type;
                } else if (type === 'Object') ; else if (typeof type === 'object') {
                    if (Enum.isEnum(type)) {
                      (attrs || initAttrs())[`${propertyNamePrefix}type`] = 'Enum';
                      attrs[`${propertyNamePrefix}enumList`] = Enum.getList(type);
                    } else if (BitMask.isBitMask(type)) {
                      (attrs || initAttrs())[`${propertyNamePrefix}type`] = 'BitMask';
                      attrs[`${propertyNamePrefix}bitmaskList`] = BitMask.getList(type);
                    } else ;
                  } else if (typeof type === 'function') {
                    (attrs || initAttrs())[`${propertyNamePrefix}type`] = 'Object';
                    attrs[`${propertyNamePrefix}ctor`] = type;
                  } else ;
              }

              if ('default' in attributes) {
                (attrs || initAttrs())[`${propertyNamePrefix}default`] = attributes.default;
              }

              const parseSimpleAttribute = (attributeName, expectType) => {
                if (attributeName in attributes) {
                  const val = attributes[attributeName];

                  if (typeof val === expectType) {
                    (attrs || initAttrs())[propertyNamePrefix + attributeName] = val;
                  }
                }
              };

              if (attributes.editorOnly) {
                {
                  (attrs || initAttrs())[`${propertyNamePrefix}editorOnly`] = true;
                }
              }

              if (attributes.__noImplicit) {
                var _attributes$serializa;

                (attrs || initAttrs())[`${propertyNamePrefix}serializable`] = (_attributes$serializa = attributes.serializable) !== null && _attributes$serializa !== void 0 ? _attributes$serializa : false;
              } else if (attributes.serializable === false) {
                {
                  (attrs || initAttrs())[`${propertyNamePrefix}serializable`] = false;
                }
              }

              parseSimpleAttribute('formerlySerializedAs', 'string');

              const range = attributes.range;

              if (range) {
                if (Array.isArray(range)) {
                  if (range.length >= 2) {
                    (attrs || initAttrs())[`${propertyNamePrefix}min`] = range[0];
                    attrs[`${propertyNamePrefix}max`] = range[1];

                    if (range.length > 2) {
                      attrs[`${propertyNamePrefix}step`] = range[2];
                    }
                  }
                }
              }

              parseSimpleAttribute('min', 'number');
              parseSimpleAttribute('max', 'number');
              parseSimpleAttribute('step', 'number');
            }

            CCClass.isArray = function (defaultVal) {
              defaultVal = getDefault(defaultVal);
              return Array.isArray(defaultVal);
            };

            CCClass.getDefault = getDefault;
            CCClass.escapeForJS = escapeForJS;
            CCClass.IDENTIFIER_RE = IDENTIFIER_RE;
            CCClass.getNewValueTypeCode =  getNewValueTypeCodeJit;
            legacyCC.Class = CCClass;

            const editorExtrasTag = exports('f2', '__editorExtras__');

            const Destroyed = 1 << 0;
            const ToDestroy = 1 << 2;
            const DontSave = 1 << 3;
            const EditorOnly = 1 << 4;
            const Dirty = 1 << 5;
            const DontDestroy = 1 << 6;
            const Destroying = 1 << 7;
            const Deactivating = 1 << 8;
            const LockedInEditor = 1 << 9;
            const HideInHierarchy = 1 << 10;
            const IsOnEnableCalled = 1 << 11;
            const IsEditorOnEnableCalled = 1 << 12;
            const IsPreloadStarted = 1 << 13;
            const IsOnLoadCalled = 1 << 14;
            const IsOnLoadStarted = 1 << 15;
            const IsStartCalled = 1 << 16;
            const IsRotationLocked = 1 << 17;
            const IsScaleLocked = 1 << 18;
            const IsAnchorLocked = 1 << 19;
            const IsSizeLocked = 1 << 20;
            const IsPositionLocked = 1 << 21;
            const IsReplicated = 1 << 22;
            const PersistentMask = ~(ToDestroy | Dirty | Destroying | DontDestroy | Deactivating | IsPreloadStarted | IsOnLoadStarted | IsOnLoadCalled | IsStartCalled | IsOnEnableCalled | IsEditorOnEnableCalled | IsRotationLocked | IsScaleLocked | IsAnchorLocked | IsSizeLocked | IsPositionLocked);
            const AllHideMasks = DontSave | EditorOnly | LockedInEditor | HideInHierarchy;
            const objectsToDestroy = [];

            function compileDestruct(obj, ctor) {
              const shouldSkipId = obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component;
              const idToSkip = shouldSkipId ? '_id' : null;
              let key;
              const propsToReset = {};

              for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                  if (key === idToSkip) {
                    continue;
                  }

                  switch (typeof obj[key]) {
                    case 'string':
                      propsToReset[key] = '';
                      break;

                    case 'object':
                    case 'function':
                      propsToReset[key] = null;
                      break;
                  }
                }
              }

              if (CCClass._isCCClass(ctor)) {
                const attrs = legacyCC.Class.Attr.getClassAttrs(ctor);
                const propList = ctor.__props__;

                for (let i = 0; i < propList.length; i++) {
                  key = propList[i];
                  const attrKey = `${key + legacyCC.Class.Attr.DELIMETER}default`;

                  if (attrKey in attrs) {
                    if (shouldSkipId && key === '_id') {
                      continue;
                    }

                    switch (typeof attrs[attrKey]) {
                      case 'string':
                        propsToReset[key] = '';
                        break;

                      case 'object':
                      case 'function':
                        propsToReset[key] = null;
                        break;

                      case 'undefined':
                        propsToReset[key] = undefined;
                        break;
                    }
                  }
                }
              }

              {
                let func = '';

                for (key in propsToReset) {
                  let statement;

                  if (CCClass.IDENTIFIER_RE.test(key)) {
                    statement = `o.${key}=`;
                  } else {
                    statement = `o[${CCClass.escapeForJS(key)}]=`;
                  }

                  let val = propsToReset[key];

                  if (val === '') {
                    val = '""';
                  }

                  func += `${statement + val};\n`;
                }

                return Function('o', func);
              }
            }

            class CCObject {
              static _deferredDestroy() {
                const deleteCount = objectsToDestroy.length;

                for (let i = 0; i < deleteCount; ++i) {
                  const obj = objectsToDestroy[i];

                  if (!(obj._objFlags & Destroyed)) {
                    obj._destroyImmediate();
                  }
                }

                if (deleteCount === objectsToDestroy.length) {
                  objectsToDestroy.length = 0;
                } else {
                  objectsToDestroy.splice(0, deleteCount);
                }
              }

              constructor(name = '') {
                this._objFlags = void 0;
                this._name = void 0;
                this._name = name;
                this._objFlags = 0;
              }

              get name() {
                return this._name;
              }

              set name(value) {
                this._name = value;
              }

              set hideFlags(hideFlags) {
                const flags = hideFlags & CCObject.Flags.AllHideMasks;
                this._objFlags = this._objFlags & ~CCObject.Flags.AllHideMasks | flags;
              }

              get hideFlags() {
                return this._objFlags & CCObject.Flags.AllHideMasks;
              }

              set replicated(value) {
                if (value) {
                  this._objFlags |= IsReplicated;
                } else {
                  this._objFlags &= ~IsReplicated;
                }
              }

              get replicated() {
                return !!(this._objFlags & IsReplicated);
              }

              get isValid() {
                return !(this._objFlags & Destroyed);
              }

              destroy() {
                if (this._objFlags & Destroyed) {
                  warnID(5000);
                  return false;
                }

                if (this._objFlags & ToDestroy) {
                  return false;
                }

                this._objFlags |= ToDestroy;
                objectsToDestroy.push(this);

                return true;
              }

              _destruct() {
                const ctor = this.constructor;
                let destruct = ctor.__destruct__;

                if (!destruct) {
                  destruct = compileDestruct(this, ctor);
                  value(ctor, '__destruct__', destruct, true);
                }

                destruct(this);
              }

              _destroyImmediate() {
                if (this._objFlags & Destroyed) {
                  errorID(5000);
                  return;
                }

                if (this._onPreDestroy) {
                  this._onPreDestroy();
                }

                {
                  this._destruct();
                }

                this._objFlags |= Destroyed;
              }

            } exports('d1', CCObject);

            const prototype = CCObject.prototype;

            prototype._deserialize = null;
            prototype._onPreDestroy = null;
            CCClass.fastDefine('cc.Object', CCObject, {
              _name: '',
              _objFlags: 0,
              [editorExtrasTag]: {}
            });
            CCClass.Attr.setClassAttr(CCObject, editorExtrasTag, 'editorOnly', true);
            value(CCObject, 'Flags', {
              Destroyed,
              DontSave,
              EditorOnly,
              Dirty,
              DontDestroy,
              PersistentMask,
              Destroying,
              Deactivating,
              LockedInEditor,
              HideInHierarchy,
              AllHideMasks,
              IsPreloadStarted,
              IsOnLoadStarted,
              IsOnLoadCalled,
              IsOnEnableCalled,
              IsStartCalled,
              IsEditorOnEnableCalled,
              IsPositionLocked,
              IsRotationLocked,
              IsScaleLocked,
              IsAnchorLocked,
              IsSizeLocked
            });
            function isValid(value, strictMode) {
              if (typeof value === 'object') {
                return !!value && !(value._objFlags & (strictMode ? Destroyed | ToDestroy : Destroyed));
              } else {
                return typeof value !== 'undefined';
              }
            }
            legacyCC.isValid = isValid;

            legacyCC.Object = CCObject;

            const fastRemoveAt$1 = array.fastRemoveAt;

            function empty() {}

            class CallbackInfo {
              constructor() {
                this.callback = empty;
                this.target = undefined;
                this.once = false;
              }

              set(callback, target, once) {
                this.callback = callback || empty;
                this.target = target;
                this.once = !!once;
              }

              reset() {
                this.target = undefined;
                this.callback = empty;
                this.once = false;
              }

              check() {
                if (this.target instanceof CCObject && !isValid(this.target, true)) {
                  return false;
                } else {
                  return true;
                }
              }

            }

            const callbackInfoPool = new Pool(() => new CallbackInfo(), 32);
            class CallbackList {
              constructor() {
                this.callbackInfos = [];
                this.isInvoking = false;
                this.containCanceled = false;
              }

              removeByCallback(cb) {
                for (let i = 0; i < this.callbackInfos.length; ++i) {
                  const info = this.callbackInfos[i];

                  if (info && info.callback === cb) {
                    info.reset();
                    callbackInfoPool.free(info);
                    fastRemoveAt$1(this.callbackInfos, i);
                    --i;
                  }
                }
              }

              removeByTarget(target) {
                for (let i = 0; i < this.callbackInfos.length; ++i) {
                  const info = this.callbackInfos[i];

                  if (info && info.target === target) {
                    info.reset();
                    callbackInfoPool.free(info);
                    fastRemoveAt$1(this.callbackInfos, i);
                    --i;
                  }
                }
              }

              cancel(index) {
                const info = this.callbackInfos[index];

                if (info) {
                  info.reset();

                  if (this.isInvoking) {
                    this.callbackInfos[index] = null;
                  } else {
                    fastRemoveAt$1(this.callbackInfos, index);
                  }

                  callbackInfoPool.free(info);
                }

                this.containCanceled = true;
              }

              cancelAll() {
                for (let i = 0; i < this.callbackInfos.length; i++) {
                  const info = this.callbackInfos[i];

                  if (info) {
                    info.reset();
                    callbackInfoPool.free(info);
                    this.callbackInfos[i] = null;
                  }
                }

                this.containCanceled = true;
              }

              purgeCanceled() {
                for (let i = this.callbackInfos.length - 1; i >= 0; --i) {
                  const info = this.callbackInfos[i];

                  if (!info) {
                    fastRemoveAt$1(this.callbackInfos, i);
                  }
                }

                this.containCanceled = false;
              }

              clear() {
                this.cancelAll();
                this.callbackInfos.length = 0;
                this.isInvoking = false;
                this.containCanceled = false;
              }

            }
            const MAX_SIZE = 16;
            const callbackListPool = new Pool(() => new CallbackList(), MAX_SIZE);
            class CallbacksInvoker {
              constructor() {
                this._callbackTable = createMap(true);
              }

              on(key, callback, target, once) {
                if (!this.hasEventListener(key, callback, target)) {
                  let list = this._callbackTable[key];

                  if (!list) {
                    list = this._callbackTable[key] = callbackListPool.alloc();
                  }

                  const info = callbackInfoPool.alloc();
                  info.set(callback, target, once);
                  list.callbackInfos.push(info);
                }

                return callback;
              }

              hasEventListener(key, callback, target) {
                const list = this._callbackTable && this._callbackTable[key];

                if (!list) {
                  return false;
                }

                const infos = list.callbackInfos;

                if (!callback) {
                  if (list.isInvoking) {
                    for (let i = 0; i < infos.length; ++i) {
                      if (infos[i]) {
                        return true;
                      }
                    }

                    return false;
                  } else {
                    return infos.length > 0;
                  }
                }

                for (let i = 0; i < infos.length; ++i) {
                  const info = infos[i];

                  if (info && info.check() && info.callback === callback && info.target === target) {
                    return true;
                  }
                }

                return false;
              }

              removeAll(keyOrTarget) {
                const type = typeof keyOrTarget;

                if (type === 'string' || type === 'number') {
                  const list = this._callbackTable && this._callbackTable[keyOrTarget];

                  if (list) {
                    if (list.isInvoking) {
                      list.cancelAll();
                    } else {
                      list.clear();
                      callbackListPool.free(list);
                      delete this._callbackTable[keyOrTarget];
                    }
                  }
                } else if (keyOrTarget) {
                  for (const key in this._callbackTable) {
                    const list = this._callbackTable[key];

                    if (list.isInvoking) {
                      const infos = list.callbackInfos;

                      for (let i = 0; i < infos.length; ++i) {
                        const info = infos[i];

                        if (info && info.target === keyOrTarget) {
                          list.cancel(i);
                        }
                      }
                    } else {
                      list.removeByTarget(keyOrTarget);
                    }
                  }
                }
              }

              off(key, callback, target) {
                const list = this._callbackTable && this._callbackTable[key];

                if (list) {
                  const infos = list.callbackInfos;

                  if (callback) {
                    for (let i = 0; i < infos.length; ++i) {
                      const info = infos[i];

                      if (info && info.callback === callback && info.target === target) {
                        list.cancel(i);
                        break;
                      }
                    }
                  } else {
                    this.removeAll(key);
                  }
                }
              }

              emit(key, arg0, arg1, arg2, arg3, arg4) {
                const list = this._callbackTable && this._callbackTable[key];

                if (list) {
                  const rootInvoker = !list.isInvoking;
                  list.isInvoking = true;
                  const infos = list.callbackInfos;

                  for (let i = 0, len = infos.length; i < len; ++i) {
                    const info = infos[i];

                    if (info) {
                      const callback = info.callback;
                      const target = info.target;

                      if (info.once) {
                        this.off(key, callback, target);
                      }

                      if (!info.check()) {
                        this.off(key, callback, target);
                      } else if (target) {
                        callback.call(target, arg0, arg1, arg2, arg3, arg4);
                      } else {
                        callback(arg0, arg1, arg2, arg3, arg4);
                      }
                    }
                  }

                  if (rootInvoker) {
                    list.isInvoking = false;

                    if (list.containCanceled) {
                      list.purgeCanceled();
                    }
                  }
                }
              }

              clear() {
                for (const key in this._callbackTable) {
                  const list = this._callbackTable[key];

                  if (list) {
                    list.clear();
                    callbackListPool.free(list);
                    delete this._callbackTable[key];
                  }
                }
              }

            }

            function Eventify(base) {
              class Eventified extends base {
                constructor(...args) {
                  super(...args);
                  this._callbackTable = createMap(true);
                }

                once(type, callback, target) {
                  return this.on(type, callback, target, true);
                }

                targetOff(typeOrTarget) {
                  this.removeAll(typeOrTarget);
                }

              }

              const callbacksInvokerPrototype = CallbacksInvoker.prototype;
              const propertyKeys = Object.getOwnPropertyNames(callbacksInvokerPrototype).concat(Object.getOwnPropertySymbols(callbacksInvokerPrototype));

              for (let iPropertyKey = 0; iPropertyKey < propertyKeys.length; ++iPropertyKey) {
                const propertyKey = propertyKeys[iPropertyKey];

                if (!(propertyKey in Eventified.prototype)) {
                  const propertyDescriptor = Object.getOwnPropertyDescriptor(callbacksInvokerPrototype, propertyKey);

                  if (propertyDescriptor) {
                    Object.defineProperty(Eventified.prototype, propertyKey, propertyDescriptor);
                  }
                }
              }

              return Eventified;
            }

            class Empty {}

            const EventTarget = exports('ec', Eventify(Empty));
            legacyCC.EventTarget = EventTarget;

            const networkTypeMap = {
              0: NetworkType.NONE,
              1: NetworkType.LAN,
              2: NetworkType.WWAN
            };
            const platformMap = {
              0: Platform.WIN32,
              2: Platform.MACOS,
              3: Platform.ANDROID,
              4: Platform.IOS,
              5: Platform.IOS,
              6: Platform.OHOS
            };

            class SystemInfo extends EventTarget {
              get networkType() {
                return networkTypeMap[jsb.device.getNetworkType()];
              }

              constructor() {
                super();
                this.isNative = void 0;
                this.isBrowser = void 0;
                this.isMobile = void 0;
                this.isLittleEndian = void 0;
                this.platform = void 0;
                this.language = void 0;
                this.nativeLanguage = void 0;
                this.os = void 0;
                this.osVersion = void 0;
                this.osMainVersion = void 0;
                this.browserType = void 0;
                this.browserVersion = void 0;
                this.pixelRatio = void 0;
                this.supportCapability = void 0;
                this.isNative = true;
                this.isBrowser = false;
                this.platform = platformMap[__getPlatform()];
                this.isMobile = this.platform === Platform.ANDROID || this.platform === Platform.IOS || this.platform === Platform.OHOS;

                this.isLittleEndian = (() => {
                  const buffer = new ArrayBuffer(2);
                  new DataView(buffer).setInt16(0, 256, true);
                  return new Int16Array(buffer)[0] === 256;
                })();

                const currLanguage = __getCurrentLanguageCode();

                this.nativeLanguage = currLanguage ? currLanguage.toLowerCase() : Language.UNKNOWN;
                this.language = __getCurrentLanguage();
                this.os = __getOS();
                this.osVersion = __getOSVersion();
                this.osMainVersion = parseInt(this.osVersion);
                this.browserType = BrowserType.UNKNOWN;
                this.browserVersion = '';
                this.pixelRatio = jsb.device.getDevicePixelRatio() || 1;
                this.supportCapability = {
                  webp: true,
                  gl: true,
                  canvas: true,
                  imageBitmap: false
                };

                this._registerEvent();
              }

              _registerEvent() {
                jsb.onPause = () => {
                  this.emit('hide');
                };

                jsb.onResume = () => {
                  this.emit('show');
                };

                jsb.onClose = () => {
                  this.emit('close');
                };
              }

              getBatteryLevel() {
                return jsb.device.getBatteryLevel();
              }

              triggerGC() {
                jsb.garbageCollect();
              }

              openURL(url) {
                jsb.openURL(url);
              }

              now() {
                if (Date.now) {
                  return Date.now();
                }

                return +new Date();
              }

              restartJSVM() {
                __restartVM();
              }

              close() {
                __close();
              }

            }

            const systemInfo = exports('ed', new SystemInfo());

            const INT_BITS = 32;
            const INT_MAX = exports('dQ', 0x7fffffff);
            const INT_MIN = -1 << INT_BITS - 1;
            function sign(v) {
              return (v > 0) - (v < 0);
            }
            function abs(v) {
              const mask = v >> INT_BITS - 1;
              return (v ^ mask) - mask;
            }
            function min(x, y) {
              return y ^ (x ^ y) & -(x < y);
            }
            function max(x, y) {
              return x ^ (x ^ y) & -(x < y);
            }
            function isPow2(v) {
              return !(v & v - 1) && !!v;
            }
            function log2(v) {
              let r;
              let shift;
              r = (v > 0xFFFF) << 4;
              v >>>= r;
              shift = (v > 0xFF) << 3;
              v >>>= shift;
              r |= shift;
              shift = (v > 0xF) << 2;
              v >>>= shift;
              r |= shift;
              shift = (v > 0x3) << 1;
              v >>>= shift;
              r |= shift;
              return r | v >> 1;
            }
            function log10(v) {
              return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
            }
            function popCount(v) {
              v -= v >>> 1 & 0x55555555;
              v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
              return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
            }
            function countTrailingZeros(v) {
              let c = 32;
              v &= -v;

              if (v) {
                c--;
              }

              if (v & 0x0000FFFF) {
                c -= 16;
              }

              if (v & 0x00FF00FF) {
                c -= 8;
              }

              if (v & 0x0F0F0F0F) {
                c -= 4;
              }

              if (v & 0x33333333) {
                c -= 2;
              }

              if (v & 0x55555555) {
                c -= 1;
              }

              return c;
            }
            function nextPow2(v) {
              v += v === 0;
              --v;
              v |= v >>> 1;
              v |= v >>> 2;
              v |= v >>> 4;
              v |= v >>> 8;
              v |= v >>> 16;
              return v + 1;
            }
            function prevPow2(v) {
              v |= v >>> 1;
              v |= v >>> 2;
              v |= v >>> 4;
              v |= v >>> 8;
              v |= v >>> 16;
              return v - (v >>> 1);
            }
            function parity(v) {
              v ^= v >>> 16;
              v ^= v >>> 8;
              v ^= v >>> 4;
              v &= 0xf;
              return 0x6996 >>> v & 1;
            }
            const REVERSE_TABLE = new Array(256);

            (tab => {
              for (let i = 0; i < 256; ++i) {
                let v = i;
                let r = i;
                let s = 7;

                for (v >>>= 1; v; v >>>= 1) {
                  r <<= 1;
                  r |= v & 1;
                  --s;
                }

                tab[i] = r << s & 0xff;
              }
            })(REVERSE_TABLE);

            function reverse(v) {
              return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
            }
            function interleave2(x, y) {
              x &= 0xFFFF;
              x = (x | x << 8) & 0x00FF00FF;
              x = (x | x << 4) & 0x0F0F0F0F;
              x = (x | x << 2) & 0x33333333;
              x = (x | x << 1) & 0x55555555;
              y &= 0xFFFF;
              y = (y | y << 8) & 0x00FF00FF;
              y = (y | y << 4) & 0x0F0F0F0F;
              y = (y | y << 2) & 0x33333333;
              y = (y | y << 1) & 0x55555555;
              return x | y << 1;
            }
            function deinterleave2(v, n) {
              v = v >>> n & 0x55555555;
              v = (v | v >>> 1) & 0x33333333;
              v = (v | v >>> 2) & 0x0F0F0F0F;
              v = (v | v >>> 4) & 0x00FF00FF;
              v = (v | v >>> 16) & 0x000FFFF;
              return v << 16 >> 16;
            }
            function interleave3(x, y, z) {
              x &= 0x3FF;
              x = (x | x << 16) & 4278190335;
              x = (x | x << 8) & 251719695;
              x = (x | x << 4) & 3272356035;
              x = (x | x << 2) & 1227133513;
              y &= 0x3FF;
              y = (y | y << 16) & 4278190335;
              y = (y | y << 8) & 251719695;
              y = (y | y << 4) & 3272356035;
              y = (y | y << 2) & 1227133513;
              x |= y << 1;
              z &= 0x3FF;
              z = (z | z << 16) & 4278190335;
              z = (z | z << 8) & 251719695;
              z = (z | z << 4) & 3272356035;
              z = (z | z << 2) & 1227133513;
              return x | z << 2;
            }
            function deinterleave3(v, n) {
              v = v >>> n & 1227133513;
              v = (v | v >>> 2) & 3272356035;
              v = (v | v >>> 4) & 251719695;
              v = (v | v >>> 8) & 4278190335;
              v = (v | v >>> 16) & 0x3FF;
              return v << 22 >> 22;
            }
            function nextCombination(v) {
              const t = v | v - 1;
              return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
            }

            var bits = /*#__PURE__*/Object.freeze({
                __proto__: null,
                INT_BITS: INT_BITS,
                INT_MAX: INT_MAX,
                INT_MIN: INT_MIN,
                sign: sign,
                abs: abs,
                min: min,
                max: max,
                isPow2: isPow2,
                log2: log2,
                log10: log10,
                popCount: popCount,
                countTrailingZeros: countTrailingZeros,
                nextPow2: nextPow2,
                prevPow2: prevPow2,
                parity: parity,
                reverse: reverse,
                interleave2: interleave2,
                deinterleave2: deinterleave2,
                interleave3: interleave3,
                deinterleave3: deinterleave3,
                nextCombination: nextCombination
            });
            exports('ex', bits);

            let defaultLogTimes = 10;
            function setDefaultLogTimes(times) {
              if (times > 0) {
                defaultLogTimes = times;
              }
            }
            let replaceProperty;
            let removeProperty;
            let markAsWarning;
            let replacePropertyLog;
            let markAsWarningLog;
            let removePropertyLog;
            let messageID = 0;
            const messageMap = new Map();

            replacePropertyLog = (n, dp, n2, newp, f, id, s) => {
              const item = messageMap.get(id);

              if (item && item.logTimes > item.count) {
                f(`'%s' is deprecated, please use '%s' instead. ${s}`, `${n}.${dp}`, `${n2}.${newp}`);
                item.count++;
              }
            };

            replaceProperty = exports('c5', (owner, ownerName, properties) => {
              if (owner == null) return;
              properties.forEach(item => {
                const id = messageID++;
                messageMap.set(id, {
                  id,
                  count: 0,
                  logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
                });
                const target = item.target != null ? item.target : owner;
                const newName = item.newName != null ? item.newName : item.name;
                const targetName = item.targetName != null ? item.targetName : ownerName;
                const sameTarget = target === owner;
                const suggest = item.suggest ? `(${item.suggest})` : '';

                if (item.customFunction != null) {
                  owner[item.name] = function () {
                    replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                    return item.customFunction.call(this, ...arguments);
                  };
                } else if (item.customSetter != null || item.customGetter != null) {
                  const hasSetter = item.customSetter != null;
                  const hasGetter = item.customGetter != null;

                  if (hasSetter && hasGetter) {
                    Object.defineProperty(owner, item.name, {
                      get() {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        return item.customGetter.call(this);
                      },

                      set(v) {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        item.customSetter.call(this, v);
                      },

                      enumerable: false
                    });
                  } else if (hasSetter) {
                    Object.defineProperty(owner, item.name, {
                      set(v) {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        item.customSetter.call(this, v);
                      },

                      enumerable: false
                    });
                  } else if (hasGetter) {
                    Object.defineProperty(owner, item.name, {
                      get() {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        return item.customGetter.call(this);
                      },

                      enumerable: false
                    });
                  }
                } else {
                  Object.defineProperty(owner, item.name, {
                    get() {
                      replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                      return sameTarget ? this[newName] : target[newName];
                    },

                    set(v) {
                      replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);

                      if (sameTarget) {
                        this[newName] = v;
                      } else {
                        target[newName] = v;
                      }
                    },

                    enumerable: false
                  });
                }
              });
            });

            removePropertyLog = (n, dp, f, id, s) => {
              const item = messageMap.get(id);

              if (item && item.logTimes > item.count) {
                f(`'%s' has been removed. ${s}`, `${n}.${dp}`);
                item.count++;
              }
            };

            removeProperty = exports('c6', (owner, ownerName, properties) => {
              if (owner == null) return;
              properties.forEach(item => {
                const id = messageID++;
                messageMap.set(id, {
                  id,
                  count: 0,
                  logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
                });
                const suggest = item.suggest ? `(${item.suggest})` : '';
                Object.defineProperty(owner, item.name, {
                  get() {
                    return removePropertyLog(ownerName, item.name, error, id, suggest);
                  },

                  set() {
                    removePropertyLog(ownerName, item.name, error, id, suggest);
                  },

                  enumerable: false
                });
              });
            });

            markAsWarningLog = (n, dp, f, id, s) => {
              const item = messageMap.get(id);

              if (item && item.logTimes > item.count) {
                f(`'%s' is deprecated. ${s}`, `${n}.${dp}`);
                item.count++;
              }
            };

            markAsWarning = exports('d7', (owner, ownerName, properties) => {
              if (owner == null) return;

              const _defaultGetSet = (d, n, dp, f, id, s) => {
                if (d.get) {
                  const oldGet = d.get;

                  d.get = function () {
                    markAsWarningLog(n, dp, f, id, s);
                    return oldGet.call(this);
                  };
                }

                if (d.set) {
                  const oldSet = d.set;

                  d.set = function (v) {
                    markAsWarningLog(n, dp, f, id, s);
                    oldSet.call(this, v);
                  };
                }

                Object.defineProperty(owner, dp, d);
              };

              properties.forEach(item => {
                const deprecatedProp = item.name;
                const descriptor = Object.getOwnPropertyDescriptor(owner, deprecatedProp);

                if (!descriptor || !descriptor.configurable) {
                  return;
                }

                const id = messageID++;
                messageMap.set(id, {
                  id,
                  count: 0,
                  logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
                });
                const suggest = item.suggest ? `(${item.suggest})` : '';

                if (typeof descriptor.value !== 'undefined') {
                  if (typeof descriptor.value === 'function') {
                    const oldValue = descriptor.value;

                    owner[deprecatedProp] = function () {
                      markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                      return oldValue.call(this, ...arguments);
                    };
                  } else {
                    let oldValue = descriptor.value;
                    Object.defineProperty(owner, deprecatedProp, {
                      configurable: true,

                      get() {
                        markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                        return oldValue;
                      }

                    });

                    if (descriptor.writable) {
                      Object.defineProperty(owner, deprecatedProp, {
                        set(value) {
                          markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                          oldValue = value;
                        }

                      });
                    }
                  }
                } else {
                  _defaultGetSet(descriptor, ownerName, deprecatedProp, warn, id, suggest);
                }

                Object.defineProperty(owner, deprecatedProp, {
                  enumerable: false
                });
              });
            });

            const _d2r = Math.PI / 180.0;

            const _r2d = 180.0 / Math.PI;

            const EPSILON = exports('eH', 0.000001);
            function equals(a, b) {
              return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
            }
            function approx(a, b, maxDiff) {
              maxDiff = maxDiff || EPSILON;
              return Math.abs(a - b) <= maxDiff;
            }
            function clamp(val, min, max) {
              if (min > max) {
                const temp = min;
                min = max;
                max = temp;
              }

              return val < min ? min : val > max ? max : val;
            }
            function clamp01(val) {
              return val < 0 ? 0 : val > 1 ? 1 : val;
            }
            function lerp(from, to, ratio) {
              return from + (to - from) * ratio;
            }
            function toRadian(a) {
              return a * _d2r;
            }
            function toDegree(a) {
              return a * _r2d;
            }
            const random = exports('dK', Math.random);
            function randomRange(min, max) {
              return Math.random() * (max - min) + min;
            }
            function randomRangeInt(min, max) {
              return Math.floor(randomRange(min, max));
            }
            function pseudoRandom(seed) {
              seed = (seed * 9301 + 49297) % 233280;
              return seed / 233280.0;
            }
            function pseudoRandomRange(seed, min, max) {
              return pseudoRandom(seed) * (max - min) + min;
            }
            function pseudoRandomRangeInt(seed, min, max) {
              return Math.floor(pseudoRandomRange(seed, min, max));
            }
            function nextPow2$1(val) {
              --val;
              val = val >> 1 | val;
              val = val >> 2 | val;
              val = val >> 4 | val;
              val = val >> 8 | val;
              val = val >> 16 | val;
              ++val;
              return val;
            }
            function repeat(t, length) {
              return t - Math.floor(t / length) * length;
            }
            function pingPong(t, length) {
              t = repeat(t, length * 2);
              t = length - Math.abs(t - length);
              return t;
            }
            function inverseLerp(from, to, value) {
              return (value - from) / (to - from);
            }
            function absMaxComponent(v) {
              if (Math.abs(v.x) > Math.abs(v.y)) {
                if (Math.abs(v.x) > Math.abs(v.z)) {
                  return v.x;
                } else {
                  return v.z;
                }
              } else if (Math.abs(v.y) > Math.abs(v.z)) {
                return v.y;
              } else {
                return v.z;
              }
            }
            function absMax(a, b) {
              if (Math.abs(a) > Math.abs(b)) {
                return a;
              } else {
                return b;
              }
            }
            function enumerableProps(prototype, attrs) {
              attrs.forEach(key => {
                Object.defineProperty(prototype, key, {
                  enumerable: true
                });
              });
            }

            const toFloat = 1 / 255;
            class Color extends ValueType {
              static clone(a) {
                const out = new Color();

                if (a._val) {
                  out._val = a._val;
                } else {
                  out._val = (a.a << 24 >>> 0) + (a.b << 16) + (a.g << 8) + a.r;
                }

                return out;
              }

              static copy(out, a) {
                out.r = a.r;
                out.g = a.g;
                out.b = a.b;
                out.a = a.a;
                return out;
              }

              static set(out, r, g, b, a) {
                out.r = r;
                out.g = g;
                out.b = b;
                out.a = a;
                return out;
              }

              static fromHEX(out, hexString) {
                hexString = hexString.indexOf('#') === 0 ? hexString.substring(1) : hexString;
                out.r = parseInt(hexString.substr(0, 2), 16) || 0;
                out.g = parseInt(hexString.substr(2, 2), 16) || 0;
                out.b = parseInt(hexString.substr(4, 2), 16) || 0;
                out.a = parseInt(hexString.substr(6, 2), 16) || 255;
                out._val = (out.a << 24 >>> 0) + (out.b << 16) + (out.g << 8) + out.r;
                return out;
              }

              static add(out, a, b) {
                out.r = a.r + b.r;
                out.g = a.g + b.g;
                out.b = a.b + b.b;
                out.a = a.a + b.a;
                return out;
              }

              static subtract(out, a, b) {
                out.r = a.r - b.r;
                out.g = a.g - b.g;
                out.b = a.b - b.b;
                out.a = a.a - b.a;
                return out;
              }

              static multiply(out, a, b) {
                out.r = a.r * b.r;
                out.g = a.g * b.g;
                out.b = a.b * b.b;
                out.a = a.a * b.a;
                return out;
              }

              static divide(out, a, b) {
                out.r = a.r / b.r;
                out.g = a.g / b.g;
                out.b = a.b / b.b;
                out.a = a.a / b.a;
                return out;
              }

              static scale(out, a, b) {
                out.r = a.r * b;
                out.g = a.g * b;
                out.b = a.b * b;
                out.a = a.a * b;
                return out;
              }

              static lerp(out, from, to, ratio) {
                let r = from.r;
                let g = from.g;
                let b = from.b;
                let a = from.a;
                r += (to.r - r) * ratio;
                g += (to.g - g) * ratio;
                b += (to.b - b) * ratio;
                a += (to.a - a) * ratio;
                out._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
                return out;
              }

              static toArray(out, a, ofs = 0) {
                const scale = a instanceof Color || a.a > 1 ? 1 / 255 : 1;
                out[ofs + 0] = a.r * scale;
                out[ofs + 1] = a.g * scale;
                out[ofs + 2] = a.b * scale;
                out[ofs + 3] = a.a * scale;
                return out;
              }

              static fromArray(arr, out, ofs = 0) {
                out.r = arr[ofs + 0] * 255;
                out.g = arr[ofs + 1] * 255;
                out.b = arr[ofs + 2] * 255;
                out.a = arr[ofs + 3] * 255;
                return out;
              }

              static strictEquals(a, b) {
                return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.r - b.r) <= epsilon * Math.max(1.0, Math.abs(a.r), Math.abs(b.r)) && Math.abs(a.g - b.g) <= epsilon * Math.max(1.0, Math.abs(a.g), Math.abs(b.g)) && Math.abs(a.b - b.b) <= epsilon * Math.max(1.0, Math.abs(a.b), Math.abs(b.b)) && Math.abs(a.a - b.a) <= epsilon * Math.max(1.0, Math.abs(a.a), Math.abs(b.a));
              }

              static hex(a) {
                return (a.r * 255 << 24 | a.g * 255 << 16 | a.b * 255 << 8 | a.a * 255) >>> 0;
              }

              get r() {
                return this._val & 0x000000ff;
              }

              set r(red) {
                red = ~~clamp(red, 0, 255);
                this._val = (this._val & 0xffffff00 | red) >>> 0;
              }

              get g() {
                return (this._val & 0x0000ff00) >> 8;
              }

              set g(green) {
                green = ~~clamp(green, 0, 255);
                this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
              }

              get b() {
                return (this._val & 0x00ff0000) >> 16;
              }

              set b(blue) {
                blue = ~~clamp(blue, 0, 255);
                this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
              }

              get a() {
                return (this._val & 0xff000000) >>> 24;
              }

              set a(alpha) {
                alpha = ~~clamp(alpha, 0, 255);
                this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
              }

              get x() {
                return this.r * toFloat;
              }

              set x(value) {
                this.r = value * 255;
              }

              get y() {
                return this.g * toFloat;
              }

              set y(value) {
                this.g = value * 255;
              }

              get z() {
                return this.b * toFloat;
              }

              set z(value) {
                this.b = value * 255;
              }

              get w() {
                return this.a * toFloat;
              }

              set w(value) {
                this.a = value * 255;
              }

              constructor(r, g, b, a) {
                super();
                this._val = 0;

                if (typeof r === 'string') {
                  this.fromHEX(r);
                } else if (g !== undefined) {
                  this.set(r, g, b, a);
                } else {
                  this.set(r);
                }
              }

              clone() {
                const ret = new Color();
                ret._val = this._val;
                return ret;
              }

              equals(other) {
                return other && this._val === other._val;
              }

              lerp(to, ratio) {
                let r = this.r;
                let g = this.g;
                let b = this.b;
                let a = this.a;
                r += (to.r - r) * ratio;
                g += (to.g - g) * ratio;
                b += (to.b - b) * ratio;
                a += (to.a - a) * ratio;
                this._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
                return this;
              }

              toString() {
                return `rgba(${this.r.toFixed()}, ${this.g.toFixed()}, ${this.b.toFixed()}, ${this.a.toFixed()})`;
              }

              toCSS(opt = 'rgba') {
                if (opt === 'rgba') {
                  return `rgba(${this.r},${this.g},${this.b},${(this.a * toFloat).toFixed(2)})`;
                } else if (opt === 'rgb') {
                  return `rgb(${this.r},${this.g},${this.b})`;
                } else {
                  return `#${this.toHEX(opt)}`;
                }
              }

              fromHEX(hexString) {
                hexString = hexString.indexOf('#') === 0 ? hexString.substring(1) : hexString;
                const r = parseInt(hexString.substr(0, 2), 16) || 0;
                const g = parseInt(hexString.substr(2, 2), 16) || 0;
                const b = parseInt(hexString.substr(4, 2), 16) || 0;
                const a = parseInt(hexString.substr(6, 2), 16) || 255;
                this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
                return this;
              }

              toHEX(fmt = '#rrggbb') {
                const prefix = '0';
                const hex = [(this.r < 16 ? prefix : '') + this.r.toString(16), (this.g < 16 ? prefix : '') + this.g.toString(16), (this.b < 16 ? prefix : '') + this.b.toString(16)];

                if (fmt === '#rgb') {
                  hex[0] = hex[0][0];
                  hex[1] = hex[1][0];
                  hex[2] = hex[2][0];
                } else if (fmt === '#rrggbbaa') {
                  hex.push((this.a < 16 ? prefix : '') + this.a.toString(16));
                }

                return hex.join('');
              }

              toRGBValue() {
                return this._val & 0x00ffffff;
              }

              fromHSV(h, s, v) {
                let r = 0;
                let g = 0;
                let b = 0;

                if (s === 0) {
                  r = g = b = v;
                } else if (v === 0) {
                  r = g = b = 0;
                } else {
                  if (h === 1) {
                    h = 0;
                  }

                  h *= 6;
                  const i = Math.floor(h);
                  const f = h - i;
                  const p = v * (1 - s);
                  const q = v * (1 - s * f);
                  const t = v * (1 - s * (1 - f));

                  switch (i) {
                    case 0:
                      r = v;
                      g = t;
                      b = p;
                      break;

                    case 1:
                      r = q;
                      g = v;
                      b = p;
                      break;

                    case 2:
                      r = p;
                      g = v;
                      b = t;
                      break;

                    case 3:
                      r = p;
                      g = q;
                      b = v;
                      break;

                    case 4:
                      r = t;
                      g = p;
                      b = v;
                      break;

                    case 5:
                      r = v;
                      g = p;
                      b = q;
                      break;
                  }
                }

                r *= 255;
                g *= 255;
                b *= 255;
                this._val = (this.a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
                return this;
              }

              toHSV() {
                const r = this.r * toFloat;
                const g = this.g * toFloat;
                const b = this.b * toFloat;
                const hsv = {
                  h: 0,
                  s: 0,
                  v: 0
                };
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let delta = 0;
                hsv.v = max;
                hsv.s = max ? (max - min) / max : 0;

                if (!hsv.s) {
                  hsv.h = 0;
                } else {
                  delta = max - min;

                  if (r === max) {
                    hsv.h = (g - b) / delta;
                  } else if (g === max) {
                    hsv.h = 2 + (b - r) / delta;
                  } else {
                    hsv.h = 4 + (r - g) / delta;
                  }

                  hsv.h /= 6;

                  if (hsv.h < 0) {
                    hsv.h += 1.0;
                  }
                }

                return hsv;
              }

              set(r, g, b, a) {
                if (typeof r === 'object') {
                  if (r._val != null) {
                    this._val = r._val;
                  } else {
                    g = r.g || 0;
                    b = r.b || 0;
                    a = typeof r.a === 'number' ? r.a : 255;
                    r = r.r || 0;
                    this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
                  }
                } else {
                  r = r || 0;
                  g = g || 0;
                  b = b || 0;
                  a = typeof a === 'number' ? a : 255;
                  this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
                }

                return this;
              }

              multiply(other) {
                const r = (this._val & 0x000000ff) * other.r >> 8;
                const g = (this._val & 0x0000ff00) * other.g >> 8;
                const b = (this._val & 0x00ff0000) * other.b >> 8;
                const a = ((this._val & 0xff000000) >>> 8) * other.a;
                this._val = a & 0xff000000 | b & 0x00ff0000 | g & 0x0000ff00 | r & 0x000000ff;
                return this;
              }

              _set_r_unsafe(red) {
                this._val = (this._val & 0xffffff00 | red) >>> 0;
                return this;
              }

              _set_g_unsafe(green) {
                this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
                return this;
              }

              _set_b_unsafe(blue) {
                this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
                return this;
              }

              _set_a_unsafe(alpha) {
                this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
                return this;
              }

            } exports('ce', Color);
            Color.WHITE = Object.freeze(new Color(255, 255, 255, 255));
            Color.GRAY = Object.freeze(new Color(127, 127, 127, 255));
            Color.BLACK = Object.freeze(new Color(0, 0, 0, 255));
            Color.TRANSPARENT = Object.freeze(new Color(0, 0, 0, 0));
            Color.RED = Object.freeze(new Color(255, 0, 0, 255));
            Color.GREEN = Object.freeze(new Color(0, 255, 0, 255));
            Color.BLUE = Object.freeze(new Color(0, 0, 255, 255));
            Color.CYAN = Object.freeze(new Color(0, 255, 255, 255));
            Color.MAGENTA = Object.freeze(new Color(255, 0, 255, 255));
            Color.YELLOW = Object.freeze(new Color(255, 255, 0, 255));
            CCClass.fastDefine('cc.Color', Color, {
              r: 0,
              g: 0,
              b: 0,
              a: 255
            });
            legacyCC.Color = Color;
            function color(r, g, b, a) {
              return new Color(r, g, b, a);
            }
            legacyCC.color = color;

            const MATH_FLOAT_ARRAY = exports('eO',  Float32Array );
            class MathBase extends ValueType {
              static createFloatArray(size) {
                return new MATH_FLOAT_ARRAY(size);
              }

              get array() {
                return this._array;
              }

            } exports('eP', MathBase);

            class Vec3 extends MathBase {
              static zero(out) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                return out;
              }

              static clone(a) {
                return new Vec3(a.x, a.y, a.z);
              }

              static copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                return out;
              }

              static set(out, x, y, z) {
                out.x = x;
                out.y = y;
                out.z = z;
                return out;
              }

              static add(out, a, b) {
                out.x = a.x + b.x;
                out.y = a.y + b.y;
                out.z = a.z + b.z;
                return out;
              }

              static subtract(out, a, b) {
                out.x = a.x - b.x;
                out.y = a.y - b.y;
                out.z = a.z - b.z;
                return out;
              }

              static multiply(out, a, b) {
                out.x = a.x * b.x;
                out.y = a.y * b.y;
                out.z = a.z * b.z;
                return out;
              }

              static divide(out, a, b) {
                out.x = a.x / b.x;
                out.y = a.y / b.y;
                out.z = a.z / b.z;
                return out;
              }

              static ceil(out, a) {
                out.x = Math.ceil(a.x);
                out.y = Math.ceil(a.y);
                out.z = Math.ceil(a.z);
                return out;
              }

              static floor(out, a) {
                out.x = Math.floor(a.x);
                out.y = Math.floor(a.y);
                out.z = Math.floor(a.z);
                return out;
              }

              static min(out, a, b) {
                out.x = Math.min(a.x, b.x);
                out.y = Math.min(a.y, b.y);
                out.z = Math.min(a.z, b.z);
                return out;
              }

              static max(out, a, b) {
                out.x = Math.max(a.x, b.x);
                out.y = Math.max(a.y, b.y);
                out.z = Math.max(a.z, b.z);
                return out;
              }

              static round(out, a) {
                out.x = Math.round(a.x);
                out.y = Math.round(a.y);
                out.z = Math.round(a.z);
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                out.z = a.z * b;
                return out;
              }

              static scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                out.z = a.z + b.z * scale;
                return out;
              }

              static distance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                const z = b.z - a.z;
                return Math.sqrt(x * x + y * y + z * z);
              }

              static squaredDistance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                const z = b.z - a.z;
                return x * x + y * y + z * z;
              }

              static len(a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                return Math.sqrt(x * x + y * y + z * z);
              }

              static lengthSqr(a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                return x * x + y * y + z * z;
              }

              static negate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                out.z = -a.z;
                return out;
              }

              static invert(out, a) {
                out.x = 1.0 / a.x;
                out.y = 1.0 / a.y;
                out.z = 1.0 / a.z;
                return out;
              }

              static invertSafe(out, a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;

                if (Math.abs(x) < EPSILON) {
                  out.x = 0;
                } else {
                  out.x = 1.0 / x;
                }

                if (Math.abs(y) < EPSILON) {
                  out.y = 0;
                } else {
                  out.y = 1.0 / y;
                }

                if (Math.abs(z) < EPSILON) {
                  out.z = 0;
                } else {
                  out.z = 1.0 / z;
                }

                return out;
              }

              static normalize(out, a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                let len = x * x + y * y + z * z;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  out.x = x * len;
                  out.y = y * len;
                  out.z = z * len;
                }

                return out;
              }

              static dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z;
              }

              static cross(out, a, b) {
                const {
                  x: ax,
                  y: ay,
                  z: az
                } = a;
                const {
                  x: bx,
                  y: by,
                  z: bz
                } = b;
                out.x = ay * bz - az * by;
                out.y = az * bx - ax * bz;
                out.z = ax * by - ay * bx;
                return out;
              }

              static lerp(out, a, b, t) {
                out.x = a.x + t * (b.x - a.x);
                out.y = a.y + t * (b.y - a.y);
                out.z = a.z + t * (b.z - a.z);
                return out;
              }

              static random(out, scale) {
                scale = scale || 1.0;
                const phi = random() * 2.0 * Math.PI;
                const cosTheta = random() * 2 - 1;
                const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                out.x = sinTheta * Math.cos(phi) * scale;
                out.y = sinTheta * Math.sin(phi) * scale;
                out.z = cosTheta * scale;
                return out;
              }

              static transformMat4(out, a, m) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                let rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
                rhw = rhw ? Math.abs(1 / rhw) : 1;
                out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw;
                out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw;
                out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw;
                return out;
              }

              static transformMat4Normal(out, a, m) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                let rhw = m.m03 * x + m.m07 * y + m.m11 * z;
                rhw = rhw ? Math.abs(1 / rhw) : 1;
                out.x = (m.m00 * x + m.m04 * y + m.m08 * z) * rhw;
                out.y = (m.m01 * x + m.m05 * y + m.m09 * z) * rhw;
                out.z = (m.m02 * x + m.m06 * y + m.m10 * z) * rhw;
                return out;
              }

              static transformMat3(out, a, m) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                out.x = x * m.m00 + y * m.m03 + z * m.m06;
                out.y = x * m.m01 + y * m.m04 + z * m.m07;
                out.z = x * m.m02 + y * m.m05 + z * m.m08;
                return out;
              }

              static transformAffine(out, v, m) {
                const x = v.x;
                const y = v.y;
                const z = v.z;
                out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12;
                out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13;
                out.x = m.m02 * x + m.m06 * y + m.m10 * z + m.m14;
                return out;
              }

              static transformQuat(out, a, q) {
                const ix = q.w * a.x + q.y * a.z - q.z * a.y;
                const iy = q.w * a.y + q.z * a.x - q.x * a.z;
                const iz = q.w * a.z + q.x * a.y - q.y * a.x;
                const iw = -q.x * a.x - q.y * a.y - q.z * a.z;
                out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;
                out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;
                out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
                return out;
              }

              static transformRTS(out, a, r, t, s) {
                const x = a.x * s.x;
                const y = a.y * s.y;
                const z = a.z * s.z;
                const ix = r.w * x + r.y * z - r.z * y;
                const iy = r.w * y + r.z * x - r.x * z;
                const iz = r.w * z + r.x * y - r.y * x;
                const iw = -r.x * x - r.y * y - r.z * z;
                out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x;
                out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y;
                out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z;
                return out;
              }

              static transformInverseRTS(out, a, r, t, s) {
                const x = a.x - t.x;
                const y = a.y - t.y;
                const z = a.z - t.z;
                const ix = r.w * x - r.y * z + r.z * y;
                const iy = r.w * y - r.z * x + r.x * z;
                const iz = r.w * z - r.x * y + r.y * x;
                const iw = r.x * x + r.y * y + r.z * z;
                out.x = (ix * r.w + iw * r.x + iy * r.z - iz * r.y) / s.x;
                out.y = (iy * r.w + iw * r.y + iz * r.x - ix * r.z) / s.y;
                out.z = (iz * r.w + iw * r.z + ix * r.y - iy * r.x) / s.z;
                return out;
              }

              static rotateX(out, v, o, a) {
                const x = v.x - o.x;
                const y = v.y - o.y;
                const z = v.z - o.z;
                const cos = Math.cos(a);
                const sin = Math.sin(a);
                const rx = x;
                const ry = y * cos - z * sin;
                const rz = y * sin + z * cos;
                out.x = rx + o.x;
                out.y = ry + o.y;
                out.z = rz + o.z;
                return out;
              }

              static rotateY(out, v, o, a) {
                const x = v.x - o.x;
                const y = v.y - o.y;
                const z = v.z - o.z;
                const cos = Math.cos(a);
                const sin = Math.sin(a);
                const rx = z * sin + x * cos;
                const ry = y;
                const rz = z * cos - x * sin;
                out.x = rx + o.x;
                out.y = ry + o.y;
                out.z = rz + o.z;
                return out;
              }

              static rotateZ(out, v, o, a) {
                const x = v.x - o.x;
                const y = v.y - o.y;
                const z = v.z - o.z;
                const cos = Math.cos(a);
                const sin = Math.sin(a);
                const rx = x * cos - y * sin;
                const ry = x * sin + y * cos;
                const rz = z;
                out.x = rx + o.x;
                out.y = ry + o.y;
                out.z = rz + o.z;
                return out;
              }

              static toArray(out, v, ofs = 0) {
                out[ofs + 0] = v.x;
                out[ofs + 1] = v.y;
                out[ofs + 2] = v.z;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                out.z = arr[ofs + 2];
                return out;
              }

              static strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z;
              }

              static equals(a, b, epsilon = EPSILON) {
                const {
                  x: a0,
                  y: a1,
                  z: a2
                } = a;
                const {
                  x: b0,
                  y: b1,
                  z: b2
                } = b;
                return Math.abs(a0 - b0) <= epsilon * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1.0, Math.abs(a2), Math.abs(b2));
              }

              static angle(a, b) {
                Vec3.normalize(v3_1, a);
                Vec3.normalize(v3_2, b);
                const cosine = Vec3.dot(v3_1, v3_2);

                if (cosine > 1.0) {
                  return 0;
                }

                if (cosine < -1.0) {
                  return Math.PI;
                }

                return Math.acos(cosine);
              }

              static projectOnPlane(out, a, n) {
                return Vec3.subtract(out, a, Vec3.project(out, a, n));
              }

              static project(out, a, b) {
                const sqrLen = Vec3.lengthSqr(b);

                if (sqrLen < 0.000001) {
                  return Vec3.set(out, 0, 0, 0);
                } else {
                  return Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
                }
              }

              get x() {
                return this._array[0];
              }

              set x(x) {
                this._array[0] = x;
              }

              get y() {
                return this._array[1];
              }

              set y(y) {
                this._array[1] = y;
              }

              get z() {
                return this._array[2];
              }

              set z(z) {
                this._array[2] = z;
              }

              constructor(x, y, z) {
                super();

                if (x && typeof x === 'object') {
                  if (ArrayBuffer.isView(x)) {
                    this._array = x;

                    this._array.fill(0);
                  } else {
                    const v = x.array;
                    this._array = MathBase.createFloatArray(3);
                    this._array[0] = v[0];
                    this._array[1] = v[1];
                    this._array[2] = v[2];
                  }
                } else {
                  this._array = MathBase.createFloatArray(3);
                  this._array[0] = x || 0;
                  this._array[1] = y || 0;
                  this._array[2] = z || 0;
                }
              }

              clone() {
                return new Vec3(this._array[0], this._array[1], this._array[2]);
              }

              set(x, y, z) {
                if (x && typeof x === 'object') {
                  this._array[0] = x.x;
                  this._array[1] = x.y;
                  this._array[2] = x.z;
                } else {
                  this._array[0] = x || 0;
                  this._array[1] = y || 0;
                  this._array[2] = z || 0;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                const v = other.array;
                return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2]));
              }

              equals3f(x, y, z, epsilon = EPSILON) {
                return Math.abs(this._array[0] - x) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(x)) && Math.abs(this._array[1] - y) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(y)) && Math.abs(this._array[2] - z) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(z));
              }

              strictEquals(other) {
                const v = other.array;
                return this._array[0] === v[0] && this._array[1] === v[1] && this._array[2] === v[2];
              }

              strictEquals3f(x, y, z) {
                return this._array[0] === x && this._array[1] === y && this._array[2] === z;
              }

              toString() {
                return `(${this._array[0].toFixed(2)}, ${this._array[1].toFixed(2)}, ${this._array[2].toFixed(2)})`;
              }

              lerp(to, ratio) {
                this._array[0] += ratio * (to.x - this._array[0]);
                this._array[1] += ratio * (to.y - this._array[1]);
                this._array[2] += ratio * (to.z - this._array[2]);
                return this;
              }

              add(other) {
                const v = other.array;
                this._array[0] += v[0];
                this._array[1] += v[1];
                this._array[2] += v[2];
                return this;
              }

              add3f(x, y, z) {
                this._array[0] += x;
                this._array[1] += y;
                this._array[2] += z;
                return this;
              }

              subtract(other) {
                const v = other.array;
                this._array[0] -= v[0];
                this._array[1] -= v[1];
                this._array[2] -= v[2];
                return this;
              }

              subtract3f(x, y, z) {
                this._array[0] -= x;
                this._array[1] -= y;
                this._array[2] -= z;
                return this;
              }

              multiplyScalar(scalar) {
                if (typeof scalar === 'object') {
                  console.warn('should use Vec3.multiply for vector * vector operation');
                }

                this._array[0] *= scalar;
                this._array[1] *= scalar;
                this._array[2] *= scalar;
                return this;
              }

              multiply(other) {
                if (typeof other !== 'object') {
                  console.warn('should use Vec3.scale for vector * scalar operation');
                }

                const v = other.array;
                this._array[0] *= v[0];
                this._array[1] *= v[1];
                this._array[2] *= v[2];
                return this;
              }

              multiply3f(x, y, z) {
                this._array[0] *= x;
                this._array[1] *= y;
                this._array[2] *= z;
                return this;
              }

              divide(other) {
                const v = other.array;
                this._array[0] /= v[0];
                this._array[1] /= v[1];
                this._array[2] /= v[2];
                return this;
              }

              divide3f(x, y, z) {
                this._array[0] /= x;
                this._array[1] /= y;
                this._array[2] /= z;
                return this;
              }

              negative() {
                this._array[0] = -this._array[0];
                this._array[1] = -this._array[1];
                this._array[2] = -this._array[2];
                return this;
              }

              clampf(minInclusive, maxInclusive) {
                const min = minInclusive.array;
                const max = maxInclusive.array;
                this._array[0] = clamp(this._array[0], min[0], max[0]);
                this._array[1] = clamp(this._array[1], min[1], max[1]);
                this._array[2] = clamp(this._array[2], min[2], max[2]);
                return this;
              }

              dot(other) {
                const v = other.array;
                return this._array[0] * v[0] + this._array[1] * v[1] + this._array[2] * v[2];
              }

              cross(other) {
                const ax = this._array[0];
                const ay = this._array[1];
                const az = this._array[2];
                const bx = other.array[0];
                const by = other.array[1];
                const bz = other.array[2];
                this._array[0] = ay * bz - az * by;
                this._array[1] = az * bx - ax * bz;
                this._array[2] = ax * by - ay * bx;
                return this;
              }

              length() {
                return Math.sqrt(this._array[0] * this._array[0] + this._array[1] * this._array[1] + this._array[2] * this._array[2]);
              }

              lengthSqr() {
                return this._array[0] * this._array[0] + this._array[1] * this._array[1] + this._array[2] * this._array[2];
              }

              normalize() {
                const x = this._array[0];
                const y = this._array[1];
                const z = this._array[2];
                let len = x * x + y * y + z * z;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  this._array[0] = x * len;
                  this._array[1] = y * len;
                  this._array[2] = z * len;
                }

                return this;
              }

              transformMat4(matrix) {
                const x = this._array[0];
                const y = this._array[1];
                const z = this._array[2];
                const v = matrix.array;
                let rhw = v[3] * x + v[7] * y + v[11] * z + v[15];
                rhw = rhw ? 1 / rhw : 1;
                this._array[0] = (v[0] * x + v[4] * y + v[8] * z + v[12]) * rhw;
                this._array[1] = (v[1] * x + v[5] * y + v[9] * z + v[13]) * rhw;
                this._array[2] = (v[2] * x + v[6] * y + v[10] * z + v[14]) * rhw;
                return this;
              }

            } exports('aZ', Vec3);
            Vec3.UNIT_X = Object.freeze(new Vec3(1, 0, 0));
            Vec3.UNIT_Y = Object.freeze(new Vec3(0, 1, 0));
            Vec3.UNIT_Z = Object.freeze(new Vec3(0, 0, 1));
            Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));
            Vec3.UP = Object.freeze(new Vec3(0, 1, 0));
            Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));
            Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0));
            Vec3.ONE = Object.freeze(new Vec3(1, 1, 1));
            Vec3.NEG_ONE = Object.freeze(new Vec3(-1, -1, -1));
            const v3_1 = new Vec3();
            const v3_2 = new Vec3();
            enumerableProps(Vec3.prototype, ['x', 'y', 'z']);
            CCClass.fastDefine('cc.Vec3', Vec3, {
              x: 0,
              y: 0,
              z: 0
            });
            legacyCC.Vec3 = Vec3;
            function v3(x, y, z) {
              return new Vec3(x, y, z);
            }
            legacyCC.v3 = v3;

            class Mat3 extends MathBase {
              static clone(a) {
                return new Mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
              }

              static copy(out, a) {
                out.m00 = a.m00;
                out.m01 = a.m01;
                out.m02 = a.m02;
                out.m03 = a.m03;
                out.m04 = a.m04;
                out.m05 = a.m05;
                out.m06 = a.m06;
                out.m07 = a.m07;
                out.m08 = a.m08;
                return out;
              }

              static set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
                out.m00 = m00;
                out.m01 = m01;
                out.m02 = m02;
                out.m03 = m10;
                out.m04 = m11;
                out.m05 = m12;
                out.m06 = m20;
                out.m07 = m21;
                out.m08 = m22;
                return out;
              }

              static identity(out) {
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 1;
                out.m05 = 0;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 1;
                return out;
              }

              static transpose(out, a) {
                if (out === a) {
                  const a01 = a.m01;
                  const a02 = a.m02;
                  const a12 = a.m05;
                  out.m01 = a.m03;
                  out.m02 = a.m06;
                  out.m03 = a01;
                  out.m05 = a.m07;
                  out.m06 = a02;
                  out.m07 = a12;
                } else {
                  out.m00 = a.m00;
                  out.m01 = a.m03;
                  out.m02 = a.m06;
                  out.m03 = a.m01;
                  out.m04 = a.m04;
                  out.m05 = a.m07;
                  out.m06 = a.m02;
                  out.m07 = a.m05;
                  out.m08 = a.m08;
                }

                return out;
              }

              static invert(out, a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                const b01 = a22 * a11 - a12 * a21;
                const b11 = -a22 * a10 + a12 * a20;
                const b21 = a21 * a10 - a11 * a20;
                let det = a00 * b01 + a01 * b11 + a02 * b21;

                if (det === 0) {
                  out.m00 = 0;
                  out.m01 = 0;
                  out.m02 = 0;
                  out.m03 = 0;
                  out.m04 = 0;
                  out.m05 = 0;
                  out.m06 = 0;
                  out.m07 = 0;
                  out.m08 = 0;
                  return out;
                }

                det = 1.0 / det;
                out.m00 = b01 * det;
                out.m01 = (-a22 * a01 + a02 * a21) * det;
                out.m02 = (a12 * a01 - a02 * a11) * det;
                out.m03 = b11 * det;
                out.m04 = (a22 * a00 - a02 * a20) * det;
                out.m05 = (-a12 * a00 + a02 * a10) * det;
                out.m06 = b21 * det;
                out.m07 = (-a21 * a00 + a01 * a20) * det;
                out.m08 = (a11 * a00 - a01 * a10) * det;
                return out;
              }

              static determinant(a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
              }

              static multiply(out, a, b) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                const b00 = b.m00;
                const b01 = b.m01;
                const b02 = b.m02;
                const b10 = b.m03;
                const b11 = b.m04;
                const b12 = b.m05;
                const b20 = b.m06;
                const b21 = b.m07;
                const b22 = b.m08;
                out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
                out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
                out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
                out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
                out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
                out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
                out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
                out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
                out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
                return out;
              }

              static multiplyMat4(out, a, b) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                const b00 = b.m00;
                const b01 = b.m01;
                const b02 = b.m02;
                const b10 = b.m04;
                const b11 = b.m05;
                const b12 = b.m06;
                const b20 = b.m08;
                const b21 = b.m09;
                const b22 = b.m10;
                out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
                out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
                out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
                out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
                out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
                out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
                out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
                out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
                out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
                return out;
              }

              static transform(out, a, v) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                const x = v.x;
                const y = v.y;
                out.m00 = a00;
                out.m01 = a01;
                out.m02 = a02;
                out.m03 = a10;
                out.m04 = a11;
                out.m05 = a12;
                out.m06 = x * a00 + y * a10 + a20;
                out.m07 = x * a01 + y * a11 + a21;
                out.m08 = x * a02 + y * a12 + a22;
                return out;
              }

              static scale(out, a, v) {
                const x = v.x;
                const y = v.y;
                out.m00 = x * a.m00;
                out.m01 = x * a.m01;
                out.m02 = x * a.m02;
                out.m03 = y * a.m03;
                out.m04 = y * a.m04;
                out.m05 = y * a.m05;
                out.m06 = a.m06;
                out.m07 = a.m07;
                out.m08 = a.m08;
                return out;
              }

              static rotate(out, a, rad) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                out.m00 = c * a00 + s * a10;
                out.m01 = c * a01 + s * a11;
                out.m02 = c * a02 + s * a12;
                out.m03 = c * a10 - s * a00;
                out.m04 = c * a11 - s * a01;
                out.m05 = c * a12 - s * a02;
                out.m06 = a20;
                out.m07 = a21;
                out.m08 = a22;
                return out;
              }

              static fromMat4(out, a) {
                out.m00 = a.m00;
                out.m01 = a.m01;
                out.m02 = a.m02;
                out.m03 = a.m04;
                out.m04 = a.m05;
                out.m05 = a.m06;
                out.m06 = a.m08;
                out.m07 = a.m09;
                out.m08 = a.m10;
                return out;
              }

              static fromViewUp(out, view, up) {
                if (Vec3.lengthSqr(view) < EPSILON * EPSILON) {
                  Mat3.identity(out);
                  return out;
                }

                Vec3.normalize(v3_1$1, Vec3.cross(v3_1$1, up || Vec3.UNIT_Y, view));

                if (Vec3.lengthSqr(v3_1$1) < EPSILON * EPSILON) {
                  Mat3.identity(out);
                  return out;
                }

                Vec3.cross(v3_2$1, view, v3_1$1);
                Mat3.set(out, v3_1$1.x, v3_1$1.y, v3_1$1.z, v3_2$1.x, v3_2$1.y, v3_2$1.z, view.x, view.y, view.z);
                return out;
              }

              static fromTranslation(out, v) {
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 1;
                out.m05 = 0;
                out.m06 = v.x;
                out.m07 = v.y;
                out.m08 = 1;
                return out;
              }

              static fromScaling(out, v) {
                out.m00 = v.x;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = v.y;
                out.m05 = 0;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 1;
                return out;
              }

              static fromRotation(out, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                out.m00 = c;
                out.m01 = s;
                out.m02 = 0;
                out.m03 = -s;
                out.m04 = c;
                out.m05 = 0;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 1;
                return out;
              }

              static fromQuat(out, q) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const yx = y * x2;
                const yy = y * y2;
                const zx = z * x2;
                const zy = z * y2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                out.m00 = 1 - yy - zz;
                out.m03 = yx - wz;
                out.m06 = zx + wy;
                out.m01 = yx + wz;
                out.m04 = 1 - xx - zz;
                out.m07 = zy - wx;
                out.m02 = zx - wy;
                out.m05 = zy + wx;
                out.m08 = 1 - xx - yy;
                return out;
              }

              static inverseTransposeMat4(out, a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const a30 = a.m12;
                const a31 = a.m13;
                const a32 = a.m14;
                const a33 = a.m15;
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (!det) {
                  return null;
                }

                det = 1.0 / det;
                out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                return out;
              }

              static toArray(out, m, ofs = 0) {
                out[ofs + 0] = m.m00;
                out[ofs + 1] = m.m01;
                out[ofs + 2] = m.m02;
                out[ofs + 3] = m.m03;
                out[ofs + 4] = m.m04;
                out[ofs + 5] = m.m05;
                out[ofs + 6] = m.m06;
                out[ofs + 7] = m.m07;
                out[ofs + 8] = m.m08;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.m00 = arr[ofs + 0];
                out.m01 = arr[ofs + 1];
                out.m02 = arr[ofs + 2];
                out.m03 = arr[ofs + 3];
                out.m04 = arr[ofs + 4];
                out.m05 = arr[ofs + 5];
                out.m06 = arr[ofs + 6];
                out.m07 = arr[ofs + 7];
                out.m08 = arr[ofs + 8];
                return out;
              }

              static add(out, a, b) {
                out.m00 = a.m00 + b.m00;
                out.m01 = a.m01 + b.m01;
                out.m02 = a.m02 + b.m02;
                out.m03 = a.m03 + b.m03;
                out.m04 = a.m04 + b.m04;
                out.m05 = a.m05 + b.m05;
                out.m06 = a.m06 + b.m06;
                out.m07 = a.m07 + b.m07;
                out.m08 = a.m08 + b.m08;
                return out;
              }

              static subtract(out, a, b) {
                out.m00 = a.m00 - b.m00;
                out.m01 = a.m01 - b.m01;
                out.m02 = a.m02 - b.m02;
                out.m03 = a.m03 - b.m03;
                out.m04 = a.m04 - b.m04;
                out.m05 = a.m05 - b.m05;
                out.m06 = a.m06 - b.m06;
                out.m07 = a.m07 - b.m07;
                out.m08 = a.m08 - b.m08;
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.m00 = a.m00 * b;
                out.m01 = a.m01 * b;
                out.m02 = a.m02 * b;
                out.m03 = a.m03 * b;
                out.m04 = a.m04 * b;
                out.m05 = a.m05 * b;
                out.m06 = a.m06 * b;
                out.m07 = a.m07 * b;
                out.m08 = a.m08 * b;
                return out;
              }

              static multiplyScalarAndAdd(out, a, b, scale) {
                out.m00 = b.m00 * scale + a.m00;
                out.m01 = b.m01 * scale + a.m01;
                out.m02 = b.m02 * scale + a.m02;
                out.m03 = b.m03 * scale + a.m03;
                out.m04 = b.m04 * scale + a.m04;
                out.m05 = b.m05 * scale + a.m05;
                out.m06 = b.m06 * scale + a.m06;
                out.m07 = b.m07 * scale + a.m07;
                out.m08 = b.m08 * scale + a.m08;
                return out;
              }

              static strictEquals(a, b) {
                return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08));
              }

              get m00() {
                return this._array[0];
              }

              set m00(m) {
                this._array[0] = m;
              }

              get m01() {
                return this._array[1];
              }

              set m01(m) {
                this._array[1] = m;
              }

              get m02() {
                return this._array[2];
              }

              set m02(m) {
                this._array[2] = m;
              }

              get m03() {
                return this._array[3];
              }

              set m03(m) {
                this._array[3] = m;
              }

              get m04() {
                return this._array[4];
              }

              set m04(m) {
                this._array[4] = m;
              }

              get m05() {
                return this._array[5];
              }

              set m05(m) {
                this._array[5] = m;
              }

              get m06() {
                return this._array[6];
              }

              set m06(m) {
                this._array[6] = m;
              }

              get m07() {
                return this._array[7];
              }

              set m07(m) {
                this._array[7] = m;
              }

              get m08() {
                return this._array[8];
              }

              set m08(m) {
                this._array[8] = m;
              }

              constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 1, m05 = 0, m06 = 0, m07 = 0, m08 = 1) {
                super();

                if (m00 && typeof m00 === 'object') {
                  if (ArrayBuffer.isView(m00)) {
                    this._array = m00;

                    this._array.set([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                  } else {
                    const v = m00.array;
                    this._array = MathBase.createFloatArray(9);
                    this._array[0] = v[0];
                    this._array[1] = v[1];
                    this._array[2] = v[2];
                    this._array[3] = v[3];
                    this._array[4] = v[4];
                    this._array[5] = v[5];
                    this._array[6] = v[6];
                    this._array[7] = v[7];
                    this._array[8] = v[8];
                  }
                } else {
                  this._array = MathBase.createFloatArray(9);
                  this._array[0] = m00;
                  this._array[1] = m01;
                  this._array[2] = m02;
                  this._array[3] = m03;
                  this._array[4] = m04;
                  this._array[5] = m05;
                  this._array[6] = m06;
                  this._array[7] = m07;
                  this._array[8] = m08;
                }
              }

              clone() {
                const m = this._array;
                return new Mat3(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);
              }

              set(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 1, m05 = 0, m06 = 0, m07 = 0, m08 = 1) {
                if (m00 && typeof m00 === 'object') {
                  const v = m00.array;
                  this._array[0] = v[0];
                  this._array[1] = v[1];
                  this._array[2] = v[2];
                  this._array[3] = v[3];
                  this._array[4] = v[4];
                  this._array[5] = v[5];
                  this._array[6] = v[6];
                  this._array[7] = v[7];
                  this._array[8] = v[8];
                } else {
                  this._array[0] = m00;
                  this._array[1] = m01;
                  this._array[2] = m02;
                  this._array[3] = m03;
                  this._array[4] = m04;
                  this._array[5] = m05;
                  this._array[6] = m06;
                  this._array[7] = m07;
                  this._array[8] = m08;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                const v = other.array;
                return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2])) && Math.abs(this._array[3] - v[3]) <= epsilon * Math.max(1.0, Math.abs(this._array[3]), Math.abs(v[3])) && Math.abs(this._array[4] - v[4]) <= epsilon * Math.max(1.0, Math.abs(this._array[4]), Math.abs(v[4])) && Math.abs(this._array[5] - v[5]) <= epsilon * Math.max(1.0, Math.abs(this._array[5]), Math.abs(v[5])) && Math.abs(this._array[6] - v[6]) <= epsilon * Math.max(1.0, Math.abs(this._array[6]), Math.abs(v[6])) && Math.abs(this._array[7] - v[7]) <= epsilon * Math.max(1.0, Math.abs(this._array[7]), Math.abs(v[7])) && Math.abs(this._array[8] - v[8]) <= epsilon * Math.max(1.0, Math.abs(this._array[8]), Math.abs(v[8]));
              }

              strictEquals(other) {
                const v = other.array;
                return this._array[0] === v[0] && this._array[1] === v[1] && this._array[2] === v[2] && this._array[3] === v[3] && this._array[4] === v[4] && this._array[5] === v[5] && this._array[6] === v[6] && this._array[7] === v[7] && this._array[8] === v[8];
              }

              toString() {
                return `[\n${this._array[0]}, ${this._array[1]}, ${this._array[2]},\n${this._array[3]},\n${this._array[4]}, ${this._array[5]},\n${this._array[6]}, ${this._array[7]},\n${this._array[8]}\n` + `]`;
              }

              identity() {
                this._array[0] = 1;
                this._array[1] = 0;
                this._array[2] = 0;
                this._array[3] = 0;
                this._array[4] = 1;
                this._array[5] = 0;
                this._array[6] = 0;
                this._array[7] = 0;
                this._array[8] = 1;
                return this;
              }

              transpose() {
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a12 = this._array[5];
                this._array[1] = this._array[3];
                this._array[2] = this._array[6];
                this._array[3] = a01;
                this._array[5] = this._array[7];
                this._array[6] = a02;
                this._array[7] = a12;
                return this;
              }

              invert() {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a10 = this._array[3];
                const a11 = this._array[4];
                const a12 = this._array[5];
                const a20 = this._array[6];
                const a21 = this._array[7];
                const a22 = this._array[8];
                const b01 = a22 * a11 - a12 * a21;
                const b11 = -a22 * a10 + a12 * a20;
                const b21 = a21 * a10 - a11 * a20;
                let det = a00 * b01 + a01 * b11 + a02 * b21;

                if (det === 0) {
                  this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                  return this;
                }

                det = 1.0 / det;
                this._array[0] = b01 * det;
                this._array[1] = (-a22 * a01 + a02 * a21) * det;
                this._array[2] = (a12 * a01 - a02 * a11) * det;
                this._array[3] = b11 * det;
                this._array[4] = (a22 * a00 - a02 * a20) * det;
                this._array[5] = (-a12 * a00 + a02 * a10) * det;
                this._array[6] = b21 * det;
                this._array[7] = (-a21 * a00 + a01 * a20) * det;
                this._array[8] = (a11 * a00 - a01 * a10) * det;
                return this;
              }

              determinant() {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a10 = this._array[3];
                const a11 = this._array[4];
                const a12 = this._array[5];
                const a20 = this._array[6];
                const a21 = this._array[7];
                const a22 = this._array[8];
                return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
              }

              add(mat) {
                const v = mat.array;
                this._array[0] += v[0];
                this._array[1] += v[1];
                this._array[2] += v[2];
                this._array[3] += v[3];
                this._array[4] += v[4];
                this._array[5] += v[5];
                this._array[6] += v[6];
                this._array[7] += v[7];
                this._array[8] += v[8];
                return this;
              }

              subtract(mat) {
                const v = mat.array;
                this._array[0] -= v[0];
                this._array[1] -= v[1];
                this._array[2] -= v[2];
                this._array[3] -= v[3];
                this._array[4] -= v[4];
                this._array[5] -= v[5];
                this._array[6] -= v[6];
                this._array[7] -= v[7];
                this._array[8] -= v[8];
                return this;
              }

              multiply(mat) {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a10 = this._array[3];
                const a11 = this._array[4];
                const a12 = this._array[5];
                const a20 = this._array[6];
                const a21 = this._array[7];
                const a22 = this._array[8];
                const v = mat.array;
                const b00 = v[0];
                const b01 = v[1];
                const b02 = v[2];
                const b10 = v[3];
                const b11 = v[4];
                const b12 = v[5];
                const b20 = v[6];
                const b21 = v[7];
                const b22 = v[8];
                this._array[0] = b00 * a00 + b01 * a10 + b02 * a20;
                this._array[1] = b00 * a01 + b01 * a11 + b02 * a21;
                this._array[2] = b00 * a02 + b01 * a12 + b02 * a22;
                this._array[3] = b10 * a00 + b11 * a10 + b12 * a20;
                this._array[4] = b10 * a01 + b11 * a11 + b12 * a21;
                this._array[5] = b10 * a02 + b11 * a12 + b12 * a22;
                this._array[6] = b20 * a00 + b21 * a10 + b22 * a20;
                this._array[7] = b20 * a01 + b21 * a11 + b22 * a21;
                this._array[8] = b20 * a02 + b21 * a12 + b22 * a22;
                return this;
              }

              multiplyScalar(scalar) {
                this._array[0] *= scalar;
                this._array[1] *= scalar;
                this._array[2] *= scalar;
                this._array[3] *= scalar;
                this._array[4] *= scalar;
                this._array[5] *= scalar;
                this._array[6] *= scalar;
                this._array[7] *= scalar;
                this._array[8] *= scalar;
                return this;
              }

              scale(vec) {
                const x = vec.array[0];
                const y = vec.array[1];
                this._array[0] *= x;
                this._array[1] *= x;
                this._array[2] *= x;
                this._array[3] *= y;
                this._array[4] *= y;
                this._array[5] *= y;
                return this;
              }

              rotate(rad) {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a10 = this._array[3];
                const a11 = this._array[4];
                const a12 = this._array[5];
                const a20 = this._array[6];
                const a21 = this._array[7];
                const a22 = this._array[8];
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                this._array[0] = c * a00 + s * a10;
                this._array[1] = c * a01 + s * a11;
                this._array[2] = c * a02 + s * a12;
                this._array[3] = c * a10 - s * a00;
                this._array[4] = c * a11 - s * a01;
                this._array[5] = c * a12 - s * a02;
                this._array[6] = a20;
                this._array[7] = a21;
                this._array[8] = a22;
                return this;
              }

              fromQuat(q) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const yx = y * x2;
                const yy = y * y2;
                const zx = z * x2;
                const zy = z * y2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                this._array[0] = 1 - yy - zz;
                this._array[3] = yx - wz;
                this._array[6] = zx + wy;
                this._array[1] = yx + wz;
                this._array[4] = 1 - xx - zz;
                this._array[7] = zy - wx;
                this._array[2] = zx - wy;
                this._array[5] = zy + wx;
                this._array[8] = 1 - xx - yy;
                return this;
              }

            } exports('eC', Mat3);
            Mat3.IDENTITY = Object.freeze(new Mat3());
            const v3_1$1 = new Vec3();
            const v3_2$1 = new Vec3();
            enumerableProps(Mat3.prototype, ['m00', 'm01', 'm02', 'm03', 'm04', 'm05', 'm06', 'm07', 'm08']);
            CCClass.fastDefine('cc.Mat3', Mat3, {
              m00: 1,
              m01: 0,
              m02: 0,
              m03: 0,
              m04: 1,
              m05: 0,
              m06: 0,
              m07: 0,
              m08: 1
            });
            legacyCC.Mat3 = Mat3;

            class Quat extends MathBase {
              static clone(a) {
                return new Quat(a.x, a.y, a.z, a.w);
              }

              static copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                out.w = a.w;
                return out;
              }

              static set(out, x, y, z, w) {
                out.x = x;
                out.y = y;
                out.z = z;
                out.w = w;
                return out;
              }

              static identity(out) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                out.w = 1;
                return out;
              }

              static rotationTo(out, a, b) {
                const dot = Vec3.dot(a, b);

                if (dot < -0.999999) {
                  Vec3.cross(v3_1$2, Vec3.UNIT_X, a);

                  if (v3_1$2.length() < 0.000001) {
                    Vec3.cross(v3_1$2, Vec3.UNIT_Y, a);
                  }

                  Vec3.normalize(v3_1$2, v3_1$2);
                  Quat.fromAxisAngle(out, v3_1$2, Math.PI);
                  return out;
                } else if (dot > 0.999999) {
                  out.x = 0;
                  out.y = 0;
                  out.z = 0;
                  out.w = 1;
                  return out;
                } else {
                  Vec3.cross(v3_1$2, a, b);
                  out.x = v3_1$2.x;
                  out.y = v3_1$2.y;
                  out.z = v3_1$2.z;
                  out.w = 1 + dot;
                  return Quat.normalize(out, out);
                }
              }

              static getAxisAngle(outAxis, q) {
                const rad = Math.acos(q.w) * 2.0;
                const s = Math.sin(rad / 2.0);

                if (s !== 0.0) {
                  outAxis.x = q.x / s;
                  outAxis.y = q.y / s;
                  outAxis.z = q.z / s;
                } else {
                  outAxis.x = 1;
                  outAxis.y = 0;
                  outAxis.z = 0;
                }

                return rad;
              }

              static multiply(out, a, b) {
                const x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;
                const y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;
                const z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;
                const w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
                out.x = x;
                out.y = y;
                out.z = z;
                out.w = w;
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                out.z = a.z * b;
                out.w = a.w * b;
                return out;
              }

              static scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                out.z = a.z + b.z * scale;
                out.w = a.w + b.w * scale;
                return out;
              }

              static rotateX(out, a, rad) {
                rad *= 0.5;
                const bx = Math.sin(rad);
                const bw = Math.cos(rad);
                const {
                  x,
                  y,
                  z,
                  w
                } = a;
                out.x = x * bw + w * bx;
                out.y = y * bw + z * bx;
                out.z = z * bw - y * bx;
                out.w = w * bw - x * bx;
                return out;
              }

              static rotateY(out, a, rad) {
                rad *= 0.5;
                const by = Math.sin(rad);
                const bw = Math.cos(rad);
                const {
                  x,
                  y,
                  z,
                  w
                } = a;
                out.x = x * bw - z * by;
                out.y = y * bw + w * by;
                out.z = z * bw + x * by;
                out.w = w * bw - y * by;
                return out;
              }

              static rotateZ(out, a, rad) {
                rad *= 0.5;
                const bz = Math.sin(rad);
                const bw = Math.cos(rad);
                const {
                  x,
                  y,
                  z,
                  w
                } = a;
                out.x = x * bw + y * bz;
                out.y = y * bw - x * bz;
                out.z = z * bw + w * bz;
                out.w = w * bw - z * bz;
                return out;
              }

              static rotateAround(out, rot, axis, rad) {
                Quat.invert(qt_1, rot);
                Vec3.transformQuat(v3_1$2, axis, qt_1);
                Quat.fromAxisAngle(qt_1, v3_1$2, rad);
                Quat.multiply(out, rot, qt_1);
                return out;
              }

              static rotateAroundLocal(out, rot, axis, rad) {
                Quat.fromAxisAngle(qt_1, axis, rad);
                Quat.multiply(out, rot, qt_1);
                return out;
              }

              static calculateW(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                out.w = Math.sqrt(Math.abs(1.0 - a.x * a.x - a.y * a.y - a.z * a.z));
                return out;
              }

              static dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
              }

              static lerp(out, a, b, t) {
                out.x = a.x + t * (b.x - a.x);
                out.y = a.y + t * (b.y - a.y);
                out.z = a.z + t * (b.z - a.z);
                out.w = a.w + t * (b.w - a.w);
                return out;
              }

              static slerp(out, a, b, t) {
                let scale0 = 0;
                let scale1 = 0;
                let bx = b.x;
                let by = b.y;
                let bz = b.z;
                let bw = b.w;
                let cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;

                if (cosom < 0.0) {
                  cosom = -cosom;
                  bx = -bx;
                  by = -by;
                  bz = -bz;
                  bw = -bw;
                }

                if (1.0 - cosom > 0.000001) {
                  const omega = Math.acos(cosom);
                  const sinom = Math.sin(omega);
                  scale0 = Math.sin((1.0 - t) * omega) / sinom;
                  scale1 = Math.sin(t * omega) / sinom;
                } else {
                  scale0 = 1.0 - t;
                  scale1 = t;
                }

                out.x = scale0 * a.x + scale1 * bx;
                out.y = scale0 * a.y + scale1 * by;
                out.z = scale0 * a.z + scale1 * bz;
                out.w = scale0 * a.w + scale1 * bw;
                return out;
              }

              static sqlerp(out, a, b, c, d, t) {
                Quat.slerp(qt_1, a, d, t);
                Quat.slerp(qt_2, b, c, t);
                Quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t));
                return out;
              }

              static invert(out, a) {
                const dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
                const invDot = dot ? 1.0 / dot : 0;
                out.x = -a.x * invDot;
                out.y = -a.y * invDot;
                out.z = -a.z * invDot;
                out.w = a.w * invDot;
                return out;
              }

              static conjugate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                out.z = -a.z;
                out.w = a.w;
                return out;
              }

              static len(a) {
                return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
              }

              static lengthSqr(a) {
                return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
              }

              static normalize(out, a) {
                let len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  out.x = a.x * len;
                  out.y = a.y * len;
                  out.z = a.z * len;
                  out.w = a.w * len;
                }

                return out;
              }

              static fromAxes(out, xAxis, yAxis, zAxis) {
                Mat3.set(m3_1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
                return Quat.normalize(out, Quat.fromMat3(out, m3_1));
              }

              static fromViewUp(out, view, up) {
                Mat3.fromViewUp(m3_1, view, up);
                return Quat.normalize(out, Quat.fromMat3(out, m3_1));
              }

              static fromAxisAngle(out, axis, rad) {
                rad *= 0.5;
                const s = Math.sin(rad);
                out.x = s * axis.x;
                out.y = s * axis.y;
                out.z = s * axis.z;
                out.w = Math.cos(rad);
                return out;
              }

              static fromMat3(out, m) {
                const {
                  m00,
                  m03: m01,
                  m06: m02,
                  m01: m10,
                  m04: m11,
                  m07: m12,
                  m02: m20,
                  m05: m21,
                  m08: m22
                } = m;
                const trace = m00 + m11 + m22;

                if (trace > 0) {
                  const s = 0.5 / Math.sqrt(trace + 1.0);
                  out.w = 0.25 / s;
                  out.x = (m21 - m12) * s;
                  out.y = (m02 - m20) * s;
                  out.z = (m10 - m01) * s;
                } else if (m00 > m11 && m00 > m22) {
                  const s = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);
                  out.w = (m21 - m12) / s;
                  out.x = 0.25 * s;
                  out.y = (m01 + m10) / s;
                  out.z = (m02 + m20) / s;
                } else if (m11 > m22) {
                  const s = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);
                  out.w = (m02 - m20) / s;
                  out.x = (m01 + m10) / s;
                  out.y = 0.25 * s;
                  out.z = (m12 + m21) / s;
                } else {
                  const s = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);
                  out.w = (m10 - m01) / s;
                  out.x = (m02 + m20) / s;
                  out.y = (m12 + m21) / s;
                  out.z = 0.25 * s;
                }

                return out;
              }

              static fromEuler(out, x, y, z) {
                x *= halfToRad;
                y *= halfToRad;
                z *= halfToRad;
                const sx = Math.sin(x);
                const cx = Math.cos(x);
                const sy = Math.sin(y);
                const cy = Math.cos(y);
                const sz = Math.sin(z);
                const cz = Math.cos(z);
                out.x = sx * cy * cz + cx * sy * sz;
                out.y = cx * sy * cz + sx * cy * sz;
                out.z = cx * cy * sz - sx * sy * cz;
                out.w = cx * cy * cz - sx * sy * sz;
                return out;
              }

              static fromAngleZ(out, z) {
                z *= halfToRad;
                out.x = out.y = 0;
                out.z = Math.sin(z);
                out.w = Math.cos(z);
                return out;
              }

              static toAxisX(out, q) {
                const fy = 2.0 * q.y;
                const fz = 2.0 * q.z;
                out.x = 1.0 - fy * q.y - fz * q.z;
                out.y = fy * q.x + fz * q.w;
                out.z = fz * q.x + fy * q.w;
                return out;
              }

              static toAxisY(out, q) {
                const fx = 2.0 * q.x;
                const fy = 2.0 * q.y;
                const fz = 2.0 * q.z;
                out.x = fy * q.x - fz * q.w;
                out.y = 1.0 - fx * q.x - fz * q.z;
                out.z = fz * q.y + fx * q.w;
                return out;
              }

              static toAxisZ(out, q) {
                const fx = 2.0 * q.x;
                const fy = 2.0 * q.y;
                const fz = 2.0 * q.z;
                out.x = fz * q.x - fy * q.w;
                out.y = fz * q.y - fx * q.w;
                out.z = 1.0 - fx * q.x - fy * q.y;
                return out;
              }

              static toEuler(out, q, outerZ) {
                const {
                  x,
                  y,
                  z,
                  w
                } = q;
                let bank = 0;
                let heading = 0;
                let attitude = 0;
                const test = x * y + z * w;

                if (test > 0.499999) {
                  bank = 0;
                  heading = toDegree(2 * Math.atan2(x, w));
                  attitude = 90;
                } else if (test < -0.499999) {
                  bank = 0;
                  heading = -toDegree(2 * Math.atan2(x, w));
                  attitude = -90;
                } else {
                  const sqx = x * x;
                  const sqy = y * y;
                  const sqz = z * z;
                  bank = toDegree(Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz));
                  heading = toDegree(Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz));
                  attitude = toDegree(Math.asin(2 * test));

                  if (outerZ) {
                    bank = -180 * Math.sign(bank + 1e-6) + bank;
                    heading = -180 * Math.sign(heading + 1e-6) + heading;
                    attitude = 180 * Math.sign(attitude + 1e-6) - attitude;
                  }
                }

                out.x = bank;
                out.y = heading;
                out.z = attitude;
                return out;
              }

              static toArray(out, q, ofs = 0) {
                out[ofs + 0] = q.x;
                out[ofs + 1] = q.y;
                out[ofs + 2] = q.z;
                out[ofs + 3] = q.w;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                out.z = arr[ofs + 2];
                out.w = arr[ofs + 3];
                return out;
              }

              static strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
              }

              get x() {
                return this._array[0];
              }

              set x(x) {
                this._array[0] = x;
              }

              get y() {
                return this._array[1];
              }

              set y(y) {
                this._array[1] = y;
              }

              get z() {
                return this._array[2];
              }

              set z(z) {
                this._array[2] = z;
              }

              get w() {
                return this._array[3];
              }

              set w(w) {
                this._array[3] = w;
              }

              constructor(x, y, z, w) {
                super();

                if (x && typeof x === 'object') {
                  if (ArrayBuffer.isView(x)) {
                    this._array = x;

                    this._array.fill(0);

                    this._array[3] = 1;
                  } else {
                    const v = x.array;
                    this._array = MathBase.createFloatArray(4);
                    this._array[0] = v[0];
                    this._array[1] = v[1];
                    this._array[2] = v[2];
                    this._array[3] = v[3];
                  }
                } else {
                  this._array = MathBase.createFloatArray(4);
                  this._array[0] = x || 0;
                  this._array[1] = y || 0;
                  this._array[2] = z || 0;
                  this._array[3] = w !== null && w !== void 0 ? w : 1;
                }
              }

              clone() {
                return new Quat(this._array[0], this._array[1], this._array[2], this._array[3]);
              }

              set(x, y, z, w) {
                if (x && typeof x === 'object') {
                  const v = x.array;
                  this._array[0] = v[0];
                  this._array[1] = v[1];
                  this._array[2] = v[2];
                  this._array[3] = v[3];
                } else {
                  this._array[0] = x || 0;
                  this._array[1] = y || 0;
                  this._array[2] = z || 0;
                  this._array[3] = w !== null && w !== void 0 ? w : 1;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                const v = other.array;
                return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2])) && Math.abs(this._array[3] - v[3]) <= epsilon * Math.max(1.0, Math.abs(this._array[3]), Math.abs(v[3]));
              }

              strictEquals(other) {
                const v = other.array;
                return other && this._array[0] === v[0] && this._array[1] === v[1] && this._array[2] === v[2] && this._array[3] === v[3];
              }

              getEulerAngles(out) {
                return Quat.toEuler(out, this);
              }

              lerp(to, ratio) {
                const tq = to.array;
                this._array[0] += ratio * (tq[0] - this._array[0]);
                this._array[1] += ratio * (tq[1] - this._array[1]);
                this._array[2] += ratio * (tq[2] - this._array[2]);
                this._array[3] += ratio * (tq[3] - this._array[3]);
                return this;
              }

              slerp(to, ratio) {
                return Quat.slerp(this, this, to, ratio);
              }

              length() {
                const v = this._array;
                return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3]);
              }

              lengthSqr() {
                const v = this._array;
                return v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3];
              }

            } exports('bN', Quat);
            Quat.IDENTITY = Object.freeze(new Quat());
            enumerableProps(Quat.prototype, ['x', 'y', 'z', 'w']);
            const qt_1 = new Quat();
            const qt_2 = new Quat();
            const v3_1$2 = new Vec3();
            const m3_1 = new Mat3();
            const halfToRad = 0.5 * Math.PI / 180.0;
            CCClass.fastDefine('cc.Quat', Quat, {
              x: 0,
              y: 0,
              z: 0,
              w: 1
            });
            legacyCC.Quat = Quat;
            function quat(x = 0, y = 0, z = 0, w = 1) {
              return new Quat(x, y, z, w);
            }
            legacyCC.quat = quat;

            const preTransforms = exports('e5', Object.freeze([Object.freeze([1, 0, 0, 1]), Object.freeze([0, 1, -1, 0]), Object.freeze([-1, 0, 0, -1]), Object.freeze([0, -1, 1, 0])]));
            class Mat4 extends MathBase {
              static clone(a) {
                return new Mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
              }

              static copy(out, a) {
                out.m00 = a.m00;
                out.m01 = a.m01;
                out.m02 = a.m02;
                out.m03 = a.m03;
                out.m04 = a.m04;
                out.m05 = a.m05;
                out.m06 = a.m06;
                out.m07 = a.m07;
                out.m08 = a.m08;
                out.m09 = a.m09;
                out.m10 = a.m10;
                out.m11 = a.m11;
                out.m12 = a.m12;
                out.m13 = a.m13;
                out.m14 = a.m14;
                out.m15 = a.m15;
                return out;
              }

              static set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
                out.m00 = m00;
                out.m01 = m01;
                out.m02 = m02;
                out.m03 = m03;
                out.m04 = m10;
                out.m05 = m11;
                out.m06 = m12;
                out.m07 = m13;
                out.m08 = m20;
                out.m09 = m21;
                out.m10 = m22;
                out.m11 = m23;
                out.m12 = m30;
                out.m13 = m31;
                out.m14 = m32;
                out.m15 = m33;
                return out;
              }

              static identity(out) {
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = 1;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = 1;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static transpose(out, a) {
                if (out === a) {
                  const a01 = a.m01;
                  const a02 = a.m02;
                  const a03 = a.m03;
                  const a12 = a.m06;
                  const a13 = a.m07;
                  const a23 = a.m11;
                  out.m01 = a.m04;
                  out.m02 = a.m08;
                  out.m03 = a.m12;
                  out.m04 = a01;
                  out.m06 = a.m09;
                  out.m07 = a.m13;
                  out.m08 = a02;
                  out.m09 = a12;
                  out.m11 = a.m14;
                  out.m12 = a03;
                  out.m13 = a13;
                  out.m14 = a23;
                } else {
                  out.m00 = a.m00;
                  out.m01 = a.m04;
                  out.m02 = a.m08;
                  out.m03 = a.m12;
                  out.m04 = a.m01;
                  out.m05 = a.m05;
                  out.m06 = a.m09;
                  out.m07 = a.m13;
                  out.m08 = a.m02;
                  out.m09 = a.m06;
                  out.m10 = a.m10;
                  out.m11 = a.m14;
                  out.m12 = a.m03;
                  out.m13 = a.m07;
                  out.m14 = a.m11;
                  out.m15 = a.m15;
                }

                return out;
              }

              static invert(out, a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const a30 = a.m12;
                const a31 = a.m13;
                const a32 = a.m14;
                const a33 = a.m15;
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (det === 0) {
                  out.m00 = 0;
                  out.m01 = 0;
                  out.m02 = 0;
                  out.m03 = 0;
                  out.m04 = 0;
                  out.m05 = 0;
                  out.m06 = 0;
                  out.m07 = 0;
                  out.m08 = 0;
                  out.m09 = 0;
                  out.m10 = 0;
                  out.m11 = 0;
                  out.m12 = 0;
                  out.m13 = 0;
                  out.m14 = 0;
                  out.m15 = 0;
                  return out;
                }

                det = 1.0 / det;
                out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return out;
              }

              static determinant(a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const a30 = a.m12;
                const a31 = a.m13;
                const a32 = a.m14;
                const a33 = a.m15;
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              }

              static multiply(out, a, b) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const a30 = a.m12;
                const a31 = a.m13;
                const a32 = a.m14;
                const a33 = a.m15;
                let b0 = b.m00;
                let b1 = b.m01;
                let b2 = b.m02;
                let b3 = b.m03;
                out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b.m04;
                b1 = b.m05;
                b2 = b.m06;
                b3 = b.m07;
                out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b.m08;
                b1 = b.m09;
                b2 = b.m10;
                b3 = b.m11;
                out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b.m12;
                b1 = b.m13;
                b2 = b.m14;
                b3 = b.m15;
                out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                return out;
              }

              static transform(out, a, v) {
                const x = v.x;
                const y = v.y;
                const z = v.z;

                if (a === out) {
                  out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12;
                  out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13;
                  out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14;
                  out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15;
                } else {
                  const a00 = a.m00;
                  const a01 = a.m01;
                  const a02 = a.m02;
                  const a03 = a.m03;
                  const a10 = a.m04;
                  const a11 = a.m05;
                  const a12 = a.m06;
                  const a13 = a.m07;
                  const a20 = a.m08;
                  const a21 = a.m09;
                  const a22 = a.m10;
                  const a23 = a.m11;
                  const a30 = a.m12;
                  const a31 = a.m13;
                  const a32 = a.m14;
                  const a33 = a.m15;
                  out.m00 = a00;
                  out.m01 = a01;
                  out.m02 = a02;
                  out.m03 = a03;
                  out.m04 = a10;
                  out.m05 = a11;
                  out.m06 = a12;
                  out.m07 = a13;
                  out.m08 = a20;
                  out.m09 = a21;
                  out.m10 = a22;
                  out.m11 = a23;
                  out.m12 = a00 * x + a10 * y + a20 * z + a.m12;
                  out.m13 = a01 * x + a11 * y + a21 * z + a.m13;
                  out.m14 = a02 * x + a12 * y + a22 * z + a.m14;
                  out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
                }

                return out;
              }

              static translate(out, a, v) {
                console.warn('function changed');

                if (a === out) {
                  out.m12 += v.x;
                  out.m13 += v.y;
                  out.m14 += v.z;
                } else {
                  out.m00 = a.m00;
                  out.m01 = a.m01;
                  out.m02 = a.m02;
                  out.m03 = a.m03;
                  out.m04 = a.m04;
                  out.m05 = a.m05;
                  out.m06 = a.m06;
                  out.m07 = a.m07;
                  out.m08 = a.m08;
                  out.m09 = a.m09;
                  out.m10 = a.m10;
                  out.m11 = a.m11;
                  out.m12 += v.x;
                  out.m13 += v.y;
                  out.m14 += v.z;
                  out.m15 = a.m15;
                }

                return out;
              }

              static scale(out, a, v) {
                const x = v.x;
                const y = v.y;
                const z = v.z;
                out.m00 = a.m00 * x;
                out.m01 = a.m01 * x;
                out.m02 = a.m02 * x;
                out.m03 = a.m03 * x;
                out.m04 = a.m04 * y;
                out.m05 = a.m05 * y;
                out.m06 = a.m06 * y;
                out.m07 = a.m07 * y;
                out.m08 = a.m08 * z;
                out.m09 = a.m09 * z;
                out.m10 = a.m10 * z;
                out.m11 = a.m11 * z;
                out.m12 = a.m12;
                out.m13 = a.m13;
                out.m14 = a.m14;
                out.m15 = a.m15;
                return out;
              }

              static rotate(out, a, rad, axis) {
                let x = axis.x;
                let y = axis.y;
                let z = axis.z;
                let len = Math.sqrt(x * x + y * y + z * z);

                if (Math.abs(len) < EPSILON) {
                  return null;
                }

                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const t = 1 - c;
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const b00 = x * x * t + c;
                const b01 = y * x * t + z * s;
                const b02 = z * x * t - y * s;
                const b10 = x * y * t - z * s;
                const b11 = y * y * t + c;
                const b12 = z * y * t + x * s;
                const b20 = x * z * t + y * s;
                const b21 = y * z * t - x * s;
                const b22 = z * z * t + c;
                out.m00 = a00 * b00 + a10 * b01 + a20 * b02;
                out.m01 = a01 * b00 + a11 * b01 + a21 * b02;
                out.m02 = a02 * b00 + a12 * b01 + a22 * b02;
                out.m03 = a03 * b00 + a13 * b01 + a23 * b02;
                out.m04 = a00 * b10 + a10 * b11 + a20 * b12;
                out.m05 = a01 * b10 + a11 * b11 + a21 * b12;
                out.m06 = a02 * b10 + a12 * b11 + a22 * b12;
                out.m07 = a03 * b10 + a13 * b11 + a23 * b12;
                out.m08 = a00 * b20 + a10 * b21 + a20 * b22;
                out.m09 = a01 * b20 + a11 * b21 + a21 * b22;
                out.m10 = a02 * b20 + a12 * b21 + a22 * b22;
                out.m11 = a03 * b20 + a13 * b21 + a23 * b22;

                if (a !== out) {
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }

                return out;
              }

              static rotateX(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;

                if (a !== out) {
                  out.m00 = a.m00;
                  out.m01 = a.m01;
                  out.m02 = a.m02;
                  out.m03 = a.m03;
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }

                out.m04 = a10 * c + a20 * s;
                out.m05 = a11 * c + a21 * s;
                out.m06 = a12 * c + a22 * s;
                out.m07 = a13 * c + a23 * s;
                out.m08 = a20 * c - a10 * s;
                out.m09 = a21 * c - a11 * s;
                out.m10 = a22 * c - a12 * s;
                out.m11 = a23 * c - a13 * s;
                return out;
              }

              static rotateY(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;

                if (a !== out) {
                  out.m04 = a.m04;
                  out.m05 = a.m05;
                  out.m06 = a.m06;
                  out.m07 = a.m07;
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }

                out.m00 = a00 * c - a20 * s;
                out.m01 = a01 * c - a21 * s;
                out.m02 = a02 * c - a22 * s;
                out.m03 = a03 * c - a23 * s;
                out.m08 = a00 * s + a20 * c;
                out.m09 = a01 * s + a21 * c;
                out.m10 = a02 * s + a22 * c;
                out.m11 = a03 * s + a23 * c;
                return out;
              }

              static rotateZ(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;

                if (a !== out) {
                  out.m08 = a.m08;
                  out.m09 = a.m09;
                  out.m10 = a.m10;
                  out.m11 = a.m11;
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }

                out.m00 = a00 * c + a10 * s;
                out.m01 = a01 * c + a11 * s;
                out.m02 = a02 * c + a12 * s;
                out.m03 = a03 * c + a13 * s;
                out.m04 = a10 * c - a00 * s;
                out.m05 = a11 * c - a01 * s;
                out.m06 = a12 * c - a02 * s;
                out.m07 = a13 * c - a03 * s;
                return out;
              }

              static fromTranslation(out, v) {
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = 1;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = 1;
                out.m11 = 0;
                out.m12 = v.x;
                out.m13 = v.y;
                out.m14 = v.z;
                out.m15 = 1;
                return out;
              }

              static fromScaling(out, v) {
                out.m00 = v.x;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = v.y;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = v.z;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static fromRotation(out, rad, axis) {
                let x = axis.x;
                let y = axis.y;
                let z = axis.z;
                let len = Math.sqrt(x * x + y * y + z * z);

                if (Math.abs(len) < EPSILON) {
                  return null;
                }

                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const t = 1 - c;
                out.m00 = x * x * t + c;
                out.m01 = y * x * t + z * s;
                out.m02 = z * x * t - y * s;
                out.m03 = 0;
                out.m04 = x * y * t - z * s;
                out.m05 = y * y * t + c;
                out.m06 = z * y * t + x * s;
                out.m07 = 0;
                out.m08 = x * z * t + y * s;
                out.m09 = y * z * t - x * s;
                out.m10 = z * z * t + c;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static fromXRotation(out, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = c;
                out.m06 = s;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = -s;
                out.m10 = c;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static fromYRotation(out, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                out.m00 = c;
                out.m01 = 0;
                out.m02 = -s;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = 1;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = s;
                out.m09 = 0;
                out.m10 = c;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static fromZRotation(out, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                out.m00 = c;
                out.m01 = s;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = -s;
                out.m05 = c;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = 1;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static fromRT(out, q, v) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const xy = x * y2;
                const xz = x * z2;
                const yy = y * y2;
                const yz = y * z2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                out.m00 = 1 - (yy + zz);
                out.m01 = xy + wz;
                out.m02 = xz - wy;
                out.m03 = 0;
                out.m04 = xy - wz;
                out.m05 = 1 - (xx + zz);
                out.m06 = yz + wx;
                out.m07 = 0;
                out.m08 = xz + wy;
                out.m09 = yz - wx;
                out.m10 = 1 - (xx + yy);
                out.m11 = 0;
                out.m12 = v.x;
                out.m13 = v.y;
                out.m14 = v.z;
                out.m15 = 1;
                return out;
              }

              static getTranslation(out, mat) {
                out.x = mat.m12;
                out.y = mat.m13;
                out.z = mat.m14;
                return out;
              }

              static getScaling(out, mat) {
                const m00 = m3_1$1.m00 = mat.m00;
                const m01 = m3_1$1.m01 = mat.m01;
                const m02 = m3_1$1.m02 = mat.m02;
                const m04 = m3_1$1.m03 = mat.m04;
                const m05 = m3_1$1.m04 = mat.m05;
                const m06 = m3_1$1.m05 = mat.m06;
                const m08 = m3_1$1.m06 = mat.m08;
                const m09 = m3_1$1.m07 = mat.m09;
                const m10 = m3_1$1.m08 = mat.m10;
                out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
                out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
                out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);

                if (Mat3.determinant(m3_1$1) < 0) {
                  out.x *= -1;
                }

                return out;
              }

              static getRotation(out, mat) {
                const trace = mat.m00 + mat.m05 + mat.m10;
                let S = 0;

                if (trace > 0) {
                  S = Math.sqrt(trace + 1.0) * 2;
                  out.w = 0.25 * S;
                  out.x = (mat.m06 - mat.m09) / S;
                  out.y = (mat.m08 - mat.m02) / S;
                  out.z = (mat.m01 - mat.m04) / S;
                } else if (mat.m00 > mat.m05 && mat.m00 > mat.m10) {
                  S = Math.sqrt(1.0 + mat.m00 - mat.m05 - mat.m10) * 2;
                  out.w = (mat.m06 - mat.m09) / S;
                  out.x = 0.25 * S;
                  out.y = (mat.m01 + mat.m04) / S;
                  out.z = (mat.m08 + mat.m02) / S;
                } else if (mat.m05 > mat.m10) {
                  S = Math.sqrt(1.0 + mat.m05 - mat.m00 - mat.m10) * 2;
                  out.w = (mat.m08 - mat.m02) / S;
                  out.x = (mat.m01 + mat.m04) / S;
                  out.y = 0.25 * S;
                  out.z = (mat.m06 + mat.m09) / S;
                } else {
                  S = Math.sqrt(1.0 + mat.m10 - mat.m00 - mat.m05) * 2;
                  out.w = (mat.m01 - mat.m04) / S;
                  out.x = (mat.m08 + mat.m02) / S;
                  out.y = (mat.m06 + mat.m09) / S;
                  out.z = 0.25 * S;
                }

                return out;
              }

              static toRTS(m, q, v, s) {
                s.x = Vec3.set(v3_1$3, m.m00, m.m01, m.m02).length();
                m3_1$1.m00 = m.m00 / s.x;
                m3_1$1.m01 = m.m01 / s.x;
                m3_1$1.m02 = m.m02 / s.x;
                s.y = Vec3.set(v3_1$3, m.m04, m.m05, m.m06).length();
                m3_1$1.m03 = m.m04 / s.y;
                m3_1$1.m04 = m.m05 / s.y;
                m3_1$1.m05 = m.m06 / s.y;
                s.z = Vec3.set(v3_1$3, m.m08, m.m09, m.m10).length();
                m3_1$1.m06 = m.m08 / s.z;
                m3_1$1.m07 = m.m09 / s.z;
                m3_1$1.m08 = m.m10 / s.z;
                const det = Mat3.determinant(m3_1$1);

                if (det < 0) {
                  s.x *= -1;
                  m3_1$1.m00 *= -1;
                  m3_1$1.m01 *= -1;
                  m3_1$1.m02 *= -1;
                }

                Quat.fromMat3(q, m3_1$1);
                Vec3.set(v, m.m12, m.m13, m.m14);
              }

              static fromRTS(out, q, v, s) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const xy = x * y2;
                const xz = x * z2;
                const yy = y * y2;
                const yz = y * z2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                const sx = s.x;
                const sy = s.y;
                const sz = s.z;
                out.m00 = (1 - (yy + zz)) * sx;
                out.m01 = (xy + wz) * sx;
                out.m02 = (xz - wy) * sx;
                out.m03 = 0;
                out.m04 = (xy - wz) * sy;
                out.m05 = (1 - (xx + zz)) * sy;
                out.m06 = (yz + wx) * sy;
                out.m07 = 0;
                out.m08 = (xz + wy) * sz;
                out.m09 = (yz - wx) * sz;
                out.m10 = (1 - (xx + yy)) * sz;
                out.m11 = 0;
                out.m12 = v.x;
                out.m13 = v.y;
                out.m14 = v.z;
                out.m15 = 1;
                return out;
              }

              static fromRTSOrigin(out, q, v, s, o) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const xy = x * y2;
                const xz = x * z2;
                const yy = y * y2;
                const yz = y * z2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                const sx = s.x;
                const sy = s.y;
                const sz = s.z;
                const ox = o.x;
                const oy = o.y;
                const oz = o.z;
                out.m00 = (1 - (yy + zz)) * sx;
                out.m01 = (xy + wz) * sx;
                out.m02 = (xz - wy) * sx;
                out.m03 = 0;
                out.m04 = (xy - wz) * sy;
                out.m05 = (1 - (xx + zz)) * sy;
                out.m06 = (yz + wx) * sy;
                out.m07 = 0;
                out.m08 = (xz + wy) * sz;
                out.m09 = (yz - wx) * sz;
                out.m10 = (1 - (xx + yy)) * sz;
                out.m11 = 0;
                out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
                out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
                out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
                out.m15 = 1;
                return out;
              }

              static fromQuat(out, q) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const yx = y * x2;
                const yy = y * y2;
                const zx = z * x2;
                const zy = z * y2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                out.m00 = 1 - yy - zz;
                out.m01 = yx + wz;
                out.m02 = zx - wy;
                out.m03 = 0;
                out.m04 = yx - wz;
                out.m05 = 1 - xx - zz;
                out.m06 = zy + wx;
                out.m07 = 0;
                out.m08 = zx + wy;
                out.m09 = zy - wx;
                out.m10 = 1 - xx - yy;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static frustum(out, left, right, bottom, top, near, far) {
                const rl = 1 / (right - left);
                const tb = 1 / (top - bottom);
                const nf = 1 / (near - far);
                out.m00 = near * 2 * rl;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = near * 2 * tb;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = (right + left) * rl;
                out.m09 = (top + bottom) * tb;
                out.m10 = (far + near) * nf;
                out.m11 = -1;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = far * near * 2 * nf;
                out.m15 = 0;
                return out;
              }

              static perspective(out, fov, aspect, near, far, isFOVY = true, minClipZ = -1, projectionSignY = 1, orientation = 0) {
                const f = 1.0 / Math.tan(fov / 2);
                const nf = 1 / (near - far);
                const x = isFOVY ? f / aspect : f;
                const y = (isFOVY ? f : f * aspect) * projectionSignY;
                const preTransform = preTransforms[orientation];
                out.m00 = x * preTransform[0];
                out.m01 = x * preTransform[1];
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = y * preTransform[2];
                out.m05 = y * preTransform[3];
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = (far - minClipZ * near) * nf;
                out.m11 = -1;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = far * near * nf * (1 - minClipZ);
                out.m15 = 0;
                return out;
              }

              static ortho(out, left, right, bottom, top, near, far, minClipZ = -1, projectionSignY = 1, orientation = 0) {
                const lr = 1 / (left - right);
                const bt = 1 / (bottom - top) * projectionSignY;
                const nf = 1 / (near - far);
                const x = -2 * lr;
                const y = -2 * bt;
                const dx = (left + right) * lr;
                const dy = (top + bottom) * bt;
                const preTransform = preTransforms[orientation];
                out.m00 = x * preTransform[0];
                out.m01 = x * preTransform[1];
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = y * preTransform[2];
                out.m05 = y * preTransform[3];
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = nf * (1 - minClipZ);
                out.m11 = 0;
                out.m12 = dx * preTransform[0] + dy * preTransform[2];
                out.m13 = dx * preTransform[1] + dy * preTransform[3];
                out.m14 = (near - minClipZ * far) * nf;
                out.m15 = 1;
                return out;
              }

              static lookAt(out, eye, center, up) {
                const eyex = eye.x;
                const eyey = eye.y;
                const eyez = eye.z;
                const upx = up.x;
                const upy = up.y;
                const upz = up.z;
                const centerx = center.x;
                const centery = center.y;
                const centerz = center.z;
                let z0 = eyex - centerx;
                let z1 = eyey - centery;
                let z2 = eyez - centerz;
                let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                z0 *= len;
                z1 *= len;
                z2 *= len;
                let x0 = upy * z2 - upz * z1;
                let x1 = upz * z0 - upx * z2;
                let x2 = upx * z1 - upy * z0;
                len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                x0 *= len;
                x1 *= len;
                x2 *= len;
                const y0 = z1 * x2 - z2 * x1;
                const y1 = z2 * x0 - z0 * x2;
                const y2 = z0 * x1 - z1 * x0;
                out.m00 = x0;
                out.m01 = y0;
                out.m02 = z0;
                out.m03 = 0;
                out.m04 = x1;
                out.m05 = y1;
                out.m06 = z1;
                out.m07 = 0;
                out.m08 = x2;
                out.m09 = y2;
                out.m10 = z2;
                out.m11 = 0;
                out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez);
                out.m15 = 1;
                return out;
              }

              static inverseTranspose(out, a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const a30 = a.m12;
                const a31 = a.m13;
                const a32 = a.m14;
                const a33 = a.m15;
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (!det) {
                  return null;
                }

                det = 1.0 / det;
                out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out.m03 = 0;
                out.m04 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out.m06 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out.m07 = 0;
                out.m08 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out.m09 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static toArray(out, m, ofs = 0) {
                out[ofs + 0] = m.m00;
                out[ofs + 1] = m.m01;
                out[ofs + 2] = m.m02;
                out[ofs + 3] = m.m03;
                out[ofs + 4] = m.m04;
                out[ofs + 5] = m.m05;
                out[ofs + 6] = m.m06;
                out[ofs + 7] = m.m07;
                out[ofs + 8] = m.m08;
                out[ofs + 9] = m.m09;
                out[ofs + 10] = m.m10;
                out[ofs + 11] = m.m11;
                out[ofs + 12] = m.m12;
                out[ofs + 13] = m.m13;
                out[ofs + 14] = m.m14;
                out[ofs + 15] = m.m15;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.m00 = arr[ofs + 0];
                out.m01 = arr[ofs + 1];
                out.m02 = arr[ofs + 2];
                out.m03 = arr[ofs + 3];
                out.m04 = arr[ofs + 4];
                out.m05 = arr[ofs + 5];
                out.m06 = arr[ofs + 6];
                out.m07 = arr[ofs + 7];
                out.m08 = arr[ofs + 8];
                out.m09 = arr[ofs + 9];
                out.m10 = arr[ofs + 10];
                out.m11 = arr[ofs + 11];
                out.m12 = arr[ofs + 12];
                out.m13 = arr[ofs + 13];
                out.m14 = arr[ofs + 14];
                out.m15 = arr[ofs + 15];
                return out;
              }

              static add(out, a, b) {
                out.m00 = a.m00 + b.m00;
                out.m01 = a.m01 + b.m01;
                out.m02 = a.m02 + b.m02;
                out.m03 = a.m03 + b.m03;
                out.m04 = a.m04 + b.m04;
                out.m05 = a.m05 + b.m05;
                out.m06 = a.m06 + b.m06;
                out.m07 = a.m07 + b.m07;
                out.m08 = a.m08 + b.m08;
                out.m09 = a.m09 + b.m09;
                out.m10 = a.m10 + b.m10;
                out.m11 = a.m11 + b.m11;
                out.m12 = a.m12 + b.m12;
                out.m13 = a.m13 + b.m13;
                out.m14 = a.m14 + b.m14;
                out.m15 = a.m15 + b.m15;
                return out;
              }

              static subtract(out, a, b) {
                out.m00 = a.m00 - b.m00;
                out.m01 = a.m01 - b.m01;
                out.m02 = a.m02 - b.m02;
                out.m03 = a.m03 - b.m03;
                out.m04 = a.m04 - b.m04;
                out.m05 = a.m05 - b.m05;
                out.m06 = a.m06 - b.m06;
                out.m07 = a.m07 - b.m07;
                out.m08 = a.m08 - b.m08;
                out.m09 = a.m09 - b.m09;
                out.m10 = a.m10 - b.m10;
                out.m11 = a.m11 - b.m11;
                out.m12 = a.m12 - b.m12;
                out.m13 = a.m13 - b.m13;
                out.m14 = a.m14 - b.m14;
                out.m15 = a.m15 - b.m15;
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.m00 = a.m00 * b;
                out.m01 = a.m01 * b;
                out.m02 = a.m02 * b;
                out.m03 = a.m03 * b;
                out.m04 = a.m04 * b;
                out.m05 = a.m05 * b;
                out.m06 = a.m06 * b;
                out.m07 = a.m07 * b;
                out.m08 = a.m08 * b;
                out.m09 = a.m09 * b;
                out.m10 = a.m10 * b;
                out.m11 = a.m11 * b;
                out.m12 = a.m12 * b;
                out.m13 = a.m13 * b;
                out.m14 = a.m14 * b;
                out.m15 = a.m15 * b;
                return out;
              }

              static multiplyScalarAndAdd(out, a, b, scale) {
                out.m00 = a.m00 + b.m00 * scale;
                out.m01 = a.m01 + b.m01 * scale;
                out.m02 = a.m02 + b.m02 * scale;
                out.m03 = a.m03 + b.m03 * scale;
                out.m04 = a.m04 + b.m04 * scale;
                out.m05 = a.m05 + b.m05 * scale;
                out.m06 = a.m06 + b.m06 * scale;
                out.m07 = a.m07 + b.m07 * scale;
                out.m08 = a.m08 + b.m08 * scale;
                out.m09 = a.m09 + b.m09 * scale;
                out.m10 = a.m10 + b.m10 * scale;
                out.m11 = a.m11 + b.m11 * scale;
                out.m12 = a.m12 + b.m12 * scale;
                out.m13 = a.m13 + b.m13 * scale;
                out.m14 = a.m14 + b.m14 * scale;
                out.m15 = a.m15 + b.m15 * scale;
                return out;
              }

              static strictEquals(a, b) {
                return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08)) && Math.abs(a.m09 - b.m09) <= epsilon * Math.max(1.0, Math.abs(a.m09), Math.abs(b.m09)) && Math.abs(a.m10 - b.m10) <= epsilon * Math.max(1.0, Math.abs(a.m10), Math.abs(b.m10)) && Math.abs(a.m11 - b.m11) <= epsilon * Math.max(1.0, Math.abs(a.m11), Math.abs(b.m11)) && Math.abs(a.m12 - b.m12) <= epsilon * Math.max(1.0, Math.abs(a.m12), Math.abs(b.m12)) && Math.abs(a.m13 - b.m13) <= epsilon * Math.max(1.0, Math.abs(a.m13), Math.abs(b.m13)) && Math.abs(a.m14 - b.m14) <= epsilon * Math.max(1.0, Math.abs(a.m14), Math.abs(b.m14)) && Math.abs(a.m15 - b.m15) <= epsilon * Math.max(1.0, Math.abs(a.m15), Math.abs(b.m15));
              }

              get m00() {
                return this._array[0];
              }

              set m00(m) {
                this._array[0] = m;
              }

              get m01() {
                return this._array[1];
              }

              set m01(m) {
                this._array[1] = m;
              }

              get m02() {
                return this._array[2];
              }

              set m02(m) {
                this._array[2] = m;
              }

              get m03() {
                return this._array[3];
              }

              set m03(m) {
                this._array[3] = m;
              }

              get m04() {
                return this._array[4];
              }

              set m04(m) {
                this._array[4] = m;
              }

              get m05() {
                return this._array[5];
              }

              set m05(m) {
                this._array[5] = m;
              }

              get m06() {
                return this._array[6];
              }

              set m06(m) {
                this._array[6] = m;
              }

              get m07() {
                return this._array[7];
              }

              set m07(m) {
                this._array[7] = m;
              }

              get m08() {
                return this._array[8];
              }

              set m08(m) {
                this._array[8] = m;
              }

              get m09() {
                return this._array[9];
              }

              set m09(m) {
                this._array[9] = m;
              }

              get m10() {
                return this._array[10];
              }

              set m10(m) {
                this._array[10] = m;
              }

              get m11() {
                return this._array[11];
              }

              set m11(m) {
                this._array[11] = m;
              }

              get m12() {
                return this._array[12];
              }

              set m12(m) {
                this._array[12] = m;
              }

              get m13() {
                return this._array[13];
              }

              set m13(m) {
                this._array[13] = m;
              }

              get m14() {
                return this._array[14];
              }

              set m14(m) {
                this._array[14] = m;
              }

              get m15() {
                return this._array[15];
              }

              set m15(m) {
                this._array[15] = m;
              }

              constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 0, m05 = 1, m06 = 0, m07 = 0, m08 = 0, m09 = 0, m10 = 1, m11 = 0, m12 = 0, m13 = 0, m14 = 0, m15 = 1) {
                super();

                if (m00 && typeof m00 === 'object') {
                  if (ArrayBuffer.isView(m00)) {
                    this._array = m00;

                    this._array.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
                  } else {
                    const v = m00.array;
                    this._array = MathBase.createFloatArray(16);
                    this._array[0] = v[0];
                    this._array[1] = v[1];
                    this._array[2] = v[2];
                    this._array[3] = v[3];
                    this._array[4] = v[4];
                    this._array[5] = v[5];
                    this._array[6] = v[6];
                    this._array[7] = v[7];
                    this._array[8] = v[8];
                    this._array[9] = v[9];
                    this._array[10] = v[10];
                    this._array[11] = v[11];
                    this._array[12] = v[12];
                    this._array[13] = v[13];
                    this._array[14] = v[14];
                    this._array[15] = v[15];
                  }
                } else {
                  this._array = MathBase.createFloatArray(16);
                  this._array[0] = m00;
                  this._array[1] = m01;
                  this._array[2] = m02;
                  this._array[3] = m03;
                  this._array[4] = m04;
                  this._array[5] = m05;
                  this._array[6] = m06;
                  this._array[7] = m07;
                  this._array[8] = m08;
                  this._array[9] = m09;
                  this._array[10] = m10;
                  this._array[11] = m11;
                  this._array[12] = m12;
                  this._array[13] = m13;
                  this._array[14] = m14;
                  this._array[15] = m15;
                }
              }

              clone() {
                const v = this._array;
                return new Mat4(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9], v[10], v[11], v[12], v[13], v[14], v[15]);
              }

              set(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 0, m05 = 1, m06 = 0, m07 = 0, m08 = 0, m09 = 0, m10 = 1, m11 = 0, m12 = 0, m13 = 0, m14 = 0, m15 = 1) {
                if (m00 && typeof m00 === 'object') {
                  const v = m00.array;
                  this._array[1] = v[1];
                  this._array[2] = v[2];
                  this._array[3] = v[3];
                  this._array[4] = v[4];
                  this._array[5] = v[5];
                  this._array[6] = v[6];
                  this._array[7] = v[7];
                  this._array[8] = v[8];
                  this._array[9] = v[9];
                  this._array[10] = v[10];
                  this._array[11] = v[11];
                  this._array[12] = v[12];
                  this._array[13] = v[13];
                  this._array[14] = v[14];
                  this._array[15] = v[15];
                  this._array[0] = v[0];
                } else {
                  this._array[1] = m01;
                  this._array[2] = m02;
                  this._array[3] = m03;
                  this._array[4] = m04;
                  this._array[5] = m05;
                  this._array[6] = m06;
                  this._array[7] = m07;
                  this._array[8] = m08;
                  this._array[9] = m09;
                  this._array[10] = m10;
                  this._array[11] = m11;
                  this._array[12] = m12;
                  this._array[13] = m13;
                  this._array[14] = m14;
                  this._array[15] = m15;
                  this._array[0] = m00;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                const v = other.array;
                return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2])) && Math.abs(this._array[3] - v[3]) <= epsilon * Math.max(1.0, Math.abs(this._array[3]), Math.abs(v[3])) && Math.abs(this._array[4] - v[4]) <= epsilon * Math.max(1.0, Math.abs(this._array[4]), Math.abs(v[4])) && Math.abs(this._array[5] - v[5]) <= epsilon * Math.max(1.0, Math.abs(this._array[5]), Math.abs(v[5])) && Math.abs(this._array[6] - v[6]) <= epsilon * Math.max(1.0, Math.abs(this._array[6]), Math.abs(v[6])) && Math.abs(this._array[7] - v[7]) <= epsilon * Math.max(1.0, Math.abs(this._array[7]), Math.abs(v[7])) && Math.abs(this._array[8] - v[8]) <= epsilon * Math.max(1.0, Math.abs(this._array[8]), Math.abs(v[8])) && Math.abs(this._array[9] - v[9]) <= epsilon * Math.max(1.0, Math.abs(this._array[9]), Math.abs(v[9])) && Math.abs(this._array[10] - v[10]) <= epsilon * Math.max(1.0, Math.abs(this._array[10]), Math.abs(v[10])) && Math.abs(this._array[11] - v[11]) <= epsilon * Math.max(1.0, Math.abs(this._array[11]), Math.abs(v[11])) && Math.abs(this._array[12] - v[12]) <= epsilon * Math.max(1.0, Math.abs(this._array[12]), Math.abs(v[12])) && Math.abs(this._array[13] - v[13]) <= epsilon * Math.max(1.0, Math.abs(this._array[13]), Math.abs(v[13])) && Math.abs(this._array[14] - v[14]) <= epsilon * Math.max(1.0, Math.abs(this._array[14]), Math.abs(v[14])) && Math.abs(this._array[15] - v[15]) <= epsilon * Math.max(1.0, Math.abs(this._array[15]), Math.abs(v[15]));
              }

              strictEquals(other) {
                const v = other.array;
                return this._array[0] === other.m00 && this._array[1] === v[1] && this._array[2] === v[2] && this._array[3] === v[3] && this._array[4] === v[4] && this._array[5] === v[5] && this._array[6] === v[6] && this._array[7] === v[7] && this._array[8] === v[8] && this._array[9] === v[9] && this._array[10] === v[10] && this._array[11] === v[11] && this._array[12] === v[12] && this._array[13] === v[13] && this._array[14] === v[14] && this._array[15] === v[15];
              }

              toString() {
                return `[\n${this._array[0]}, ${this._array[1]}, ${this._array[2]}, ${this._array[3]},\n${this._array[4]}, ${this._array[5]}, ${this._array[6]}, ${this._array[7]},\n${this._array[8]}, ${this._array[9]}, ${this._array[10]}, ${this._array[11]},\n${this._array[12]}, ${this._array[13]}, ${this._array[14]}, ${this._array[15]}\n` + `]`;
              }

              identity() {
                this._array[0] = 1;
                this._array[1] = 0;
                this._array[2] = 0;
                this._array[3] = 0;
                this._array[4] = 0;
                this._array[5] = 1;
                this._array[6] = 0;
                this._array[7] = 0;
                this._array[8] = 0;
                this._array[9] = 0;
                this._array[10] = 1;
                this._array[11] = 0;
                this._array[12] = 0;
                this._array[13] = 0;
                this._array[14] = 0;
                this._array[15] = 1;
                return this;
              }

              zero() {
                this.m00 = 0;
                this.m01 = 0;
                this.m02 = 0;
                this.m03 = 0;
                this.m04 = 0;
                this.m05 = 0;
                this.m06 = 0;
                this.m07 = 0;
                this.m08 = 0;
                this.m09 = 0;
                this.m10 = 0;
                this.m11 = 0;
                this.m12 = 0;
                this.m13 = 0;
                this.m14 = 0;
                this.m15 = 0;
                return this;
              }

              transpose() {
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a03 = this._array[3];
                const a12 = this._array[6];
                const a13 = this._array[7];
                const a23 = this._array[11];
                this._array[1] = this._array[4];
                this._array[2] = this._array[8];
                this._array[3] = this._array[12];
                this._array[4] = a01;
                this._array[6] = this._array[9];
                this._array[7] = this._array[13];
                this._array[8] = a02;
                this._array[9] = a12;
                this._array[11] = this._array[14];
                this._array[12] = a03;
                this._array[13] = a13;
                this._array[14] = a23;
                return this;
              }

              invert() {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a03 = this._array[3];
                const a10 = this._array[4];
                const a11 = this._array[5];
                const a12 = this._array[6];
                const a13 = this._array[7];
                const a20 = this._array[8];
                const a21 = this._array[9];
                const a22 = this._array[10];
                const a23 = this._array[11];
                const a30 = this._array[12];
                const a31 = this._array[13];
                const a32 = this._array[14];
                const a33 = this._array[15];
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (det === 0) {
                  this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                  return this;
                }

                det = 1.0 / det;
                this._array[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                this._array[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                this._array[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                this._array[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                this._array[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                this._array[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                this._array[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                this._array[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                this._array[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                this._array[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                this._array[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                this._array[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                this._array[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                this._array[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                this._array[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                this._array[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return this;
              }

              determinant() {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a03 = this._array[3];
                const a10 = this._array[4];
                const a11 = this._array[5];
                const a12 = this._array[6];
                const a13 = this._array[7];
                const a20 = this._array[8];
                const a21 = this._array[9];
                const a22 = this._array[10];
                const a23 = this._array[11];
                const a30 = this._array[12];
                const a31 = this._array[13];
                const a32 = this._array[14];
                const a33 = this._array[15];
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              }

              add(mat) {
                const v = mat.array;
                this._array[0] += v[0];
                this._array[1] += v[1];
                this._array[2] += v[2];
                this._array[3] += v[3];
                this._array[4] += v[4];
                this._array[5] += v[5];
                this._array[6] += v[6];
                this._array[7] += v[7];
                this._array[8] += v[8];
                this._array[9] += v[9];
                this._array[10] += v[10];
                this._array[11] += v[11];
                this._array[12] += v[12];
                this._array[13] += v[13];
                this._array[14] += v[14];
                this._array[15] += v[15];
                return this;
              }

              subtract(mat) {
                const v = mat.array;
                this._array[0] -= v[0];
                this._array[1] -= v[1];
                this._array[2] -= v[2];
                this._array[3] -= v[3];
                this._array[4] -= v[4];
                this._array[5] -= v[5];
                this._array[6] -= v[6];
                this._array[7] -= v[7];
                this._array[8] -= v[8];
                this._array[9] -= v[9];
                this._array[10] -= v[10];
                this._array[11] -= v[11];
                this._array[12] -= v[12];
                this._array[13] -= v[13];
                this._array[14] -= v[14];
                this._array[15] -= v[15];
                return this;
              }

              multiply(mat) {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a03 = this._array[3];
                const a10 = this._array[4];
                const a11 = this._array[5];
                const a12 = this._array[6];
                const a13 = this._array[7];
                const a20 = this._array[8];
                const a21 = this._array[9];
                const a22 = this._array[10];
                const a23 = this._array[11];
                const a30 = this._array[12];
                const a31 = this._array[13];
                const a32 = this._array[14];
                const a33 = this._array[15];
                const v = mat.array;
                let b0 = v[0];
                let b1 = v[1];
                let b2 = v[2];
                let b3 = v[3];
                this._array[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                this._array[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                this._array[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                this._array[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = v[4];
                b1 = v[5];
                b2 = v[6];
                b3 = v[7];
                this._array[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                this._array[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                this._array[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                this._array[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = v[8];
                b1 = v[9];
                b2 = v[10];
                b3 = v[11];
                this._array[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                this._array[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                this._array[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                this._array[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = v[12];
                b1 = v[13];
                b2 = v[14];
                b3 = v[15];
                this._array[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                this._array[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                this._array[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                this._array[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                return this;
              }

              multiplyScalar(scalar) {
                this._array[0] *= scalar;
                this._array[1] *= scalar;
                this._array[2] *= scalar;
                this._array[3] *= scalar;
                this._array[4] *= scalar;
                this._array[5] *= scalar;
                this._array[6] *= scalar;
                this._array[7] *= scalar;
                this._array[8] *= scalar;
                this._array[9] *= scalar;
                this._array[10] *= scalar;
                this._array[11] *= scalar;
                this._array[12] *= scalar;
                this._array[13] *= scalar;
                this._array[14] *= scalar;
                this._array[15] *= scalar;
                return this;
              }

              translate(vec) {
                console.warn('function changed');
                const v = vec.array;
                this._array[12] += v[0];
                this._array[13] += v[1];
                this._array[14] += v[2];
                return this;
              }

              scale(vec) {
                const v = vec.array;
                const x = v[0];
                const y = v[1];
                const z = v[2];
                this._array[0] *= x;
                this._array[1] *= x;
                this._array[2] *= x;
                this._array[3] *= x;
                this._array[4] *= y;
                this._array[5] *= y;
                this._array[6] *= y;
                this._array[7] *= y;
                this._array[8] *= z;
                this._array[9] *= z;
                this._array[10] *= z;
                this._array[11] *= z;
                return this;
              }

              rotate(rad, axis) {
                let x = axis.x;
                let y = axis.y;
                let z = axis.z;
                let len = Math.sqrt(x * x + y * y + z * z);

                if (Math.abs(len) < EPSILON) {
                  return null;
                }

                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const t = 1 - c;
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a03 = this._array[3];
                const a10 = this._array[4];
                const a11 = this._array[5];
                const a12 = this._array[6];
                const a13 = this._array[7];
                const a20 = this._array[8];
                const a21 = this._array[9];
                const a22 = this._array[10];
                const a23 = this._array[11];
                const b00 = x * x * t + c;
                const b01 = y * x * t + z * s;
                const b02 = z * x * t - y * s;
                const b10 = x * y * t - z * s;
                const b11 = y * y * t + c;
                const b12 = z * y * t + x * s;
                const b20 = x * z * t + y * s;
                const b21 = y * z * t - x * s;
                const b22 = z * z * t + c;
                this._array[0] = a00 * b00 + a10 * b01 + a20 * b02;
                this._array[1] = a01 * b00 + a11 * b01 + a21 * b02;
                this._array[2] = a02 * b00 + a12 * b01 + a22 * b02;
                this._array[3] = a03 * b00 + a13 * b01 + a23 * b02;
                this._array[4] = a00 * b10 + a10 * b11 + a20 * b12;
                this._array[5] = a01 * b10 + a11 * b11 + a21 * b12;
                this._array[6] = a02 * b10 + a12 * b11 + a22 * b12;
                this._array[7] = a03 * b10 + a13 * b11 + a23 * b12;
                this._array[8] = a00 * b20 + a10 * b21 + a20 * b22;
                this._array[9] = a01 * b20 + a11 * b21 + a21 * b22;
                this._array[10] = a02 * b20 + a12 * b21 + a22 * b22;
                this._array[11] = a03 * b20 + a13 * b21 + a23 * b22;
                return this;
              }

              getTranslation(out) {
                out.x = this._array[12];
                out.y = this._array[13];
                out.z = this._array[14];
                return out;
              }

              getScale(out) {
                const o = out.array;
                const t = m3_1$1.array;
                const m00 = t[0] = this._array[0];
                const m01 = t[1] = this._array[1];
                const m02 = t[2] = this._array[2];
                const m04 = t[3] = this._array[4];
                const m05 = t[4] = this._array[5];
                const m06 = t[5] = this._array[6];
                const m08 = t[6] = this._array[8];
                const m09 = t[7] = this._array[9];
                const m10 = t[8] = this._array[10];
                o[0] = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
                o[1] = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
                o[2] = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);

                if (Mat3.determinant(m3_1$1) < 0) {
                  out.x *= -1;
                }

                return out;
              }

              getRotation(out) {
                const trace = this._array[0] + this._array[5] + this._array[10];
                let S = 0;

                if (trace > 0) {
                  S = Math.sqrt(trace + 1.0) * 2;
                  out.w = 0.25 * S;
                  out.x = (this._array[6] - this._array[9]) / S;
                  out.y = (this._array[8] - this._array[2]) / S;
                  out.z = (this._array[1] - this._array[4]) / S;
                } else if (this._array[0] > this._array[5] && this._array[0] > this._array[10]) {
                  S = Math.sqrt(1.0 + this._array[0] - this._array[5] - this._array[10]) * 2;
                  out.w = (this._array[6] - this._array[9]) / S;
                  out.x = 0.25 * S;
                  out.y = (this._array[1] + this._array[4]) / S;
                  out.z = (this._array[8] + this._array[2]) / S;
                } else if (this._array[5] > this._array[10]) {
                  S = Math.sqrt(1.0 + this._array[5] - this._array[0] - this._array[10]) * 2;
                  out.w = (this._array[8] - this._array[2]) / S;
                  out.x = (this._array[1] + this._array[4]) / S;
                  out.y = 0.25 * S;
                  out.z = (this._array[6] + this._array[9]) / S;
                } else {
                  S = Math.sqrt(1.0 + this._array[10] - this._array[0] - this._array[5]) * 2;
                  out.w = (this._array[1] - this._array[4]) / S;
                  out.x = (this._array[8] + this._array[2]) / S;
                  out.y = (this._array[6] + this._array[9]) / S;
                  out.z = 0.25 * S;
                }

                return out;
              }

              fromRTS(q, v, s) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const xy = x * y2;
                const xz = x * z2;
                const yy = y * y2;
                const yz = y * z2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                const sx = s.x;
                const sy = s.y;
                const sz = s.z;
                this._array[0] = (1 - (yy + zz)) * sx;
                this._array[1] = (xy + wz) * sx;
                this._array[2] = (xz - wy) * sx;
                this._array[3] = 0;
                this._array[4] = (xy - wz) * sy;
                this._array[5] = (1 - (xx + zz)) * sy;
                this._array[6] = (yz + wx) * sy;
                this._array[7] = 0;
                this._array[8] = (xz + wy) * sz;
                this._array[9] = (yz - wx) * sz;
                this._array[10] = (1 - (xx + yy)) * sz;
                this._array[11] = 0;
                this._array[12] = v.x;
                this._array[13] = v.y;
                this._array[14] = v.z;
                this._array[15] = 1;
                return this;
              }

              fromQuat(q) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const yx = y * x2;
                const yy = y * y2;
                const zx = z * x2;
                const zy = z * y2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                this._array[0] = 1 - yy - zz;
                this._array[1] = yx + wz;
                this._array[2] = zx - wy;
                this._array[3] = 0;
                this._array[4] = yx - wz;
                this._array[5] = 1 - xx - zz;
                this._array[6] = zy + wx;
                this._array[7] = 0;
                this._array[8] = zx + wy;
                this._array[9] = zy - wx;
                this._array[10] = 1 - xx - yy;
                this._array[11] = 0;
                this._array[12] = 0;
                this._array[13] = 0;
                this._array[14] = 0;
                this._array[15] = 1;
                return this;
              }

            } exports('c4', Mat4);
            Mat4.IDENTITY = Object.freeze(new Mat4());
            const v3_1$3 = new Vec3();
            const m3_1$1 = new Mat3();
            enumerableProps(Mat4.prototype, ['m00', 'm01', 'm02', 'm03', 'm04', 'm05', 'm06', 'm07', 'm08', 'm09', 'm10', 'm11', 'm12', 'm13', 'm14', 'm15']);
            CCClass.fastDefine('cc.Mat4', Mat4, {
              m00: 1,
              m01: 0,
              m02: 0,
              m03: 0,
              m04: 0,
              m05: 1,
              m06: 0,
              m07: 0,
              m08: 0,
              m09: 0,
              m10: 1,
              m11: 0,
              m12: 0,
              m13: 0,
              m14: 0,
              m15: 1
            });
            legacyCC.Mat4 = Mat4;
            function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
              return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
            }
            legacyCC.mat4 = mat4;

            class Vec2 extends ValueType {
              static clone(a) {
                return new Vec2(a.x, a.y);
              }

              static copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                return out;
              }

              static set(out, x, y) {
                out.x = x;
                out.y = y;
                return out;
              }

              static add(out, a, b) {
                out.x = a.x + b.x;
                out.y = a.y + b.y;
                return out;
              }

              static subtract(out, a, b) {
                out.x = a.x - b.x;
                out.y = a.y - b.y;
                return out;
              }

              static multiply(out, a, b) {
                out.x = a.x * b.x;
                out.y = a.y * b.y;
                return out;
              }

              static divide(out, a, b) {
                out.x = a.x / b.x;
                out.y = a.y / b.y;
                return out;
              }

              static ceil(out, a) {
                out.x = Math.ceil(a.x);
                out.y = Math.ceil(a.y);
                return out;
              }

              static floor(out, a) {
                out.x = Math.floor(a.x);
                out.y = Math.floor(a.y);
                return out;
              }

              static min(out, a, b) {
                out.x = Math.min(a.x, b.x);
                out.y = Math.min(a.y, b.y);
                return out;
              }

              static max(out, a, b) {
                out.x = Math.max(a.x, b.x);
                out.y = Math.max(a.y, b.y);
                return out;
              }

              static round(out, a) {
                out.x = Math.round(a.x);
                out.y = Math.round(a.y);
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                return out;
              }

              static scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                return out;
              }

              static distance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                return Math.sqrt(x * x + y * y);
              }

              static squaredDistance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                return x * x + y * y;
              }

              static len(a) {
                const x = a.x;
                const y = a.y;
                return Math.sqrt(x * x + y * y);
              }

              static lengthSqr(a) {
                const x = a.x;
                const y = a.y;
                return x * x + y * y;
              }

              static negate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                return out;
              }

              static inverse(out, a) {
                out.x = 1.0 / a.x;
                out.y = 1.0 / a.y;
                return out;
              }

              static inverseSafe(out, a) {
                const x = a.x;
                const y = a.y;

                if (Math.abs(x) < EPSILON) {
                  out.x = 0;
                } else {
                  out.x = 1.0 / x;
                }

                if (Math.abs(y) < EPSILON) {
                  out.y = 0;
                } else {
                  out.y = 1.0 / y;
                }

                return out;
              }

              static normalize(out, a) {
                const x = a.x;
                const y = a.y;
                let len = x * x + y * y;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  out.x = x * len;
                  out.y = y * len;
                }

                return out;
              }

              static dot(a, b) {
                return a.x * b.x + a.y * b.y;
              }

              static cross(out, a, b) {
                out.x = out.y = 0;
                out.z = a.x * b.y - a.y * b.x;
                return out;
              }

              static lerp(out, a, b, t) {
                const x = a.x;
                const y = a.y;
                out.x = x + t * (b.x - x);
                out.y = y + t * (b.y - y);
                return out;
              }

              static random(out, scale) {
                scale = scale || 1.0;
                const r = random() * 2.0 * Math.PI;
                out.x = Math.cos(r) * scale;
                out.y = Math.sin(r) * scale;
                return out;
              }

              static transformMat3(out, a, m) {
                const x = a.x;
                const y = a.y;
                out.x = m.m00 * x + m.m03 * y + m.m06;
                out.y = m.m01 * x + m.m04 * y + m.m07;
                return out;
              }

              static transformMat4(out, a, m) {
                const x = a.x;
                const y = a.y;
                out.x = m.m00 * x + m.m04 * y + m.m12;
                out.y = m.m01 * x + m.m05 * y + m.m13;
                return out;
              }

              static str(a) {
                return `Vec2(${a.x}, ${a.y})`;
              }

              static toArray(out, v, ofs = 0) {
                out[ofs + 0] = v.x;
                out[ofs + 1] = v.y;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                return out;
              }

              static strictEquals(a, b) {
                return a.x === b.x && a.y === b.y;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y));
              }

              static angle(a, b) {
                Vec2.normalize(v2_1, a);
                Vec2.normalize(v2_2, b);
                const cosine = Vec2.dot(v2_1, v2_2);

                if (cosine > 1.0) {
                  return 0;
                }

                if (cosine < -1.0) {
                  return Math.PI;
                }

                return Math.acos(cosine);
              }

              constructor(x, y) {
                super();

                if (x && typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                }
              }

              clone() {
                return new Vec2(this.x, this.y);
              }

              set(x, y) {
                if (x && typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y));
              }

              equals2f(x, y, epsilon = EPSILON) {
                return Math.abs(this.x - x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(y));
              }

              strictEquals(other) {
                return other && this.x === other.x && this.y === other.y;
              }

              strictEquals2f(x, y) {
                return this.x === x && this.y === y;
              }

              toString() {
                return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
              }

              lerp(to, ratio) {
                const x = this.x;
                const y = this.y;
                this.x = x + ratio * (to.x - x);
                this.y = y + ratio * (to.y - y);
                return this;
              }

              clampf(minInclusive, maxInclusive) {
                this.x = clamp(this.x, minInclusive.x, maxInclusive.x);
                this.y = clamp(this.y, minInclusive.y, maxInclusive.y);
                return this;
              }

              add(other) {
                this.x += other.x;
                this.y += other.y;
                return this;
              }

              add2f(x, y) {
                this.x += x;
                this.y += y;
                return this;
              }

              subtract(other) {
                this.x -= other.x;
                this.y -= other.y;
                return this;
              }

              subtract2f(x, y) {
                this.x -= x;
                this.y -= y;
                return this;
              }

              multiplyScalar(scalar) {
                if (typeof scalar === 'object') {
                  console.warn('should use Vec2.multiply for vector * vector operation');
                }

                this.x *= scalar;
                this.y *= scalar;
                return this;
              }

              multiply(other) {
                if (typeof other !== 'object') {
                  console.warn('should use Vec2.scale for vector * scalar operation');
                }

                this.x *= other.x;
                this.y *= other.y;
                return this;
              }

              multiply2f(x, y) {
                this.x *= x;
                this.y *= y;
                return this;
              }

              divide(other) {
                this.x /= other.x;
                this.y /= other.y;
                return this;
              }

              divide2f(x, y) {
                this.x /= x;
                this.y /= y;
                return this;
              }

              negative() {
                this.x = -this.x;
                this.y = -this.y;
                return this;
              }

              dot(other) {
                return this.x * other.x + this.y * other.y;
              }

              cross(other) {
                return this.x * other.y - this.y * other.x;
              }

              length() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
              }

              lengthSqr() {
                return this.x * this.x + this.y * this.y;
              }

              normalize() {
                const x = this.x;
                const y = this.y;
                let len = x * x + y * y;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  this.x *= len;
                  this.y *= len;
                }

                return this;
              }

              angle(other) {
                const magSqr1 = this.lengthSqr();
                const magSqr2 = other.lengthSqr();

                if (magSqr1 === 0 || magSqr2 === 0) {
                  console.warn('Can\'t get angle between zero vector');
                  return 0.0;
                }

                const dot = this.dot(other);
                let theta = dot / Math.sqrt(magSqr1 * magSqr2);
                theta = clamp(theta, -1.0, 1.0);
                return Math.acos(theta);
              }

              signAngle(other) {
                const angle = this.angle(other);
                return this.cross(other) < 0 ? -angle : angle;
              }

              rotate(radians) {
                const x = this.x;
                const y = this.y;
                const sin = Math.sin(radians);
                const cos = Math.cos(radians);
                this.x = cos * x - sin * y;
                this.y = sin * x + cos * y;
                return this;
              }

              project(other) {
                const scalar = this.dot(other) / other.dot(other);
                this.x = other.x * scalar;
                this.y = other.y * scalar;
                return this;
              }

              transformMat4(matrix) {
                const x = this.x;
                const y = this.y;
                this.x = matrix.m00 * x + matrix.m04 * y + matrix.m12;
                this.y = matrix.m01 * x + matrix.m05 * y + matrix.m13;
                return this;
              }

            } exports('cD', Vec2);
            Vec2.ZERO = Object.freeze(new Vec2(0, 0));
            Vec2.ONE = Object.freeze(new Vec2(1, 1));
            Vec2.NEG_ONE = Object.freeze(new Vec2(-1, -1));
            Vec2.UNIT_X = Object.freeze(new Vec2(1, 0));
            Vec2.UNIT_Y = Object.freeze(new Vec2(0, 1));
            const v2_1 = new Vec2();
            const v2_2 = new Vec2();
            CCClass.fastDefine('cc.Vec2', Vec2, {
              x: 0,
              y: 0
            });
            legacyCC.Vec2 = Vec2;
            function v2(x, y) {
              return new Vec2(x, y);
            }
            legacyCC.v2 = v2;

            class Vec4 extends ValueType {
              static clone(a) {
                return new Vec4(a.x, a.y, a.z, a.w);
              }

              static copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                out.w = a.w;
                return out;
              }

              static set(out, x, y, z, w) {
                out.x = x;
                out.y = y;
                out.z = z;
                out.w = w;
                return out;
              }

              static add(out, a, b) {
                out.x = a.x + b.x;
                out.y = a.y + b.y;
                out.z = a.z + b.z;
                out.w = a.w + b.w;
                return out;
              }

              static subtract(out, a, b) {
                out.x = a.x - b.x;
                out.y = a.y - b.y;
                out.z = a.z - b.z;
                out.w = a.w - b.w;
                return out;
              }

              static multiply(out, a, b) {
                out.x = a.x * b.x;
                out.y = a.y * b.y;
                out.z = a.z * b.z;
                out.w = a.w * b.w;
                return out;
              }

              static divide(out, a, b) {
                out.x = a.x / b.x;
                out.y = a.y / b.y;
                out.z = a.z / b.z;
                out.w = a.w / b.w;
                return out;
              }

              static ceil(out, a) {
                out.x = Math.ceil(a.x);
                out.y = Math.ceil(a.y);
                out.z = Math.ceil(a.z);
                out.w = Math.ceil(a.w);
                return out;
              }

              static floor(out, a) {
                out.x = Math.floor(a.x);
                out.y = Math.floor(a.y);
                out.z = Math.floor(a.z);
                out.w = Math.floor(a.w);
                return out;
              }

              static min(out, a, b) {
                out.x = Math.min(a.x, b.x);
                out.y = Math.min(a.y, b.y);
                out.z = Math.min(a.z, b.z);
                out.w = Math.min(a.w, b.w);
                return out;
              }

              static max(out, a, b) {
                out.x = Math.max(a.x, b.x);
                out.y = Math.max(a.y, b.y);
                out.z = Math.max(a.z, b.z);
                out.w = Math.max(a.w, b.w);
                return out;
              }

              static round(out, a) {
                out.x = Math.round(a.x);
                out.y = Math.round(a.y);
                out.z = Math.round(a.z);
                out.w = Math.round(a.w);
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                out.z = a.z * b;
                out.w = a.w * b;
                return out;
              }

              static scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                out.z = a.z + b.z * scale;
                out.w = a.w + b.w * scale;
                return out;
              }

              static distance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                const z = b.z - a.z;
                const w = b.w - a.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
              }

              static squaredDistance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                const z = b.z - a.z;
                const w = b.w - a.w;
                return x * x + y * y + z * z + w * w;
              }

              static len(a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                const w = a.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
              }

              static lengthSqr(a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                const w = a.w;
                return x * x + y * y + z * z + w * w;
              }

              static negate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                out.z = -a.z;
                out.w = -a.w;
                return out;
              }

              static inverse(out, a) {
                out.x = 1.0 / a.x;
                out.y = 1.0 / a.y;
                out.z = 1.0 / a.z;
                out.w = 1.0 / a.w;
                return out;
              }

              static inverseSafe(out, a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                const w = a.w;

                if (Math.abs(x) < EPSILON) {
                  out.x = 0;
                } else {
                  out.x = 1.0 / x;
                }

                if (Math.abs(y) < EPSILON) {
                  out.y = 0;
                } else {
                  out.y = 1.0 / y;
                }

                if (Math.abs(z) < EPSILON) {
                  out.z = 0;
                } else {
                  out.z = 1.0 / z;
                }

                if (Math.abs(w) < EPSILON) {
                  out.w = 0;
                } else {
                  out.w = 1.0 / w;
                }

                return out;
              }

              static normalize(out, a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                const w = a.w;
                let len = x * x + y * y + z * z + w * w;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  out.x = x * len;
                  out.y = y * len;
                  out.z = z * len;
                  out.w = w * len;
                }

                return out;
              }

              static dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
              }

              static lerp(out, a, b, t) {
                out.x = a.x + t * (b.x - a.x);
                out.y = a.y + t * (b.y - a.y);
                out.z = a.z + t * (b.z - a.z);
                out.w = a.w + t * (b.w - a.w);
                return out;
              }

              static random(out, scale) {
                scale = scale || 1.0;
                const phi = random() * 2.0 * Math.PI;
                const cosTheta = random() * 2 - 1;
                const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                out.x = sinTheta * Math.cos(phi) * scale;
                out.y = sinTheta * Math.sin(phi) * scale;
                out.z = cosTheta * scale;
                out.w = 0;
                return out;
              }

              static transformMat4(out, a, m) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                const w = a.w;
                out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
                out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
                out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
                out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w;
                return out;
              }

              static transformAffine(out, v, m) {
                const x = v.x;
                const y = v.y;
                const z = v.z;
                const w = v.w;
                out.x = m.m00 * x + m.m01 * y + m.m02 * z + m.m03 * w;
                out.y = m.m04 * x + m.m05 * y + m.m06 * z + m.m07 * w;
                out.x = m.m08 * x + m.m09 * y + m.m10 * z + m.m11 * w;
                out.w = v.w;
                return out;
              }

              static transformQuat(out, a, q) {
                const {
                  x,
                  y,
                  z
                } = a;
                const _x = q.x;
                const _y = q.y;
                const _z = q.z;
                const _w = q.w;
                const ix = _w * x + _y * z - _z * y;
                const iy = _w * y + _z * x - _x * z;
                const iz = _w * z + _x * y - _y * x;
                const iw = -_x * x - _y * y - _z * z;
                out.x = ix * _w + iw * -_x + iy * -_z - iz * -_y;
                out.y = iy * _w + iw * -_y + iz * -_x - ix * -_z;
                out.z = iz * _w + iw * -_z + ix * -_y - iy * -_x;
                out.w = a.w;
                return out;
              }

              static toArray(out, v, ofs = 0) {
                out[ofs + 0] = v.x;
                out[ofs + 1] = v.y;
                out[ofs + 2] = v.z;
                out[ofs + 3] = v.w;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                out.z = arr[ofs + 2];
                out.w = arr[ofs + 3];
                return out;
              }

              static strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
              }

              constructor(x, y, z, w) {
                super();

                if (x && typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                  this.z = x.z;
                  this.w = x.w;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                  this.w = w || 0;
                }
              }

              clone() {
                return new Vec4(this.x, this.y, this.z, this.w);
              }

              set(x, y, z, w) {
                if (x && typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                  this.z = x.z;
                  this.w = x.w;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                  this.w = w || 0;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(other.w));
              }

              equals4f(x, y, z, w, epsilon = EPSILON) {
                return Math.abs(this.x - x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(z)) && Math.abs(this.w - w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(w));
              }

              strictEquals(other) {
                return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
              }

              strictEquals4f(x, y, z, w) {
                return this.x === x && this.y === y && this.z === z && this.w === w;
              }

              lerp(to, ratio) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;
                this.x = x + ratio * (to.x - x);
                this.y = y + ratio * (to.y - y);
                this.z = z + ratio * (to.z - z);
                this.w = w + ratio * (to.w - w);
                return this;
              }

              toString() {
                return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.z.toFixed(2)}, ${this.w.toFixed(2)})`;
              }

              clampf(minInclusive, maxInclusive) {
                this.x = clamp(this.x, minInclusive.x, maxInclusive.x);
                this.y = clamp(this.y, minInclusive.y, maxInclusive.y);
                this.z = clamp(this.z, minInclusive.z, maxInclusive.z);
                this.w = clamp(this.w, minInclusive.w, maxInclusive.w);
                return this;
              }

              add(other) {
                this.x += other.x;
                this.y += other.y;
                this.z += other.z;
                this.w += other.w;
                return this;
              }

              add4f(x, y, z, w) {
                this.x += x;
                this.y += y;
                this.z += z;
                this.w += w;
                return this;
              }

              subtract(other) {
                this.x -= other.x;
                this.y -= other.y;
                this.z -= other.z;
                this.w -= other.w;
                return this;
              }

              subtract4f(x, y, z, w) {
                this.x -= x;
                this.y -= y;
                this.z -= z;
                this.w -= w;
                return this;
              }

              multiplyScalar(scalar) {
                if (typeof scalar === 'object') {
                  console.warn('should use Vec4.multiply for vector * vector operation');
                }

                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
                this.w *= scalar;
                return this;
              }

              multiply(other) {
                if (typeof other !== 'object') {
                  console.warn('should use Vec4.scale for vector * scalar operation');
                }

                this.x *= other.x;
                this.y *= other.y;
                this.z *= other.z;
                this.w *= other.w;
                return this;
              }

              multiply4f(x, y, z, w) {
                this.x *= x;
                this.y *= y;
                this.z *= z;
                this.w *= w;
                return this;
              }

              divide(other) {
                this.x /= other.x;
                this.y /= other.y;
                this.z /= other.z;
                this.w /= other.w;
                return this;
              }

              divide4f(x, y, z, w) {
                this.x /= x;
                this.y /= y;
                this.z /= z;
                this.w /= w;
                return this;
              }

              negative() {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                this.w = -this.w;
                return this;
              }

              dot(vector) {
                return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
              }

              cross(vector) {
                const {
                  x: ax,
                  y: ay,
                  z: az
                } = this;
                const {
                  x: bx,
                  y: by,
                  z: bz
                } = vector;
                this.x = ay * bz - az * by;
                this.y = az * bx - ax * bz;
                this.z = ax * by - ay * bx;
                return this;
              }

              length() {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
              }

              lengthSqr() {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;
                return x * x + y * y + z * z + w * w;
              }

              normalize() {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;
                let len = x * x + y * y + z * z + w * w;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  this.x = x * len;
                  this.y = y * len;
                  this.z = z * len;
                  this.w = w * len;
                }

                return this;
              }

              transformMat4(matrix) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;
                this.x = matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12 * w;
                this.y = matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13 * w;
                this.z = matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14 * w;
                this.w = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15 * w;
                return this;
              }

            } exports('bX', Vec4);
            Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));
            Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));
            Vec4.NEG_ONE = Object.freeze(new Vec4(-1, -1, -1, -1));
            CCClass.fastDefine('cc.Vec4', Vec4, {
              x: 0,
              y: 0,
              z: 0,
              w: 0
            });
            legacyCC.Vec4 = Vec4;
            function v4(x, y, z, w) {
              return new Vec4(x, y, z, w);
            }
            legacyCC.v4 = v4;

            replaceProperty(Vec2, 'Vec2', [{
              name: 'sub',
              newName: 'subtract',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'div',
              newName: 'divide',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'dist',
              newName: 'distance',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'sqrDist',
              newName: 'squaredDistance',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'mag',
              newName: 'len',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec2,
              targetName: 'Vec2'
            }]);
            replaceProperty(Vec2.prototype, 'Vec2', [{
              name: 'mag',
              newName: 'length',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }, {
              name: 'magSqr',
              newName: 'lengthSqr',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }]);
            replaceProperty(Vec3, 'Vec3', [{
              name: 'sub',
              newName: 'subtract',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'div',
              newName: 'divide',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'dist',
              newName: 'distance',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'sqrDist',
              newName: 'squaredDistance',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'mag',
              newName: 'len',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec3,
              targetName: 'Vec3'
            }]);
            replaceProperty(Vec3.prototype, 'Vec3', [{
              name: 'mag',
              newName: 'length',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }, {
              name: 'magSqr',
              newName: 'lengthSqr',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }]);
            replaceProperty(Vec4, 'Vec4', [{
              name: 'sub',
              newName: 'subtract',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'div',
              newName: 'divide',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'dist',
              newName: 'distance',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'sqrDist',
              newName: 'squaredDistance',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'mag',
              newName: 'len',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec4,
              targetName: 'Vec4'
            }]);
            replaceProperty(Vec4.prototype, 'Vec4', [{
              name: 'mag',
              newName: 'length',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }, {
              name: 'magSqr',
              newName: 'lengthSqr',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }]);
            replaceProperty(Quat, 'Quat', [{
              name: 'mag',
              newName: 'len',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Quat,
              targetName: 'Quat'
            }]);
            replaceProperty(Quat.prototype, 'Quat', [{
              name: 'scale',
              newName: 'multiplyScalar',
              target: Quat.prototype,
              targetName: 'Quat'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Quat.prototype,
              targetName: 'Quat'
            }]);
            replaceProperty(Color, 'Color', [{
              name: 'sub',
              newName: 'subtract',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'div',
              newName: 'divide',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'fromHex',
              newName: 'fromHEX',

              customFunction(...args) {
                const arg1 = args[1].toString(16);
                return legacyCC.Color.fromHEX(args[0], arg1);
              }

            }]);
            replaceProperty(Mat3, 'Mat3', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat3,
              targetName: 'Mat3'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat3,
              targetName: 'Mat3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat3,
              targetName: 'Mat3'
            }, {
              name: 'transfrom',
              newName: 'transform',
              target: Mat3,
              targetName: 'Mat3'
            }]);
            replaceProperty(Mat3.prototype, 'Mat3', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }, {
              name: 'mulScalar',
              newName: 'multiplyScalar',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }]);
            replaceProperty(Mat4, 'Mat4', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat4,
              targetName: 'Mat4'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat4,
              targetName: 'Mat4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat4,
              targetName: 'Mat4'
            }]);
            replaceProperty(Mat4.prototype, 'Mat4', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }, {
              name: 'mulScalar',
              newName: 'multiplyScalar',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }]);

            class AffineTransform {
              static identity() {
                return new AffineTransform();
              }

              static clone(affineTransform) {
                return new AffineTransform(affineTransform.a, affineTransform.b, affineTransform.c, affineTransform.d, affineTransform.tx, affineTransform.ty);
              }

              static concat(out, t1, t2) {
                const a = t1.a;
                const b = t1.b;
                const c = t1.c;
                const d = t1.d;
                const tx = t1.tx;
                const ty = t1.ty;
                out.a = a * t2.a + b * t2.c;
                out.b = a * t2.b + b * t2.d;
                out.c = c * t2.a + d * t2.c;
                out.d = c * t2.b + d * t2.d;
                out.tx = tx * t2.a + ty * t2.c + t2.tx;
                out.ty = tx * t2.b + ty * t2.d + t2.ty;
              }

              static invert(out, t) {
                const determinant = 1 / (t.a * t.d - t.b * t.c);
                out.a = determinant * t.d;
                out.b = -determinant * t.b;
                out.c = -determinant * t.c;
                out.d = determinant * t.a;
                out.tx = determinant * (t.c * t.ty - t.d * t.tx);
                out.ty = determinant * (t.b * t.tx - t.a * t.ty);
              }

              static fromMat4(out, mat) {
                out.a = mat.m00;
                out.b = mat.m01;
                out.c = mat.m04;
                out.d = mat.m05;
                out.tx = mat.m12;
                out.ty = mat.m13;
              }

              static transformVec2(out, point, transOrY, t) {
                let x;
                let y;

                if (t === undefined) {
                  t = transOrY;
                  x = point.x;
                  y = point.y;
                } else {
                  x = point;
                  y = transOrY;
                }

                out.x = t.a * x + t.c * y + t.tx;
                out.y = t.b * x + t.d * y + t.ty;
              }

              static transformSize(out, size, t) {
                out.width = t.a * size.width + t.c * size.height;
                out.height = t.b * size.width + t.d * size.height;
              }

              static transformRect(out, rect, t) {
                const or = rect.x + rect.width;
                const ot = rect.y + rect.height;
                const lbx = t.a * rect.x + t.c * rect.y + t.tx;
                const lby = t.b * rect.x + t.d * rect.y + t.ty;
                const rbx = t.a * or + t.c * rect.y + t.tx;
                const rby = t.b * or + t.d * rect.y + t.ty;
                const ltx = t.a * rect.x + t.c * ot + t.tx;
                const lty = t.b * rect.x + t.d * ot + t.ty;
                const rtx = t.a * or + t.c * ot + t.tx;
                const rty = t.b * or + t.d * ot + t.ty;
                const minX = Math.min(lbx, rbx, ltx, rtx);
                const maxX = Math.max(lbx, rbx, ltx, rtx);
                const minY = Math.min(lby, rby, lty, rty);
                const maxY = Math.max(lby, rby, lty, rty);
                out.x = minX;
                out.y = minY;
                out.width = maxX - minX;
                out.height = maxY - minY;
              }

              static transformObb(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
                const tx = anAffineTransform.a * rect.x + anAffineTransform.c * rect.y + anAffineTransform.tx;
                const ty = anAffineTransform.b * rect.x + anAffineTransform.d * rect.y + anAffineTransform.ty;
                const xa = anAffineTransform.a * rect.width;
                const xb = anAffineTransform.b * rect.width;
                const yc = anAffineTransform.c * rect.height;
                const yd = anAffineTransform.d * rect.height;
                out_tl.x = tx;
                out_tl.y = ty;
                out_tr.x = xa + tx;
                out_tr.y = xb + ty;
                out_bl.x = yc + tx;
                out_bl.y = yd + ty;
                out_br.x = xa + yc + tx;
                out_br.y = xb + yd + ty;
              }

              constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
                this.a = a;
                this.b = b;
                this.c = c;
                this.d = d;
                this.tx = tx;
                this.ty = ty;
              }

            } exports('eD', AffineTransform);
            legacyCC.AffineTransform = AffineTransform;

            class Size extends ValueType {
              static lerp(out, from, to, ratio) {
                out.width = from.width + (to.width - from.width) * ratio;
                out.height = from.height + (to.height - from.height) * ratio;
                return out;
              }

              set x(val) {
                this.width = val;
              }

              get x() {
                return this.width;
              }

              set y(val) {
                this.height = val;
              }

              get y() {
                return this.height;
              }

              constructor(width, height) {
                super();

                if (width && typeof width === 'object') {
                  this.width = width.width;
                  this.height = width.height;
                } else {
                  this.width = width || 0;
                  this.height = height || 0;
                }
              }

              clone() {
                return new Size(this.width, this.height);
              }

              set(width, height) {
                if (width && typeof width === 'object') {
                  this.height = width.height;
                  this.width = width.width;
                } else {
                  this.width = width || 0;
                  this.height = height || 0;
                }

                return this;
              }

              equals(other) {
                return this.width === other.width && this.height === other.height;
              }

              lerp(to, ratio) {
                this.width += (to.width - this.width) * ratio;
                this.height += (to.height - this.height) * ratio;
                return this;
              }

              toString() {
                return `(${this.width.toFixed(2)}, ${this.height.toFixed(2)})`;
              }

            } exports('cJ', Size);
            Size.ZERO = Object.freeze(new Size(0, 0));
            Size.ONE = Object.freeze(new Size(1, 1));
            CCClass.fastDefine('cc.Size', Size, {
              width: 0,
              height: 0
            });
            function size(width = 0, height = 0) {
              return new Size(width, height);
            }
            legacyCC.size = size;
            legacyCC.Size = Size;

            class Rect extends ValueType {
              static fromMinMax(out, v1, v2) {
                const minX = Math.min(v1.x, v2.x);
                const minY = Math.min(v1.y, v2.y);
                const maxX = Math.max(v1.x, v2.x);
                const maxY = Math.max(v1.y, v2.y);
                out.x = minX;
                out.y = minY;
                out.width = maxX - minX;
                out.height = maxY - minY;
                return out;
              }

              static lerp(out, from, to, ratio) {
                const x = from.x;
                const y = from.y;
                const w = from.width;
                const h = from.height;
                out.x = x + (to.x - x) * ratio;
                out.y = y + (to.y - y) * ratio;
                out.width = w + (to.width - w) * ratio;
                out.height = h + (to.height - h) * ratio;
                return out;
              }

              static intersection(out, one, other) {
                const axMin = one.x;
                const ayMin = one.y;
                const axMax = one.x + one.width;
                const ayMax = one.y + one.height;
                const bxMin = other.x;
                const byMin = other.y;
                const bxMax = other.x + other.width;
                const byMax = other.y + other.height;
                out.x = Math.max(axMin, bxMin);
                out.y = Math.max(ayMin, byMin);
                out.width = Math.min(axMax, bxMax) - out.x;
                out.height = Math.min(ayMax, byMax) - out.y;
                return out;
              }

              static union(out, one, other) {
                const x = one.x;
                const y = one.y;
                const w = one.width;
                const h = one.height;
                const bx = other.x;
                const by = other.y;
                const bw = other.width;
                const bh = other.height;
                out.x = Math.min(x, bx);
                out.y = Math.min(y, by);
                out.width = Math.max(x + w, bx + bw) - out.x;
                out.height = Math.max(y + h, by + bh) - out.y;
                return out;
              }

              get xMin() {
                return this.x;
              }

              set xMin(value) {
                this.width += this.x - value;
                this.x = value;
              }

              get yMin() {
                return this.y;
              }

              set yMin(value) {
                this.height += this.y - value;
                this.y = value;
              }

              get xMax() {
                return this.x + this.width;
              }

              set xMax(value) {
                this.width = value - this.x;
              }

              get yMax() {
                return this.y + this.height;
              }

              set yMax(value) {
                this.height = value - this.y;
              }

              get center() {
                return new Vec2(this.x + this.width * 0.5, this.y + this.height * 0.5);
              }

              set center(value) {
                this.x = value.x - this.width * 0.5;
                this.y = value.y - this.height * 0.5;
              }

              get origin() {
                return new Vec2(this.x, this.y);
              }

              set origin(value) {
                this.x = value.x;
                this.y = value.y;
              }

              get size() {
                return new Size(this.width, this.height);
              }

              set size(value) {
                this.width = value.width;
                this.height = value.height;
              }

              set z(val) {
                this.width = val;
              }

              get z() {
                return this.width;
              }

              set w(val) {
                this.height = val;
              }

              get w() {
                return this.height;
              }

              constructor(x, y, width, height) {
                super();

                if (x && typeof x === 'object') {
                  this.y = x.y;
                  this.width = x.width;
                  this.height = x.height;
                  this.x = x.x;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.width = width || 0;
                  this.height = height || 0;
                }
              }

              clone() {
                return new Rect(this.x, this.y, this.width, this.height);
              }

              set(x, y, width, height) {
                if (x && typeof x === 'object') {
                  this.y = x.y;
                  this.width = x.width;
                  this.height = x.height;
                  this.x = x.x;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.width = width || 0;
                  this.height = height || 0;
                }

                return this;
              }

              equals(other) {
                return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
              }

              lerp(to, ratio) {
                const x = this.x;
                const y = this.y;
                const w = this.width;
                const h = this.height;
                this.x = x + (to.x - x) * ratio;
                this.y = y + (to.y - y) * ratio;
                this.width = w + (to.width - w) * ratio;
                this.height = h + (to.height - h) * ratio;
                return this;
              }

              toString() {
                return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.width.toFixed(2)}, ${this.height.toFixed(2)})`;
              }

              intersects(other) {
                const maxax = this.x + this.width;
                const maxay = this.y + this.height;
                const maxbx = other.x + other.width;
                const maxby = other.y + other.height;
                return !(maxax < other.x || maxbx < this.x || maxay < other.y || maxby < this.y);
              }

              contains(point) {
                return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
              }

              containsRect(other) {
                return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;
              }

              transformMat4(mat) {
                const ol = this.x;
                const ob = this.y;
                const or = ol + this.width;
                const ot = ob + this.height;
                const lbx = mat.m00 * ol + mat.m04 * ob + mat.m12;
                const lby = mat.m01 * ol + mat.m05 * ob + mat.m13;
                const rbx = mat.m00 * or + mat.m04 * ob + mat.m12;
                const rby = mat.m01 * or + mat.m05 * ob + mat.m13;
                const ltx = mat.m00 * ol + mat.m04 * ot + mat.m12;
                const lty = mat.m01 * ol + mat.m05 * ot + mat.m13;
                const rtx = mat.m00 * or + mat.m04 * ot + mat.m12;
                const rty = mat.m01 * or + mat.m05 * ot + mat.m13;
                const minX = Math.min(lbx, rbx, ltx, rtx);
                const maxX = Math.max(lbx, rbx, ltx, rtx);
                const minY = Math.min(lby, rby, lty, rty);
                const maxY = Math.max(lby, rby, lty, rty);
                this.x = minX;
                this.y = minY;
                this.width = maxX - minX;
                this.height = maxY - minY;
                return this;
              }

              transformMat4ToPoints(mat, out_lb, out_lt, out_rt, out_rb) {
                const ol = this.x;
                const ob = this.y;
                const or = ol + this.width;
                const ot = ob + this.height;
                out_lb.x = mat.m00 * ol + mat.m04 * ob + mat.m12;
                out_lb.y = mat.m01 * ol + mat.m05 * ob + mat.m13;
                out_rb.x = mat.m00 * or + mat.m04 * ob + mat.m12;
                out_rb.y = mat.m01 * or + mat.m05 * ob + mat.m13;
                out_lt.x = mat.m00 * ol + mat.m04 * ot + mat.m12;
                out_lt.y = mat.m01 * ol + mat.m05 * ot + mat.m13;
                out_rt.x = mat.m00 * or + mat.m04 * ot + mat.m12;
                out_rt.y = mat.m01 * or + mat.m05 * ot + mat.m13;
              }

            } exports('cI', Rect);
            CCClass.fastDefine('cc.Rect', Rect, {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            });
            legacyCC.Rect = Rect;
            function rect(x = 0, y = 0, width = 0, height = 0) {
              return new Rect(x, y, width, height);
            }
            legacyCC.rect = rect;

            var math = /*#__PURE__*/Object.freeze({
                __proto__: null,
                bits: bits,
                Vec2: Vec2,
                v2: v2,
                Vec3: Vec3,
                v3: v3,
                Vec4: Vec4,
                v4: v4,
                Quat: Quat,
                quat: quat,
                Mat3: Mat3,
                Mat4: Mat4,
                mat4: mat4,
                AffineTransform: AffineTransform,
                Size: Size,
                size: size,
                Rect: Rect,
                rect: rect,
                Color: Color,
                color: color,
                EPSILON: EPSILON,
                equals: equals,
                approx: approx,
                clamp: clamp,
                clamp01: clamp01,
                lerp: lerp,
                toRadian: toRadian,
                toDegree: toDegree,
                random: random,
                randomRange: randomRange,
                randomRangeInt: randomRangeInt,
                pseudoRandom: pseudoRandom,
                pseudoRandomRange: pseudoRandomRange,
                pseudoRandomRangeInt: pseudoRandomRangeInt,
                nextPow2: nextPow2$1,
                repeat: repeat,
                pingPong: pingPong,
                inverseLerp: inverseLerp,
                absMaxComponent: absMaxComponent,
                absMax: absMax,
                enumerableProps: enumerableProps,
                MATH_FLOAT_ARRAY: MATH_FLOAT_ARRAY,
                MathBase: MathBase
            });
            exports('ev', math);

            const LEFT = 1 << 2;
            const RIGHT = 1 << 3;
            let Orientation;

            (function (Orientation) {
              Orientation[Orientation["PORTRAIT"] = 1] = "PORTRAIT";
              Orientation[Orientation["PORTRAIT_UPSIDE_DOWN"] = 2] = "PORTRAIT_UPSIDE_DOWN";
              Orientation[Orientation["LANDSCAPE_LEFT"] = LEFT] = "LANDSCAPE_LEFT";
              Orientation[Orientation["LANDSCAPE_RIGHT"] = RIGHT] = "LANDSCAPE_RIGHT";
              Orientation[Orientation["LANDSCAPE"] = LEFT | RIGHT] = "LANDSCAPE";
            })(Orientation || (Orientation = {}));

            const orientationMap = {
              0: Orientation.PORTRAIT,
              '-90': Orientation.LANDSCAPE_LEFT,
              90: Orientation.LANDSCAPE_RIGHT,
              180: Orientation.PORTRAIT_UPSIDE_DOWN
            };

            class ScreenAdapter extends EventTarget {
              constructor() {
                super();

                this._registerEvent();
              }

              _registerEvent() {
                jsb.onResize = size => {
                  if (size.width === 0 || size.height === 0) return;
                  size.width /= systemInfo.pixelRatio;
                  size.height /= systemInfo.pixelRatio;
                  window.resize(size.width, size.height);
                  this.emit('window-resize');
                };

                jsb.onOrientationChanged = event => {
                  this.emit('orientation-change');
                };
              }

              get supportFullScreen() {
                return false;
              }

              get isFullScreen() {
                return false;
              }

              get windowSize() {
                return new Size(window.innerWidth, window.innerHeight);
              }

              set windowSize(size) {
                console.warn('Setting window size is not supported yet.');
              }

              get orientation() {
                return orientationMap[jsb.device.getDeviceOrientation()];
              }

              get safeAreaEdge() {
                const nativeSafeArea = jsb.device.getSafeAreaEdge();
                let topEdge = nativeSafeArea.x;
                let bottomEdge = nativeSafeArea.z;
                let leftEdge = nativeSafeArea.y;
                let rightEdge = nativeSafeArea.w;
                const orientation = this.orientation;

                if (orientation === Orientation.PORTRAIT) {
                  if (topEdge < bottomEdge) {
                    topEdge = bottomEdge;
                  } else {
                    bottomEdge = topEdge;
                  }
                } else if (leftEdge < rightEdge) {
                  leftEdge = rightEdge;
                } else {
                  rightEdge = leftEdge;
                }

                return {
                  top: topEdge,
                  bottom: bottomEdge,
                  left: leftEdge,
                  right: rightEdge
                };
              }

              requestFullScreen() {
                return Promise.reject(new Error('request fullscreen has not been supported yet on this platform.'));
              }

              exitFullScreen() {
                return Promise.reject(new Error('exit fullscreen has not been supported yet on this platform.'));
              }

            }

            const screenAdapter = exports('dC', new ScreenAdapter());

            const windowSize = screenAdapter.windowSize;
            const pixelRatio = systemInfo.pixelRatio;
            const sys = exports('bp', {
              NetworkType,
              Language,
              OS,
              Platform,
              BrowserType,
              isNative: systemInfo.isNative,
              isBrowser: systemInfo.isBrowser,
              isMobile: systemInfo.isMobile,
              isLittleEndian: systemInfo.isLittleEndian,
              platform: systemInfo.platform,
              language: systemInfo.language,
              languageCode: systemInfo.nativeLanguage,
              os: systemInfo.os,
              osVersion: systemInfo.osVersion,
              osMainVersion: systemInfo.osMainVersion,
              browserType: systemInfo.browserType,
              browserVersion: systemInfo.browserVersion,
              windowPixelResolution: {
                width: windowSize.width * pixelRatio,
                height: windowSize.height * pixelRatio
              },
              capabilities: {
                canvas: systemInfo.supportCapability.canvas,
                opengl: systemInfo.supportCapability.gl,
                webp: systemInfo.supportCapability.webp,
                imageBitmap: systemInfo.supportCapability.imageBitmap,
                touches: false,
                mouse: false,
                keyboard: false,
                accelerometer: false
              },
              localStorage: {},

              getNetworkType() {
                return systemInfo.networkType;
              },

              getBatteryLevel() {
                return systemInfo.getBatteryLevel();
              },

              garbageCollect() {
                systemInfo.triggerGC();
              },

              isObjectValid(obj) {
                if (obj === null || obj === undefined) {
                  return false;
                }

                return true;
              },

              dump() {
                let str = '';
                str += `isMobile : ${this.isMobile}\r\n`;
                str += `language : ${this.language}\r\n`;
                str += `browserType : ${this.browserType}\r\n`;
                str += `browserVersion : ${this.browserVersion}\r\n`;
                str += `capabilities : ${JSON.stringify(this.capabilities)}\r\n`;
                str += `os : ${this.os}\r\n`;
                str += `osVersion : ${this.osVersion}\r\n`;
                str += `platform : ${this.platform}\r\n`;
                str += `Using ${legacyCC.game.renderType === legacyCC.game.RENDER_TYPE_WEBGL ? 'WEBGL' : 'CANVAS'} renderer.\r\n`;
                log(str);
              },

              openURL(url) {
                systemInfo.openURL(url);
              },

              now() {
                return systemInfo.now();
              },

              restartVM() {
                systemInfo.restartJSVM();
              },

              getSafeAreaRect() {
                const locView = legacyCC.view;
                const edge = screenAdapter.safeAreaEdge;
                const windowSize = screenAdapter.windowSize;
                const leftBottom = new Vec2(edge.left, windowSize.height - edge.bottom);
                const rightTop = new Vec2(windowSize.width - edge.right, edge.top);
                const relatedPos = {
                  left: 0,
                  top: 0,
                  width: windowSize.width,
                  height: windowSize.height
                };
                locView.convertToLocationInView(leftBottom.x, leftBottom.y, relatedPos, leftBottom);
                locView.convertToLocationInView(rightTop.x, rightTop.y, relatedPos, rightTop);

                locView._convertPointWithScale(leftBottom);

                locView._convertPointWithScale(rightTop);

                const x = leftBottom.x;
                const y = leftBottom.y;
                const width = rightTop.x - leftBottom.x;
                const height = rightTop.y - leftBottom.y;
                return new Rect(x, y, width, height);
              }

            });

            (function initSys() {
              try {
                let localStorage = sys.localStorage = window.localStorage;
                localStorage.setItem('storage', '');
                localStorage.removeItem('storage');
                localStorage = null;
              } catch (e) {
                const warn = function () {
                  warnID(5200);
                };

                sys.localStorage = {
                  getItem: warn,
                  setItem: warn,
                  clear: warn,
                  removeItem: warn
                };
              }

              const win = window;
              const nav = win.navigator;
              const doc = document;
              const docEle = doc.documentElement;
              const capabilities = sys.capabilities;

              if (docEle.ontouchstart !== undefined || doc.ontouchstart !== undefined || nav.msPointerEnabled) {
                capabilities.touches = true;
              }

              if (docEle.onmouseup !== undefined) {
                capabilities.mouse = true;
              }

              if (docEle.onkeyup !== undefined) {
                capabilities.keyboard = true;
              }

              if (win.DeviceMotionEvent || win.DeviceOrientationEvent) {
                capabilities.accelerometer = true;
              }

              sys.__isWebIOS14OrIPadOS14Env = (sys.os === OS.IOS || sys.os === OS.OSX) && systemInfo.isBrowser && /(OS 1[4-9])|(Version\/1[4-9])/.test(window.navigator.userAgent);
              screenAdapter.on('window-resize', () => {
                const windowSize = screenAdapter.windowSize;
                sys.windowPixelResolution = {
                  width: Math.round(windowSize.width * pixelRatio),
                  height: Math.round(windowSize.height * pixelRatio)
                };
              });
            })();

            legacyCC.sys = sys;

            const EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
            const DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
            const NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
            function join(...segments) {
              let result = '';

              for (const segment of segments) {
                result = (result + (result === '' ? '' : '/') + segment).replace(/(\/|\\\\)$/, '');
              }

              return result;
            }
            function extname(path) {
              const temp = EXTNAME_RE.exec(path);
              return temp ? temp[1] : '';
            }
            function mainFileName(fileName) {
              if (fileName) {
                const idx = fileName.lastIndexOf('.');

                if (idx !== -1) {
                  return fileName.substring(0, idx);
                }
              }

              return fileName;
            }
            function basename(path, extName) {
              const index = path.indexOf('?');

              if (index > 0) {
                path = path.substring(0, index);
              }

              const reg = /(\/|\\)([^\/\\]+)$/g;
              const result = reg.exec(path.replace(/(\/|\\)$/, ''));

              if (!result) {
                return path;
              }

              const baseName = result[2];

              if (extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase()) {
                return baseName.substring(0, baseName.length - extName.length);
              }

              return baseName;
            }
            function dirname(path) {
              const temp = DIRNAME_RE.exec(path);
              return temp ? temp[2] : '';
            }
            function changeExtname(path, extName) {
              extName = extName || '';
              let index = path.indexOf('?');
              let tempStr = '';

              if (index > 0) {
                tempStr = path.substring(index);
                path = path.substring(0, index);
              }

              index = path.lastIndexOf('.');

              if (index < 0) {
                return path + extName + tempStr;
              }

              return path.substring(0, index) + extName + tempStr;
            }
            function changeBasename(path, baseName, isSameExt) {
              if (baseName.indexOf('.') === 0) {
                return changeExtname(path, baseName);
              }

              let index = path.indexOf('?');
              let tempStr = '';
              const ext = isSameExt ? extname(path) : '';

              if (index > 0) {
                tempStr = path.substring(index);
                path = path.substring(0, index);
              }

              index = path.lastIndexOf('/');
              index = index <= 0 ? 0 : index + 1;
              return path.substring(0, index) + baseName + ext + tempStr;
            }
            function _normalize(url) {
              let oldUrl = url = String(url);

              do {
                oldUrl = url;
                url = url.replace(NORMALIZE_RE, '');
              } while (oldUrl.length !== url.length);

              return url;
            }
            function stripSep(path) {
              return path.replace(/[\/\\]$/, '');
            }
            function getSeperator() {
              return sys.os === OS.WINDOWS ? '\\' : '/';
            }

            var path = /*#__PURE__*/Object.freeze({
                __proto__: null,
                join: join,
                extname: extname,
                mainFileName: mainFileName,
                basename: basename,
                dirname: dirname,
                changeExtname: changeExtname,
                changeBasename: changeBasename,
                _normalize: _normalize,
                stripSep: stripSep,
                getSeperator: getSeperator
            });
            exports('eU', path);

            legacyCC.log = log;
            legacyCC.warn = warn;
            legacyCC.error = error;
            legacyCC.assert = assert;
            legacyCC._throw = _throw;
            legacyCC.logID = logID;
            legacyCC.warnID = warnID;
            legacyCC.errorID = errorID;
            legacyCC.assertID = assertID;
            legacyCC.debug = debug$1;
            legacyCC.path = {
              join,
              extname,
              mainFileName,
              basename,
              dirname,
              changeExtname,
              changeBasename,
              _normalize,
              stripSep,

              get sep() {
                return getSeperator();
              }

            };

            let _stageOffset = 0;
            const _name2stageID = {};
            var config = {
              addStage(name) {
                if (_name2stageID[name] !== undefined) {
                  return;
                }

                const stageID = 1 << _stageOffset;
                _name2stageID[name] = stageID;
                _stageOffset += 1;
              },

              stageID(name) {
                const id = _name2stageID[name];

                if (id === undefined) {
                  return -1;
                }

                return id;
              },

              stageIDs(nameList) {
                let key = 0;

                for (const name of nameList) {
                  const id = _name2stageID[name];

                  if (id !== undefined) {
                    key |= id;
                  }
                }

                return key;
              }

            };

            const NativeNode = ns.Node;
            const NativeScene = ns.Scene;
            const NativeModel = ns.Model;
            const NativeSkinningModel = exports('cr', ns.SkinningModel);
            const NativeBakedSkinningModel = exports('cw', ns.BakedSkinningModel);
            const NativeLight = ns.light;
            const NativeDirectionalLight = ns.DirectionalLight;
            const NativeSpotLight = ns.SpotLight;
            const NativeSphereLight = ns.SphereLight;
            const NaitveSkybox = ns.Skybox;
            const NativeFog = ns.Fog;
            const NativeAmbient = ns.Ambient;
            const NativeShadow = ns.Shadow;
            const NativeCamera = ns.Camera;
            const NativeRenderWindow = ns.RenderWindow;
            const NativeRenderScene = ns.RenderScene;
            const NativeDrawBatch2D = exports('da', ns.DrawBatch2D);
            const NativePass = ns.Pass;
            const NativeSubModel = ns.SubModel;
            const NativeRoot = ns.Root;
            const NativePipelineSharedSceneData = ns.PipelineSharedSceneData;
            const NativeAABB = ns.AABB;

            class Ambient {
              get colorArray() {
                return this._colorArray;
              }

              get albedoArray() {
                return this._albedoArray;
              }

              set enabled(val) {
                this._enabled = val;

                {
                  this._nativeObj.enabled = val;
                }
              }

              get enabled() {
                return this._enabled;
              }

              get skyColor() {
                return this._skyColor;
              }

              set skyColor(color) {
                this._skyColor.set(color);

                Color.toArray(this._colorArray, this._skyColor);

                {
                  this._nativeObj.skyColor = this._skyColor;
                }
              }

              get skyIllum() {
                return this._skyIllum;
              }

              set skyIllum(illum) {
                this._skyIllum = illum;

                {
                  this._nativeObj.skyIllum = illum;
                }
              }

              get groundAlbedo() {
                return this._groundAlbedo;
              }

              set groundAlbedo(color) {
                this._groundAlbedo.set(color);

                Vec3.toArray(this._albedoArray, this._groundAlbedo);

                {
                  this._nativeObj.groundAlbedo = this._groundAlbedo;
                }
              }

              get native() {
                return this._nativeObj;
              }

              constructor() {
                this._skyColor = new Color(51, 128, 204, 1.0);
                this._groundAlbedo = new Color(51, 51, 51, 255);
                this._albedoArray = Float32Array.from([0.2, 0.2, 0.2, 1.0]);
                this._colorArray = Float32Array.from([0.2, 0.5, 0.8, 1.0]);
                this._enabled = false;
                this._skyIllum = 0;

                {
                  this._nativeObj = new NativeAmbient();
                }
              }

              initialize(ambientInfo) {
                this.skyColor = ambientInfo.skyColor;
                this.groundAlbedo = ambientInfo.groundAlbedo;
                this.skyIllum = ambientInfo.skyIllum;
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this._destroy();
              }

            }
            Ambient.SUN_ILLUM = 65000.0;
            Ambient.SKY_ILLUM = 20000.0;
            legacyCC.Ambient = Ambient;

            const X = new Vec3();
            const Y = new Vec3();
            const Z = new Vec3();
            const d = new Vec3();
            const min$1 = new Vec3();
            const max$1 = new Vec3();
            const u = new Array(3);
            const e = new Array(3);
            function point_plane(point, plane_) {
              return Vec3.dot(plane_.n, point) - plane_.d;
            }
            function pt_point_plane(out, point, plane_) {
              const t = point_plane(point, plane_);
              return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
            }
            function pt_point_aabb(out, point, aabb_) {
              Vec3.copy(out, point);
              Vec3.subtract(min$1, aabb_.center, aabb_.halfExtents);
              Vec3.add(max$1, aabb_.center, aabb_.halfExtents);
              out.x = out.x < min$1.x ? min$1.x : out.x;
              out.y = out.y < min$1.y ? min$1.y : out.y;
              out.z = out.z < min$1.z ? min$1.z : out.z;
              out.x = out.x > max$1.x ? max$1.x : out.x;
              out.y = out.y > max$1.y ? max$1.y : out.y;
              out.z = out.z > max$1.z ? max$1.z : out.z;
              return out;
            }
            function pt_point_obb(out, point, obb_) {
              Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02);
              Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05);
              Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08);
              u[0] = X;
              u[1] = Y;
              u[2] = Z;
              e[0] = obb_.halfExtents.x;
              e[1] = obb_.halfExtents.y;
              e[2] = obb_.halfExtents.z;
              Vec3.subtract(d, point, obb_.center);
              Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);

              for (let i = 0; i < 3; i++) {
                let dist = Vec3.dot(d, u[i]);

                if (dist > e[i]) {
                  dist = e[i];
                }

                if (dist < -e[i]) {
                  dist = -e[i];
                }

                out.x += dist * u[i].x;
                out.y += dist * u[i].y;
                out.z += dist * u[i].z;
              }

              return out;
            }
            function pt_point_line(out, point, linePointA, linePointB) {
              Vec3.subtract(X, linePointA, linePointB);
              const dir = X;
              const dirSquaredLength = Vec3.lengthSqr(dir);

              if (dirSquaredLength == 0) {
                Vec3.copy(out, linePointA);
              } else {
                Vec3.subtract(X, point, linePointA);
                const t = Vec3.dot(X, dir) / dirSquaredLength;

                if (t < 0) {
                  Vec3.copy(out, linePointA);
                } else if (t > 1) {
                  Vec3.copy(out, linePointB);
                } else {
                  Vec3.scaleAndAdd(out, linePointA, dir, t);
                }
              }
            }

            var distance = /*#__PURE__*/Object.freeze({
                __proto__: null,
                point_plane: point_plane,
                pt_point_plane: pt_point_plane,
                pt_point_aabb: pt_point_aabb,
                pt_point_obb: pt_point_obb,
                pt_point_line: pt_point_line
            });

            var enums = {
              SHAPE_RAY: 1 << 0,
              SHAPE_LINE: 1 << 1,
              SHAPE_SPHERE: 1 << 2,
              SHAPE_AABB: 1 << 3,
              SHAPE_OBB: 1 << 4,
              SHAPE_PLANE: 1 << 5,
              SHAPE_TRIANGLE: 1 << 6,
              SHAPE_FRUSTUM: 1 << 7,
              SHAPE_FRUSTUM_ACCURATE: 1 << 8,
              SHAPE_CAPSULE: 1 << 9
            };

            class Line {
              static create(sx, sy, sz, ex, ey, ez) {
                return new Line(sx, sy, sz, ex, ey, ez);
              }

              static clone(a) {
                return new Line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
              }

              static copy(out, a) {
                Vec3.copy(out.s, a.s);
                Vec3.copy(out.e, a.e);
                return out;
              }

              static fromPoints(out, start, end) {
                Vec3.copy(out.s, start);
                Vec3.copy(out.e, end);
                return out;
              }

              static set(out, sx, sy, sz, ex, ey, ez) {
                out.s.x = sx;
                out.s.y = sy;
                out.s.z = sz;
                out.e.x = ex;
                out.e.y = ey;
                out.e.z = ez;
                return out;
              }

              static len(a) {
                return Vec3.distance(a.s, a.e);
              }

              get type() {
                return this._type;
              }

              constructor(sx = 0, sy = 0, sz = 0, ex = 0, ey = 0, ez = -1) {
                this.s = void 0;
                this.e = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_LINE;
                this.s = new Vec3(sx, sy, sz);
                this.e = new Vec3(ex, ey, ez);
              }

              length() {
                return Vec3.distance(this.s, this.e);
              }

            }

            class Ray {
              static create(ox = 0, oy = 0, oz = 0, dx = 0, dy = 0, dz = 1) {
                return new Ray(ox, oy, oz, dx, dy, dz);
              }

              static clone(a) {
                return new Ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
              }

              static copy(out, a) {
                Vec3.copy(out.o, a.o);
                Vec3.copy(out.d, a.d);
                return out;
              }

              static fromPoints(out, origin, target) {
                Vec3.copy(out.o, origin);
                Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin));
                return out;
              }

              static set(out, ox, oy, oz, dx, dy, dz) {
                out.o.x = ox;
                out.o.y = oy;
                out.o.z = oz;
                out.d.x = dx;
                out.d.y = dy;
                out.d.z = dz;
                return out;
              }

              get type() {
                return this._type;
              }

              constructor(ox = 0, oy = 0, oz = 0, dx = 0, dy = 0, dz = -1) {
                this.o = void 0;
                this.d = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_RAY;
                this.o = new Vec3(ox, oy, oz);
                this.d = new Vec3(dx, dy, dz);
              }

              computeHit(out, distance) {
                Vec3.normalize(out, this.d);
                Vec3.scaleAndAdd(out, this.o, out, distance);
              }

            }

            const _v3_tmp = new Vec3();

            const _offset = new Vec3();

            const _min = new Vec3();

            const _max = new Vec3();

            function maxComponent(v) {
              return Math.max(Math.max(v.x, v.y), v.z);
            }

            class Sphere {
              static create(cx, cy, cz, r) {
                return new Sphere(cx, cy, cz, r);
              }

              static clone(p) {
                return new Sphere(p.center.x, p.center.y, p.center.z, p.radius);
              }

              static copy(out, p) {
                Vec3.copy(out.center, p.center);
                out.radius = p.radius;
                return out;
              }

              static fromPoints(out, minPos, maxPos) {
                Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), 0.5);
                out.radius = Vec3.subtract(_v3_tmp, maxPos, minPos).length() * 0.5;
                return out;
              }

              static set(out, cx, cy, cz, r) {
                out.center.x = cx;
                out.center.y = cy;
                out.center.z = cz;
                out.radius = r;
                return out;
              }

              static mergePoint(out, s, point) {
                if (s.radius < 0.0) {
                  out.center.set(point);
                  out.radius = 0.0;
                  return out;
                }

                Vec3.subtract(_offset, point, s.center);

                const dist = _offset.length();

                if (dist > s.radius) {
                  const half = (dist - s.radius) * 0.5;
                  out.radius += half;
                  Vec3.multiplyScalar(_offset, _offset, half / dist);
                  Vec3.add(out.center, out.center, _offset);
                }

                return out;
              }

              static mergeAABB(out, s, a) {
                a.getBoundary(_min, _max);
                Sphere.mergePoint(out, s, _min);
                Sphere.mergePoint(out, s, _max);
                return out;
              }

              get center() {
                return this._center;
              }

              set center(val) {
                this._center = val;
              }

              get radius() {
                return this._radius;
              }

              set radius(val) {
                this._radius = val;
              }

              get type() {
                return this._type;
              }

              constructor(cx = 0, cy = 0, cz = 0, r = 1) {
                this._center = new Vec3(0, 0, 0);
                this._radius = 0;
                this._type = void 0;
                this._type = enums.SHAPE_SPHERE;
                this._center = new Vec3(cx, cy, cz);
                this._radius = r;
              }

              destroy() {}

              clone() {
                return Sphere.clone(this);
              }

              copy(a) {
                return Sphere.copy(this, a);
              }

              getBoundary(minPos, maxPos) {
                Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius);
                Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
              }

              transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m);
                out.radius = this.radius * maxComponent(scale);
              }

              translateAndRotate(m, rot, out) {
                Vec3.transformMat4(out.center, this.center, m);
              }

              setScale(scale, out) {
                out.radius = this.radius * maxComponent(scale);
              }

            } exports('dW', Sphere);

            class Triangle {
              static create(ax = 1, ay = 0, az = 0, bx = 0, by = 0, bz = 0, cx = 0, cy = 0, cz = 1) {
                return new Triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
              }

              static clone(t) {
                return new Triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
              }

              static copy(out, t) {
                Vec3.copy(out.a, t.a);
                Vec3.copy(out.b, t.b);
                Vec3.copy(out.c, t.c);
                return out;
              }

              static fromPoints(out, a, b, c) {
                Vec3.copy(out.a, a);
                Vec3.copy(out.b, b);
                Vec3.copy(out.c, c);
                return out;
              }

              static set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
                out.a.x = ax;
                out.a.y = ay;
                out.a.z = az;
                out.b.x = bx;
                out.b.y = by;
                out.b.z = bz;
                out.c.x = cx;
                out.c.y = cy;
                out.c.z = cz;
                return out;
              }

              get type() {
                return this._type;
              }

              constructor(ax = 0, ay = 0, az = 0, bx = 1, by = 0, bz = 0, cx = 0, cy = 1, cz = 0) {
                this.a = void 0;
                this.b = void 0;
                this.c = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_TRIANGLE;
                this.a = new Vec3(ax, ay, az);
                this.b = new Vec3(bx, by, bz);
                this.c = new Vec3(cx, cy, cz);
              }

            }

            const deepCopy = (target, source, Ctor) => {
              for (let i = 0; i < source.length; ++i) {
                if (target.length <= i) target.push(new Ctor());
                target[i].copy(source[i]);
              }

              target.length = source.length;
            };

            let ObjectType;

            (function (ObjectType) {
              ObjectType[ObjectType["UNKNOWN"] = 0] = "UNKNOWN";
              ObjectType[ObjectType["BUFFER"] = 1] = "BUFFER";
              ObjectType[ObjectType["TEXTURE"] = 2] = "TEXTURE";
              ObjectType[ObjectType["RENDER_PASS"] = 3] = "RENDER_PASS";
              ObjectType[ObjectType["FRAMEBUFFER"] = 4] = "FRAMEBUFFER";
              ObjectType[ObjectType["SAMPLER"] = 5] = "SAMPLER";
              ObjectType[ObjectType["SHADER"] = 6] = "SHADER";
              ObjectType[ObjectType["DESCRIPTOR_SET_LAYOUT"] = 7] = "DESCRIPTOR_SET_LAYOUT";
              ObjectType[ObjectType["PIPELINE_LAYOUT"] = 8] = "PIPELINE_LAYOUT";
              ObjectType[ObjectType["PIPELINE_STATE"] = 9] = "PIPELINE_STATE";
              ObjectType[ObjectType["DESCRIPTOR_SET"] = 10] = "DESCRIPTOR_SET";
              ObjectType[ObjectType["INPUT_ASSEMBLER"] = 11] = "INPUT_ASSEMBLER";
              ObjectType[ObjectType["COMMAND_BUFFER"] = 12] = "COMMAND_BUFFER";
              ObjectType[ObjectType["QUEUE"] = 13] = "QUEUE";
              ObjectType[ObjectType["GLOBAL_BARRIER"] = 14] = "GLOBAL_BARRIER";
              ObjectType[ObjectType["TEXTURE_BARRIER"] = 15] = "TEXTURE_BARRIER";
              ObjectType[ObjectType["BUFFER_BARRIER"] = 16] = "BUFFER_BARRIER";
            })(ObjectType || (ObjectType = exports('a', {})));

            let Status;

            (function (Status) {
              Status[Status["UNREADY"] = 0] = "UNREADY";
              Status[Status["FAILED"] = 1] = "FAILED";
              Status[Status["SUCCESS"] = 2] = "SUCCESS";
            })(Status || (Status = exports('S', {})));

            let API;

            (function (API) {
              API[API["UNKNOWN"] = 0] = "UNKNOWN";
              API[API["GLES2"] = 1] = "GLES2";
              API[API["GLES3"] = 2] = "GLES3";
              API[API["METAL"] = 3] = "METAL";
              API[API["VULKAN"] = 4] = "VULKAN";
              API[API["WEBGL"] = 5] = "WEBGL";
              API[API["WEBGL2"] = 6] = "WEBGL2";
              API[API["WEBGPU"] = 7] = "WEBGPU";
            })(API || (API = exports('f', {})));

            let SurfaceTransform;

            (function (SurfaceTransform) {
              SurfaceTransform[SurfaceTransform["IDENTITY"] = 0] = "IDENTITY";
              SurfaceTransform[SurfaceTransform["ROTATE_90"] = 1] = "ROTATE_90";
              SurfaceTransform[SurfaceTransform["ROTATE_180"] = 2] = "ROTATE_180";
              SurfaceTransform[SurfaceTransform["ROTATE_270"] = 3] = "ROTATE_270";
            })(SurfaceTransform || (SurfaceTransform = exports('g', {})));

            let Feature;

            (function (Feature) {
              Feature[Feature["COLOR_FLOAT"] = 0] = "COLOR_FLOAT";
              Feature[Feature["COLOR_HALF_FLOAT"] = 1] = "COLOR_HALF_FLOAT";
              Feature[Feature["TEXTURE_FLOAT"] = 2] = "TEXTURE_FLOAT";
              Feature[Feature["TEXTURE_HALF_FLOAT"] = 3] = "TEXTURE_HALF_FLOAT";
              Feature[Feature["TEXTURE_FLOAT_LINEAR"] = 4] = "TEXTURE_FLOAT_LINEAR";
              Feature[Feature["TEXTURE_HALF_FLOAT_LINEAR"] = 5] = "TEXTURE_HALF_FLOAT_LINEAR";
              Feature[Feature["FORMAT_R11G11B10F"] = 6] = "FORMAT_R11G11B10F";
              Feature[Feature["FORMAT_SRGB"] = 7] = "FORMAT_SRGB";
              Feature[Feature["FORMAT_ETC1"] = 8] = "FORMAT_ETC1";
              Feature[Feature["FORMAT_ETC2"] = 9] = "FORMAT_ETC2";
              Feature[Feature["FORMAT_DXT"] = 10] = "FORMAT_DXT";
              Feature[Feature["FORMAT_PVRTC"] = 11] = "FORMAT_PVRTC";
              Feature[Feature["FORMAT_ASTC"] = 12] = "FORMAT_ASTC";
              Feature[Feature["FORMAT_RGB8"] = 13] = "FORMAT_RGB8";
              Feature[Feature["ELEMENT_INDEX_UINT"] = 14] = "ELEMENT_INDEX_UINT";
              Feature[Feature["INSTANCED_ARRAYS"] = 15] = "INSTANCED_ARRAYS";
              Feature[Feature["MULTIPLE_RENDER_TARGETS"] = 16] = "MULTIPLE_RENDER_TARGETS";
              Feature[Feature["BLEND_MINMAX"] = 17] = "BLEND_MINMAX";
              Feature[Feature["COMPUTE_SHADER"] = 18] = "COMPUTE_SHADER";
              Feature[Feature["COUNT"] = 19] = "COUNT";
            })(Feature || (Feature = exports('h', {})));

            let Format;

            (function (Format) {
              Format[Format["UNKNOWN"] = 0] = "UNKNOWN";
              Format[Format["A8"] = 1] = "A8";
              Format[Format["L8"] = 2] = "L8";
              Format[Format["LA8"] = 3] = "LA8";
              Format[Format["R8"] = 4] = "R8";
              Format[Format["R8SN"] = 5] = "R8SN";
              Format[Format["R8UI"] = 6] = "R8UI";
              Format[Format["R8I"] = 7] = "R8I";
              Format[Format["R16F"] = 8] = "R16F";
              Format[Format["R16UI"] = 9] = "R16UI";
              Format[Format["R16I"] = 10] = "R16I";
              Format[Format["R32F"] = 11] = "R32F";
              Format[Format["R32UI"] = 12] = "R32UI";
              Format[Format["R32I"] = 13] = "R32I";
              Format[Format["RG8"] = 14] = "RG8";
              Format[Format["RG8SN"] = 15] = "RG8SN";
              Format[Format["RG8UI"] = 16] = "RG8UI";
              Format[Format["RG8I"] = 17] = "RG8I";
              Format[Format["RG16F"] = 18] = "RG16F";
              Format[Format["RG16UI"] = 19] = "RG16UI";
              Format[Format["RG16I"] = 20] = "RG16I";
              Format[Format["RG32F"] = 21] = "RG32F";
              Format[Format["RG32UI"] = 22] = "RG32UI";
              Format[Format["RG32I"] = 23] = "RG32I";
              Format[Format["RGB8"] = 24] = "RGB8";
              Format[Format["SRGB8"] = 25] = "SRGB8";
              Format[Format["RGB8SN"] = 26] = "RGB8SN";
              Format[Format["RGB8UI"] = 27] = "RGB8UI";
              Format[Format["RGB8I"] = 28] = "RGB8I";
              Format[Format["RGB16F"] = 29] = "RGB16F";
              Format[Format["RGB16UI"] = 30] = "RGB16UI";
              Format[Format["RGB16I"] = 31] = "RGB16I";
              Format[Format["RGB32F"] = 32] = "RGB32F";
              Format[Format["RGB32UI"] = 33] = "RGB32UI";
              Format[Format["RGB32I"] = 34] = "RGB32I";
              Format[Format["RGBA8"] = 35] = "RGBA8";
              Format[Format["BGRA8"] = 36] = "BGRA8";
              Format[Format["SRGB8_A8"] = 37] = "SRGB8_A8";
              Format[Format["RGBA8SN"] = 38] = "RGBA8SN";
              Format[Format["RGBA8UI"] = 39] = "RGBA8UI";
              Format[Format["RGBA8I"] = 40] = "RGBA8I";
              Format[Format["RGBA16F"] = 41] = "RGBA16F";
              Format[Format["RGBA16UI"] = 42] = "RGBA16UI";
              Format[Format["RGBA16I"] = 43] = "RGBA16I";
              Format[Format["RGBA32F"] = 44] = "RGBA32F";
              Format[Format["RGBA32UI"] = 45] = "RGBA32UI";
              Format[Format["RGBA32I"] = 46] = "RGBA32I";
              Format[Format["R5G6B5"] = 47] = "R5G6B5";
              Format[Format["R11G11B10F"] = 48] = "R11G11B10F";
              Format[Format["RGB5A1"] = 49] = "RGB5A1";
              Format[Format["RGBA4"] = 50] = "RGBA4";
              Format[Format["RGB10A2"] = 51] = "RGB10A2";
              Format[Format["RGB10A2UI"] = 52] = "RGB10A2UI";
              Format[Format["RGB9E5"] = 53] = "RGB9E5";
              Format[Format["D16"] = 54] = "D16";
              Format[Format["D16S8"] = 55] = "D16S8";
              Format[Format["D24"] = 56] = "D24";
              Format[Format["D24S8"] = 57] = "D24S8";
              Format[Format["D32F"] = 58] = "D32F";
              Format[Format["D32F_S8"] = 59] = "D32F_S8";
              Format[Format["BC1"] = 60] = "BC1";
              Format[Format["BC1_ALPHA"] = 61] = "BC1_ALPHA";
              Format[Format["BC1_SRGB"] = 62] = "BC1_SRGB";
              Format[Format["BC1_SRGB_ALPHA"] = 63] = "BC1_SRGB_ALPHA";
              Format[Format["BC2"] = 64] = "BC2";
              Format[Format["BC2_SRGB"] = 65] = "BC2_SRGB";
              Format[Format["BC3"] = 66] = "BC3";
              Format[Format["BC3_SRGB"] = 67] = "BC3_SRGB";
              Format[Format["BC4"] = 68] = "BC4";
              Format[Format["BC4_SNORM"] = 69] = "BC4_SNORM";
              Format[Format["BC5"] = 70] = "BC5";
              Format[Format["BC5_SNORM"] = 71] = "BC5_SNORM";
              Format[Format["BC6H_UF16"] = 72] = "BC6H_UF16";
              Format[Format["BC6H_SF16"] = 73] = "BC6H_SF16";
              Format[Format["BC7"] = 74] = "BC7";
              Format[Format["BC7_SRGB"] = 75] = "BC7_SRGB";
              Format[Format["ETC_RGB8"] = 76] = "ETC_RGB8";
              Format[Format["ETC2_RGB8"] = 77] = "ETC2_RGB8";
              Format[Format["ETC2_SRGB8"] = 78] = "ETC2_SRGB8";
              Format[Format["ETC2_RGB8_A1"] = 79] = "ETC2_RGB8_A1";
              Format[Format["ETC2_SRGB8_A1"] = 80] = "ETC2_SRGB8_A1";
              Format[Format["ETC2_RGBA8"] = 81] = "ETC2_RGBA8";
              Format[Format["ETC2_SRGB8_A8"] = 82] = "ETC2_SRGB8_A8";
              Format[Format["EAC_R11"] = 83] = "EAC_R11";
              Format[Format["EAC_R11SN"] = 84] = "EAC_R11SN";
              Format[Format["EAC_RG11"] = 85] = "EAC_RG11";
              Format[Format["EAC_RG11SN"] = 86] = "EAC_RG11SN";
              Format[Format["PVRTC_RGB2"] = 87] = "PVRTC_RGB2";
              Format[Format["PVRTC_RGBA2"] = 88] = "PVRTC_RGBA2";
              Format[Format["PVRTC_RGB4"] = 89] = "PVRTC_RGB4";
              Format[Format["PVRTC_RGBA4"] = 90] = "PVRTC_RGBA4";
              Format[Format["PVRTC2_2BPP"] = 91] = "PVRTC2_2BPP";
              Format[Format["PVRTC2_4BPP"] = 92] = "PVRTC2_4BPP";
              Format[Format["ASTC_RGBA_4X4"] = 93] = "ASTC_RGBA_4X4";
              Format[Format["ASTC_RGBA_5X4"] = 94] = "ASTC_RGBA_5X4";
              Format[Format["ASTC_RGBA_5X5"] = 95] = "ASTC_RGBA_5X5";
              Format[Format["ASTC_RGBA_6X5"] = 96] = "ASTC_RGBA_6X5";
              Format[Format["ASTC_RGBA_6X6"] = 97] = "ASTC_RGBA_6X6";
              Format[Format["ASTC_RGBA_8X5"] = 98] = "ASTC_RGBA_8X5";
              Format[Format["ASTC_RGBA_8X6"] = 99] = "ASTC_RGBA_8X6";
              Format[Format["ASTC_RGBA_8X8"] = 100] = "ASTC_RGBA_8X8";
              Format[Format["ASTC_RGBA_10X5"] = 101] = "ASTC_RGBA_10X5";
              Format[Format["ASTC_RGBA_10X6"] = 102] = "ASTC_RGBA_10X6";
              Format[Format["ASTC_RGBA_10X8"] = 103] = "ASTC_RGBA_10X8";
              Format[Format["ASTC_RGBA_10X10"] = 104] = "ASTC_RGBA_10X10";
              Format[Format["ASTC_RGBA_12X10"] = 105] = "ASTC_RGBA_12X10";
              Format[Format["ASTC_RGBA_12X12"] = 106] = "ASTC_RGBA_12X12";
              Format[Format["ASTC_SRGBA_4X4"] = 107] = "ASTC_SRGBA_4X4";
              Format[Format["ASTC_SRGBA_5X4"] = 108] = "ASTC_SRGBA_5X4";
              Format[Format["ASTC_SRGBA_5X5"] = 109] = "ASTC_SRGBA_5X5";
              Format[Format["ASTC_SRGBA_6X5"] = 110] = "ASTC_SRGBA_6X5";
              Format[Format["ASTC_SRGBA_6X6"] = 111] = "ASTC_SRGBA_6X6";
              Format[Format["ASTC_SRGBA_8X5"] = 112] = "ASTC_SRGBA_8X5";
              Format[Format["ASTC_SRGBA_8X6"] = 113] = "ASTC_SRGBA_8X6";
              Format[Format["ASTC_SRGBA_8X8"] = 114] = "ASTC_SRGBA_8X8";
              Format[Format["ASTC_SRGBA_10X5"] = 115] = "ASTC_SRGBA_10X5";
              Format[Format["ASTC_SRGBA_10X6"] = 116] = "ASTC_SRGBA_10X6";
              Format[Format["ASTC_SRGBA_10X8"] = 117] = "ASTC_SRGBA_10X8";
              Format[Format["ASTC_SRGBA_10X10"] = 118] = "ASTC_SRGBA_10X10";
              Format[Format["ASTC_SRGBA_12X10"] = 119] = "ASTC_SRGBA_12X10";
              Format[Format["ASTC_SRGBA_12X12"] = 120] = "ASTC_SRGBA_12X12";
              Format[Format["COUNT"] = 121] = "COUNT";
            })(Format || (Format = exports('i', {})));

            let FormatType;

            (function (FormatType) {
              FormatType[FormatType["NONE"] = 0] = "NONE";
              FormatType[FormatType["UNORM"] = 1] = "UNORM";
              FormatType[FormatType["SNORM"] = 2] = "SNORM";
              FormatType[FormatType["UINT"] = 3] = "UINT";
              FormatType[FormatType["INT"] = 4] = "INT";
              FormatType[FormatType["UFLOAT"] = 5] = "UFLOAT";
              FormatType[FormatType["FLOAT"] = 6] = "FLOAT";
            })(FormatType || (FormatType = exports('j', {})));

            let Type;

            (function (Type) {
              Type[Type["UNKNOWN"] = 0] = "UNKNOWN";
              Type[Type["BOOL"] = 1] = "BOOL";
              Type[Type["BOOL2"] = 2] = "BOOL2";
              Type[Type["BOOL3"] = 3] = "BOOL3";
              Type[Type["BOOL4"] = 4] = "BOOL4";
              Type[Type["INT"] = 5] = "INT";
              Type[Type["INT2"] = 6] = "INT2";
              Type[Type["INT3"] = 7] = "INT3";
              Type[Type["INT4"] = 8] = "INT4";
              Type[Type["UINT"] = 9] = "UINT";
              Type[Type["UINT2"] = 10] = "UINT2";
              Type[Type["UINT3"] = 11] = "UINT3";
              Type[Type["UINT4"] = 12] = "UINT4";
              Type[Type["FLOAT"] = 13] = "FLOAT";
              Type[Type["FLOAT2"] = 14] = "FLOAT2";
              Type[Type["FLOAT3"] = 15] = "FLOAT3";
              Type[Type["FLOAT4"] = 16] = "FLOAT4";
              Type[Type["MAT2"] = 17] = "MAT2";
              Type[Type["MAT2X3"] = 18] = "MAT2X3";
              Type[Type["MAT2X4"] = 19] = "MAT2X4";
              Type[Type["MAT3X2"] = 20] = "MAT3X2";
              Type[Type["MAT3"] = 21] = "MAT3";
              Type[Type["MAT3X4"] = 22] = "MAT3X4";
              Type[Type["MAT4X2"] = 23] = "MAT4X2";
              Type[Type["MAT4X3"] = 24] = "MAT4X3";
              Type[Type["MAT4"] = 25] = "MAT4";
              Type[Type["SAMPLER1D"] = 26] = "SAMPLER1D";
              Type[Type["SAMPLER1D_ARRAY"] = 27] = "SAMPLER1D_ARRAY";
              Type[Type["SAMPLER2D"] = 28] = "SAMPLER2D";
              Type[Type["SAMPLER2D_ARRAY"] = 29] = "SAMPLER2D_ARRAY";
              Type[Type["SAMPLER3D"] = 30] = "SAMPLER3D";
              Type[Type["SAMPLER_CUBE"] = 31] = "SAMPLER_CUBE";
              Type[Type["SAMPLER"] = 32] = "SAMPLER";
              Type[Type["TEXTURE1D"] = 33] = "TEXTURE1D";
              Type[Type["TEXTURE1D_ARRAY"] = 34] = "TEXTURE1D_ARRAY";
              Type[Type["TEXTURE2D"] = 35] = "TEXTURE2D";
              Type[Type["TEXTURE2D_ARRAY"] = 36] = "TEXTURE2D_ARRAY";
              Type[Type["TEXTURE3D"] = 37] = "TEXTURE3D";
              Type[Type["TEXTURE_CUBE"] = 38] = "TEXTURE_CUBE";
              Type[Type["IMAGE1D"] = 39] = "IMAGE1D";
              Type[Type["IMAGE1D_ARRAY"] = 40] = "IMAGE1D_ARRAY";
              Type[Type["IMAGE2D"] = 41] = "IMAGE2D";
              Type[Type["IMAGE2D_ARRAY"] = 42] = "IMAGE2D_ARRAY";
              Type[Type["IMAGE3D"] = 43] = "IMAGE3D";
              Type[Type["IMAGE_CUBE"] = 44] = "IMAGE_CUBE";
              Type[Type["SUBPASS_INPUT"] = 45] = "SUBPASS_INPUT";
              Type[Type["COUNT"] = 46] = "COUNT";
            })(Type || (Type = exports('k', {})));

            let BufferUsageBit;

            (function (BufferUsageBit) {
              BufferUsageBit[BufferUsageBit["NONE"] = 0] = "NONE";
              BufferUsageBit[BufferUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
              BufferUsageBit[BufferUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
              BufferUsageBit[BufferUsageBit["INDEX"] = 4] = "INDEX";
              BufferUsageBit[BufferUsageBit["VERTEX"] = 8] = "VERTEX";
              BufferUsageBit[BufferUsageBit["UNIFORM"] = 16] = "UNIFORM";
              BufferUsageBit[BufferUsageBit["STORAGE"] = 32] = "STORAGE";
              BufferUsageBit[BufferUsageBit["INDIRECT"] = 64] = "INDIRECT";
            })(BufferUsageBit || (BufferUsageBit = exports('B', {})));

            let BufferFlagBit;

            (function (BufferFlagBit) {
              BufferFlagBit[BufferFlagBit["NONE"] = 0] = "NONE";
            })(BufferFlagBit || (BufferFlagBit = exports('c', {})));

            let MemoryAccessBit;

            (function (MemoryAccessBit) {
              MemoryAccessBit[MemoryAccessBit["NONE"] = 0] = "NONE";
              MemoryAccessBit[MemoryAccessBit["READ_ONLY"] = 1] = "READ_ONLY";
              MemoryAccessBit[MemoryAccessBit["WRITE_ONLY"] = 2] = "WRITE_ONLY";
              MemoryAccessBit[MemoryAccessBit["READ_WRITE"] = 3] = "READ_WRITE";
            })(MemoryAccessBit || (MemoryAccessBit = exports('l', {})));

            let MemoryUsageBit;

            (function (MemoryUsageBit) {
              MemoryUsageBit[MemoryUsageBit["NONE"] = 0] = "NONE";
              MemoryUsageBit[MemoryUsageBit["DEVICE"] = 1] = "DEVICE";
              MemoryUsageBit[MemoryUsageBit["HOST"] = 2] = "HOST";
            })(MemoryUsageBit || (MemoryUsageBit = exports('M', {})));

            let TextureType;

            (function (TextureType) {
              TextureType[TextureType["TEX1D"] = 0] = "TEX1D";
              TextureType[TextureType["TEX2D"] = 1] = "TEX2D";
              TextureType[TextureType["TEX3D"] = 2] = "TEX3D";
              TextureType[TextureType["CUBE"] = 3] = "CUBE";
              TextureType[TextureType["TEX1D_ARRAY"] = 4] = "TEX1D_ARRAY";
              TextureType[TextureType["TEX2D_ARRAY"] = 5] = "TEX2D_ARRAY";
            })(TextureType || (TextureType = exports('n', {})));

            let TextureUsageBit;

            (function (TextureUsageBit) {
              TextureUsageBit[TextureUsageBit["NONE"] = 0] = "NONE";
              TextureUsageBit[TextureUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
              TextureUsageBit[TextureUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
              TextureUsageBit[TextureUsageBit["SAMPLED"] = 4] = "SAMPLED";
              TextureUsageBit[TextureUsageBit["STORAGE"] = 8] = "STORAGE";
              TextureUsageBit[TextureUsageBit["COLOR_ATTACHMENT"] = 16] = "COLOR_ATTACHMENT";
              TextureUsageBit[TextureUsageBit["DEPTH_STENCIL_ATTACHMENT"] = 32] = "DEPTH_STENCIL_ATTACHMENT";
              TextureUsageBit[TextureUsageBit["INPUT_ATTACHMENT"] = 64] = "INPUT_ATTACHMENT";
            })(TextureUsageBit || (TextureUsageBit = exports('o', {})));

            let TextureFlagBit;

            (function (TextureFlagBit) {
              TextureFlagBit[TextureFlagBit["NONE"] = 0] = "NONE";
              TextureFlagBit[TextureFlagBit["GEN_MIPMAP"] = 1] = "GEN_MIPMAP";
              TextureFlagBit[TextureFlagBit["IMMUTABLE"] = 2] = "IMMUTABLE";
              TextureFlagBit[TextureFlagBit["GENERAL_LAYOUT"] = 4] = "GENERAL_LAYOUT";
            })(TextureFlagBit || (TextureFlagBit = exports('p', {})));

            let SampleCount;

            (function (SampleCount) {
              SampleCount[SampleCount["X1"] = 1] = "X1";
              SampleCount[SampleCount["X2"] = 2] = "X2";
              SampleCount[SampleCount["X4"] = 4] = "X4";
              SampleCount[SampleCount["X8"] = 8] = "X8";
              SampleCount[SampleCount["X16"] = 16] = "X16";
              SampleCount[SampleCount["X32"] = 32] = "X32";
              SampleCount[SampleCount["X64"] = 64] = "X64";
            })(SampleCount || (SampleCount = exports('q', {})));

            let Filter;

            (function (Filter) {
              Filter[Filter["NONE"] = 0] = "NONE";
              Filter[Filter["POINT"] = 1] = "POINT";
              Filter[Filter["LINEAR"] = 2] = "LINEAR";
              Filter[Filter["ANISOTROPIC"] = 3] = "ANISOTROPIC";
            })(Filter || (Filter = exports('F', {})));

            let Address;

            (function (Address) {
              Address[Address["WRAP"] = 0] = "WRAP";
              Address[Address["MIRROR"] = 1] = "MIRROR";
              Address[Address["CLAMP"] = 2] = "CLAMP";
              Address[Address["BORDER"] = 3] = "BORDER";
            })(Address || (Address = exports('A', {})));

            let ComparisonFunc;

            (function (ComparisonFunc) {
              ComparisonFunc[ComparisonFunc["NEVER"] = 0] = "NEVER";
              ComparisonFunc[ComparisonFunc["LESS"] = 1] = "LESS";
              ComparisonFunc[ComparisonFunc["EQUAL"] = 2] = "EQUAL";
              ComparisonFunc[ComparisonFunc["LESS_EQUAL"] = 3] = "LESS_EQUAL";
              ComparisonFunc[ComparisonFunc["GREATER"] = 4] = "GREATER";
              ComparisonFunc[ComparisonFunc["NOT_EQUAL"] = 5] = "NOT_EQUAL";
              ComparisonFunc[ComparisonFunc["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
              ComparisonFunc[ComparisonFunc["ALWAYS"] = 7] = "ALWAYS";
            })(ComparisonFunc || (ComparisonFunc = exports('d', {})));

            let StencilOp;

            (function (StencilOp) {
              StencilOp[StencilOp["ZERO"] = 0] = "ZERO";
              StencilOp[StencilOp["KEEP"] = 1] = "KEEP";
              StencilOp[StencilOp["REPLACE"] = 2] = "REPLACE";
              StencilOp[StencilOp["INCR"] = 3] = "INCR";
              StencilOp[StencilOp["DECR"] = 4] = "DECR";
              StencilOp[StencilOp["INVERT"] = 5] = "INVERT";
              StencilOp[StencilOp["INCR_WRAP"] = 6] = "INCR_WRAP";
              StencilOp[StencilOp["DECR_WRAP"] = 7] = "DECR_WRAP";
            })(StencilOp || (StencilOp = exports('r', {})));

            let BlendFactor;

            (function (BlendFactor) {
              BlendFactor[BlendFactor["ZERO"] = 0] = "ZERO";
              BlendFactor[BlendFactor["ONE"] = 1] = "ONE";
              BlendFactor[BlendFactor["SRC_ALPHA"] = 2] = "SRC_ALPHA";
              BlendFactor[BlendFactor["DST_ALPHA"] = 3] = "DST_ALPHA";
              BlendFactor[BlendFactor["ONE_MINUS_SRC_ALPHA"] = 4] = "ONE_MINUS_SRC_ALPHA";
              BlendFactor[BlendFactor["ONE_MINUS_DST_ALPHA"] = 5] = "ONE_MINUS_DST_ALPHA";
              BlendFactor[BlendFactor["SRC_COLOR"] = 6] = "SRC_COLOR";
              BlendFactor[BlendFactor["DST_COLOR"] = 7] = "DST_COLOR";
              BlendFactor[BlendFactor["ONE_MINUS_SRC_COLOR"] = 8] = "ONE_MINUS_SRC_COLOR";
              BlendFactor[BlendFactor["ONE_MINUS_DST_COLOR"] = 9] = "ONE_MINUS_DST_COLOR";
              BlendFactor[BlendFactor["SRC_ALPHA_SATURATE"] = 10] = "SRC_ALPHA_SATURATE";
              BlendFactor[BlendFactor["CONSTANT_COLOR"] = 11] = "CONSTANT_COLOR";
              BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 12] = "ONE_MINUS_CONSTANT_COLOR";
              BlendFactor[BlendFactor["CONSTANT_ALPHA"] = 13] = "CONSTANT_ALPHA";
              BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 14] = "ONE_MINUS_CONSTANT_ALPHA";
            })(BlendFactor || (BlendFactor = exports('s', {})));

            let BlendOp;

            (function (BlendOp) {
              BlendOp[BlendOp["ADD"] = 0] = "ADD";
              BlendOp[BlendOp["SUB"] = 1] = "SUB";
              BlendOp[BlendOp["REV_SUB"] = 2] = "REV_SUB";
              BlendOp[BlendOp["MIN"] = 3] = "MIN";
              BlendOp[BlendOp["MAX"] = 4] = "MAX";
            })(BlendOp || (BlendOp = exports('t', {})));

            let ColorMask;

            (function (ColorMask) {
              ColorMask[ColorMask["NONE"] = 0] = "NONE";
              ColorMask[ColorMask["R"] = 1] = "R";
              ColorMask[ColorMask["G"] = 2] = "G";
              ColorMask[ColorMask["B"] = 4] = "B";
              ColorMask[ColorMask["A"] = 8] = "A";
              ColorMask[ColorMask["ALL"] = 15] = "ALL";
            })(ColorMask || (ColorMask = exports('u', {})));

            let ShaderStageFlagBit;

            (function (ShaderStageFlagBit) {
              ShaderStageFlagBit[ShaderStageFlagBit["NONE"] = 0] = "NONE";
              ShaderStageFlagBit[ShaderStageFlagBit["VERTEX"] = 1] = "VERTEX";
              ShaderStageFlagBit[ShaderStageFlagBit["CONTROL"] = 2] = "CONTROL";
              ShaderStageFlagBit[ShaderStageFlagBit["EVALUATION"] = 4] = "EVALUATION";
              ShaderStageFlagBit[ShaderStageFlagBit["GEOMETRY"] = 8] = "GEOMETRY";
              ShaderStageFlagBit[ShaderStageFlagBit["FRAGMENT"] = 16] = "FRAGMENT";
              ShaderStageFlagBit[ShaderStageFlagBit["COMPUTE"] = 32] = "COMPUTE";
              ShaderStageFlagBit[ShaderStageFlagBit["ALL"] = 63] = "ALL";
            })(ShaderStageFlagBit || (ShaderStageFlagBit = exports('v', {})));

            let LoadOp;

            (function (LoadOp) {
              LoadOp[LoadOp["LOAD"] = 0] = "LOAD";
              LoadOp[LoadOp["CLEAR"] = 1] = "CLEAR";
              LoadOp[LoadOp["DISCARD"] = 2] = "DISCARD";
            })(LoadOp || (LoadOp = exports('L', {})));

            let StoreOp;

            (function (StoreOp) {
              StoreOp[StoreOp["STORE"] = 0] = "STORE";
              StoreOp[StoreOp["DISCARD"] = 1] = "DISCARD";
            })(StoreOp || (StoreOp = exports('w', {})));

            let AccessType;

            (function (AccessType) {
              AccessType[AccessType["NONE"] = 0] = "NONE";
              AccessType[AccessType["INDIRECT_BUFFER"] = 1] = "INDIRECT_BUFFER";
              AccessType[AccessType["INDEX_BUFFER"] = 2] = "INDEX_BUFFER";
              AccessType[AccessType["VERTEX_BUFFER"] = 3] = "VERTEX_BUFFER";
              AccessType[AccessType["VERTEX_SHADER_READ_UNIFORM_BUFFER"] = 4] = "VERTEX_SHADER_READ_UNIFORM_BUFFER";
              AccessType[AccessType["VERTEX_SHADER_READ_TEXTURE"] = 5] = "VERTEX_SHADER_READ_TEXTURE";
              AccessType[AccessType["VERTEX_SHADER_READ_OTHER"] = 6] = "VERTEX_SHADER_READ_OTHER";
              AccessType[AccessType["FRAGMENT_SHADER_READ_UNIFORM_BUFFER"] = 7] = "FRAGMENT_SHADER_READ_UNIFORM_BUFFER";
              AccessType[AccessType["FRAGMENT_SHADER_READ_TEXTURE"] = 8] = "FRAGMENT_SHADER_READ_TEXTURE";
              AccessType[AccessType["FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT"] = 9] = "FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT";
              AccessType[AccessType["FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT"] = 10] = "FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT";
              AccessType[AccessType["FRAGMENT_SHADER_READ_OTHER"] = 11] = "FRAGMENT_SHADER_READ_OTHER";
              AccessType[AccessType["COLOR_ATTACHMENT_READ"] = 12] = "COLOR_ATTACHMENT_READ";
              AccessType[AccessType["DEPTH_STENCIL_ATTACHMENT_READ"] = 13] = "DEPTH_STENCIL_ATTACHMENT_READ";
              AccessType[AccessType["COMPUTE_SHADER_READ_UNIFORM_BUFFER"] = 14] = "COMPUTE_SHADER_READ_UNIFORM_BUFFER";
              AccessType[AccessType["COMPUTE_SHADER_READ_TEXTURE"] = 15] = "COMPUTE_SHADER_READ_TEXTURE";
              AccessType[AccessType["COMPUTE_SHADER_READ_OTHER"] = 16] = "COMPUTE_SHADER_READ_OTHER";
              AccessType[AccessType["TRANSFER_READ"] = 17] = "TRANSFER_READ";
              AccessType[AccessType["HOST_READ"] = 18] = "HOST_READ";
              AccessType[AccessType["PRESENT"] = 19] = "PRESENT";
              AccessType[AccessType["VERTEX_SHADER_WRITE"] = 20] = "VERTEX_SHADER_WRITE";
              AccessType[AccessType["FRAGMENT_SHADER_WRITE"] = 21] = "FRAGMENT_SHADER_WRITE";
              AccessType[AccessType["COLOR_ATTACHMENT_WRITE"] = 22] = "COLOR_ATTACHMENT_WRITE";
              AccessType[AccessType["DEPTH_STENCIL_ATTACHMENT_WRITE"] = 23] = "DEPTH_STENCIL_ATTACHMENT_WRITE";
              AccessType[AccessType["COMPUTE_SHADER_WRITE"] = 24] = "COMPUTE_SHADER_WRITE";
              AccessType[AccessType["TRANSFER_WRITE"] = 25] = "TRANSFER_WRITE";
              AccessType[AccessType["HOST_PREINITIALIZED"] = 26] = "HOST_PREINITIALIZED";
              AccessType[AccessType["HOST_WRITE"] = 27] = "HOST_WRITE";
            })(AccessType || (AccessType = exports('x', {})));

            let ResolveMode;

            (function (ResolveMode) {
              ResolveMode[ResolveMode["NONE"] = 0] = "NONE";
              ResolveMode[ResolveMode["SAMPLE_ZERO"] = 1] = "SAMPLE_ZERO";
              ResolveMode[ResolveMode["AVERAGE"] = 2] = "AVERAGE";
              ResolveMode[ResolveMode["MIN"] = 3] = "MIN";
              ResolveMode[ResolveMode["MAX"] = 4] = "MAX";
            })(ResolveMode || (ResolveMode = exports('R', {})));

            let PipelineBindPoint;

            (function (PipelineBindPoint) {
              PipelineBindPoint[PipelineBindPoint["GRAPHICS"] = 0] = "GRAPHICS";
              PipelineBindPoint[PipelineBindPoint["COMPUTE"] = 1] = "COMPUTE";
              PipelineBindPoint[PipelineBindPoint["RAY_TRACING"] = 2] = "RAY_TRACING";
            })(PipelineBindPoint || (PipelineBindPoint = exports('y', {})));

            let PrimitiveMode;

            (function (PrimitiveMode) {
              PrimitiveMode[PrimitiveMode["POINT_LIST"] = 0] = "POINT_LIST";
              PrimitiveMode[PrimitiveMode["LINE_LIST"] = 1] = "LINE_LIST";
              PrimitiveMode[PrimitiveMode["LINE_STRIP"] = 2] = "LINE_STRIP";
              PrimitiveMode[PrimitiveMode["LINE_LOOP"] = 3] = "LINE_LOOP";
              PrimitiveMode[PrimitiveMode["LINE_LIST_ADJACENCY"] = 4] = "LINE_LIST_ADJACENCY";
              PrimitiveMode[PrimitiveMode["LINE_STRIP_ADJACENCY"] = 5] = "LINE_STRIP_ADJACENCY";
              PrimitiveMode[PrimitiveMode["ISO_LINE_LIST"] = 6] = "ISO_LINE_LIST";
              PrimitiveMode[PrimitiveMode["TRIANGLE_LIST"] = 7] = "TRIANGLE_LIST";
              PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP"] = 8] = "TRIANGLE_STRIP";
              PrimitiveMode[PrimitiveMode["TRIANGLE_FAN"] = 9] = "TRIANGLE_FAN";
              PrimitiveMode[PrimitiveMode["TRIANGLE_LIST_ADJACENCY"] = 10] = "TRIANGLE_LIST_ADJACENCY";
              PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP_ADJACENCY"] = 11] = "TRIANGLE_STRIP_ADJACENCY";
              PrimitiveMode[PrimitiveMode["TRIANGLE_PATCH_ADJACENCY"] = 12] = "TRIANGLE_PATCH_ADJACENCY";
              PrimitiveMode[PrimitiveMode["QUAD_PATCH_LIST"] = 13] = "QUAD_PATCH_LIST";
            })(PrimitiveMode || (PrimitiveMode = exports('z', {})));

            let PolygonMode;

            (function (PolygonMode) {
              PolygonMode[PolygonMode["FILL"] = 0] = "FILL";
              PolygonMode[PolygonMode["POINT"] = 1] = "POINT";
              PolygonMode[PolygonMode["LINE"] = 2] = "LINE";
            })(PolygonMode || (PolygonMode = exports('E', {})));

            let ShadeModel;

            (function (ShadeModel) {
              ShadeModel[ShadeModel["GOURAND"] = 0] = "GOURAND";
              ShadeModel[ShadeModel["FLAT"] = 1] = "FLAT";
            })(ShadeModel || (ShadeModel = exports('H', {})));

            let CullMode;

            (function (CullMode) {
              CullMode[CullMode["NONE"] = 0] = "NONE";
              CullMode[CullMode["FRONT"] = 1] = "FRONT";
              CullMode[CullMode["BACK"] = 2] = "BACK";
            })(CullMode || (CullMode = exports('I', {})));

            let DynamicStateFlagBit;

            (function (DynamicStateFlagBit) {
              DynamicStateFlagBit[DynamicStateFlagBit["NONE"] = 0] = "NONE";
              DynamicStateFlagBit[DynamicStateFlagBit["VIEWPORT"] = 1] = "VIEWPORT";
              DynamicStateFlagBit[DynamicStateFlagBit["SCISSOR"] = 2] = "SCISSOR";
              DynamicStateFlagBit[DynamicStateFlagBit["LINE_WIDTH"] = 4] = "LINE_WIDTH";
              DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BIAS"] = 8] = "DEPTH_BIAS";
              DynamicStateFlagBit[DynamicStateFlagBit["BLEND_CONSTANTS"] = 16] = "BLEND_CONSTANTS";
              DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BOUNDS"] = 32] = "DEPTH_BOUNDS";
              DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_WRITE_MASK"] = 64] = "STENCIL_WRITE_MASK";
              DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_COMPARE_MASK"] = 128] = "STENCIL_COMPARE_MASK";
            })(DynamicStateFlagBit || (DynamicStateFlagBit = exports('J', {})));

            let StencilFace;

            (function (StencilFace) {
              StencilFace[StencilFace["FRONT"] = 1] = "FRONT";
              StencilFace[StencilFace["BACK"] = 2] = "BACK";
              StencilFace[StencilFace["ALL"] = 3] = "ALL";
            })(StencilFace || (StencilFace = exports('K', {})));

            let DescriptorType;

            (function (DescriptorType) {
              DescriptorType[DescriptorType["UNKNOWN"] = 0] = "UNKNOWN";
              DescriptorType[DescriptorType["UNIFORM_BUFFER"] = 1] = "UNIFORM_BUFFER";
              DescriptorType[DescriptorType["DYNAMIC_UNIFORM_BUFFER"] = 2] = "DYNAMIC_UNIFORM_BUFFER";
              DescriptorType[DescriptorType["STORAGE_BUFFER"] = 4] = "STORAGE_BUFFER";
              DescriptorType[DescriptorType["DYNAMIC_STORAGE_BUFFER"] = 8] = "DYNAMIC_STORAGE_BUFFER";
              DescriptorType[DescriptorType["SAMPLER_TEXTURE"] = 16] = "SAMPLER_TEXTURE";
              DescriptorType[DescriptorType["SAMPLER"] = 32] = "SAMPLER";
              DescriptorType[DescriptorType["TEXTURE"] = 64] = "TEXTURE";
              DescriptorType[DescriptorType["STORAGE_IMAGE"] = 128] = "STORAGE_IMAGE";
              DescriptorType[DescriptorType["INPUT_ATTACHMENT"] = 256] = "INPUT_ATTACHMENT";
            })(DescriptorType || (DescriptorType = exports('N', {})));

            let QueueType;

            (function (QueueType) {
              QueueType[QueueType["GRAPHICS"] = 0] = "GRAPHICS";
              QueueType[QueueType["COMPUTE"] = 1] = "COMPUTE";
              QueueType[QueueType["TRANSFER"] = 2] = "TRANSFER";
            })(QueueType || (QueueType = exports('Q', {})));

            let CommandBufferType;

            (function (CommandBufferType) {
              CommandBufferType[CommandBufferType["PRIMARY"] = 0] = "PRIMARY";
              CommandBufferType[CommandBufferType["SECONDARY"] = 1] = "SECONDARY";
            })(CommandBufferType || (CommandBufferType = exports('C', {})));

            let ClearFlagBit;

            (function (ClearFlagBit) {
              ClearFlagBit[ClearFlagBit["NONE"] = 0] = "NONE";
              ClearFlagBit[ClearFlagBit["COLOR"] = 1] = "COLOR";
              ClearFlagBit[ClearFlagBit["DEPTH"] = 2] = "DEPTH";
              ClearFlagBit[ClearFlagBit["STENCIL"] = 4] = "STENCIL";
              ClearFlagBit[ClearFlagBit["DEPTH_STENCIL"] = 6] = "DEPTH_STENCIL";
              ClearFlagBit[ClearFlagBit["ALL"] = 7] = "ALL";
            })(ClearFlagBit || (ClearFlagBit = exports('U', {})));

            class Size$1 {
              constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
              }

              copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.z = info.z;
                return this;
              }

            } exports('V', Size$1);
            class DeviceCaps {
              constructor(maxVertexAttributes = 0, maxVertexUniformVectors = 0, maxFragmentUniformVectors = 0, maxTextureUnits = 0, maxImageUnits = 0, maxVertexTextureUnits = 0, maxColorRenderTargets = 0, maxShaderStorageBufferBindings = 0, maxShaderStorageBlockSize = 0, maxUniformBufferBindings = 0, maxUniformBlockSize = 0, maxTextureSize = 0, maxCubeMapTextureSize = 0, depthBits = 0, stencilBits = 0, uboOffsetAlignment = 1, maxComputeSharedMemorySize = 0, maxComputeWorkGroupInvocations = 0, maxComputeWorkGroupSize = new Size$1(), maxComputeWorkGroupCount = new Size$1(), clipSpaceMinZ = -1, screenSpaceSignY = 1, clipSpaceSignY = 1) {
                this.maxVertexAttributes = maxVertexAttributes;
                this.maxVertexUniformVectors = maxVertexUniformVectors;
                this.maxFragmentUniformVectors = maxFragmentUniformVectors;
                this.maxTextureUnits = maxTextureUnits;
                this.maxImageUnits = maxImageUnits;
                this.maxVertexTextureUnits = maxVertexTextureUnits;
                this.maxColorRenderTargets = maxColorRenderTargets;
                this.maxShaderStorageBufferBindings = maxShaderStorageBufferBindings;
                this.maxShaderStorageBlockSize = maxShaderStorageBlockSize;
                this.maxUniformBufferBindings = maxUniformBufferBindings;
                this.maxUniformBlockSize = maxUniformBlockSize;
                this.maxTextureSize = maxTextureSize;
                this.maxCubeMapTextureSize = maxCubeMapTextureSize;
                this.depthBits = depthBits;
                this.stencilBits = stencilBits;
                this.uboOffsetAlignment = uboOffsetAlignment;
                this.maxComputeSharedMemorySize = maxComputeSharedMemorySize;
                this.maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
                this.maxComputeWorkGroupSize = maxComputeWorkGroupSize;
                this.maxComputeWorkGroupCount = maxComputeWorkGroupCount;
                this.clipSpaceMinZ = clipSpaceMinZ;
                this.screenSpaceSignY = screenSpaceSignY;
                this.clipSpaceSignY = clipSpaceSignY;
              }

              copy(info) {
                this.maxVertexAttributes = info.maxVertexAttributes;
                this.maxVertexUniformVectors = info.maxVertexUniformVectors;
                this.maxFragmentUniformVectors = info.maxFragmentUniformVectors;
                this.maxTextureUnits = info.maxTextureUnits;
                this.maxImageUnits = info.maxImageUnits;
                this.maxVertexTextureUnits = info.maxVertexTextureUnits;
                this.maxColorRenderTargets = info.maxColorRenderTargets;
                this.maxShaderStorageBufferBindings = info.maxShaderStorageBufferBindings;
                this.maxShaderStorageBlockSize = info.maxShaderStorageBlockSize;
                this.maxUniformBufferBindings = info.maxUniformBufferBindings;
                this.maxUniformBlockSize = info.maxUniformBlockSize;
                this.maxTextureSize = info.maxTextureSize;
                this.maxCubeMapTextureSize = info.maxCubeMapTextureSize;
                this.depthBits = info.depthBits;
                this.stencilBits = info.stencilBits;
                this.uboOffsetAlignment = info.uboOffsetAlignment;
                this.maxComputeSharedMemorySize = info.maxComputeSharedMemorySize;
                this.maxComputeWorkGroupInvocations = info.maxComputeWorkGroupInvocations;
                this.maxComputeWorkGroupSize.copy(info.maxComputeWorkGroupSize);
                this.maxComputeWorkGroupCount.copy(info.maxComputeWorkGroupCount);
                this.clipSpaceMinZ = info.clipSpaceMinZ;
                this.screenSpaceSignY = info.screenSpaceSignY;
                this.clipSpaceSignY = info.clipSpaceSignY;
                return this;
              }

            } exports('W', DeviceCaps);
            class Offset {
              constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
              }

              copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.z = info.z;
                return this;
              }

            } exports('X', Offset);
            class Rect$1 {
              constructor(x = 0, y = 0, width = 0, height = 0) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
              }

              copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.width = info.width;
                this.height = info.height;
                return this;
              }

            } exports('Y', Rect$1);
            class Extent {
              constructor(width = 0, height = 0, depth = 1) {
                this.width = width;
                this.height = height;
                this.depth = depth;
              }

              copy(info) {
                this.width = info.width;
                this.height = info.height;
                this.depth = info.depth;
                return this;
              }

            } exports('Z', Extent);
            class TextureSubresLayers {
              constructor(mipLevel = 0, baseArrayLayer = 0, layerCount = 1) {
                this.mipLevel = mipLevel;
                this.baseArrayLayer = baseArrayLayer;
                this.layerCount = layerCount;
              }

              copy(info) {
                this.mipLevel = info.mipLevel;
                this.baseArrayLayer = info.baseArrayLayer;
                this.layerCount = info.layerCount;
                return this;
              }

            } exports('_', TextureSubresLayers);
            class TextureSubresRange {
              constructor(baseMipLevel = 0, levelCount = 1, baseArrayLayer = 0, layerCount = 1) {
                this.baseMipLevel = baseMipLevel;
                this.levelCount = levelCount;
                this.baseArrayLayer = baseArrayLayer;
                this.layerCount = layerCount;
              }

              copy(info) {
                this.baseMipLevel = info.baseMipLevel;
                this.levelCount = info.levelCount;
                this.baseArrayLayer = info.baseArrayLayer;
                this.layerCount = info.layerCount;
                return this;
              }

            } exports('$', TextureSubresRange);
            class TextureCopy {
              constructor(srcSubres = new TextureSubresLayers(), srcOffset = new Offset(), dstSubres = new TextureSubresLayers(), dstOffset = new Offset(), extent = new Extent()) {
                this.srcSubres = srcSubres;
                this.srcOffset = srcOffset;
                this.dstSubres = dstSubres;
                this.dstOffset = dstOffset;
                this.extent = extent;
              }

              copy(info) {
                this.srcSubres.copy(info.srcSubres);
                this.srcOffset.copy(info.srcOffset);
                this.dstSubres.copy(info.dstSubres);
                this.dstOffset.copy(info.dstOffset);
                this.extent.copy(info.extent);
                return this;
              }

            } exports('a0', TextureCopy);
            class TextureBlit {
              constructor(srcSubres = new TextureSubresLayers(), srcOffset = new Offset(), srcExtent = new Extent(), dstSubres = new TextureSubresLayers(), dstOffset = new Offset(), dstExtent = new Extent()) {
                this.srcSubres = srcSubres;
                this.srcOffset = srcOffset;
                this.srcExtent = srcExtent;
                this.dstSubres = dstSubres;
                this.dstOffset = dstOffset;
                this.dstExtent = dstExtent;
              }

              copy(info) {
                this.srcSubres.copy(info.srcSubres);
                this.srcOffset.copy(info.srcOffset);
                this.srcExtent.copy(info.srcExtent);
                this.dstSubres.copy(info.dstSubres);
                this.dstOffset.copy(info.dstOffset);
                this.dstExtent.copy(info.dstExtent);
                return this;
              }

            } exports('a1', TextureBlit);
            class BufferTextureCopy {
              constructor(buffStride = 0, buffTexHeight = 0, texOffset = new Offset(), texExtent = new Extent(), texSubres = new TextureSubresLayers()) {
                this.buffStride = buffStride;
                this.buffTexHeight = buffTexHeight;
                this.texOffset = texOffset;
                this.texExtent = texExtent;
                this.texSubres = texSubres;
              }

              copy(info) {
                this.buffStride = info.buffStride;
                this.buffTexHeight = info.buffTexHeight;
                this.texOffset.copy(info.texOffset);
                this.texExtent.copy(info.texExtent);
                this.texSubres.copy(info.texSubres);
                return this;
              }

            } exports('a2', BufferTextureCopy);
            class Viewport {
              constructor(left = 0, top = 0, width = 0, height = 0, minDepth = 0, maxDepth = 1) {
                this.left = left;
                this.top = top;
                this.width = width;
                this.height = height;
                this.minDepth = minDepth;
                this.maxDepth = maxDepth;
              }

              copy(info) {
                this.left = info.left;
                this.top = info.top;
                this.width = info.width;
                this.height = info.height;
                this.minDepth = info.minDepth;
                this.maxDepth = info.maxDepth;
                return this;
              }

            } exports('a3', Viewport);
            class Color$1 {
              constructor(x = 0, y = 0, z = 0, w = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
              }

              copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.z = info.z;
                this.w = info.w;
                return this;
              }

            } exports('e', Color$1);
            class BindingMappingInfo {
              constructor(bufferOffsets = [], samplerOffsets = [], flexibleSet = 0) {
                this.bufferOffsets = bufferOffsets;
                this.samplerOffsets = samplerOffsets;
                this.flexibleSet = flexibleSet;
              }

              copy(info) {
                this.bufferOffsets = info.bufferOffsets.slice();
                this.samplerOffsets = info.samplerOffsets.slice();
                this.flexibleSet = info.flexibleSet;
                return this;
              }

            } exports('a4', BindingMappingInfo);
            class BufferInfo {
              constructor(usage = BufferUsageBit.NONE, memUsage = MemoryUsageBit.NONE, size = 0, stride = 0, flags = BufferFlagBit.NONE) {
                this.usage = usage;
                this.memUsage = memUsage;
                this.size = size;
                this.stride = stride;
                this.flags = flags;
              }

              copy(info) {
                this.usage = info.usage;
                this.memUsage = info.memUsage;
                this.size = info.size;
                this.stride = info.stride;
                this.flags = info.flags;
                return this;
              }

            } exports('a5', BufferInfo);
            class BufferViewInfo {
              constructor(buffer = null, offset = 0, range = 0) {
                this.buffer = buffer;
                this.offset = offset;
                this.range = range;
              }

              copy(info) {
                this.buffer = info.buffer;
                this.offset = info.offset;
                this.range = info.range;
                return this;
              }

            } exports('a6', BufferViewInfo);
            class DrawInfo {
              constructor(vertexCount = 0, firstVertex = 0, indexCount = 0, firstIndex = 0, vertexOffset = 0, instanceCount = 0, firstInstance = 0) {
                this.vertexCount = vertexCount;
                this.firstVertex = firstVertex;
                this.indexCount = indexCount;
                this.firstIndex = firstIndex;
                this.vertexOffset = vertexOffset;
                this.instanceCount = instanceCount;
                this.firstInstance = firstInstance;
              }

              copy(info) {
                this.vertexCount = info.vertexCount;
                this.firstVertex = info.firstVertex;
                this.indexCount = info.indexCount;
                this.firstIndex = info.firstIndex;
                this.vertexOffset = info.vertexOffset;
                this.instanceCount = info.instanceCount;
                this.firstInstance = info.firstInstance;
                return this;
              }

            } exports('a7', DrawInfo);
            class DispatchInfo {
              constructor(groupCountX = 0, groupCountY = 0, groupCountZ = 0, indirectBuffer = null, indirectOffset = 0) {
                this.groupCountX = groupCountX;
                this.groupCountY = groupCountY;
                this.groupCountZ = groupCountZ;
                this.indirectBuffer = indirectBuffer;
                this.indirectOffset = indirectOffset;
              }

              copy(info) {
                this.groupCountX = info.groupCountX;
                this.groupCountY = info.groupCountY;
                this.groupCountZ = info.groupCountZ;
                this.indirectBuffer = info.indirectBuffer;
                this.indirectOffset = info.indirectOffset;
                return this;
              }

            } exports('a8', DispatchInfo);
            class IndirectBuffer {
              constructor(drawInfos = []) {
                this.drawInfos = drawInfos;
              }

              copy(info) {
                deepCopy(this.drawInfos, info.drawInfos, DrawInfo);
                return this;
              }

            } exports('a9', IndirectBuffer);
            class TextureInfo {
              constructor(type = TextureType.TEX2D, usage = TextureUsageBit.NONE, format = Format.UNKNOWN, width = 0, height = 0, flags = TextureFlagBit.NONE, layerCount = 1, levelCount = 1, samples = SampleCount.X1, depth = 1) {
                this.type = type;
                this.usage = usage;
                this.format = format;
                this.width = width;
                this.height = height;
                this.flags = flags;
                this.layerCount = layerCount;
                this.levelCount = levelCount;
                this.samples = samples;
                this.depth = depth;
              }

              copy(info) {
                this.type = info.type;
                this.usage = info.usage;
                this.format = info.format;
                this.width = info.width;
                this.height = info.height;
                this.flags = info.flags;
                this.layerCount = info.layerCount;
                this.levelCount = info.levelCount;
                this.samples = info.samples;
                this.depth = info.depth;
                return this;
              }

            } exports('aa', TextureInfo);
            class TextureViewInfo {
              constructor(texture = null, type = TextureType.TEX2D, format = Format.UNKNOWN, baseLevel = 0, levelCount = 1, baseLayer = 0, layerCount = 1) {
                this.texture = texture;
                this.type = type;
                this.format = format;
                this.baseLevel = baseLevel;
                this.levelCount = levelCount;
                this.baseLayer = baseLayer;
                this.layerCount = layerCount;
              }

              copy(info) {
                this.texture = info.texture;
                this.type = info.type;
                this.format = info.format;
                this.baseLevel = info.baseLevel;
                this.levelCount = info.levelCount;
                this.baseLayer = info.baseLayer;
                this.layerCount = info.layerCount;
                return this;
              }

            } exports('ab', TextureViewInfo);
            class SamplerInfo {
              constructor(minFilter = Filter.LINEAR, magFilter = Filter.LINEAR, mipFilter = Filter.NONE, addressU = Address.WRAP, addressV = Address.WRAP, addressW = Address.WRAP, maxAnisotropy = 0, cmpFunc = ComparisonFunc.ALWAYS, borderColor = new Color$1(), mipLODBias = 0) {
                this.minFilter = minFilter;
                this.magFilter = magFilter;
                this.mipFilter = mipFilter;
                this.addressU = addressU;
                this.addressV = addressV;
                this.addressW = addressW;
                this.maxAnisotropy = maxAnisotropy;
                this.cmpFunc = cmpFunc;
                this.borderColor = borderColor;
                this.mipLODBias = mipLODBias;
              }

              copy(info) {
                this.minFilter = info.minFilter;
                this.magFilter = info.magFilter;
                this.mipFilter = info.mipFilter;
                this.addressU = info.addressU;
                this.addressV = info.addressV;
                this.addressW = info.addressW;
                this.maxAnisotropy = info.maxAnisotropy;
                this.cmpFunc = info.cmpFunc;
                this.borderColor.copy(info.borderColor);
                this.mipLODBias = info.mipLODBias;
                return this;
              }

            } exports('ac', SamplerInfo);
            class Uniform {
              constructor(name = '', type = Type.UNKNOWN, count = 0) {
                this.name = name;
                this.type = type;
                this.count = count;
              }

              copy(info) {
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                return this;
              }

            } exports('ad', Uniform);
            class UniformBlock {
              constructor(set = 0, binding = 0, name = '', members = [], count = 0) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.members = members;
                this.count = count;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                deepCopy(this.members, info.members, Uniform);
                this.count = info.count;
                return this;
              }

            } exports('ae', UniformBlock);
            class UniformSamplerTexture {
              constructor(set = 0, binding = 0, name = '', type = Type.UNKNOWN, count = 0) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.type = type;
                this.count = count;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                return this;
              }

            } exports('af', UniformSamplerTexture);
            class UniformSampler {
              constructor(set = 0, binding = 0, name = '', count = 0) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.count = count;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.count = info.count;
                return this;
              }

            } exports('ag', UniformSampler);
            class UniformTexture {
              constructor(set = 0, binding = 0, name = '', type = Type.UNKNOWN, count = 0) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.type = type;
                this.count = count;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                return this;
              }

            } exports('ah', UniformTexture);
            class UniformStorageImage {
              constructor(set = 0, binding = 0, name = '', type = Type.UNKNOWN, count = 0, memoryAccess = MemoryAccessBit.READ_WRITE) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.type = type;
                this.count = count;
                this.memoryAccess = memoryAccess;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                this.memoryAccess = info.memoryAccess;
                return this;
              }

            } exports('ai', UniformStorageImage);
            class UniformStorageBuffer {
              constructor(set = 0, binding = 0, name = '', count = 0, memoryAccess = MemoryAccessBit.READ_WRITE) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.count = count;
                this.memoryAccess = memoryAccess;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.count = info.count;
                this.memoryAccess = info.memoryAccess;
                return this;
              }

            } exports('aj', UniformStorageBuffer);
            class UniformInputAttachment {
              constructor(set = 0, binding = 0, name = '', count = 0) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.count = count;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.count = info.count;
                return this;
              }

            } exports('ak', UniformInputAttachment);
            class ShaderStage {
              constructor(stage = ShaderStageFlagBit.NONE, source = '') {
                this.stage = stage;
                this.source = source;
              }

              copy(info) {
                this.stage = info.stage;
                this.source = info.source;
                return this;
              }

            } exports('al', ShaderStage);
            class Attribute {
              constructor(name = '', format = Format.UNKNOWN, isNormalized = false, stream = 0, isInstanced = false, location = 0) {
                this.name = name;
                this.format = format;
                this.isNormalized = isNormalized;
                this.stream = stream;
                this.isInstanced = isInstanced;
                this.location = location;
              }

              copy(info) {
                this.name = info.name;
                this.format = info.format;
                this.isNormalized = info.isNormalized;
                this.stream = info.stream;
                this.isInstanced = info.isInstanced;
                this.location = info.location;
                return this;
              }

            } exports('am', Attribute);
            class ShaderInfo {
              constructor(name = '', stages = [], attributes = [], blocks = [], buffers = [], samplerTextures = [], samplers = [], textures = [], images = [], subpassInputs = []) {
                this.name = name;
                this.stages = stages;
                this.attributes = attributes;
                this.blocks = blocks;
                this.buffers = buffers;
                this.samplerTextures = samplerTextures;
                this.samplers = samplers;
                this.textures = textures;
                this.images = images;
                this.subpassInputs = subpassInputs;
              }

              copy(info) {
                this.name = info.name;
                deepCopy(this.stages, info.stages, ShaderStage);
                deepCopy(this.attributes, info.attributes, Attribute);
                deepCopy(this.blocks, info.blocks, UniformBlock);
                deepCopy(this.buffers, info.buffers, UniformStorageBuffer);
                deepCopy(this.samplerTextures, info.samplerTextures, UniformSamplerTexture);
                deepCopy(this.samplers, info.samplers, UniformSampler);
                deepCopy(this.textures, info.textures, UniformTexture);
                deepCopy(this.images, info.images, UniformStorageImage);
                deepCopy(this.subpassInputs, info.subpassInputs, UniformInputAttachment);
                return this;
              }

            } exports('an', ShaderInfo);
            class InputAssemblerInfo {
              constructor(attributes = [], vertexBuffers = [], indexBuffer = null, indirectBuffer = null) {
                this.attributes = attributes;
                this.vertexBuffers = vertexBuffers;
                this.indexBuffer = indexBuffer;
                this.indirectBuffer = indirectBuffer;
              }

              copy(info) {
                deepCopy(this.attributes, info.attributes, Attribute);
                this.vertexBuffers = info.vertexBuffers.slice();
                this.indexBuffer = info.indexBuffer;
                this.indirectBuffer = info.indirectBuffer;
                return this;
              }

            } exports('ao', InputAssemblerInfo);
            class ColorAttachment {
              constructor(format = Format.UNKNOWN, sampleCount = SampleCount.X1, loadOp = LoadOp.CLEAR, storeOp = StoreOp.STORE, beginAccesses = [], endAccesses = [AccessType.PRESENT], isGeneralLayout = false) {
                this.format = format;
                this.sampleCount = sampleCount;
                this.loadOp = loadOp;
                this.storeOp = storeOp;
                this.beginAccesses = beginAccesses;
                this.endAccesses = endAccesses;
                this.isGeneralLayout = isGeneralLayout;
              }

              copy(info) {
                this.format = info.format;
                this.sampleCount = info.sampleCount;
                this.loadOp = info.loadOp;
                this.storeOp = info.storeOp;
                this.beginAccesses = info.beginAccesses.slice();
                this.endAccesses = info.endAccesses.slice();
                this.isGeneralLayout = info.isGeneralLayout;
                return this;
              }

            } exports('ap', ColorAttachment);
            class DepthStencilAttachment {
              constructor(format = Format.UNKNOWN, sampleCount = SampleCount.X1, depthLoadOp = LoadOp.CLEAR, depthStoreOp = StoreOp.STORE, stencilLoadOp = LoadOp.CLEAR, stencilStoreOp = StoreOp.STORE, beginAccesses = [], endAccesses = [AccessType.DEPTH_STENCIL_ATTACHMENT_WRITE], isGeneralLayout = false) {
                this.format = format;
                this.sampleCount = sampleCount;
                this.depthLoadOp = depthLoadOp;
                this.depthStoreOp = depthStoreOp;
                this.stencilLoadOp = stencilLoadOp;
                this.stencilStoreOp = stencilStoreOp;
                this.beginAccesses = beginAccesses;
                this.endAccesses = endAccesses;
                this.isGeneralLayout = isGeneralLayout;
              }

              copy(info) {
                this.format = info.format;
                this.sampleCount = info.sampleCount;
                this.depthLoadOp = info.depthLoadOp;
                this.depthStoreOp = info.depthStoreOp;
                this.stencilLoadOp = info.stencilLoadOp;
                this.stencilStoreOp = info.stencilStoreOp;
                this.beginAccesses = info.beginAccesses.slice();
                this.endAccesses = info.endAccesses.slice();
                this.isGeneralLayout = info.isGeneralLayout;
                return this;
              }

            } exports('aq', DepthStencilAttachment);
            class SubpassInfo {
              constructor(inputs = [], colors = [], resolves = [], preserves = [], depthStencil = -1, depthStencilResolve = -1, depthResolveMode = ResolveMode.NONE, stencilResolveMode = ResolveMode.NONE) {
                this.inputs = inputs;
                this.colors = colors;
                this.resolves = resolves;
                this.preserves = preserves;
                this.depthStencil = depthStencil;
                this.depthStencilResolve = depthStencilResolve;
                this.depthResolveMode = depthResolveMode;
                this.stencilResolveMode = stencilResolveMode;
              }

              copy(info) {
                this.inputs = info.inputs.slice();
                this.colors = info.colors.slice();
                this.resolves = info.resolves.slice();
                this.preserves = info.preserves.slice();
                this.depthStencil = info.depthStencil;
                this.depthStencilResolve = info.depthStencilResolve;
                this.depthResolveMode = info.depthResolveMode;
                this.stencilResolveMode = info.stencilResolveMode;
                return this;
              }

            } exports('ar', SubpassInfo);
            class SubpassDependency {
              constructor(srcSubpass = 0, dstSubpass = 0, srcAccesses = [], dstAccesses = []) {
                this.srcSubpass = srcSubpass;
                this.dstSubpass = dstSubpass;
                this.srcAccesses = srcAccesses;
                this.dstAccesses = dstAccesses;
              }

              copy(info) {
                this.srcSubpass = info.srcSubpass;
                this.dstSubpass = info.dstSubpass;
                this.srcAccesses = info.srcAccesses.slice();
                this.dstAccesses = info.dstAccesses.slice();
                return this;
              }

            } exports('as', SubpassDependency);
            class RenderPassInfo {
              constructor(colorAttachments = [], depthStencilAttachment = new DepthStencilAttachment(), subpasses = [], dependencies = []) {
                this.colorAttachments = colorAttachments;
                this.depthStencilAttachment = depthStencilAttachment;
                this.subpasses = subpasses;
                this.dependencies = dependencies;
              }

              copy(info) {
                deepCopy(this.colorAttachments, info.colorAttachments, ColorAttachment);
                this.depthStencilAttachment.copy(info.depthStencilAttachment);
                deepCopy(this.subpasses, info.subpasses, SubpassInfo);
                deepCopy(this.dependencies, info.dependencies, SubpassDependency);
                return this;
              }

            } exports('at', RenderPassInfo);
            class GlobalBarrierInfo {
              constructor(prevAccesses = [], nextAccesses = []) {
                this.prevAccesses = prevAccesses;
                this.nextAccesses = nextAccesses;
              }

              copy(info) {
                this.prevAccesses = info.prevAccesses.slice();
                this.nextAccesses = info.nextAccesses.slice();
                return this;
              }

            } exports('G', GlobalBarrierInfo);
            class TextureBarrierInfo {
              constructor(prevAccesses = [], nextAccesses = [], discardContents = false, srcQueue = null, dstQueue = null) {
                this.prevAccesses = prevAccesses;
                this.nextAccesses = nextAccesses;
                this.discardContents = discardContents;
                this.srcQueue = srcQueue;
                this.dstQueue = dstQueue;
              }

              copy(info) {
                this.prevAccesses = info.prevAccesses.slice();
                this.nextAccesses = info.nextAccesses.slice();
                this.discardContents = info.discardContents;
                this.srcQueue = info.srcQueue;
                this.dstQueue = info.dstQueue;
                return this;
              }

            } exports('T', TextureBarrierInfo);
            class FramebufferInfo {
              constructor(renderPass = null, colorTextures = [], depthStencilTexture = null) {
                this.renderPass = renderPass;
                this.colorTextures = colorTextures;
                this.depthStencilTexture = depthStencilTexture;
              }

              copy(info) {
                this.renderPass = info.renderPass;
                this.colorTextures = info.colorTextures.slice();
                this.depthStencilTexture = info.depthStencilTexture;
                return this;
              }

            } exports('au', FramebufferInfo);
            class DescriptorSetLayoutBinding {
              constructor(binding = -1, descriptorType = DescriptorType.UNKNOWN, count = 0, stageFlags = ShaderStageFlagBit.NONE, immutableSamplers = []) {
                this.binding = binding;
                this.descriptorType = descriptorType;
                this.count = count;
                this.stageFlags = stageFlags;
                this.immutableSamplers = immutableSamplers;
              }

              copy(info) {
                this.binding = info.binding;
                this.descriptorType = info.descriptorType;
                this.count = info.count;
                this.stageFlags = info.stageFlags;
                this.immutableSamplers = info.immutableSamplers.slice();
                return this;
              }

            } exports('av', DescriptorSetLayoutBinding);
            class DescriptorSetLayoutInfo {
              constructor(bindings = []) {
                this.bindings = bindings;
              }

              copy(info) {
                deepCopy(this.bindings, info.bindings, DescriptorSetLayoutBinding);
                return this;
              }

            } exports('aw', DescriptorSetLayoutInfo);
            class DescriptorSetInfo {
              constructor(layout = null) {
                this.layout = layout;
              }

              copy(info) {
                this.layout = info.layout;
                return this;
              }

            } exports('ax', DescriptorSetInfo);
            class PipelineLayoutInfo {
              constructor(setLayouts = []) {
                this.setLayouts = setLayouts;
              }

              copy(info) {
                this.setLayouts = info.setLayouts.slice();
                return this;
              }

            } exports('ay', PipelineLayoutInfo);
            class InputState {
              constructor(attributes = []) {
                this.attributes = attributes;
              }

              copy(info) {
                deepCopy(this.attributes, info.attributes, Attribute);
                return this;
              }

            } exports('az', InputState);
            class CommandBufferInfo {
              constructor(queue = null, type = CommandBufferType.PRIMARY) {
                this.queue = queue;
                this.type = type;
              }

              copy(info) {
                this.queue = info.queue;
                this.type = info.type;
                return this;
              }

            } exports('aA', CommandBufferInfo);
            class QueueInfo {
              constructor(type = QueueType.GRAPHICS) {
                this.type = type;
              }

              copy(info) {
                this.type = info.type;
                return this;
              }

            } exports('aB', QueueInfo);
            class FormatInfo {
              constructor(name = '', size = 0, count = 0, type = FormatType.NONE, hasAlpha = false, hasDepth = false, hasStencil = false, isCompressed = false) {
                this.name = name;
                this.size = size;
                this.count = count;
                this.type = type;
                this.hasAlpha = hasAlpha;
                this.hasDepth = hasDepth;
                this.hasStencil = hasStencil;
                this.isCompressed = isCompressed;
              }

            } exports('aC', FormatInfo);
            class MemoryStatus {
              constructor(bufferSize = 0, textureSize = 0) {
                this.bufferSize = bufferSize;
                this.textureSize = textureSize;
              }

              copy(info) {
                this.bufferSize = info.bufferSize;
                this.textureSize = info.textureSize;
                return this;
              }

            } exports('aD', MemoryStatus);
            class DynamicStencilStates {
              constructor(writeMask = 0, compareMask = 0, reference = 0) {
                this.writeMask = writeMask;
                this.compareMask = compareMask;
                this.reference = reference;
              }

              copy(info) {
                this.writeMask = info.writeMask;
                this.compareMask = info.compareMask;
                this.reference = info.reference;
                return this;
              }

            } exports('aE', DynamicStencilStates);
            class DynamicStates {
              constructor(viewport = new Viewport(), scissor = new Rect$1(), blendConstant = new Color$1(), lineWidth = 1, depthBiasConstant = 0, depthBiasClamp = 0, depthBiasSlope = 0, depthMinBounds = 0, depthMaxBounds = 0, stencilStatesFront = new DynamicStencilStates(), stencilStatesBack = new DynamicStencilStates()) {
                this.viewport = viewport;
                this.scissor = scissor;
                this.blendConstant = blendConstant;
                this.lineWidth = lineWidth;
                this.depthBiasConstant = depthBiasConstant;
                this.depthBiasClamp = depthBiasClamp;
                this.depthBiasSlope = depthBiasSlope;
                this.depthMinBounds = depthMinBounds;
                this.depthMaxBounds = depthMaxBounds;
                this.stencilStatesFront = stencilStatesFront;
                this.stencilStatesBack = stencilStatesBack;
              }

              copy(info) {
                this.viewport.copy(info.viewport);
                this.scissor.copy(info.scissor);
                this.blendConstant.copy(info.blendConstant);
                this.lineWidth = info.lineWidth;
                this.depthBiasConstant = info.depthBiasConstant;
                this.depthBiasClamp = info.depthBiasClamp;
                this.depthBiasSlope = info.depthBiasSlope;
                this.depthMinBounds = info.depthMinBounds;
                this.depthMaxBounds = info.depthMaxBounds;
                this.stencilStatesFront.copy(info.stencilStatesFront);
                this.stencilStatesBack.copy(info.stencilStatesBack);
                return this;
              }

            } exports('aF', DynamicStates);
            class Obj {
              get gfxType() {
                return this._gfxType;
              }

              constructor(gfxType) {
                this._gfxType = ObjectType.UNKNOWN;
                this._gfxType = gfxType;
              }

            } exports('O', Obj);
            class DeviceInfo {
              constructor(canvasElm, isAntialias = true, isPremultipliedAlpha = true, devicePixelRatio = 1, width = 1, height = 1, bindingMappingInfo = new BindingMappingInfo()) {
                this.canvasElm = canvasElm;
                this.isAntialias = isAntialias;
                this.isPremultipliedAlpha = isPremultipliedAlpha;
                this.devicePixelRatio = devicePixelRatio;
                this.width = width;
                this.height = height;
                this.bindingMappingInfo = bindingMappingInfo;
              }

            } exports('aG', DeviceInfo);
            let AttributeName;

            (function (AttributeName) {
              AttributeName["ATTR_POSITION"] = "a_position";
              AttributeName["ATTR_NORMAL"] = "a_normal";
              AttributeName["ATTR_TANGENT"] = "a_tangent";
              AttributeName["ATTR_BITANGENT"] = "a_bitangent";
              AttributeName["ATTR_WEIGHTS"] = "a_weights";
              AttributeName["ATTR_JOINTS"] = "a_joints";
              AttributeName["ATTR_COLOR"] = "a_color";
              AttributeName["ATTR_COLOR1"] = "a_color1";
              AttributeName["ATTR_COLOR2"] = "a_color2";
              AttributeName["ATTR_TEX_COORD"] = "a_texCoord";
              AttributeName["ATTR_TEX_COORD1"] = "a_texCoord1";
              AttributeName["ATTR_TEX_COORD2"] = "a_texCoord2";
              AttributeName["ATTR_TEX_COORD3"] = "a_texCoord3";
              AttributeName["ATTR_TEX_COORD4"] = "a_texCoord4";
              AttributeName["ATTR_TEX_COORD5"] = "a_texCoord5";
              AttributeName["ATTR_TEX_COORD6"] = "a_texCoord6";
              AttributeName["ATTR_TEX_COORD7"] = "a_texCoord7";
              AttributeName["ATTR_TEX_COORD8"] = "a_texCoord8";
              AttributeName["ATTR_BATCH_ID"] = "a_batch_id";
              AttributeName["ATTR_BATCH_UV"] = "a_batch_uv";
            })(AttributeName || (AttributeName = exports('aH', {})));

            const FormatInfos = exports('aI', Object.freeze([new FormatInfo('UNKNOWN', 0, 0, FormatType.NONE, false, false, false, false), new FormatInfo('A8', 1, 1, FormatType.UNORM, true, false, false, false), new FormatInfo('L8', 1, 1, FormatType.UNORM, false, false, false, false), new FormatInfo('LA8', 1, 2, FormatType.UNORM, true, false, false, false), new FormatInfo('R8', 1, 1, FormatType.UNORM, false, false, false, false), new FormatInfo('R8SN', 1, 1, FormatType.SNORM, false, false, false, false), new FormatInfo('R8UI', 1, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R8I', 1, 1, FormatType.INT, false, false, false, false), new FormatInfo('R16F', 2, 1, FormatType.FLOAT, false, false, false, false), new FormatInfo('R16UI', 2, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R16I', 2, 1, FormatType.INT, false, false, false, false), new FormatInfo('R32F', 4, 1, FormatType.FLOAT, false, false, false, false), new FormatInfo('R32UI', 4, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R32I', 4, 1, FormatType.INT, false, false, false, false), new FormatInfo('RG8', 2, 2, FormatType.UNORM, false, false, false, false), new FormatInfo('RG8SN', 2, 2, FormatType.SNORM, false, false, false, false), new FormatInfo('RG8UI', 2, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG8I', 2, 2, FormatType.INT, false, false, false, false), new FormatInfo('RG16F', 4, 2, FormatType.FLOAT, false, false, false, false), new FormatInfo('RG16UI', 4, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG16I', 4, 2, FormatType.INT, false, false, false, false), new FormatInfo('RG32F', 8, 2, FormatType.FLOAT, false, false, false, false), new FormatInfo('RG32UI', 8, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG32I', 8, 2, FormatType.INT, false, false, false, false), new FormatInfo('RGB8', 3, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('SRGB8', 3, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('RGB8SN', 3, 3, FormatType.SNORM, false, false, false, false), new FormatInfo('RGB8UI', 3, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB8I', 3, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGB16F', 6, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB16UI', 6, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB16I', 6, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGB32F', 12, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB32UI', 12, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB32I', 12, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGBA8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('BGRA8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('SRGB8_A8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA8SN', 4, 4, FormatType.SNORM, true, false, false, false), new FormatInfo('RGBA8UI', 4, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA8I', 4, 4, FormatType.INT, true, false, false, false), new FormatInfo('RGBA16F', 8, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA16UI', 8, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA16I', 8, 4, FormatType.INT, true, false, false, false), new FormatInfo('RGBA32F', 16, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA32UI', 16, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA32I', 16, 4, FormatType.INT, true, false, false, false), new FormatInfo('R5G6B5', 2, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('R11G11B10F', 4, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB5A1', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA4', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2UI', 2, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGB9E5', 2, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('D16', 2, 1, FormatType.UINT, false, true, false, false), new FormatInfo('D16S8', 3, 2, FormatType.UINT, false, true, true, false), new FormatInfo('D24', 3, 1, FormatType.UINT, false, true, false, false), new FormatInfo('D24S8', 4, 2, FormatType.UINT, false, true, true, false), new FormatInfo('D32F', 4, 1, FormatType.FLOAT, false, true, false, false), new FormatInfo('D32FS8', 5, 2, FormatType.FLOAT, false, true, true, false), new FormatInfo('BC1', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_ALPHA', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC1_SRGB', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_SRGB_ALPHA', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC2', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC2_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC3', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC3_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC4', 1, 1, FormatType.UNORM, false, false, false, true), new FormatInfo('BC4_SNORM', 1, 1, FormatType.SNORM, false, false, false, true), new FormatInfo('BC5', 1, 2, FormatType.UNORM, false, false, false, true), new FormatInfo('BC5_SNORM', 1, 2, FormatType.SNORM, false, false, false, true), new FormatInfo('BC6H_UF16', 1, 3, FormatType.UFLOAT, false, false, false, true), new FormatInfo('BC6H_SF16', 1, 3, FormatType.FLOAT, false, false, false, true), new FormatInfo('BC7', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC7_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC_RGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_SRGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8_A1', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A1', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_RGBA8', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A8', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('EAC_R11', 1, 1, FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_R11SN', 1, 1, FormatType.SNORM, false, false, false, true), new FormatInfo('EAC_RG11', 2, 2, FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_RG11SN', 2, 2, FormatType.SNORM, false, false, false, true), new FormatInfo('PVRTC_RGB2', 2, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA2', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC_RGB4', 2, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA4', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_2BPP', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_4BPP', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_4x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x12', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_4x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x12', 1, 4, FormatType.UNORM, true, false, false, true)]));
            const DESCRIPTOR_BUFFER_TYPE = exports('D', DescriptorType.UNIFORM_BUFFER | DescriptorType.DYNAMIC_UNIFORM_BUFFER | DescriptorType.STORAGE_BUFFER | DescriptorType.DYNAMIC_STORAGE_BUFFER);
            const DESCRIPTOR_SAMPLER_TYPE = exports('b', DescriptorType.SAMPLER_TEXTURE | DescriptorType.SAMPLER | DescriptorType.TEXTURE | DescriptorType.STORAGE_IMAGE | DescriptorType.INPUT_ATTACHMENT);
            const DESCRIPTOR_DYNAMIC_TYPE = exports('aJ', DescriptorType.DYNAMIC_STORAGE_BUFFER | DescriptorType.DYNAMIC_UNIFORM_BUFFER);
            const DRAW_INFO_SIZE = exports('aK', 28);
            function IsPowerOf2(x) {
              return x > 0 && (x & x - 1) === 0;
            }
            function FormatSize(format, width, height, depth) {
              if (!FormatInfos[format].isCompressed) {
                return width * height * depth * FormatInfos[format].size;
              } else {
                switch (format) {
                  case Format.BC1:
                  case Format.BC1_ALPHA:
                  case Format.BC1_SRGB:
                  case Format.BC1_SRGB_ALPHA:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

                  case Format.BC2:
                  case Format.BC2_SRGB:
                  case Format.BC3:
                  case Format.BC3_SRGB:
                  case Format.BC4:
                  case Format.BC4_SNORM:
                  case Format.BC6H_SF16:
                  case Format.BC6H_UF16:
                  case Format.BC7:
                  case Format.BC7_SRGB:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

                  case Format.BC5:
                  case Format.BC5_SNORM:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;

                  case Format.ETC_RGB8:
                  case Format.ETC2_RGB8:
                  case Format.ETC2_SRGB8:
                  case Format.ETC2_RGB8_A1:
                  case Format.EAC_R11:
                  case Format.EAC_R11SN:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

                  case Format.ETC2_RGBA8:
                  case Format.ETC2_SRGB8_A1:
                  case Format.EAC_RG11:
                  case Format.EAC_RG11SN:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

                  case Format.PVRTC_RGB2:
                  case Format.PVRTC_RGBA2:
                  case Format.PVRTC2_2BPP:
                    return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 4) * depth;

                  case Format.PVRTC_RGB4:
                  case Format.PVRTC_RGBA4:
                  case Format.PVRTC2_4BPP:
                    return Math.ceil(Math.max(width, 8) * Math.max(height, 8) / 2) * depth;

                  case Format.ASTC_RGBA_4X4:
                  case Format.ASTC_SRGBA_4X4:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

                  case Format.ASTC_RGBA_5X4:
                  case Format.ASTC_SRGBA_5X4:
                    return Math.ceil(width / 5) * Math.ceil(height / 4) * 16 * depth;

                  case Format.ASTC_RGBA_5X5:
                  case Format.ASTC_SRGBA_5X5:
                    return Math.ceil(width / 5) * Math.ceil(height / 5) * 16 * depth;

                  case Format.ASTC_RGBA_6X5:
                  case Format.ASTC_SRGBA_6X5:
                    return Math.ceil(width / 6) * Math.ceil(height / 5) * 16 * depth;

                  case Format.ASTC_RGBA_6X6:
                  case Format.ASTC_SRGBA_6X6:
                    return Math.ceil(width / 6) * Math.ceil(height / 6) * 16 * depth;

                  case Format.ASTC_RGBA_8X5:
                  case Format.ASTC_SRGBA_8X5:
                    return Math.ceil(width / 8) * Math.ceil(height / 5) * 16 * depth;

                  case Format.ASTC_RGBA_8X6:
                  case Format.ASTC_SRGBA_8X6:
                    return Math.ceil(width / 8) * Math.ceil(height / 6) * 16 * depth;

                  case Format.ASTC_RGBA_8X8:
                  case Format.ASTC_SRGBA_8X8:
                    return Math.ceil(width / 8) * Math.ceil(height / 8) * 16 * depth;

                  case Format.ASTC_RGBA_10X5:
                  case Format.ASTC_SRGBA_10X5:
                    return Math.ceil(width / 10) * Math.ceil(height / 5) * 16 * depth;

                  case Format.ASTC_RGBA_10X6:
                  case Format.ASTC_SRGBA_10X6:
                    return Math.ceil(width / 10) * Math.ceil(height / 6) * 16 * depth;

                  case Format.ASTC_RGBA_10X8:
                  case Format.ASTC_SRGBA_10X8:
                    return Math.ceil(width / 10) * Math.ceil(height / 8) * 16 * depth;

                  case Format.ASTC_RGBA_10X10:
                  case Format.ASTC_SRGBA_10X10:
                    return Math.ceil(width / 10) * Math.ceil(height / 10) * 16 * depth;

                  case Format.ASTC_RGBA_12X10:
                  case Format.ASTC_SRGBA_12X10:
                    return Math.ceil(width / 12) * Math.ceil(height / 10) * 16 * depth;

                  case Format.ASTC_RGBA_12X12:
                  case Format.ASTC_SRGBA_12X12:
                    return Math.ceil(width / 12) * Math.ceil(height / 12) * 16 * depth;

                  default:
                    {
                      return 0;
                    }
                }
              }
            }
            function FormatSurfaceSize(format, width, height, depth, mips) {
              let size = 0;

              for (let i = 0; i < mips; ++i) {
                size += FormatSize(format, width, height, depth);
                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
              }

              return size;
            }
            const _type2size = [0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4];
            function GetTypeSize(type) {
              return _type2size[type] || 0;
            }
            function getTypedArrayConstructor(info) {
              const stride = info.size / info.count;

              switch (info.type) {
                case FormatType.UNORM:
                case FormatType.UINT:
                  {
                    switch (stride) {
                      case 1:
                        return Uint8Array;

                      case 2:
                        return Uint16Array;

                      case 4:
                        return Uint32Array;
                    }

                    break;
                  }

                case FormatType.SNORM:
                case FormatType.INT:
                  {
                    switch (stride) {
                      case 1:
                        return Int8Array;

                      case 2:
                        return Int16Array;

                      case 4:
                        return Int32Array;
                    }

                    break;
                  }

                case FormatType.FLOAT:
                  {
                    return Float32Array;
                  }
              }

              return Float32Array;
            }

            var defines = /*#__PURE__*/Object.freeze({
                __proto__: null,
                get ObjectType () { return ObjectType; },
                get Status () { return Status; },
                get API () { return API; },
                get SurfaceTransform () { return SurfaceTransform; },
                get Feature () { return Feature; },
                get Format () { return Format; },
                get FormatType () { return FormatType; },
                get Type () { return Type; },
                get BufferUsageBit () { return BufferUsageBit; },
                get BufferFlagBit () { return BufferFlagBit; },
                get MemoryAccessBit () { return MemoryAccessBit; },
                get MemoryUsageBit () { return MemoryUsageBit; },
                get TextureType () { return TextureType; },
                get TextureUsageBit () { return TextureUsageBit; },
                get TextureFlagBit () { return TextureFlagBit; },
                get SampleCount () { return SampleCount; },
                get Filter () { return Filter; },
                get Address () { return Address; },
                get ComparisonFunc () { return ComparisonFunc; },
                get StencilOp () { return StencilOp; },
                get BlendFactor () { return BlendFactor; },
                get BlendOp () { return BlendOp; },
                get ColorMask () { return ColorMask; },
                get ShaderStageFlagBit () { return ShaderStageFlagBit; },
                get LoadOp () { return LoadOp; },
                get StoreOp () { return StoreOp; },
                get AccessType () { return AccessType; },
                get ResolveMode () { return ResolveMode; },
                get PipelineBindPoint () { return PipelineBindPoint; },
                get PrimitiveMode () { return PrimitiveMode; },
                get PolygonMode () { return PolygonMode; },
                get ShadeModel () { return ShadeModel; },
                get CullMode () { return CullMode; },
                get DynamicStateFlagBit () { return DynamicStateFlagBit; },
                get StencilFace () { return StencilFace; },
                get DescriptorType () { return DescriptorType; },
                get QueueType () { return QueueType; },
                get CommandBufferType () { return CommandBufferType; },
                get ClearFlagBit () { return ClearFlagBit; },
                Size: Size$1,
                DeviceCaps: DeviceCaps,
                Offset: Offset,
                Rect: Rect$1,
                Extent: Extent,
                TextureSubresLayers: TextureSubresLayers,
                TextureSubresRange: TextureSubresRange,
                TextureCopy: TextureCopy,
                TextureBlit: TextureBlit,
                BufferTextureCopy: BufferTextureCopy,
                Viewport: Viewport,
                Color: Color$1,
                BindingMappingInfo: BindingMappingInfo,
                BufferInfo: BufferInfo,
                BufferViewInfo: BufferViewInfo,
                DrawInfo: DrawInfo,
                DispatchInfo: DispatchInfo,
                IndirectBuffer: IndirectBuffer,
                TextureInfo: TextureInfo,
                TextureViewInfo: TextureViewInfo,
                SamplerInfo: SamplerInfo,
                Uniform: Uniform,
                UniformBlock: UniformBlock,
                UniformSamplerTexture: UniformSamplerTexture,
                UniformSampler: UniformSampler,
                UniformTexture: UniformTexture,
                UniformStorageImage: UniformStorageImage,
                UniformStorageBuffer: UniformStorageBuffer,
                UniformInputAttachment: UniformInputAttachment,
                ShaderStage: ShaderStage,
                Attribute: Attribute,
                ShaderInfo: ShaderInfo,
                InputAssemblerInfo: InputAssemblerInfo,
                ColorAttachment: ColorAttachment,
                DepthStencilAttachment: DepthStencilAttachment,
                SubpassInfo: SubpassInfo,
                SubpassDependency: SubpassDependency,
                RenderPassInfo: RenderPassInfo,
                GlobalBarrierInfo: GlobalBarrierInfo,
                TextureBarrierInfo: TextureBarrierInfo,
                FramebufferInfo: FramebufferInfo,
                DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
                DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
                DescriptorSetInfo: DescriptorSetInfo,
                PipelineLayoutInfo: PipelineLayoutInfo,
                InputState: InputState,
                CommandBufferInfo: CommandBufferInfo,
                QueueInfo: QueueInfo,
                FormatInfo: FormatInfo,
                MemoryStatus: MemoryStatus,
                DynamicStencilStates: DynamicStencilStates,
                DynamicStates: DynamicStates,
                Obj: Obj,
                DeviceInfo: DeviceInfo,
                get AttributeName () { return AttributeName; },
                FormatInfos: FormatInfos,
                DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
                DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
                DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
                DRAW_INFO_SIZE: DRAW_INFO_SIZE,
                IsPowerOf2: IsPowerOf2,
                FormatSize: FormatSize,
                FormatSurfaceSize: FormatSurfaceSize,
                GetTypeSize: GetTypeSize,
                getTypedArrayConstructor: getTypedArrayConstructor
            });

            class RasterizerState {
              constructor(isDiscard = false, polygonMode = PolygonMode.FILL, shadeModel = ShadeModel.GOURAND, cullMode = CullMode.BACK, isFrontFaceCCW = true, depthBiasEnabled = false, depthBias = 0, depthBiasClamp = 0.0, depthBiasSlop = 0.0, isDepthClip = true, isMultisample = false, lineWidth = 1.0) {
                this._nativeObj = void 0;
                this._isDiscard = false;
                this._polygonMode = PolygonMode.FILL;
                this._shadeModel = ShadeModel.GOURAND;
                this._cullMode = CullMode.BACK;
                this._isFrontFaceCCW = true;
                this._depthBiasEnabled = false;
                this._depthBias = 0;
                this._depthBiasClamp = 0.0;
                this._depthBiasSlop = 0.0;
                this._isDepthClip = true;
                this._isMultisample = false;
                this._lineWidth = 1.0;
                this._nativeObj = new gfx.RasterizerState();
                this.assignProperties(isDiscard, polygonMode, shadeModel, cullMode, isFrontFaceCCW, depthBiasEnabled, depthBias, depthBiasClamp, depthBiasSlop, isDepthClip, isMultisample, lineWidth);
              }

              get native() {
                return this._nativeObj;
              }

              get isDiscard() {
                return this._isDiscard;
              }

              set isDiscard(val) {
                this._isDiscard = val;
                this._nativeObj.isDiscard = val;
              }

              get polygonMode() {
                return this._polygonMode;
              }

              set polygonMode(val) {
                this._polygonMode = val;
                this._nativeObj.polygonMode = val;
              }

              get shadeModel() {
                return this._shadeModel;
              }

              set shadeModel(val) {
                this._shadeModel = val;
                this._nativeObj.shadeModel = val;
              }

              get cullMode() {
                return this._cullMode;
              }

              set cullMode(val) {
                this._cullMode = val;
                this._nativeObj.cullMode = val;
              }

              get isFrontFaceCCW() {
                return this._isFrontFaceCCW;
              }

              set isFrontFaceCCW(val) {
                this._isFrontFaceCCW = val;
                this._nativeObj.isFrontFaceCCW = val;
              }

              get depthBiasEnabled() {
                return this._depthBiasEnabled;
              }

              set depthBiasEnabled(val) {
                this._depthBiasEnabled = val;
                this._nativeObj.depthBiasEnabled = val;
              }

              get depthBias() {
                return this._depthBias;
              }

              set depthBias(val) {
                this._depthBias = val;
                this._nativeObj.depthBias = val;
              }

              get depthBiasClamp() {
                return this._depthBiasClamp;
              }

              set depthBiasClamp(val) {
                this._depthBiasClamp = val;
                this._nativeObj.depthBiasClamp = val;
              }

              get depthBiasSlop() {
                return this._depthBiasSlop;
              }

              set depthBiasSlop(val) {
                this._depthBiasSlop = val;
                this._nativeObj.depthBiasSlop = val;
              }

              get isDepthClip() {
                return this._isDepthClip;
              }

              set isDepthClip(val) {
                this._isDepthClip = val;
                this._nativeObj.isDepthClip = val;
              }

              get isMultisample() {
                return this._isMultisample;
              }

              set isMultisample(val) {
                this._isMultisample = val;
                this._nativeObj.isMultisample = val;
              }

              get lineWidth() {
                return this._lineWidth;
              }

              set lineWidth(val) {
                this._lineWidth = val;
                this._nativeObj.lineWidth = val;
              }

              reset() {
                this.assignProperties(false, PolygonMode.FILL, ShadeModel.GOURAND, CullMode.BACK, true, false, 0, 0.0, 0.0, true, false, 1.0);
              }

              assign(rs) {
                if (!rs) return;
                this.assignProperties(rs.isDiscard, rs.polygonMode, rs.shadeModel, rs.cullMode, rs.isFrontFaceCCW, rs.depthBiasEnabled, rs.depthBias, rs.depthBiasClamp, rs.depthBiasSlop, rs.isDepthClip, rs.isMultisample, rs.lineWidth);
              }

              destroy() {
                this._nativeObj = null;
              }

              assignProperties(isDiscard, polygonMode, shadeModel, cullMode, isFrontFaceCCW, depthBiasEnabled, depthBias, depthBiasClamp, depthBiasSlop, isDepthClip, isMultisample, lineWidth) {
                if (isDiscard !== undefined) this.isDiscard = isDiscard;
                if (polygonMode !== undefined) this.polygonMode = polygonMode;
                if (shadeModel !== undefined) this.shadeModel = shadeModel;
                if (cullMode !== undefined) this.cullMode = cullMode;
                if (isFrontFaceCCW !== undefined) this.isFrontFaceCCW = isFrontFaceCCW;
                if (depthBiasEnabled !== undefined) this.depthBiasEnabled = depthBiasEnabled;
                if (depthBias !== undefined) this.depthBias = depthBias;
                if (depthBiasClamp !== undefined) this.depthBiasClamp = depthBiasClamp;
                if (depthBiasSlop !== undefined) this.depthBiasSlop = depthBiasSlop;
                if (isDepthClip !== undefined) this.isDepthClip = isDepthClip;
                if (isMultisample !== undefined) this.isMultisample = isMultisample;
                if (lineWidth !== undefined) this.lineWidth = lineWidth;
              }

            }
            class DepthStencilState {
              constructor(depthTest = true, depthWrite = true, depthFunc = ComparisonFunc.LESS, stencilTestFront = false, stencilFuncFront = ComparisonFunc.ALWAYS, stencilReadMaskFront = 0xffff, stencilWriteMaskFront = 0xffff, stencilFailOpFront = StencilOp.KEEP, stencilZFailOpFront = StencilOp.KEEP, stencilPassOpFront = StencilOp.KEEP, stencilRefFront = 1, stencilTestBack = false, stencilFuncBack = ComparisonFunc.ALWAYS, stencilReadMaskBack = 0xffff, stencilWriteMaskBack = 0xffff, stencilFailOpBack = StencilOp.KEEP, stencilZFailOpBack = StencilOp.KEEP, stencilPassOpBack = StencilOp.KEEP, stencilRefBack = 1) {
                this._nativeObj = void 0;
                this._depthTest = true;
                this._depthWrite = true;
                this._depthFunc = ComparisonFunc.LESS;
                this._stencilTestFront = false;
                this._stencilFuncFront = ComparisonFunc.ALWAYS;
                this._stencilReadMaskFront = 0xffff;
                this._stencilWriteMaskFront = 0xffff;
                this._stencilFailOpFront = StencilOp.KEEP;
                this._stencilZFailOpFront = StencilOp.KEEP;
                this._stencilPassOpFront = StencilOp.KEEP;
                this._stencilRefFront = 1;
                this._stencilTestBack = false;
                this._stencilFuncBack = ComparisonFunc.ALWAYS;
                this._stencilReadMaskBack = 0xffff;
                this._stencilWriteMaskBack = 0xffff;
                this._stencilFailOpBack = StencilOp.KEEP;
                this._stencilZFailOpBack = StencilOp.KEEP;
                this._stencilPassOpBack = StencilOp.KEEP;
                this._stencilRefBack = 1;
                this._nativeObj = new gfx.DepthStencilState();
                this.assignProperties(depthTest, depthWrite, depthFunc, stencilTestFront, stencilFuncFront, stencilReadMaskFront, stencilWriteMaskFront, stencilFailOpFront, stencilZFailOpFront, stencilPassOpFront, stencilRefFront, stencilTestBack, stencilFuncBack, stencilReadMaskBack, stencilWriteMaskBack, stencilFailOpBack, stencilZFailOpBack, stencilPassOpBack, stencilRefBack);
              }

              get native() {
                return this._nativeObj;
              }

              get depthTest() {
                return this._depthTest;
              }

              set depthTest(val) {
                this._depthTest = val;
                this._nativeObj.depthTest = val;
              }

              get depthWrite() {
                return this._depthWrite;
              }

              set depthWrite(val) {
                this._depthWrite = val;
                this._nativeObj.depthWrite = val;
              }

              get depthFunc() {
                return this._depthFunc;
              }

              set depthFunc(val) {
                this._depthFunc = val;
                this._nativeObj.depthFunc = val;
              }

              get stencilTestFront() {
                return this._stencilTestFront;
              }

              set stencilTestFront(val) {
                this._stencilTestFront = val;
                this._nativeObj.stencilTestFront = val;
              }

              get stencilFuncFront() {
                return this._stencilFuncFront;
              }

              set stencilFuncFront(val) {
                this._stencilFuncFront = val;
                this._nativeObj.stencilFuncFront = val;
              }

              get stencilReadMaskFront() {
                return this._stencilReadMaskFront;
              }

              set stencilReadMaskFront(val) {
                this._stencilReadMaskFront = val;
                this._nativeObj.stencilReadMaskFront = val;
              }

              get stencilWriteMaskFront() {
                return this._stencilWriteMaskFront;
              }

              set stencilWriteMaskFront(val) {
                this._stencilWriteMaskFront = val;
                this._nativeObj.stencilWriteMaskFront = val;
              }

              get stencilFailOpFront() {
                return this._stencilFailOpFront;
              }

              set stencilFailOpFront(val) {
                this._stencilFailOpFront = val;
                this._nativeObj.stencilFailOpFront = val;
              }

              get stencilZFailOpFront() {
                return this._stencilZFailOpFront;
              }

              set stencilZFailOpFront(val) {
                this._stencilZFailOpFront = val;
                this._nativeObj.stencilZFailOpFront = val;
              }

              get stencilPassOpFront() {
                return this._stencilPassOpFront;
              }

              set stencilPassOpFront(val) {
                this._stencilPassOpFront = val;
                this._nativeObj.stencilPassOpFront = val;
              }

              get stencilRefFront() {
                return this._stencilRefFront;
              }

              set stencilRefFront(val) {
                this._stencilRefFront = val;
                this._nativeObj.stencilRefFront = val;
              }

              get stencilTestBack() {
                return this._stencilTestBack;
              }

              set stencilTestBack(val) {
                this._stencilTestBack = val;
                this._nativeObj.stencilTestBack = val;
              }

              get stencilFuncBack() {
                return this._stencilFuncBack;
              }

              set stencilFuncBack(val) {
                this._stencilFuncBack = val;
                this._nativeObj.stencilFuncBack = val;
              }

              get stencilReadMaskBack() {
                return this._stencilReadMaskBack;
              }

              set stencilReadMaskBack(val) {
                this._stencilReadMaskBack = val;
                this._nativeObj.stencilReadMaskBack = val;
              }

              get stencilWriteMaskBack() {
                return this._stencilWriteMaskBack;
              }

              set stencilWriteMaskBack(val) {
                this._stencilWriteMaskBack = val;
                this._nativeObj.stencilWriteMaskBack = val;
              }

              get stencilFailOpBack() {
                return this._stencilFailOpBack;
              }

              set stencilFailOpBack(val) {
                this._stencilFailOpBack = val;
                this._nativeObj.stencilFailOpBack = val;
              }

              get stencilZFailOpBack() {
                return this._stencilZFailOpBack;
              }

              set stencilZFailOpBack(val) {
                this._stencilZFailOpBack = val;
                this._nativeObj.stencilZFailOpBack = val;
              }

              get stencilPassOpBack() {
                return this._stencilPassOpBack;
              }

              set stencilPassOpBack(val) {
                this._stencilPassOpBack = val;
                this._nativeObj.stencilPassOpBack = val;
              }

              get stencilRefBack() {
                return this._stencilRefBack;
              }

              set stencilRefBack(val) {
                this._stencilRefBack = val;
                this._nativeObj.stencilRefBack = val;
              }

              reset() {
                this.assignProperties(true, true, ComparisonFunc.LESS, false, ComparisonFunc.ALWAYS, 0xffff, 0xffff, StencilOp.KEEP, StencilOp.KEEP, StencilOp.KEEP, 1, false, ComparisonFunc.ALWAYS, 0xffff, 0xffff, StencilOp.KEEP, StencilOp.KEEP, StencilOp.KEEP, 1);
              }

              assign(dss) {
                if (!dss) return;
                this.assignProperties(dss.depthTest, dss.depthWrite, dss.depthFunc, dss.stencilTestFront, dss.stencilFuncFront, dss.stencilReadMaskFront, dss.stencilWriteMaskFront, dss.stencilFailOpFront, dss.stencilZFailOpFront, dss.stencilPassOpFront, dss.stencilRefFront, dss.stencilTestBack, dss.stencilFuncBack, dss.stencilReadMaskBack, dss.stencilWriteMaskBack, dss.stencilFailOpBack, dss.stencilZFailOpBack, dss.stencilPassOpBack, dss.stencilRefBack);
              }

              destroy() {
                this._nativeObj = null;
              }

              assignProperties(depthTest, depthWrite, depthFunc, stencilTestFront, stencilFuncFront, stencilReadMaskFront, stencilWriteMaskFront, stencilFailOpFront, stencilZFailOpFront, stencilPassOpFront, stencilRefFront, stencilTestBack, stencilFuncBack, stencilReadMaskBack, stencilWriteMaskBack, stencilFailOpBack, stencilZFailOpBack, stencilPassOpBack, stencilRefBack) {
                if (depthTest !== undefined) this.depthTest = depthTest;
                if (depthWrite !== undefined) this.depthWrite = depthWrite;
                if (depthFunc !== undefined) this.depthFunc = depthFunc;
                if (stencilTestFront !== undefined) this.stencilTestFront = stencilTestFront;
                if (stencilFuncFront !== undefined) this.stencilFuncFront = stencilFuncFront;
                if (stencilReadMaskFront !== undefined) this.stencilReadMaskFront = stencilReadMaskFront;
                if (stencilWriteMaskFront !== undefined) this.stencilWriteMaskFront = stencilWriteMaskFront;
                if (stencilFailOpFront !== undefined) this.stencilFailOpFront = stencilFailOpFront;
                if (stencilZFailOpFront !== undefined) this.stencilZFailOpFront = stencilZFailOpFront;
                if (stencilPassOpFront !== undefined) this.stencilPassOpFront = stencilPassOpFront;
                if (stencilRefFront !== undefined) this.stencilRefFront = stencilRefFront;
                if (stencilTestBack !== undefined) this.stencilTestBack = stencilTestBack;
                if (stencilFuncBack !== undefined) this.stencilFuncBack = stencilFuncBack;
                if (stencilReadMaskBack !== undefined) this.stencilReadMaskBack = stencilReadMaskBack;
                if (stencilWriteMaskBack !== undefined) this.stencilWriteMaskBack = stencilWriteMaskBack;
                if (stencilFailOpBack !== undefined) this.stencilFailOpBack = stencilFailOpBack;
                if (stencilZFailOpBack !== undefined) this.stencilZFailOpBack = stencilZFailOpBack;
                if (stencilPassOpBack !== undefined) this.stencilPassOpBack = stencilPassOpBack;
                if (stencilRefBack !== undefined) this.stencilRefBack = stencilRefBack;
              }

            }
            class BlendTarget {
              get native() {
                return this._nativeObj;
              }

              constructor(blend = false, blendSrc = BlendFactor.ONE, blendDst = BlendFactor.ZERO, blendEq = BlendOp.ADD, blendSrcAlpha = BlendFactor.ONE, blendDstAlpha = BlendFactor.ZERO, blendAlphaEq = BlendOp.ADD, blendColorMask = ColorMask.ALL) {
                this._nativeObj = void 0;
                this._blend = false;
                this._blendSrc = BlendFactor.ONE;
                this._blendDst = BlendFactor.ZERO;
                this._blendEq = BlendOp.ADD;
                this._blendSrcAlpha = BlendFactor.ONE;
                this._blendDstAlpha = BlendFactor.ZERO;
                this._blendAlphaEq = BlendOp.ADD;
                this._blendColorMask = ColorMask.ALL;
                this._nativeObj = new gfx.BlendTarget();
                this.assignProperties(blend, blendSrc, blendDst, blendEq, blendSrcAlpha, blendDstAlpha, blendAlphaEq, blendColorMask);
              }

              get blend() {
                return this._blend;
              }

              set blend(val) {
                this._blend = val;
                this._nativeObj.blend = val;
              }

              get blendSrc() {
                return this._blendSrc;
              }

              set blendSrc(val) {
                this._blendSrc = val;
                this._nativeObj.blendSrc = val;
              }

              get blendDst() {
                return this._blendDst;
              }

              set blendDst(val) {
                this._blendDst = val;
                this._nativeObj.blendDst = val;
              }

              get blendEq() {
                return this._blendEq;
              }

              set blendEq(val) {
                this._blendEq = val;
                this._nativeObj.blendEq = val;
              }

              get blendSrcAlpha() {
                return this._blendSrcAlpha;
              }

              set blendSrcAlpha(val) {
                this._blendSrcAlpha = val;
                this._nativeObj.blendSrcAlpha = val;
              }

              get blendDstAlpha() {
                return this._blendDstAlpha;
              }

              set blendDstAlpha(val) {
                this._blendDstAlpha = val;
                this._nativeObj.blendDstAlpha = val;
              }

              get blendAlphaEq() {
                return this._blendAlphaEq;
              }

              set blendAlphaEq(val) {
                this._blendAlphaEq = val;
                this._nativeObj.blendAlphaEq = val;
              }

              get blendColorMask() {
                return this._blendColorMask;
              }

              set blendColorMask(val) {
                this._blendColorMask = val;
                this._nativeObj.blendColorMask = val;
              }

              reset() {
                this.assignProperties(false, BlendFactor.ONE, BlendFactor.ZERO, BlendOp.ADD, BlendFactor.ONE, BlendFactor.ZERO, BlendOp.ADD, ColorMask.ALL);
              }

              destroy() {
                this._nativeObj = null;
              }

              assign(target) {
                if (!target) return;
                this.assignProperties(target.blend, target.blendSrc, target.blendDst, target.blendEq, target.blendSrcAlpha, target.blendDstAlpha, target.blendAlphaEq, target.blendColorMask);
              }

              assignProperties(blend, blendSrc, blendDst, blendEq, blendSrcAlpha, blendDstAlpha, blendAlphaEq, blendColorMask) {
                if (blend !== undefined) this.blend = blend;
                if (blendSrc !== undefined) this.blendSrc = blendSrc;
                if (blendDst !== undefined) this.blendDst = blendDst;
                if (blendEq !== undefined) this.blendEq = blendEq;
                if (blendSrcAlpha !== undefined) this.blendSrcAlpha = blendSrcAlpha;
                if (blendDstAlpha !== undefined) this.blendDstAlpha = blendDstAlpha;
                if (blendAlphaEq !== undefined) this.blendAlphaEq = blendAlphaEq;
                if (blendColorMask !== undefined) this.blendColorMask = blendColorMask;
              }

            }

            function watchArrayElementsField(self, list, eleField, cachedFieldName, callback) {
              for (let i = 0, l = list.length; i < l; i++) {
                let ele = list[i];
                let originField = ele[eleField][cachedFieldName] || ele[eleField];
                ele[eleField] = new Proxy(originField, {
                  get: (originTarget, key) => {
                    if (key === cachedFieldName) {
                      return originTarget;
                    }

                    return Reflect.get(originTarget, key);
                  },
                  set: (originTarget, prop, value) => {
                    Reflect.set(originTarget, prop, value);
                    callback(self, i, originTarget, prop, value);
                    return true;
                  }
                });
              }
            }

            class BlendState {
              _setTargets(targets) {
                this.targets = targets;
                const CACHED_FIELD_NAME = `$__nativeObj`;

                this._syncTargetsToNativeObj(CACHED_FIELD_NAME);

                watchArrayElementsField(this, this.targets, "_nativeObj", CACHED_FIELD_NAME, (self, _idx, _originTarget, _prop, _value) => {
                  self._syncTargetsToNativeObj(CACHED_FIELD_NAME);
                });
              }

              _syncTargetsToNativeObj(cachedFieldName) {
                const nativeTars = this.targets.map(target => {
                  return target.native[cachedFieldName] || target.native;
                });
                this._nativeObj.targets = nativeTars;
              }

              get native() {
                return this._nativeObj;
              }

              constructor(isA2C = false, isIndepend = false, blendColor = new Color$1(), targets = [new BlendTarget()]) {
                this.targets = void 0;
                this._blendColor = void 0;
                this._nativeObj = void 0;
                this._isA2C = false;
                this._isIndepend = false;
                this._nativeObj = new gfx.BlendState();

                this._setTargets(targets);

                this.blendColor = blendColor;
                this.isA2c = isA2C;
                this.isIndepend = isIndepend;
              }

              get isA2c() {
                return this._isA2C;
              }

              set isA2c(val) {
                this._isA2C = val;
                this._nativeObj.isA2C = val;
              }

              get isIndepend() {
                return this._isIndepend;
              }

              set isIndepend(val) {
                this._isIndepend = val;
                this._nativeObj.isIndepend = val;
              }

              get blendColor() {
                return this._blendColor;
              }

              set blendColor(color) {
                this._blendColor = color;
                this._nativeObj.blendColor = color;
              }

              setTarget(index, target) {
                let tg = this.targets[index];

                if (!tg) {
                  tg = this.targets[index] = new BlendTarget();
                }

                tg.assign(target);

                this._setTargets(this.targets);
              }

              reset() {
                this.isA2c = false;
                this.isIndepend = false;
                this.blendColor = new Color$1(0, 0, 0, 0);
                const targets = this.targets;

                for (let i = 1, len = targets.length; i < len; ++i) {
                  targets[i].destroy();
                }

                targets.length = 1;
                targets[0].reset();

                this._setTargets(targets);
              }

              destroy() {
                for (let i = 0, len = this.targets.length; i < len; ++i) {
                  this.targets[i].destroy();
                }

                this.targets = null;
                this._nativeObj = null;
              }

            }
            const PipelineState = gfx.PipelineState;
            const PipelineStateInfo = gfx.PipelineStateInfo;

            ccenum(Format);
            class Device {
              constructor() {
                this._canvas = null;
                this._canvas2D = null;
                this._gfxAPI = API.UNKNOWN;
                this._transform = SurfaceTransform.IDENTITY;
                this._deviceName = '';
                this._renderer = '';
                this._vendor = '';
                this._version = '';
                this._features = new Array(Feature.COUNT);
                this._queue = null;
                this._cmdBuff = null;
                this._devicePixelRatio = 1.0;
                this._width = 0;
                this._height = 0;
                this._colorFmt = Format.UNKNOWN;
                this._depthStencilFmt = Format.UNKNOWN;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
                this._memoryStatus = new MemoryStatus();
                this._caps = new DeviceCaps();
              }

              get canvas() {
                return this._canvas;
              }

              get canvas2D() {
                return this._canvas2D;
              }

              get gfxAPI() {
                return this._gfxAPI;
              }

              get queue() {
                return this._queue;
              }

              get commandBuffer() {
                return this._cmdBuff;
              }

              get devicePixelRatio() {
                return this._devicePixelRatio;
              }

              get width() {
                return this._width;
              }

              get height() {
                return this._height;
              }

              get renderer() {
                return this._renderer;
              }

              get vendor() {
                return this._vendor;
              }

              get colorFormat() {
                return this._colorFmt;
              }

              get depthStencilFormat() {
                return this._depthStencilFmt;
              }

              get numDrawCalls() {
                return this._numDrawCalls;
              }

              get numInstances() {
                return this._numInstances;
              }

              get numTris() {
                return this._numTris;
              }

              get memoryStatus() {
                return this._memoryStatus;
              }

              get capabilities() {
                return this._caps;
              }

              get surfaceTransform() {
                return this._transform;
              }

              hasFeature(feature) {
                return this._features[feature];
              }

            } exports('aQ', Device);

            const getUint8ForString = String.prototype.charCodeAt;

            function getUint8ForArray(idx) {
              return this[idx];
            }

            function murmurhash2_32_gc(input, seed) {
              let l = input.length;
              let h = seed ^ l;
              let i = 0;
              const getUint8 = typeof input === 'string' ? getUint8ForString : getUint8ForArray;

              while (l >= 4) {
                let k = getUint8.call(input, i) & 0xff | (getUint8.call(input, ++i) & 0xff) << 8 | (getUint8.call(input, ++i) & 0xff) << 16 | (getUint8.call(input, ++i) & 0xff) << 24;
                k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
                k ^= k >>> 24;
                k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
                h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
                l -= 4;
                ++i;
              }

              switch (l) {
                case 3:
                  h ^= (getUint8.call(input, i + 2) & 0xff) << 16;

                case 2:
                  h ^= (getUint8.call(input, i + 1) & 0xff) << 8;

                case 1:
                  h ^= getUint8.call(input, i) & 0xff;
                  h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
              }

              h ^= h >>> 13;
              h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
              h ^= h >>> 15;
              return h >>> 0;
            }

            class Shader extends Obj {
              get id() {
                return this._id;
              }

              get name() {
                return this._name;
              }

              get attributes() {
                return this._attributes;
              }

              get blocks() {
                return this._blocks;
              }

              get samplers() {
                return this._samplers;
              }

              constructor(device) {
                super(ObjectType.SHADER);
                this._device = void 0;
                this._id = void 0;
                this._name = '';
                this._stages = [];
                this._attributes = [];
                this._blocks = [];
                this._samplers = [];
                this._device = device;
                this._id = Shader._shaderIdGen++;
              }

            } exports('aR', Shader);
            Shader._shaderIdGen = 0;

            class Texture extends Obj {
              get type() {
                return this._type;
              }

              get usage() {
                return this._usage;
              }

              get format() {
                return this._format;
              }

              get width() {
                return this._width;
              }

              get height() {
                return this._height;
              }

              get depth() {
                return this._depth;
              }

              get layerCount() {
                return this._layerCount;
              }

              get levelCount() {
                return this._levelCount;
              }

              get samples() {
                return this._samples;
              }

              get flags() {
                return this._flags;
              }

              get size() {
                return this._size;
              }

              constructor(device) {
                super(ObjectType.TEXTURE);
                this._device = void 0;
                this._type = TextureType.TEX2D;
                this._usage = TextureUsageBit.NONE;
                this._format = Format.UNKNOWN;
                this._width = 0;
                this._height = 0;
                this._depth = 1;
                this._layerCount = 1;
                this._levelCount = 1;
                this._samples = SampleCount.X1;
                this._flags = TextureFlagBit.NONE;
                this._isPowerOf2 = false;
                this._size = 0;
                this._device = device;
              }

            } exports('aS', Texture);

            const customMappings = {
              Obj: 'GFXObject',
              DRAW_INFO_SIZE: 'GFX_DRAW_INFO_SIZE',
              DESCRIPTOR_BUFFER_TYPE: '',
              DESCRIPTOR_SAMPLER_TYPE: '',
              DESCRIPTOR_DYNAMIC_TYPE: '',
              getTypedArrayConstructor: ''
            };

            for (const api in legacyCC.gfx) {
              if (api === '__esModule') continue;
              let deprecated = customMappings[api];

              if (deprecated === '') {
                deprecated = api;
              } else if (deprecated === undefined) {
                deprecated = `GFX${api}`;
              }

              replaceProperty(legacyCC, 'cc', [{
                name: deprecated,
                newName: api,
                target: legacyCC.gfx,
                targetName: 'cc.gfx'
              }]);
            }

            const polyfillCC = Object.assign({}, defines);
            polyfillCC.Device = gfx.Device;
            polyfillCC.Buffer = gfx.Buffer;
            polyfillCC.Texture = gfx.Texture;
            polyfillCC.Sampler = gfx.Sampler;
            polyfillCC.Shader = gfx.Shader;
            polyfillCC.InputAssembler = gfx.InputAssembler;
            polyfillCC.RenderPass = gfx.RenderPass;
            polyfillCC.Framebuffer = gfx.Framebuffer;
            polyfillCC.DescriptorSet = gfx.DescriptorSet;
            polyfillCC.DescriptorSetLayout = gfx.DescriptorSetLayout;
            polyfillCC.PipelineLayout = gfx.PipelineLayout;
            polyfillCC.PipelineState = gfx.PipelineState;
            polyfillCC.CommandBuffer = gfx.CommandBuffer;
            polyfillCC.Queue = gfx.Queue;
            legacyCC.gfx = polyfillCC;
            const BlendTarget$1 = exports('aT', BlendTarget);
            const BlendState$1 = exports('aU', BlendState);
            const RasterizerState$1 = exports('aV', RasterizerState);
            const DepthStencilState$1 = exports('aW', DepthStencilState);
            const PipelineState$1 = exports('aX', PipelineState);
            const PipelineStateInfo$1 = exports('aY', PipelineStateInfo);
            polyfillCC.BlendTarget = BlendTarget;
            polyfillCC.BlendState = BlendState;
            polyfillCC.RasterizerState = RasterizerState;
            polyfillCC.DepthStencilState = DepthStencilState;
            polyfillCC.PipelineStateInfo = PipelineStateInfo;

            let ERaycastMode;

            (function (ERaycastMode) {
              ERaycastMode[ERaycastMode["ALL"] = 0] = "ALL";
              ERaycastMode[ERaycastMode["CLOSEST"] = 1] = "CLOSEST";
              ERaycastMode[ERaycastMode["ANY"] = 2] = "ANY";
            })(ERaycastMode || (ERaycastMode = {}));

            const rayPlane = function () {
              const pt = new Vec3(0, 0, 0);
              return function (ray, plane) {
                const denom = Vec3.dot(ray.d, plane.n);

                if (Math.abs(denom) < Number.EPSILON) {
                  return 0;
                }

                Vec3.multiplyScalar(pt, plane.n, plane.d);
                const t = Vec3.dot(Vec3.subtract(pt, pt, ray.o), plane.n) / denom;

                if (t < 0) {
                  return 0;
                }

                return t;
              };
            }();

            const rayTriangle = function () {
              const ab = new Vec3(0, 0, 0);
              const ac = new Vec3(0, 0, 0);
              const pvec = new Vec3(0, 0, 0);
              const tvec = new Vec3(0, 0, 0);
              const qvec = new Vec3(0, 0, 0);
              return function (ray, triangle, doubleSided) {
                Vec3.subtract(ab, triangle.b, triangle.a);
                Vec3.subtract(ac, triangle.c, triangle.a);
                Vec3.cross(pvec, ray.d, ac);
                const det = Vec3.dot(ab, pvec);

                if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) {
                  return 0;
                }

                const inv_det = 1 / det;
                Vec3.subtract(tvec, ray.o, triangle.a);
                const u = Vec3.dot(tvec, pvec) * inv_det;

                if (u < 0 || u > 1) {
                  return 0;
                }

                Vec3.cross(qvec, tvec, ab);
                const v = Vec3.dot(ray.d, qvec) * inv_det;

                if (v < 0 || u + v > 1) {
                  return 0;
                }

                const t = Vec3.dot(ac, qvec) * inv_det;
                return t < 0 ? 0 : t;
              };
            }();

            const raySphere = function () {
              const e = new Vec3(0, 0, 0);
              return function (ray, sphere) {
                const r = sphere.radius;
                const c = sphere.center;
                const o = ray.o;
                const d = ray.d;
                const rSq = r * r;
                Vec3.subtract(e, c, o);
                const eSq = e.lengthSqr();
                const aLength = Vec3.dot(e, d);
                const fSq = rSq - (eSq - aLength * aLength);

                if (fSq < 0) {
                  return 0;
                }

                const f = Math.sqrt(fSq);
                const t = eSq < rSq ? aLength + f : aLength - f;

                if (t < 0) {
                  return 0;
                }

                return t;
              };
            }();

            const rayAABB = function () {
              const min = new Vec3();
              const max = new Vec3();
              return function (ray, aabb) {
                Vec3.subtract(min, aabb.center, aabb.halfExtents);
                Vec3.add(max, aabb.center, aabb.halfExtents);
                return rayAABB2(ray, min, max);
              };
            }();

            function rayAABB2(ray, min, max) {
              const o = ray.o;
              const d = ray.d;
              const ix = 1 / d.x;
              const iy = 1 / d.y;
              const iz = 1 / d.z;
              const t1 = (min.x - o.x) * ix;
              const t2 = (max.x - o.x) * ix;
              const t3 = (min.y - o.y) * iy;
              const t4 = (max.y - o.y) * iy;
              const t5 = (min.z - o.z) * iz;
              const t6 = (max.z - o.z) * iz;
              const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
              const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

              if (tmax < 0 || tmin > tmax) {
                return 0;
              }

              return tmin > 0 ? tmin : tmax;
            }

            const rayOBB = function () {
              let center = new Vec3();
              let o = new Vec3();
              let d = new Vec3();
              const X = new Vec3();
              const Y = new Vec3();
              const Z = new Vec3();
              const p = new Vec3();
              const size = new Array(3);
              const f = new Array(3);
              const e = new Array(3);
              const t = new Array(6);
              return function (ray, obb) {
                size[0] = obb.halfExtents.x;
                size[1] = obb.halfExtents.y;
                size[2] = obb.halfExtents.z;
                center = obb.center;
                o = ray.o;
                d = ray.d;
                Vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
                Vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
                Vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
                Vec3.subtract(p, center, o);
                f[0] = Vec3.dot(X, d);
                f[1] = Vec3.dot(Y, d);
                f[2] = Vec3.dot(Z, d);
                e[0] = Vec3.dot(X, p);
                e[1] = Vec3.dot(Y, p);
                e[2] = Vec3.dot(Z, p);

                for (let i = 0; i < 3; ++i) {
                  if (f[i] === 0) {
                    if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) {
                      return 0;
                    }

                    f[i] = 0.0000001;
                  }

                  t[i * 2 + 0] = (e[i] + size[i]) / f[i];
                  t[i * 2 + 1] = (e[i] - size[i]) / f[i];
                }

                const tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5]));
                const tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));

                if (tmax < 0 || tmin > tmax) {
                  return 0;
                }

                return tmin > 0 ? tmin : tmax;
              };
            }();

            const rayCapsule = function () {
              const v3_0 = new Vec3();
              const v3_1 = new Vec3();
              const v3_2 = new Vec3();
              const v3_3 = new Vec3();
              const v3_4 = new Vec3();
              const v3_5 = new Vec3();
              const v3_6 = new Vec3();
              const sphere_0 = new Sphere();
              return function (ray, capsule) {
                const radiusSqr = capsule.radius * capsule.radius;
                const vRayNorm = Vec3.normalize(v3_0, ray.d);
                const A = capsule.ellipseCenter0;
                const B = capsule.ellipseCenter1;
                const BA = Vec3.subtract(v3_1, B, A);

                if (BA.equals(Vec3.ZERO)) {
                  sphere_0.radius = capsule.radius;
                  sphere_0.center.set(capsule.ellipseCenter0);
                  return intersect.raySphere(ray, sphere_0);
                }

                const O = ray.o;
                const OA = Vec3.subtract(v3_2, O, A);
                const VxBA = Vec3.cross(v3_3, vRayNorm, BA);
                const a = VxBA.lengthSqr();

                if (a === 0) {
                  sphere_0.radius = capsule.radius;
                  const BO = Vec3.subtract(v3_4, B, O);

                  if (OA.lengthSqr() < BO.lengthSqr()) {
                    sphere_0.center.set(capsule.ellipseCenter0);
                  } else {
                    sphere_0.center.set(capsule.ellipseCenter1);
                  }

                  return intersect.raySphere(ray, sphere_0);
                }

                const OAxBA = Vec3.cross(v3_4, OA, BA);
                const ab2 = BA.lengthSqr();
                const b = 2 * Vec3.dot(VxBA, OAxBA);
                const c = OAxBA.lengthSqr() - radiusSqr * ab2;
                const d = b * b - 4 * a * c;

                if (d < 0) {
                  return 0;
                }

                const t = (-b - Math.sqrt(d)) / (2 * a);

                if (t < 0) {
                  sphere_0.radius = capsule.radius;
                  const BO = Vec3.subtract(v3_5, B, O);

                  if (OA.lengthSqr() < BO.lengthSqr()) {
                    sphere_0.center.set(capsule.ellipseCenter0);
                  } else {
                    sphere_0.center.set(capsule.ellipseCenter1);
                  }

                  return intersect.raySphere(ray, sphere_0);
                } else {
                  const iPos = Vec3.scaleAndAdd(v3_5, ray.o, vRayNorm, t);
                  const iPosLen = Vec3.subtract(v3_6, iPos, A);
                  const tLimit = Vec3.dot(iPosLen, BA) / ab2;

                  if (tLimit >= 0 && tLimit <= 1) {
                    return t;
                  } else if (tLimit < 0) {
                    sphere_0.radius = capsule.radius;
                    sphere_0.center.set(capsule.ellipseCenter0);
                    return intersect.raySphere(ray, sphere_0);
                  } else if (tLimit > 1) {
                    sphere_0.radius = capsule.radius;
                    sphere_0.center.set(capsule.ellipseCenter1);
                    return intersect.raySphere(ray, sphere_0);
                  } else {
                    return 0;
                  }
                }
              };
            }();

            const raySubMesh = function () {
              const tri = Triangle.create();
              const deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              let minDis = 0;

              const fillResult = (m, d, i0, i1, i2, r) => {
                if (m === ERaycastMode.CLOSEST) {
                  if (minDis > d || minDis === 0) {
                    minDis = d;

                    if (r) {
                      if (r.length === 0) {
                        r.push({
                          distance: d,
                          vertexIndex0: i0 / 3,
                          vertexIndex1: i1 / 3,
                          vertexIndex2: i2 / 3
                        });
                      } else {
                        r[0].distance = d;
                        r[0].vertexIndex0 = i0 / 3;
                        r[0].vertexIndex1 = i1 / 3;
                        r[0].vertexIndex2 = i2 / 3;
                      }
                    }
                  }
                } else {
                  minDis = d;
                  if (r) r.push({
                    distance: d,
                    vertexIndex0: i0 / 3,
                    vertexIndex1: i1 / 3,
                    vertexIndex2: i2 / 3
                  });
                }
              };

              const narrowphase = (vb, ib, pm, ray, opt) => {
                if (pm === PrimitiveMode.TRIANGLE_LIST) {
                  const cnt = ib.length;

                  for (let j = 0; j < cnt; j += 3) {
                    const i0 = ib[j] * 3;
                    const i1 = ib[j + 1] * 3;
                    const i2 = ib[j + 2] * 3;
                    Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                    Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                    Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                    const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
                    if (dist === 0 || dist > opt.distance) continue;
                    fillResult(opt.mode, dist, i0, i1, i2, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return dist;
                  }
                } else if (pm === PrimitiveMode.TRIANGLE_STRIP) {
                  const cnt = ib.length - 2;
                  let rev = 0;

                  for (let j = 0; j < cnt; j += 1) {
                    const i0 = ib[j - rev] * 3;
                    const i1 = ib[j + rev + 1] * 3;
                    const i2 = ib[j + 2] * 3;
                    Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                    Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                    Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                    rev = ~rev;
                    const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
                    if (dist === 0 || dist > opt.distance) continue;
                    fillResult(opt.mode, dist, i0, i1, i2, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return dist;
                  }
                } else if (pm === PrimitiveMode.TRIANGLE_FAN) {
                  const cnt = ib.length - 1;
                  const i0 = ib[0] * 3;
                  Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);

                  for (let j = 1; j < cnt; j += 1) {
                    const i1 = ib[j] * 3;
                    const i2 = ib[j + 1] * 3;
                    Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                    Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                    const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
                    if (dist === 0 || dist > opt.distance) continue;
                    fillResult(opt.mode, dist, i0, i1, i2, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return dist;
                  }
                }

                return minDis;
              };

              return function (ray, submesh, options) {
                minDis = 0;
                if (submesh.geometricInfo.positions.length === 0) return minDis;
                const opt = options === undefined ? deOpt : options;
                const min = submesh.geometricInfo.boundingBox.min;
                const max = submesh.geometricInfo.boundingBox.max;

                if (rayAABB2(ray, min, max)) {
                  const pm = submesh.primitiveMode;
                  const {
                    positions: vb,
                    indices: ib
                  } = submesh.geometricInfo;
                  narrowphase(vb, ib, pm, ray, opt);
                }

                return minDis;
              };
            }();

            const rayMesh = function () {
              let minDis = 0;
              const deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              return function (ray, mesh, options) {
                minDis = 0;
                const opt = options === undefined ? deOpt : options;
                const length = mesh.renderingSubMeshes.length;
                const min = mesh.struct.minPosition;
                const max = mesh.struct.maxPosition;
                if (min && max && !rayAABB2(ray, min, max)) return minDis;

                for (let i = 0; i < length; i++) {
                  const sm = mesh.renderingSubMeshes[i];
                  const dis = raySubMesh(ray, sm, opt);

                  if (dis) {
                    if (opt.mode === ERaycastMode.CLOSEST) {
                      if (minDis === 0 || minDis > dis) {
                        minDis = dis;
                        if (opt.subIndices) opt.subIndices[0] = i;
                      }
                    } else {
                      minDis = dis;
                      if (opt.subIndices) opt.subIndices.push(i);

                      if (opt.mode === ERaycastMode.ANY) {
                        return dis;
                      }
                    }
                  }
                }

                if (minDis && opt.mode === ERaycastMode.CLOSEST) {
                  if (opt.result) {
                    opt.result[0].distance = minDis;
                    opt.result.length = 1;
                  }

                  if (opt.subIndices) opt.subIndices.length = 1;
                }

                return minDis;
              };
            }();

            const rayModel = function () {
              let minDis = 0;
              const deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              const modelRay = new Ray();
              const m4 = new Mat4();
              return function (r, model, options) {
                minDis = 0;
                const opt = options === undefined ? deOpt : options;
                const wb = model.worldBounds;
                if (wb && !rayAABB(r, wb)) return minDis;
                Ray.copy(modelRay, r);

                if (model.node) {
                  Mat4.invert(m4, model.node.getWorldMatrix(m4));
                  Vec3.transformMat4(modelRay.o, r.o, m4);
                  Vec3.transformMat4Normal(modelRay.d, r.d, m4);
                }

                const subModels = model.subModels;

                for (let i = 0; i < subModels.length; i++) {
                  const subMesh = subModels[i].subMesh;
                  const dis = raySubMesh(modelRay, subMesh, opt);

                  if (dis) {
                    if (opt.mode === ERaycastMode.CLOSEST) {
                      if (minDis === 0 || minDis > dis) {
                        minDis = dis;
                        if (opt.subIndices) opt.subIndices[0] = i;
                      }
                    } else {
                      minDis = dis;
                      if (opt.subIndices) opt.subIndices.push(i);

                      if (opt.mode === ERaycastMode.ANY) {
                        return dis;
                      }
                    }
                  }
                }

                if (minDis && opt.mode === ERaycastMode.CLOSEST) {
                  if (opt.result) {
                    opt.result[0].distance = minDis;
                    opt.result.length = 1;
                  }

                  if (opt.subIndices) opt.subIndices.length = 1;
                }

                return minDis;
              };
            }();

            const linePlane = function () {
              const ab = new Vec3(0, 0, 0);
              return function (line, plane) {
                Vec3.subtract(ab, line.e, line.s);
                const t = (plane.d - Vec3.dot(line.s, plane.n)) / Vec3.dot(ab, plane.n);

                if (t < 0 || t > 1) {
                  return 0;
                }

                return t;
              };
            }();

            const lineTriangle = function () {
              const ab = new Vec3(0, 0, 0);
              const ac = new Vec3(0, 0, 0);
              const qp = new Vec3(0, 0, 0);
              const ap = new Vec3(0, 0, 0);
              const n = new Vec3(0, 0, 0);
              const e = new Vec3(0, 0, 0);
              return function (line, triangle, outPt) {
                Vec3.subtract(ab, triangle.b, triangle.a);
                Vec3.subtract(ac, triangle.c, triangle.a);
                Vec3.subtract(qp, line.s, line.e);
                Vec3.cross(n, ab, ac);
                const det = Vec3.dot(qp, n);

                if (det <= 0.0) {
                  return 0;
                }

                Vec3.subtract(ap, line.s, triangle.a);
                const t = Vec3.dot(ap, n);

                if (t < 0 || t > det) {
                  return 0;
                }

                Vec3.cross(e, qp, ap);
                let v = Vec3.dot(ac, e);

                if (v < 0 || v > det) {
                  return 0;
                }

                let w = -Vec3.dot(ab, e);

                if (w < 0.0 || v + w > det) {
                  return 0;
                }

                if (outPt) {
                  const invDet = 1.0 / det;
                  v *= invDet;
                  w *= invDet;
                  const u = 1.0 - v - w;
                  Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
                }

                return 1;
              };
            }();

            const r_t = new Ray();

            function lineAABB(line, aabb) {
              r_t.o.set(line.s);
              Vec3.subtract(r_t.d, line.e, line.s);
              r_t.d.normalize();
              const min = rayAABB(r_t, aabb);
              const len = line.length();

              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }

            function lineOBB(line, obb) {
              r_t.o.set(line.s);
              Vec3.subtract(r_t.d, line.e, line.s);
              r_t.d.normalize();
              const min = rayOBB(r_t, obb);
              const len = line.length();

              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }

            function lineSphere(line, sphere) {
              r_t.o.set(line.s);
              Vec3.subtract(r_t.d, line.e, line.s);
              r_t.d.normalize();
              const min = raySphere(r_t, sphere);
              const len = line.length();

              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }

            const aabbWithAABB = function () {
              const aMin = new Vec3();
              const aMax = new Vec3();
              const bMin = new Vec3();
              const bMax = new Vec3();
              return function (aabb1, aabb2) {
                Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents);
                Vec3.add(aMax, aabb1.center, aabb1.halfExtents);
                Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents);
                Vec3.add(bMax, aabb2.center, aabb2.halfExtents);
                return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
              };
            }();

            function getAABBVertices(min, max, out) {
              Vec3.set(out[0], min.x, max.y, max.z);
              Vec3.set(out[1], min.x, max.y, min.z);
              Vec3.set(out[2], min.x, min.y, max.z);
              Vec3.set(out[3], min.x, min.y, min.z);
              Vec3.set(out[4], max.x, max.y, max.z);
              Vec3.set(out[5], max.x, max.y, min.z);
              Vec3.set(out[6], max.x, min.y, max.z);
              Vec3.set(out[7], max.x, min.y, min.z);
            }

            function getOBBVertices(c, e, a1, a2, a3, out) {
              Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z);
              Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z);
              Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z);
              Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z);
              Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z);
              Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z);
              Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z);
              Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
            }

            function getInterval(vertices, axis) {
              let min = Vec3.dot(axis, vertices[0]);
              let max = min;

              for (let i = 1; i < 8; ++i) {
                const projection = Vec3.dot(axis, vertices[i]);
                min = projection < min ? projection : min;
                max = projection > max ? projection : max;
              }

              return [min, max];
            }

            const aabbWithOBB = function () {
              const test = new Array(15);

              for (let i = 0; i < 15; i++) {
                test[i] = new Vec3(0, 0, 0);
              }

              const vertices = new Array(8);
              const vertices2 = new Array(8);

              for (let i = 0; i < 8; i++) {
                vertices[i] = new Vec3(0, 0, 0);
                vertices2[i] = new Vec3(0, 0, 0);
              }

              const min = new Vec3();
              const max = new Vec3();
              return function (aabb, obb) {
                Vec3.set(test[0], 1, 0, 0);
                Vec3.set(test[1], 0, 1, 0);
                Vec3.set(test[2], 0, 0, 1);
                Vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
                Vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
                Vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);

                for (let i = 0; i < 3; ++i) {
                  Vec3.cross(test[6 + i * 3 + 0], test[i], test[0]);
                  Vec3.cross(test[6 + i * 3 + 1], test[i], test[1]);
                  Vec3.cross(test[6 + i * 3 + 1], test[i], test[2]);
                }

                Vec3.subtract(min, aabb.center, aabb.halfExtents);
                Vec3.add(max, aabb.center, aabb.halfExtents);
                getAABBVertices(min, max, vertices);
                getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);

                for (let j = 0; j < 15; ++j) {
                  const a = getInterval(vertices, test[j]);
                  const b = getInterval(vertices2, test[j]);

                  if (b[0] > a[1] || a[0] > b[1]) {
                    return 0;
                  }
                }

                return 1;
              };
            }();

            const aabbPlane = function (aabb, plane) {
              const r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z);
              const dot = Vec3.dot(plane.n, aabb.center);

              if (dot + r < plane.d) {
                return -1;
              } else if (dot - r > plane.d) {
                return 0;
              }

              return 1;
            };

            const aabbFrustum = function (aabb, frustum) {
              for (let i = 0; i < frustum.planes.length; i++) {
                if (aabbPlane(aabb, frustum.planes[i]) === -1) {
                  return 0;
                }
              }

              return 1;
            };

            const aabbFrustumAccurate = function () {
              const tmp = new Array(8);
              let out1 = 0;
              let out2 = 0;

              for (let i = 0; i < tmp.length; i++) {
                tmp[i] = new Vec3(0, 0, 0);
              }

              return function (aabb, frustum) {
                let result = 0;
                let intersects = false;

                for (let i = 0; i < frustum.planes.length; i++) {
                  result = aabbPlane(aabb, frustum.planes[i]);
                  if (result === -1) return 0;else if (result === 1) {
                      intersects = true;
                    }
                }

                if (!intersects) {
                  return 1;
                }

                for (let i = 0; i < frustum.vertices.length; i++) {
                  Vec3.subtract(tmp[i], frustum.vertices[i], aabb.center);
                }

                out1 = 0, out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  if (tmp[i].x > aabb.halfExtents.x) {
                    out1++;
                  } else if (tmp[i].x < -aabb.halfExtents.x) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  if (tmp[i].y > aabb.halfExtents.y) {
                    out1++;
                  } else if (tmp[i].y < -aabb.halfExtents.y) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  if (tmp[i].z > aabb.halfExtents.z) {
                    out1++;
                  } else if (tmp[i].z < -aabb.halfExtents.z) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                return 1;
              };
            }();

            const obbPoint = function () {
              const tmp = new Vec3(0, 0, 0);
              const m3 = new Mat3();

              const lessThan = function (a, b) {
                return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
              };

              return function (obb, point) {
                Vec3.subtract(tmp, point, obb.center);
                Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation));
                return lessThan(tmp, obb.halfExtents);
              };
            }();

            const obbPlane = function () {
              const absDot = function (n, x, y, z) {
                return Math.abs(n.x * x + n.y * y + n.z * z);
              };

              return function (obb, plane) {
                const r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
                const dot = Vec3.dot(plane.n, obb.center);

                if (dot + r < plane.d) {
                  return -1;
                } else if (dot - r > plane.d) {
                  return 0;
                }

                return 1;
              };
            }();

            const obbFrustum = function (obb, frustum) {
              for (let i = 0; i < frustum.planes.length; i++) {
                if (obbPlane(obb, frustum.planes[i]) === -1) {
                  return 0;
                }
              }

              return 1;
            };

            const obbFrustumAccurate = function () {
              const tmp = new Array(8);
              let dist = 0;
              let out1 = 0;
              let out2 = 0;

              for (let i = 0; i < tmp.length; i++) {
                tmp[i] = new Vec3(0, 0, 0);
              }

              const dot = function (n, x, y, z) {
                return n.x * x + n.y * y + n.z * z;
              };

              return function (obb, frustum) {
                let result = 0;
                let intersects = false;

                for (let i = 0; i < frustum.planes.length; i++) {
                  result = obbPlane(obb, frustum.planes[i]);
                  if (result === -1) return 0;else if (result === 1) {
                      intersects = true;
                    }
                }

                if (!intersects) {
                  return 1;
                }

                for (let i = 0; i < frustum.vertices.length; i++) {
                  Vec3.subtract(tmp[i], frustum.vertices[i], obb.center);
                }

                out1 = 0, out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  dist = dot(tmp[i], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);

                  if (dist > obb.halfExtents.x) {
                    out1++;
                  } else if (dist < -obb.halfExtents.x) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  dist = dot(tmp[i], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);

                  if (dist > obb.halfExtents.y) {
                    out1++;
                  } else if (dist < -obb.halfExtents.y) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  dist = dot(tmp[i], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);

                  if (dist > obb.halfExtents.z) {
                    out1++;
                  } else if (dist < -obb.halfExtents.z) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                return 1;
              };
            }();

            const obbWithOBB = function () {
              const test = new Array(15);

              for (let i = 0; i < 15; i++) {
                test[i] = new Vec3(0, 0, 0);
              }

              const vertices = new Array(8);
              const vertices2 = new Array(8);

              for (let i = 0; i < 8; i++) {
                vertices[i] = new Vec3(0, 0, 0);
                vertices2[i] = new Vec3(0, 0, 0);
              }

              return function (obb1, obb2) {
                Vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02);
                Vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05);
                Vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08);
                Vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02);
                Vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05);
                Vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);

                for (let i = 0; i < 3; ++i) {
                  Vec3.cross(test[6 + i * 3 + 0], test[i], test[3]);
                  Vec3.cross(test[6 + i * 3 + 1], test[i], test[4]);
                  Vec3.cross(test[6 + i * 3 + 2], test[i], test[5]);
                }

                getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices);
                getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);

                for (let i = 0; i < 15; ++i) {
                  const a = getInterval(vertices, test[i]);
                  const b = getInterval(vertices2, test[i]);

                  if (b[0] > a[1] || a[0] > b[1]) {
                    return 0;
                  }
                }

                return 1;
              };
            }();

            const obbCapsule = function () {
              const sphere_0 = new Sphere();
              const v3_0 = new Vec3();
              const v3_1 = new Vec3();
              const v3_2 = new Vec3();
              const v3_verts8 = new Array(8);

              for (let i = 0; i < 8; i++) {
                v3_verts8[i] = new Vec3();
              }

              const v3_axis8 = new Array(8);

              for (let i = 0; i < 8; i++) {
                v3_axis8[i] = new Vec3();
              }

              return function (obb, capsule) {
                const h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);

                if (h === 0) {
                  sphere_0.radius = capsule.radius;
                  sphere_0.center.set(capsule.ellipseCenter0);
                  return intersect.sphereOBB(sphere_0, obb);
                } else {
                  v3_0.x = obb.orientation.m00;
                  v3_0.y = obb.orientation.m01;
                  v3_0.z = obb.orientation.m02;
                  v3_1.x = obb.orientation.m03;
                  v3_1.y = obb.orientation.m04;
                  v3_1.z = obb.orientation.m05;
                  v3_2.x = obb.orientation.m06;
                  v3_2.y = obb.orientation.m07;
                  v3_2.z = obb.orientation.m08;
                  getOBBVertices(obb.center, obb.halfExtents, v3_0, v3_1, v3_2, v3_verts8);
                  const axes = v3_axis8;
                  const a0 = Vec3.copy(axes[0], v3_0);
                  const a1 = Vec3.copy(axes[1], v3_1);
                  const a2 = Vec3.copy(axes[2], v3_2);
                  const C = Vec3.subtract(axes[3], capsule.center, obb.center);
                  C.normalize();
                  const B = Vec3.subtract(axes[4], capsule.ellipseCenter0, capsule.ellipseCenter1);
                  B.normalize();
                  Vec3.cross(axes[5], a0, B);
                  Vec3.cross(axes[6], a1, B);
                  Vec3.cross(axes[7], a2, B);

                  for (let i = 0; i < 8; ++i) {
                    const a = getInterval(v3_verts8, axes[i]);
                    const d0 = Vec3.dot(axes[i], capsule.ellipseCenter0);
                    const d1 = Vec3.dot(axes[i], capsule.ellipseCenter1);
                    const max_d = Math.max(d0, d1);
                    const min_d = Math.min(d0, d1);
                    const d_min = min_d - capsule.radius;
                    const d_max = max_d + capsule.radius;

                    if (d_min > a[1] || a[0] > d_max) {
                      return 0;
                    }
                  }

                  return 1;
                }
              };
            }();

            const spherePlane = function (sphere, plane) {
              const dot = Vec3.dot(plane.n, sphere.center);
              const r = sphere.radius * plane.n.length();

              if (dot + r < plane.d) {
                return -1;
              } else if (dot - r > plane.d) {
                return 0;
              }

              return 1;
            };

            const sphereFrustum = function (sphere, frustum) {
              for (let i = 0; i < frustum.planes.length; i++) {
                if (spherePlane(sphere, frustum.planes[i]) === -1) {
                  return 0;
                }
              }

              return 1;
            };

            const sphereFrustumAccurate = function () {
              const pt = new Vec3(0, 0, 0);
              const map = [1, -1, 1, -1, 1, -1];
              return function (sphere, frustum) {
                for (let i = 0; i < 6; i++) {
                  const plane = frustum.planes[i];
                  const r = sphere.radius;
                  const c = sphere.center;
                  const n = plane.n;
                  const d = plane.d;
                  const dot = Vec3.dot(n, c);
                  if (dot + r < d) return 0;else if (dot - r > d) {
                      continue;
                    }
                  Vec3.add(pt, c, Vec3.multiplyScalar(pt, n, r));

                  for (let j = 0; j < 6; j++) {
                    if (j === i || j === i + map[i]) {
                      continue;
                    }

                    const test = frustum.planes[j];

                    if (Vec3.dot(test.n, pt) < test.d) {
                      return 0;
                    }
                  }
                }

                return 1;
              };
            }();

            const sphereWithSphere = function (sphere0, sphere1) {
              const r = sphere0.radius + sphere1.radius;
              return Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
            };

            const sphereAABB = function () {
              const pt = new Vec3();
              return function (sphere, aabb) {
                pt_point_aabb(pt, sphere.center, aabb);
                return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
              };
            }();

            const sphereOBB = function () {
              const pt = new Vec3();
              return function (sphere, obb) {
                pt_point_obb(pt, sphere.center, obb);
                return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
              };
            }();

            const sphereCapsule = function () {
              const v3_0 = new Vec3();
              const v3_1 = new Vec3();
              return function (sphere, capsule) {
                const r = sphere.radius + capsule.radius;
                const squaredR = r * r;
                const h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);

                if (h === 0) {
                  return Vec3.squaredDistance(sphere.center, capsule.center) < squaredR;
                } else {
                  Vec3.subtract(v3_0, sphere.center, capsule.ellipseCenter0);
                  Vec3.subtract(v3_1, capsule.ellipseCenter1, capsule.ellipseCenter0);
                  const t = Vec3.dot(v3_0, v3_1) / h;

                  if (t < 0) {
                    return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter0) < squaredR;
                  } else if (t > 1) {
                    return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter1) < squaredR;
                  } else {
                    Vec3.scaleAndAdd(v3_0, capsule.ellipseCenter0, v3_1, t);
                    return Vec3.squaredDistance(sphere.center, v3_0) < squaredR;
                  }
                }
              };
            }();

            const capsuleWithCapsule = function () {
              const v3_0 = new Vec3();
              const v3_1 = new Vec3();
              const v3_2 = new Vec3();
              const v3_3 = new Vec3();
              const v3_4 = new Vec3();
              const v3_5 = new Vec3();
              return function capsuleWithCapsule(capsuleA, capsuleB) {
                const u = Vec3.subtract(v3_0, capsuleA.ellipseCenter1, capsuleA.ellipseCenter0);
                const v = Vec3.subtract(v3_1, capsuleB.ellipseCenter1, capsuleB.ellipseCenter0);
                const w = Vec3.subtract(v3_2, capsuleA.ellipseCenter0, capsuleB.ellipseCenter0);
                const a = Vec3.dot(u, u);
                const b = Vec3.dot(u, v);
                const c = Vec3.dot(v, v);
                const d = Vec3.dot(u, w);
                const e = Vec3.dot(v, w);
                const D = a * c - b * b;
                let sN;
                let sD = D;
                let tN;
                let tD = D;

                if (D < EPSILON) {
                  sN = 0.0;
                  sD = 1.0;
                  tN = e;
                  tD = c;
                } else {
                  sN = b * e - c * d;
                  tN = a * e - b * d;

                  if (sN < 0.0) {
                    sN = 0.0;
                    tN = e;
                    tD = c;
                  } else if (sN > sD) {
                    sN = sD;
                    tN = e + b;
                    tD = c;
                  }
                }

                if (tN < 0.0) {
                  tN = 0.0;

                  if (-d < 0.0) {
                    sN = 0.0;
                  } else if (-d > a) {
                    sN = sD;
                  } else {
                    sN = -d;
                    sD = a;
                  }
                } else if (tN > tD) {
                  tN = tD;

                  if (-d + b < 0.0) {
                    sN = 0;
                  } else if (-d + b > a) {
                    sN = sD;
                  } else {
                    sN = -d + b;
                    sD = a;
                  }
                }

                const sc = Math.abs(sN) < EPSILON ? 0.0 : sN / sD;
                const tc = Math.abs(tN) < EPSILON ? 0.0 : tN / tD;
                const dP = v3_3;
                dP.set(w);
                dP.add(Vec3.multiplyScalar(v3_4, u, sc));
                dP.subtract(Vec3.multiplyScalar(v3_5, v, tc));
                const radius = capsuleA.radius + capsuleB.radius;
                return dP.lengthSqr() < radius * radius;
              };
            }();

            const intersect = {
              raySphere,
              rayAABB,
              rayOBB,
              rayPlane,
              rayTriangle,
              rayCapsule,
              raySubMesh,
              rayMesh,
              rayModel,
              lineSphere,
              lineAABB,
              lineOBB,
              linePlane,
              lineTriangle,
              sphereWithSphere,
              sphereAABB,
              sphereOBB,
              spherePlane,
              sphereFrustum,
              sphereFrustumAccurate,
              sphereCapsule,
              aabbWithAABB,
              aabbWithOBB,
              aabbPlane,
              aabbFrustum,
              aabbFrustumAccurate,
              obbWithOBB,
              obbPlane,
              obbFrustum,
              obbFrustumAccurate,
              obbPoint,
              obbCapsule,
              capsuleWithCapsule,

              resolve(g1, g2, outPt = null) {
                const type1 = g1._type;
                const type2 = g2._type;
                const resolver = this[type1 | type2];
                return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
              }

            };
            intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = raySphere;
            intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = rayAABB;
            intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = rayOBB;
            intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = rayPlane;
            intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = rayTriangle;
            intersect[enums.SHAPE_RAY | enums.SHAPE_CAPSULE] = rayCapsule;
            intersect[enums.SHAPE_LINE | enums.SHAPE_SPHERE] = lineSphere;
            intersect[enums.SHAPE_LINE | enums.SHAPE_AABB] = lineAABB;
            intersect[enums.SHAPE_LINE | enums.SHAPE_OBB] = lineOBB;
            intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = linePlane;
            intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = lineTriangle;
            intersect[enums.SHAPE_SPHERE] = sphereWithSphere;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphereAABB;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphereOBB;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = spherePlane;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphereFrustum;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphereFrustumAccurate;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_CAPSULE] = sphereCapsule;
            intersect[enums.SHAPE_AABB] = aabbWithAABB;
            intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabbWithOBB;
            intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabbPlane;
            intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabbFrustum;
            intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabbFrustumAccurate;
            intersect[enums.SHAPE_OBB] = obbWithOBB;
            intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obbPlane;
            intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obbFrustum;
            intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obbFrustumAccurate;
            intersect[enums.SHAPE_OBB | enums.SHAPE_CAPSULE] = obbCapsule;
            intersect[enums.SHAPE_CAPSULE] = capsuleWithCapsule;

            replaceProperty(Line.prototype, 'line', [{
              name: 'mag',
              newName: 'len'
            }, {
              name: 'magnitude',
              newName: 'len'
            }]);
            removeProperty(intersect, 'intersect', [{
              name: 'line_quad'
            }]);

            const v1 = new Vec3(0, 0, 0);
            const v2$1 = new Vec3(0, 0, 0);
            const temp_mat = legacyCC.mat4();
            const temp_vec4 = legacyCC.v4();
            class Plane {
              static create(nx, ny, nz, d) {
                return new Plane(nx, ny, nz, d);
              }

              static clone(p) {
                return new Plane(p.n.x, p.n.y, p.n.z, p.d);
              }

              static copy(out, p) {
                Vec3.copy(out.n, p.n);
                out.d = p.d;
                return out;
              }

              static fromPoints(out, a, b, c) {
                Vec3.subtract(v1, b, a);
                Vec3.subtract(v2$1, c, a);
                Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2$1));
                out.d = Vec3.dot(out.n, a);
                return out;
              }

              static set(out, nx, ny, nz, d) {
                out.n.x = nx;
                out.n.y = ny;
                out.n.z = nz;
                out.d = d;
                return out;
              }

              static fromNormalAndPoint(out, normal, point) {
                Vec3.copy(out.n, normal);
                out.d = Vec3.dot(normal, point);
                return out;
              }

              static normalize(out, a) {
                const len = a.n.length();
                Vec3.normalize(out.n, a.n);

                if (len > 0) {
                  out.d = a.d / len;
                }

                return out;
              }

              get type() {
                return this._type;
              }

              set x(val) {
                this.n.x = val;
              }

              get x() {
                return this.n.x;
              }

              set y(val) {
                this.n.y = val;
              }

              get y() {
                return this.n.y;
              }

              set z(val) {
                this.n.z = val;
              }

              get z() {
                return this.n.z;
              }

              set w(val) {
                this.d = val;
              }

              get w() {
                return this.d;
              }

              constructor(nx = 0, ny = 1, nz = 0, d = 0) {
                this.n = void 0;
                this.d = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_PLANE;
                this.n = new Vec3(nx, ny, nz);
                this.d = d;
              }

              transform(mat) {
                Mat4.invert(temp_mat, mat);
                Mat4.transpose(temp_mat, temp_mat);
                Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, this.d);
                Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat);
                Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z);
                this.d = temp_vec4.w;
              }

            }

            const NativeBufferPool = jsb.NativeBufferPool;
            const NativeObjectPool = jsb.NativeObjectPool;
            const NativeBufferAllocator = jsb.NativeBufferAllocator;

            const contains$2 = (a, t) => {
              for (let i = 0; i < a.length; ++i) {
                if (a[i] === t) return true;
              }

              return false;
            };

            var BufferDataType;

            (function (BufferDataType) {
              BufferDataType[BufferDataType["UINT32"] = 0] = "UINT32";
              BufferDataType[BufferDataType["FLOAT32"] = 1] = "FLOAT32";
              BufferDataType[BufferDataType["NEVER"] = 2] = "NEVER";
            })(BufferDataType || (BufferDataType = {}));

            class BufferPool {
              constructor(poolType, dataType, dataMembers, enumType, entryBits = 8) {
                this._dataType = void 0;
                this._dataMembers = void 0;
                this._elementCount = void 0;
                this._entryBits = void 0;
                this._stride = void 0;
                this._entriesPerChunk = void 0;
                this._entryMask = void 0;
                this._chunkMask = void 0;
                this._poolFlag = void 0;
                this._arrayBuffers = [];
                this._freeLists = [];
                this._uint32BufferViews = [];
                this._float32BufferViews = [];
                this._hasUint32 = false;
                this._hasFloat32 = false;
                this._nativePool = void 0;
                this._elementCount = enumType.COUNT;
                this._entryBits = entryBits;
                this._dataType = dataType;
                this._dataMembers = dataMembers;
                const bytesPerElement = 4;
                this._stride = bytesPerElement * this._elementCount;
                this._entriesPerChunk = 1 << entryBits;
                this._entryMask = this._entriesPerChunk - 1;
                this._poolFlag = 1 << 30;
                this._chunkMask = ~(this._entryMask | this._poolFlag);
                this._nativePool = new NativeBufferPool(poolType, entryBits, this._stride);
                let type = BufferDataType.NEVER;
                let hasFloat32 = false;
                let hasUint32 = false;

                for (const e in dataType) {
                  hasFloat32 = this._hasFloat32;
                  hasUint32 = this._hasUint32;

                  if (hasUint32 && hasFloat32) {
                    break;
                  }

                  type = dataType[e];

                  if (!hasFloat32 && type === BufferDataType.FLOAT32) {
                    this._hasFloat32 = true;
                  } else if (!hasUint32 && type === BufferDataType.UINT32) {
                    this._hasUint32 = true;
                  }
                }
              }

              alloc() {
                let i = 0;

                for (; i < this._freeLists.length; i++) {
                  const list = this._freeLists[i];

                  if (list.length) {
                    const j = list[list.length - 1];
                    list.length--;
                    return (i << this._entryBits) + j + this._poolFlag;
                  }
                }

                const buffer = this._nativePool.allocateNewChunk();

                const float32BufferViews = [];
                const uint32BufferViews = [];
                const freeList = [];
                const hasFloat32 = this._hasFloat32;
                const hasUint32 = this._hasUint32;

                for (let j = 0; j < this._entriesPerChunk; j++) {
                  if (hasFloat32) {
                    float32BufferViews.push(new Float32Array(buffer, this._stride * j, this._elementCount));
                  }

                  if (hasUint32) {
                    uint32BufferViews.push(new Uint32Array(buffer, this._stride * j, this._elementCount));
                  }

                  if (j) {
                    freeList.push(j);
                  }
                }

                if (hasUint32) {
                  this._uint32BufferViews.push(uint32BufferViews);
                }

                if (hasFloat32) {
                  this._float32BufferViews.push(float32BufferViews);
                }

                this._freeLists.push(freeList);

                this._arrayBuffers.push(buffer);

                const handle = (i << this._entryBits) + this._poolFlag;
                return handle;
              }

              getBuffer(handle) {
                const chunk = (this._chunkMask & handle) >> this._entryBits;
                const entry = this._entryMask & handle;
                const bufferViews = this._hasFloat32 ? this._float32BufferViews : this._uint32BufferViews;

                if ( (!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains$2(this._freeLists[chunk], entry))) {
                  console.warn('invalid buffer pool handle');
                  return [];
                }

                return bufferViews[chunk][entry];
              }

              getTypedArray(handle, element) {
                const chunk = (this._chunkMask & handle) >> this._entryBits;
                const entry = this._entryMask & handle;
                const bufferViews = this._dataType[element] === BufferDataType.UINT32 ? this._uint32BufferViews : this._float32BufferViews;

                if ( (!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains$2(this._freeLists[chunk], entry))) {
                  console.warn('invalid buffer pool handle');
                  return [];
                }

                const index = element;
                const view = bufferViews[chunk][entry];
                const count = this._dataMembers[element];
                return view.subarray(index, index + count);
              }

              free(handle) {
                const chunk = (this._chunkMask & handle) >> this._entryBits;
                const entry = this._entryMask & handle;

                if ( (!handle || chunk < 0 || chunk >= this._freeLists.length || entry < 0 || entry >= this._entriesPerChunk || contains$2(this._freeLists[chunk], entry))) {
                  console.warn('invalid buffer pool handle');
                  return;
                }

                const bufferViews = this._hasUint32 ? this._uint32BufferViews : this._float32BufferViews;
                bufferViews[chunk][entry].fill(0);

                this._freeLists[chunk].push(entry);
              }

            }

            let PoolType;

            (function (PoolType) {
              PoolType[PoolType["NODE"] = 0] = "NODE";
              PoolType[PoolType["PASS"] = 1] = "PASS";
              PoolType[PoolType["AABB"] = 2] = "AABB";
            })(PoolType || (PoolType = {}));

            const NULL_HANDLE = 0;
            let NodeView;

            (function (NodeView) {
              NodeView[NodeView["DIRTY_FLAG"] = 0] = "DIRTY_FLAG";
              NodeView[NodeView["LAYER"] = 1] = "LAYER";
              NodeView[NodeView["WORLD_SCALE"] = 2] = "WORLD_SCALE";
              NodeView[NodeView["WORLD_POSITION"] = 5] = "WORLD_POSITION";
              NodeView[NodeView["WORLD_ROTATION"] = 8] = "WORLD_ROTATION";
              NodeView[NodeView["WORLD_MATRIX"] = 12] = "WORLD_MATRIX";
              NodeView[NodeView["LOCAL_SCALE"] = 28] = "LOCAL_SCALE";
              NodeView[NodeView["LOCAL_POSITION"] = 31] = "LOCAL_POSITION";
              NodeView[NodeView["LOCAL_ROTATION"] = 34] = "LOCAL_ROTATION";
              NodeView[NodeView["COUNT"] = 38] = "COUNT";
            })(NodeView || (NodeView = {}));

            const NodeViewDataType = {
              [NodeView.DIRTY_FLAG]: BufferDataType.UINT32,
              [NodeView.LAYER]: BufferDataType.UINT32,
              [NodeView.WORLD_SCALE]: BufferDataType.FLOAT32,
              [NodeView.WORLD_POSITION]: BufferDataType.FLOAT32,
              [NodeView.WORLD_ROTATION]: BufferDataType.FLOAT32,
              [NodeView.WORLD_MATRIX]: BufferDataType.FLOAT32,
              [NodeView.LOCAL_SCALE]: BufferDataType.FLOAT32,
              [NodeView.LOCAL_POSITION]: BufferDataType.FLOAT32,
              [NodeView.LOCAL_ROTATION]: BufferDataType.FLOAT32,
              [NodeView.COUNT]: BufferDataType.NEVER
            };
            const NodeViewDataMembers = {
              [NodeView.DIRTY_FLAG]: NodeView.LAYER - NodeView.DIRTY_FLAG,
              [NodeView.LAYER]: NodeView.WORLD_SCALE - NodeView.LAYER,
              [NodeView.WORLD_SCALE]: NodeView.WORLD_POSITION - NodeView.WORLD_SCALE,
              [NodeView.WORLD_POSITION]: NodeView.WORLD_ROTATION - NodeView.WORLD_POSITION,
              [NodeView.WORLD_ROTATION]: NodeView.WORLD_MATRIX - NodeView.WORLD_ROTATION,
              [NodeView.WORLD_MATRIX]: NodeView.LOCAL_SCALE - NodeView.WORLD_MATRIX,
              [NodeView.LOCAL_SCALE]: NodeView.LOCAL_POSITION - NodeView.LOCAL_SCALE,
              [NodeView.LOCAL_POSITION]: NodeView.LOCAL_ROTATION - NodeView.LOCAL_POSITION,
              [NodeView.LOCAL_ROTATION]: NodeView.COUNT - NodeView.LOCAL_ROTATION,
              [NodeView.COUNT]: 1
            };
            const NodePool = new BufferPool(PoolType.NODE, NodeViewDataType, NodeViewDataMembers, NodeView);
            let PassView;

            (function (PassView) {
              PassView[PassView["PRIORITY"] = 0] = "PRIORITY";
              PassView[PassView["STAGE"] = 1] = "STAGE";
              PassView[PassView["PHASE"] = 2] = "PHASE";
              PassView[PassView["PRIMITIVE"] = 3] = "PRIMITIVE";
              PassView[PassView["BATCHING_SCHEME"] = 4] = "BATCHING_SCHEME";
              PassView[PassView["DYNAMIC_STATE"] = 5] = "DYNAMIC_STATE";
              PassView[PassView["HASH"] = 6] = "HASH";
              PassView[PassView["COUNT"] = 7] = "COUNT";
            })(PassView || (PassView = {}));

            const PassViewDataType = {
              [PassView.PRIORITY]: BufferDataType.UINT32,
              [PassView.STAGE]: BufferDataType.UINT32,
              [PassView.PHASE]: BufferDataType.UINT32,
              [PassView.PRIMITIVE]: BufferDataType.UINT32,
              [PassView.BATCHING_SCHEME]: BufferDataType.UINT32,
              [PassView.DYNAMIC_STATE]: BufferDataType.UINT32,
              [PassView.HASH]: BufferDataType.UINT32,
              [PassView.COUNT]: BufferDataType.NEVER
            };
            const PassViewDataMembers = {
              [PassView.PRIORITY]: PassView.STAGE - PassView.PRIORITY,
              [PassView.STAGE]: PassView.PHASE - PassView.STAGE,
              [PassView.PHASE]: PassView.PRIMITIVE - PassView.PHASE,
              [PassView.PRIMITIVE]: PassView.BATCHING_SCHEME - PassView.PRIMITIVE,
              [PassView.BATCHING_SCHEME]: PassView.DYNAMIC_STATE - PassView.BATCHING_SCHEME,
              [PassView.DYNAMIC_STATE]: PassView.HASH - PassView.DYNAMIC_STATE,
              [PassView.HASH]: PassView.COUNT - PassView.HASH,
              [PassView.COUNT]: 1
            };
            const PassPool = new BufferPool(PoolType.PASS, PassViewDataType, PassViewDataMembers, PassView);
            let AABBView;

            (function (AABBView) {
              AABBView[AABBView["CENTER"] = 0] = "CENTER";
              AABBView[AABBView["HALFEXTENTS"] = 3] = "HALFEXTENTS";
              AABBView[AABBView["COUNT"] = 6] = "COUNT";
            })(AABBView || (AABBView = {}));

            const AABBViewDataType = {
              [AABBView.CENTER]: BufferDataType.FLOAT32,
              [AABBView.HALFEXTENTS]: BufferDataType.FLOAT32,
              [AABBView.COUNT]: BufferDataType.NEVER
            };
            const AABBViewDataMembers = {
              [AABBView.CENTER]: AABBView.HALFEXTENTS - AABBView.CENTER,
              [AABBView.HALFEXTENTS]: AABBView.COUNT - AABBView.HALFEXTENTS,
              [AABBView.COUNT]: 1
            };
            const AABBPool = new BufferPool(PoolType.AABB, AABBViewDataType, AABBViewDataMembers, AABBView);

            const _v3_tmp$1 = new Vec3();

            const _v3_tmp2 = new Vec3();

            const _v3_tmp3 = new Vec3();

            const _v3_tmp4 = new Vec3();

            const _m3_tmp = new Mat3();

            const transform_extent_m4 = (out, extent, m4) => {
              _m3_tmp.m00 = Math.abs(m4.m00);
              _m3_tmp.m01 = Math.abs(m4.m01);
              _m3_tmp.m02 = Math.abs(m4.m02);
              _m3_tmp.m03 = Math.abs(m4.m04);
              _m3_tmp.m04 = Math.abs(m4.m05);
              _m3_tmp.m05 = Math.abs(m4.m06);
              _m3_tmp.m06 = Math.abs(m4.m08);
              _m3_tmp.m07 = Math.abs(m4.m09);
              _m3_tmp.m08 = Math.abs(m4.m10);
              Vec3.transformMat3(out, extent, _m3_tmp);
            };

            class AABB {
              static create(px, py, pz, hw, hh, hl) {
                return new AABB(px, py, pz, hw, hh, hl);
              }

              static clone(a) {
                return new AABB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
              }

              static copy(out, a) {
                Vec3.copy(out.center, a.center);
                Vec3.copy(out.halfExtents, a.halfExtents);
                return out;
              }

              static fromPoints(out, minPos, maxPos) {
                Vec3.add(_v3_tmp$1, maxPos, minPos);
                Vec3.subtract(_v3_tmp2, maxPos, minPos);
                Vec3.multiplyScalar(out.center, _v3_tmp$1, 0.5);
                Vec3.multiplyScalar(out.halfExtents, _v3_tmp2, 0.5);
                return out;
              }

              static set(out, px, py, pz, hw, hh, hl) {
                out.center.set(px, py, pz);
                out.halfExtents.set(hw, hh, hl);
                return out;
              }

              static merge(out, a, b) {
                Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents);
                Vec3.subtract(_v3_tmp2, b.center, b.halfExtents);
                Vec3.add(_v3_tmp3, a.center, a.halfExtents);
                Vec3.add(_v3_tmp4, b.center, b.halfExtents);
                Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4);
                Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2);
                return AABB.fromPoints(out, _v3_tmp3, _v3_tmp4);
              }

              static toBoundingSphere(out, a) {
                a.getBoundary(_v3_tmp$1, _v3_tmp2);
                out.center.set(_v3_tmp$1);
                out.radius = 0.0;
                Vec3.subtract(_v3_tmp3, _v3_tmp2, out.center);

                const dist = _v3_tmp3.length();

                const half = dist * 0.5;
                out.radius += half;
                Vec3.multiplyScalar(_v3_tmp3, _v3_tmp3, half / dist);
                Vec3.add(out.center, out.center, _v3_tmp3);
                return out;
              }

              static transform(out, a, matrix) {
                Vec3.transformMat4(out.center, a.center, matrix);
                transform_extent_m4(out.halfExtents, a.halfExtents, matrix);
                return out;
              }

              get type() {
                return this._type;
              }

              constructor(px = 0, py = 0, pz = 0, hw = 1, hh = 1, hl = 1) {
                this.center = void 0;
                this.halfExtents = void 0;
                this._type = void 0;
                this._aabbHandle = NULL_HANDLE;
                this._type = enums.SHAPE_AABB;

                {
                  this._aabbHandle = AABBPool.alloc();
                  this.center = new Vec3(AABBPool.getTypedArray(this._aabbHandle, AABBView.CENTER));
                  this.halfExtents = new Vec3(AABBPool.getTypedArray(this._aabbHandle, AABBView.HALFEXTENTS));
                  this.center.set(px, py, pz);
                  this.halfExtents.set(hw, hh, hl);
                  this._nativeObj = new NativeAABB();

                  this._nativeObj.initWithData(AABBPool.getBuffer(this._aabbHandle));

                  return;
                }
              }

              get native() {
                return this._nativeObj;
              }

              getBoundary(minPos, maxPos) {
                Vec3.subtract(minPos, this.center, this.halfExtents);
                Vec3.add(maxPos, this.center, this.halfExtents);
              }

              transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m);
                transform_extent_m4(out.halfExtents, this.halfExtents, m);
              }

              clone() {
                return AABB.clone(this);
              }

              copy(a) {
                return AABB.copy(this, a);
              }

            } exports('bM', AABB);

            const _v3_tmp$2 = new Vec3();

            const _v3_tmp2$1 = new Vec3();

            const _m3_tmp$1 = new Mat3();

            const transform_extent_m3 = (out, extent, m3) => {
              _m3_tmp$1.m00 = Math.abs(m3.m00);
              _m3_tmp$1.m01 = Math.abs(m3.m01);
              _m3_tmp$1.m02 = Math.abs(m3.m02);
              _m3_tmp$1.m03 = Math.abs(m3.m03);
              _m3_tmp$1.m04 = Math.abs(m3.m04);
              _m3_tmp$1.m05 = Math.abs(m3.m05);
              _m3_tmp$1.m06 = Math.abs(m3.m06);
              _m3_tmp$1.m07 = Math.abs(m3.m07);
              _m3_tmp$1.m08 = Math.abs(m3.m08);
              Vec3.transformMat3(out, extent, _m3_tmp$1);
            };

            class OBB {
              static create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                return new OBB(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
              }

              static clone(a) {
                return new OBB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
              }

              static copy(out, a) {
                Vec3.copy(out.center, a.center);
                Vec3.copy(out.halfExtents, a.halfExtents);
                Mat3.copy(out.orientation, a.orientation);
                return out;
              }

              static fromPoints(out, minPos, maxPos) {
                Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), 0.5);
                Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2$1, maxPos, minPos), 0.5);
                Mat3.identity(out.orientation);
                return out;
              }

              static set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                Vec3.set(out.center, cx, cy, cz);
                Vec3.set(out.halfExtents, hw, hh, hl);
                Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
                return out;
              }

              get type() {
                return this._type;
              }

              constructor(cx = 0, cy = 0, cz = 0, hw = 1, hh = 1, hl = 1, ox_1 = 1, ox_2 = 0, ox_3 = 0, oy_1 = 0, oy_2 = 1, oy_3 = 0, oz_1 = 0, oz_2 = 0, oz_3 = 1) {
                this.center = void 0;
                this.halfExtents = void 0;
                this.orientation = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_OBB;
                this.center = new Vec3(cx, cy, cz);
                this.halfExtents = new Vec3(hw, hh, hl);
                this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
              }

              getBoundary(minPos, maxPos) {
                transform_extent_m3(_v3_tmp$2, this.halfExtents, this.orientation);
                Vec3.subtract(minPos, this.center, _v3_tmp$2);
                Vec3.add(maxPos, this.center, _v3_tmp$2);
              }

              transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m);
                Mat3.fromQuat(out.orientation, rot);
                Vec3.multiply(out.halfExtents, this.halfExtents, scale);
              }

              translateAndRotate(m, rot, out) {
                Vec3.transformMat4(out.center, this.center, m);
                Mat3.fromQuat(out.orientation, rot);
              }

              setScale(scale, out) {
                Vec3.multiply(out.halfExtents, this.halfExtents, scale);
              }

            }

            class Capsule {
              get type() {
                return this._type;
              }

              constructor(radius = 0.5, halfHeight = 0.5, axis = 1) {
                this._type = void 0;
                this.radius = void 0;
                this.halfHeight = void 0;
                this.axis = void 0;
                this.center = void 0;
                this.rotation = void 0;
                this.ellipseCenter0 = void 0;
                this.ellipseCenter1 = void 0;
                this._type = enums.SHAPE_CAPSULE;
                this.radius = radius;
                this.halfHeight = halfHeight;
                this.axis = axis;
                this.center = new Vec3();
                this.rotation = new Quat();
                this.ellipseCenter0 = new Vec3(0, halfHeight, 0);
                this.ellipseCenter1 = new Vec3(0, -halfHeight, 0);
                this.updateCache();
              }

              transform(m, pos, rot, scale, out) {
                const ws = scale;
                const s = absMaxComponent(ws);
                out.radius = this.radius * Math.abs(s);
                const halfTotalWorldHeight = (this.halfHeight + this.radius) * Math.abs(ws.y);
                let halfWorldHeight = halfTotalWorldHeight - out.radius;
                if (halfWorldHeight < 0) halfWorldHeight = 0;
                out.halfHeight = halfWorldHeight;
                Vec3.transformMat4(out.center, this.center, m);
                Quat.multiply(out.rotation, this.rotation, rot);
                out.updateCache();
              }

              updateCache() {
                this.updateLocalCenter();
                Vec3.transformQuat(this.ellipseCenter0, this.ellipseCenter0, this.rotation);
                Vec3.transformQuat(this.ellipseCenter1, this.ellipseCenter1, this.rotation);
                this.ellipseCenter0.add(this.center);
                this.ellipseCenter1.add(this.center);
              }

              updateLocalCenter() {
                const halfHeight = this.halfHeight;
                const axis = this.axis;

                switch (axis) {
                  case 0:
                    this.ellipseCenter0.set(halfHeight, 0, 0);
                    this.ellipseCenter1.set(-halfHeight, 0, 0);
                    break;

                  case 1:
                    this.ellipseCenter0.set(0, halfHeight, 0);
                    this.ellipseCenter1.set(0, -halfHeight, 0);
                    break;

                  case 2:
                    this.ellipseCenter0.set(0, 0, halfHeight);
                    this.ellipseCenter1.set(0, 0, -halfHeight);
                    break;
                }
              }

            }

            const _v = new Array(8);

            _v[0] = new Vec3(1, 1, 1);
            _v[1] = new Vec3(-1, 1, 1);
            _v[2] = new Vec3(-1, -1, 1);
            _v[3] = new Vec3(1, -1, 1);
            _v[4] = new Vec3(1, 1, -1);
            _v[5] = new Vec3(-1, 1, -1);
            _v[6] = new Vec3(-1, -1, -1);
            _v[7] = new Vec3(1, -1, -1);
            class Frustum {
              set accurate(b) {
                this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
              }

              static create() {
                return new Frustum();
              }

              static clone(f) {
                return Frustum.copy(new Frustum(), f);
              }

              static copy(out, f) {
                out._type = f._type;

                for (let i = 0; i < 6; ++i) {
                  Plane.copy(out.planes[i], f.planes[i]);
                }

                for (let i = 0; i < 8; ++i) {
                  Vec3.copy(out.vertices[i], f.vertices[i]);
                }

                return out;
              }

              get type() {
                return this._type;
              }

              constructor() {
                this._type = void 0;
                this.planes = void 0;
                this.vertices = void 0;
                this._type = enums.SHAPE_FRUSTUM;
                this.planes = new Array(6);

                for (let i = 0; i < 6; ++i) {
                  this.planes[i] = Plane.create(0, 0, 0, 0);
                }

                this.vertices = new Array(8);

                for (let i = 0; i < 8; ++i) {
                  this.vertices[i] = new Vec3();
                }
              }

              update(m, inv) {
                Vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08);
                this.planes[0].d = -(m.m15 + m.m12);
                Vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08);
                this.planes[1].d = -(m.m15 - m.m12);
                Vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09);
                this.planes[2].d = -(m.m15 + m.m13);
                Vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09);
                this.planes[3].d = -(m.m15 - m.m13);
                Vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10);
                this.planes[4].d = -(m.m15 + m.m14);
                Vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10);
                this.planes[5].d = -(m.m15 - m.m14);

                if (this._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
                  return;
                }

                for (let i = 0; i < 6; i++) {
                  const pl = this.planes[i];
                  const invDist = 1 / pl.n.length();
                  Vec3.multiplyScalar(pl.n, pl.n, invDist);
                  pl.d *= invDist;
                }

                for (let i = 0; i < 8; i++) {
                  Vec3.transformMat4(this.vertices[i], _v[i], inv);
                }
              }

              transform(mat) {
                if (this._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
                  return;
                }

                for (let i = 0; i < 8; i++) {
                  Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
                }

                Plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[5], this.vertices[6]);
                Plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[7], this.vertices[4]);
                Plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[7], this.vertices[3]);
                Plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[4], this.vertices[5]);
                Plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[3], this.vertices[0]);
                Plane.fromPoints(this.planes[0], this.vertices[7], this.vertices[6], this.vertices[5]);
              }

            }

            Frustum.createOrtho = (() => {
              const _temp_v3 = new Vec3();

              return (out, width, height, near, far, transform) => {
                const halfWidth = width / 2;
                const halfHeight = height / 2;
                Vec3.set(_temp_v3, halfWidth, halfHeight, near);
                Vec3.transformMat4(out.vertices[0], _temp_v3, transform);
                Vec3.set(_temp_v3, -halfWidth, halfHeight, near);
                Vec3.transformMat4(out.vertices[1], _temp_v3, transform);
                Vec3.set(_temp_v3, -halfWidth, -halfHeight, near);
                Vec3.transformMat4(out.vertices[2], _temp_v3, transform);
                Vec3.set(_temp_v3, halfWidth, -halfHeight, near);
                Vec3.transformMat4(out.vertices[3], _temp_v3, transform);
                Vec3.set(_temp_v3, halfWidth, halfHeight, far);
                Vec3.transformMat4(out.vertices[4], _temp_v3, transform);
                Vec3.set(_temp_v3, -halfWidth, halfHeight, far);
                Vec3.transformMat4(out.vertices[5], _temp_v3, transform);
                Vec3.set(_temp_v3, -halfWidth, -halfHeight, far);
                Vec3.transformMat4(out.vertices[6], _temp_v3, transform);
                Vec3.set(_temp_v3, halfWidth, -halfHeight, far);
                Vec3.transformMat4(out.vertices[7], _temp_v3, transform);
                Plane.fromPoints(out.planes[0], out.vertices[1], out.vertices[6], out.vertices[5]);
                Plane.fromPoints(out.planes[1], out.vertices[3], out.vertices[4], out.vertices[7]);
                Plane.fromPoints(out.planes[2], out.vertices[6], out.vertices[3], out.vertices[7]);
                Plane.fromPoints(out.planes[3], out.vertices[0], out.vertices[5], out.vertices[4]);
                Plane.fromPoints(out.planes[4], out.vertices[2], out.vertices[0], out.vertices[3]);
                Plane.fromPoints(out.planes[0], out.vertices[7], out.vertices[5], out.vertices[6]);
              };
            })();

            function _initializerDefineProperty(target, property, descriptor, context) {
              if (!descriptor) return;
              Object.defineProperty(target, property, {
                enumerable: descriptor.enumerable,
                configurable: descriptor.configurable,
                writable: descriptor.writable,
                value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
              });
            }

            function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
              var desc = {};
              Object.keys(descriptor).forEach(function (key) {
                desc[key] = descriptor[key];
              });
              desc.enumerable = !!desc.enumerable;
              desc.configurable = !!desc.configurable;

              if ('value' in desc || desc.initializer) {
                desc.writable = true;
              }

              desc = decorators.slice().reverse().reduce(function (desc, decorator) {
                return decorator(target, property, desc) || desc;
              }, desc);

              if (context && desc.initializer !== void 0) {
                desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
                desc.initializer = undefined;
              }

              if (desc.initializer === void 0) {
                Object.defineProperty(target, property, desc);
                desc = null;
              }

              return desc;
            }

            let WrapModeMask;

            (function (WrapModeMask) {
              WrapModeMask[WrapModeMask["Default"] = 0] = "Default";
              WrapModeMask[WrapModeMask["Normal"] = 1] = "Normal";
              WrapModeMask[WrapModeMask["Loop"] = 2] = "Loop";
              WrapModeMask[WrapModeMask["ShouldWrap"] = 4] = "ShouldWrap";
              WrapModeMask[WrapModeMask["Clamp"] = 8] = "Clamp";
              WrapModeMask[WrapModeMask["PingPong"] = 22] = "PingPong";
              WrapModeMask[WrapModeMask["Reverse"] = 36] = "Reverse";
            })(WrapModeMask || (WrapModeMask = {}));

            let WrapMode;

            (function (WrapMode) {
              WrapMode[WrapMode["Default"] = WrapModeMask.Default] = "Default";
              WrapMode[WrapMode["Normal"] = WrapModeMask.Normal] = "Normal";
              WrapMode[WrapMode["Reverse"] = WrapModeMask.Reverse] = "Reverse";
              WrapMode[WrapMode["Loop"] = WrapModeMask.Loop] = "Loop";
              WrapMode[WrapMode["LoopReverse"] = WrapModeMask.Loop | WrapModeMask.Reverse] = "LoopReverse";
              WrapMode[WrapMode["PingPong"] = WrapModeMask.PingPong] = "PingPong";
              WrapMode[WrapMode["PingPongReverse"] = WrapModeMask.PingPong | WrapModeMask.Reverse] = "PingPongReverse";
            })(WrapMode || (WrapMode = {}));

            ccenum(WrapMode);
            class WrappedInfo {
              constructor(info) {
                this.ratio = 0;
                this.time = 0;
                this.direction = 1;
                this.stopped = true;
                this.iterations = 0;
                this.frameIndex = undefined;

                if (info) {
                  this.set(info);
                }
              }

              set(info) {
                this.ratio = info.ratio;
                this.time = info.time;
                this.direction = info.direction;
                this.stopped = info.stopped;
                this.iterations = info.iterations;
                this.frameIndex = info.frameIndex;
              }

            }
            function isLerpable(object) {
              return typeof object.lerp === 'function';
            }

            function binarySearchEpsilon(array, value, EPSILON = 1e-6) {
              let low = 0;
              let high = array.length - 1;
              let middle = high >>> 1;

              for (; low <= high; middle = low + high >>> 1) {
                const test = array[middle];

                if (test > value + EPSILON) {
                  high = middle - 1;
                } else if (test < value - EPSILON) {
                  low = middle + 1;
                } else {
                  return middle;
                }
              }

              return ~low;
            }

            const emptyDecorator = () => {};
            const emptyDecoratorFn = () => emptyDecorator;
            const emptySmartClassDecorator = makeSmartClassDecorator(() => {});
            function makeSmartClassDecorator(decorate) {
              return proxyFn;

              function proxyFn(target) {
                if (typeof target === 'function') {
                  return decorate(target);
                } else {
                  return function (constructor) {
                    return decorate(constructor, target);
                  };
                }
              }
            }

            function writeEditorClassProperty(constructor, propertyName, value) {
              const cache = getClassCache(constructor);

              if (cache) {
                const proto = getSubDict(cache, 'proto');
                getSubDict(proto, 'editor')[propertyName] = value;
              }
            }

            function makeEditorClassDecoratorFn(propertyName) {
              return value => constructor => {
                writeEditorClassProperty(constructor, propertyName, value);
              };
            }
            const CACHE_KEY = '__ccclassCache__';
            function getClassCache(ctor, decoratorName) {

              return getSubDict(ctor, CACHE_KEY);
            }
            function getSubDict(obj, key) {
              return obj[key] || (obj[key] = {});
            }

            const ccclass = exports('bH', makeSmartClassDecorator((constructor, name) => {
              let base = js.getSuper(constructor);

              if (base === Object) {
                base = null;
              }

              const proto = {
                name,
                extends: base,
                ctor: constructor
              };
              const cache = constructor[CACHE_KEY];

              if (cache) {
                const decoratedProto = cache.proto;

                if (decoratedProto) {
                  js.mixin(proto, decoratedProto);
                }

                constructor[CACHE_KEY] = undefined;
              }

              const res = CCClass(proto);

              return res;
            }));

            const requireComponent = exports('cX', makeEditorClassDecoratorFn('requireComponent'));
            const executionOrder = exports('bZ', makeEditorClassDecoratorFn('executionOrder'));
            const disallowMultiple = exports('cS',  emptySmartClassDecorator);

            function property(target, propertyKey, descriptor) {
              let options = null;

              function normalized(target, propertyKey, descriptor) {
                const cache = getClassCache(target.constructor);

                if (cache) {
                  const ccclassProto = getSubDict(cache, 'proto');
                  const properties = getSubDict(ccclassProto, 'properties');
                  genProperty(target.constructor, properties, propertyKey, options, descriptor, cache);
                }
              }

              if (target === undefined) {
                return property({
                  type: undefined
                });
              } else if (typeof propertyKey === 'undefined') {
                options = target;
                return normalized;
              } else {
                normalized(target, propertyKey, descriptor);
              }
            }

            function getDefaultFromInitializer(initializer) {
              let value;

              try {
                value = initializer();
              } catch (e) {
                return initializer;
              }

              if (typeof value !== 'object' || value === null) {
                return value;
              } else {
                return initializer;
              }
            }

            function extractActualDefaultValues(ctor) {
              let dummyObj;

              try {
                dummyObj = new ctor();
              } catch (e) {

                return {};
              }

              return dummyObj;
            }

            function genProperty(ctor, properties, propertyKey, options, descriptor, cache) {
              let fullOptions;
              const isGetset = descriptor && (descriptor.get || descriptor.set);

              if (options) {
                fullOptions = getFullFormOfProperty(options, isGetset);
              }

              const existsPropertyRecord = properties[propertyKey];
              const propertyRecord = js.mixin(existsPropertyRecord || {}, fullOptions || options || {});

              if (isGetset) {

                if (descriptor.get) {
                  propertyRecord.get = descriptor.get;
                }

                if (descriptor.set) {
                  propertyRecord.set = descriptor.set;
                }
              } else {

                if (descriptor) {
                  if (descriptor.initializer) {
                    propertyRecord.default = getDefaultFromInitializer(descriptor.initializer);
                  }
                } else {
                  const actualDefaultValues = cache.default || (cache.default = extractActualDefaultValues(ctor));

                  if (actualDefaultValues.hasOwnProperty(propertyKey)) {
                    propertyRecord.default = actualDefaultValues[propertyKey];
                  }
                }
              }

              properties[propertyKey] = propertyRecord;
            }

            const serializable = exports('bJ', (target, propertyKey, descriptor) => property(makeSerializable({}))(target, propertyKey, descriptor));
            function formerlySerializedAs(name) {
              return property(makeSerializable({
                formerlySerializedAs: name
              }));
            }
            const editorOnly = exports('dz', (target, propertyKey, descriptor) => property({
              editorOnly: true
            })(target, propertyKey, descriptor));

            function makeSerializable(options) {
              options.__noImplicit = true;

              if (!('serializable' in options)) {
                options.serializable = true;
              }

              return options;
            }

            const uniquelyReferenced =  emptyDecorator ;

            const executeInEditMode = exports('bV',  emptySmartClassDecorator);
            const menu = exports('b_',  emptyDecoratorFn);
            const playOnFocus = exports('e9',  emptySmartClassDecorator);
            const inspector =  emptyDecoratorFn;
            const icon =  emptyDecoratorFn;
            const help = exports('bY',  emptyDecoratorFn);
            const editable = exports('bT',  emptyDecorator );
            const visible = exports('c0',  emptyDecoratorFn );
            const readOnly = exports('dX',  emptyDecorator );
            const displayName = exports('cY',  emptyDecoratorFn );
            const tooltip = exports('b$',  emptyDecoratorFn );
            const range = exports('cb',  emptyDecoratorFn );
            const rangeMin = exports('dk',  emptyDecoratorFn );
            const rangeMax = exports('dl',  emptyDecoratorFn );
            const rangeStep =  emptyDecoratorFn ;
            const slide = exports('ca',  emptyDecorator );
            const displayOrder = exports('cU',  emptyDecoratorFn );
            const unit = exports('cf',  emptyDecoratorFn );
            const radian = exports('dO',  emptyDecorator );
            const multiline = exports('cZ',  emptyDecorator );
            const disallowAnimation = exports('bW',  emptyDecorator );

            const integer = type(CCInteger);
            const float = type(CCFloat);
            const boolean = type(CCBoolean);
            const string = exports('cM', type(CCString));
            function type(type) {
              return property({
                type
              });
            }

            const override = exports('cC', (target, propertyKey, descriptor) => property({
              __noImplicit: true,
              override: true
            })(target, propertyKey, descriptor));

            let _Symbol$iterator;

            var _dec, _class, _class2, _descriptor, _descriptor2, _temp;
            let KeyframeCurve = (_dec = ccclass('cc.KeyframeCurve'), _dec(_class = (_class2 = (_temp = (_Symbol$iterator = Symbol.iterator, class KeyframeCurve {
              constructor() {
                _initializerDefineProperty(this, "_times", _descriptor, this);

                _initializerDefineProperty(this, "_values", _descriptor2, this);
              }

              get keyFramesCount() {
                return this._times.length;
              }

              get rangeMin() {
                return this._times[0];
              }

              get rangeMax() {
                return this._times[this._values.length - 1];
              }

              [_Symbol$iterator]() {
                let index = 0;
                return {
                  next: () => {
                    if (index >= this._times.length) {
                      return {
                        done: true,
                        value: undefined
                      };
                    } else {
                      const value = [this._times[index], this._values[index]];
                      ++index;
                      return {
                        done: false,
                        value
                      };
                    }
                  }
                };
              }

              keyframes() {
                return this;
              }

              times() {
                return this._times;
              }

              values() {
                return this._values;
              }

              getKeyframeTime(index) {
                return this._times[index];
              }

              getKeyframeValue(index) {
                return this._values[index];
              }

              addKeyFrame(time, keyframeValue) {
                return this._insertNewKeyframe(time, keyframeValue);
              }

              removeKeyframe(index) {
                this._times.splice(index, 1);

                this._values.splice(index, 1);
              }

              indexOfKeyframe(time) {
                return binarySearchEpsilon(this._times, time);
              }

              updateTime(index, time) {
                const value = this._values[index];
                this.removeKeyframe(index);

                this._insertNewKeyframe(time, value);
              }

              assignSorted(times, values) {
                if (values !== undefined) {
                  assertIsTrue(Array.isArray(times));
                  this.setKeyframes(times.slice(), values.slice());
                } else {
                  const keyframes = Array.from(times);
                  this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => value));
                }
              }

              clear() {
                this._times.length = 0;
                this._values.length = 0;
              }

              searchKeyframe(time) {
                return binarySearchEpsilon(this._times, time);
              }

              setKeyframes(times, values) {
                assertIsTrue(times.length === values.length);
                assertIsTrue(isSorted(times));
                this._times = times;
                this._values = values;
              }

              _insertNewKeyframe(time, value) {
                const times = this._times;
                const values = this._values;
                const nFrames = times.length;
                const index = binarySearchEpsilon(times, time);

                if (index >= 0) {
                  return index;
                }

                const iNext = ~index;

                if (iNext === 0) {
                  times.unshift(time);
                  values.unshift(value);
                } else if (iNext === nFrames) {
                  times.push(time);
                  values.push(value);
                } else {
                  assertIsTrue(nFrames > 1);
                  times.splice(iNext - 1, 0, time);
                  values.splice(iNext - 1, 0, value);
                }

                return iNext;
              }

            }), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_times", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_values", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2)) || _class);

            function isSorted(values) {
              return values.every((value, index, array) => index === 0 || value > array[index - 1] || approx(value, array[index - 1], 1e-6));
            }

            let RealInterpolationMode;

            (function (RealInterpolationMode) {
              RealInterpolationMode[RealInterpolationMode["LINEAR"] = 0] = "LINEAR";
              RealInterpolationMode[RealInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
              RealInterpolationMode[RealInterpolationMode["CUBIC"] = 2] = "CUBIC";
            })(RealInterpolationMode || (RealInterpolationMode = exports('g6', {})));

            let ExtrapolationMode;

            (function (ExtrapolationMode) {
              ExtrapolationMode[ExtrapolationMode["LINEAR"] = 0] = "LINEAR";
              ExtrapolationMode[ExtrapolationMode["CLAMP"] = 1] = "CLAMP";
              ExtrapolationMode[ExtrapolationMode["LOOP"] = 2] = "LOOP";
              ExtrapolationMode[ExtrapolationMode["PING_PONG"] = 3] = "PING_PONG";
            })(ExtrapolationMode || (ExtrapolationMode = exports('g7', {})));

            let TangentWeightMode;

            (function (TangentWeightMode) {
              TangentWeightMode[TangentWeightMode["NONE"] = 0] = "NONE";
              TangentWeightMode[TangentWeightMode["LEFT"] = 1] = "LEFT";
              TangentWeightMode[TangentWeightMode["RIGHT"] = 2] = "RIGHT";
              TangentWeightMode[TangentWeightMode["BOTH"] = 3] = "BOTH";
            })(TangentWeightMode || (TangentWeightMode = exports('g8', {})));

            function solveCubic(coeff0, coeff1, coeff2, coeff3, solutions) {
              const a = coeff2 / coeff3;
              const b = coeff1 / coeff3;
              const c = coeff0 / coeff3;
              const sqrA = a * a;
              const p = 1.0 / 3.0 * (-1.0 / 3 * sqrA + b);
              const q = 1.0 / 2.0 * (2.0 / 27.0 * a * sqrA - 1.0 / 3 * a * b + c);
              const cubicP = p * p * p;
              const d = q * q + cubicP;
              let nSolutions = 0;

              if (isZero(d)) {
                if (isZero(q)) {
                  solutions[0] = 0;
                  return 1;
                } else {
                  const u = Math.cbrt(-q);
                  solutions[0] = 2 * u;
                  solutions[1] = -u;
                  return 2;
                }
              } else if (d < 0) {
                const phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cubicP));
                const t = 2 * Math.sqrt(-p);
                solutions[0] = t * Math.cos(phi);
                solutions[1] = -t * Math.cos(phi + Math.PI / 3);
                solutions[2] = -t * Math.cos(phi - Math.PI / 3);
                nSolutions = 3;
              } else {
                const sqrtD = Math.sqrt(d);
                const u = Math.cbrt(sqrtD - q);
                const v = -Math.cbrt(sqrtD + q);
                solutions[0] = u + v;
                nSolutions = 1;
              }

              const sub = 1.0 / 3 * a;

              for (let i = 0; i < nSolutions; ++i) {
                solutions[i] -= sub;
              }

              return nSolutions;
            }
            const EQN_EPS = 1e-9;

            function isZero(x) {
              return x > -EQN_EPS && x < EQN_EPS;
            }

            const EditorExtendable = editorExtendableInternal();
            assertIsTrue(editorExtrasTag === '__editorExtras__', 'editorExtrasTag needs to be updated.');

            function editorExtendableInternal(Base, className) {
              {
                return Base !== null && Base !== void 0 ? Base : Object;
              }
            }

            var _decorator = /*#__PURE__*/Object.freeze({
                __proto__: null,
                uniquelyReferenced: uniquelyReferenced,
                ccclass: ccclass,
                property: property,
                requireComponent: requireComponent,
                executionOrder: executionOrder,
                disallowMultiple: disallowMultiple,
                executeInEditMode: executeInEditMode,
                menu: menu,
                playOnFocus: playOnFocus,
                inspector: inspector,
                icon: icon,
                help: help,
                type: type,
                integer: integer,
                float: float,
                boolean: boolean,
                string: string
            });
            exports('e3', _decorator);

            class Cache {
              constructor(map) {
                this._map = null;
                this._count = 0;

                if (map) {
                  this._map = map;
                  this._count = Object.keys(map).length;
                } else {
                  this._map = js.createMap(true);
                  this._count = 0;
                }
              }

              add(key, val) {
                if (!(key in this._map)) {
                  this._count++;
                }

                return this._map[key] = val;
              }

              get(key) {
                return this._map[key];
              }

              has(key) {
                return key in this._map;
              }

              remove(key) {
                const out = this._map[key];

                if (key in this._map) {
                  delete this._map[key];
                  this._count--;
                }

                return out;
              }

              clear() {
                if (this._count !== 0) {
                  this._map = js.createMap(true);
                  this._count = 0;
                }
              }

              forEach(func) {
                for (const key in this._map) {
                  func(this._map[key], key);
                }
              }

              find(predicate) {
                for (const key in this._map) {
                  if (predicate(this._map[key], key)) {
                    return this._map[key];
                  }
                }

                return null;
              }

              get count() {
                return this._count;
              }

              destroy() {
                this._map = null;
              }

            }

            class Pipeline {
              constructor(name, funcs) {
                this.id = Pipeline._pipelineId++;
                this.name = '';
                this.pipes = [];
                this.name = name;

                for (let i = 0, l = funcs.length; i < l; i++) {
                  this.pipes.push(funcs[i]);
                }
              }

              insert(func, index) {
                if (index > this.pipes.length) {
                  warnID(4921);
                  return this;
                }

                this.pipes.splice(index, 0, func);
                return this;
              }

              append(func) {
                this.pipes.push(func);
                return this;
              }

              remove(index) {
                this.pipes.splice(index, 1);
                return this;
              }

              sync(task) {
                const pipes = this.pipes;

                if (pipes.length === 0) {
                  return null;
                }

                task.isFinish = false;

                for (let i = 0, l = pipes.length; i < l;) {
                  const pipe = pipes[i];
                  const result = pipe(task);

                  if (result) {
                    task.isFinish = true;
                    return result;
                  }

                  i++;

                  if (i !== l) {
                    task.input = task.output;
                    task.output = null;
                  }
                }

                task.isFinish = true;
                return task.output;
              }

              async(task) {
                const pipes = this.pipes;

                if (pipes.length === 0) {
                  return;
                }

                task.isFinish = false;

                this._flow(0, task);
              }

              _flow(index, task) {
                const pipe = this.pipes[index];
                pipe(task, result => {
                  if (result) {
                    task.isFinish = true;
                    task.dispatch('complete', result);
                  } else {
                    index++;

                    if (index < this.pipes.length) {
                      task.input = task.output;
                      task.output = null;

                      this._flow(index, task);
                    } else {
                      task.isFinish = true;
                      task.dispatch('complete', result, task.output);
                    }
                  }
                });
              }

            }
            Pipeline._pipelineId = 0;

            const assets =  new Cache();
            const files = new Cache();
            const parsed = new Cache();
            const bundles = new Cache();
            const pipeline = new Pipeline('normal load', []);
            const fetchPipeline = new Pipeline('fetch', []);
            const transformPipeline = new Pipeline('transform url', []);
            const references =  null;
            let RequestType;

            (function (RequestType) {
              RequestType["UUID"] = "uuid";
              RequestType["PATH"] = "path";
              RequestType["DIR"] = "dir";
              RequestType["URL"] = "url";
              RequestType["SCENE"] = "scene";
            })(RequestType || (RequestType = {}));

            const presets = {
              default: {
                priority: 0
              },
              preload: {
                maxConcurrency: 6,
                maxRequestsPerFrame: 2,
                priority: -1
              },
              scene: {
                maxConcurrency: 20,
                maxRequestsPerFrame: 20,
                priority: 1
              },
              bundle: {
                maxConcurrency: 20,
                maxRequestsPerFrame: 20,
                priority: 2
              },
              remote: {
                maxRetryCount: 4
              }
            };
            let BuiltinBundleName;

            (function (BuiltinBundleName) {
              BuiltinBundleName["RESOURCES"] = "resources";
              BuiltinBundleName["MAIN"] = "main";
              BuiltinBundleName["START_SCENE"] = "start-scene";
            })(BuiltinBundleName || (BuiltinBundleName = {}));

            class Task {
              static create(options) {
                let out;

                if (Task._deadPool.length !== 0) {
                  out = Task._deadPool.pop();
                  out.set(options);
                } else {
                  out = new Task(options);
                }

                return out;
              }

              constructor(options) {
                this.id = Task._taskId++;
                this.onComplete = null;
                this.onProgress = null;
                this.onError = null;
                this.source = null;
                this.output = null;
                this.input = null;
                this.progress = null;
                this.options = null;
                this.isFinish = true;
                this.set(options);
              }

              set(options = Object.create(null)) {
                this.onComplete = options.onComplete || null;
                this.onProgress = options.onProgress || null;
                this.onError = options.onError || null;
                this.source = this.input = options.input;
                this.output = null;
                this.progress = options.progress;
                this.options = options.options || Object.create(null);
              }

              dispatch(event, param1, param2, param3, param4) {
                switch (event) {
                  case 'complete':
                    if (this.onComplete) {
                      this.onComplete(param1, param2);
                    }

                    break;

                  case 'progress':
                    if (this.onProgress) {
                      this.onProgress(param1, param2, param3, param4);
                    }

                    break;

                  case 'error':
                    if (this.onError) {
                      this.onError(param1, param2, param3, param4);
                    }

                    break;

                  default:
                    {
                      const str = `on${event[0].toUpperCase()}${event.substr(1)}`;

                      if (typeof this[str] === 'function') {
                        this[str](param1, param2, param3, param4);
                      }

                      break;
                    }
                }
              }

              recycle() {
                if (Task._deadPool.length === Task.MAX_DEAD_NUM) {
                  return;
                }

                this.onComplete = null;
                this.onProgress = null;
                this.onError = null;
                this.source = this.output = this.input = null;
                this.progress = null;
                this.options = null;

                Task._deadPool.push(this);
              }

            }
            Task.MAX_DEAD_NUM = 500;
            Task._taskId = 0;
            Task._deadPool = [];

            const HexChars = '0123456789abcdef'.split('');
            const _t = ['', '', '', ''];

            const UuidTemplate = _t.concat(_t, '-', _t, '-', _t, '-', _t, '-', _t, _t, _t);

            const Indices = UuidTemplate.map((x, i) => x === '-' ? NaN : i).filter(isFinite);
            function decodeUuid(base64) {
              const strs = base64.split('@');
              const uuid = strs[0];

              if (uuid.length !== 22) {
                return base64;
              }

              UuidTemplate[0] = base64[0];
              UuidTemplate[1] = base64[1];

              for (let i = 2, j = 2; i < 22; i += 2) {
                const lhs = BASE64_VALUES[base64.charCodeAt(i)];
                const rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
                UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
                UuidTemplate[Indices[j++]] = HexChars[(lhs & 3) << 2 | rhs >> 4];
                UuidTemplate[Indices[j++]] = HexChars[rhs & 0xF];
              }

              return base64.replace(uuid, UuidTemplate.join(''));
            }

            const _uuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
            function getUuidFromURL(url) {
              const matches = _uuidRegex.exec(url);

              if (matches) {
                return matches[1];
              }

              return '';
            }
            function getUrlWithUuid(uuid, options) {
              options = options || Object.create(null);
              options.__isNative__ = options.isNative;
              options.ext = options.nativeExt;
              const bundle = bundles.find(b => !!b.getAssetInfo(uuid));

              if (bundle) {
                options.bundle = bundle.name;
              }

              return transform(uuid, options);
            }
            function isScene(asset) {
              return !!asset && (asset instanceof legacyCC.SceneAsset || asset instanceof legacyCC.Scene);
            }
            function normalize(url) {
              if (url) {
                if (url.charCodeAt(0) === 46 && url.charCodeAt(1) === 47) {
                  url = url.slice(2);
                } else if (url.charCodeAt(0) === 47) {
                  url = url.slice(1);
                }
              }

              return url;
            }
            function transform(input, options) {
              const subTask = Task.create({
                input,
                options
              });
              const urls = [];

              try {
                const result = transformPipeline.sync(subTask);

                for (const requestItem of result) {
                  const url = requestItem.url;
                  requestItem.recycle();
                  urls.push(url);
                }
              } catch (e) {
                for (const item of subTask.output) {
                  item.recycle();
                }

                error(e.message, e.stack);
              }

              subTask.recycle();
              return urls.length > 1 ? urls : urls[0];
            }

            var helper = /*#__PURE__*/Object.freeze({
                __proto__: null,
                getUuidFromURL: getUuidFromURL,
                getUrlWithUuid: getUrlWithUuid,
                isScene: isScene,
                normalize: normalize,
                transform: transform,
                decodeUuid: decodeUuid
            });

            class Event {
              constructor(type, bubbles) {
                this.type = void 0;
                this.bubbles = void 0;
                this.target = null;
                this.currentTarget = null;
                this.eventPhase = 0;
                this.propagationStopped = false;
                this.propagationImmediateStopped = false;
                this.type = type;
                this.bubbles = !!bubbles;
              }

              unuse() {
                this.type = Event.NO_TYPE;
                this.target = null;
                this.currentTarget = null;
                this.eventPhase = Event.NONE;
                this.propagationStopped = false;
                this.propagationImmediateStopped = false;
              }

              reuse(type, bubbles) {
                this.type = type;
                this.bubbles = bubbles || false;
              }

              isStopped() {
                return this.propagationStopped || this.propagationImmediateStopped;
              }

              getCurrentTarget() {
                return this.currentTarget;
              }

              getType() {
                return this.type;
              }

            } exports('dw', Event);
            Event.NO_TYPE = 'no_type';
            Event.TOUCH = 'touch';
            Event.MOUSE = 'mouse';
            Event.KEYBOARD = 'keyboard';
            Event.ACCELERATION = 'acceleration';
            Event.NONE = 0;
            Event.CAPTURING_PHASE = 1;
            Event.AT_TARGET = 2;
            Event.BUBBLING_PHASE = 3;
            legacyCC.Event = Event;

            class GarbageCollectionManager {
              constructor() {
                this._finalizationRegistry =  null;
              }

              registerGCObject(gcObject) {
                {
                  return gcObject;
                }
              }

              unregisterGCObject(gcObject) {
              }

              init() {}

              finalizationRegistryCallback(gcObject) {
                gcObject.destroy();
              }

              destroy() {}

            }

            const garbageCollectionManager = new GarbageCollectionManager();

            var _dec$1, _class$1;
            let GCObject = (_dec$1 = ccclass('cc.GCObject'), _dec$1(_class$1 = class GCObject extends CCObject {
              constructor(...arg) {
                super(...arg);
                return garbageCollectionManager.registerGCObject(this);
              }

              equals(gcObject) {
                if (!gcObject) {
                  return false;
                }

                {
                  return gcObject === this;
                }
              }

              destroy() {
                garbageCollectionManager.unregisterGCObject(this);
                return super.destroy();
              }

            }) || _class$1);

            var _dec$2, _class$2, _class2$1, _descriptor$1, _temp$1;
            let Asset = exports('bK', (_dec$2 = ccclass('cc.Asset'), _dec$2(_class$2 = (_class2$1 = (_temp$1 = class Asset extends Eventify(GCObject) {
              static deserialize(data) {
                return legacyCC.deserialize(data);
              }

              get nativeUrl() {
                if (!this._nativeUrl) {
                  if (!this._native) return '';
                  const name = this._native;

                  if (name.charCodeAt(0) === 47) {
                    return name.slice(1);
                  }

                  if (name.charCodeAt(0) === 46) {
                    this._nativeUrl = getUrlWithUuid(this._uuid, {
                      nativeExt: name,
                      isNative: true
                    });
                  } else {
                    this._nativeUrl = getUrlWithUuid(this._uuid, {
                      __nativeName__: name,
                      nativeExt: extname(name),
                      isNative: true
                    });
                  }
                }

                return this._nativeUrl;
              }

              get _nativeAsset() {
                return this._file;
              }

              set _nativeAsset(obj) {
                this._file = obj;
              }

              constructor(...args) {
                super(...args);
                this.loaded = true;

                _initializerDefineProperty(this, "_native", _descriptor$1, this);

                this._nativeUrl = '';
                this._file = null;
                this._ref = 0;
                Object.defineProperty(this, '_uuid', {
                  value: '',
                  writable: true
                });
              }

              toString() {
                return this.nativeUrl;
              }

              serialize() {}

              _setRawAsset(filename, inLibrary = true) {
                if (inLibrary !== false) {
                  this._native = filename || '';
                } else {
                  this._native = `/${filename}`;
                }
              }

              get _nativeDep() {
                if (this._native) {
                  return {
                    __isNative__: true,
                    uuid: this._uuid,
                    ext: this._native
                  };
                }

                return undefined;
              }

              get refCount() {
                return this._ref;
              }

              addRef() {
                this._ref++;
                return this;
              }

              decRef(autoRelease = true) {
                if (this._ref > 0) {
                  this._ref--;
                }

                if (autoRelease) {
                  legacyCC.assetManager._releaseManager.tryRelease(this);
                }

                return this;
              }

              onLoaded() {}

              initDefault(uuid) {
                if (uuid) {
                  this._uuid = uuid;
                }

                this.isDefault = true;
              }

              validate() {
                return true;
              }

              destroy() {
                debug(getError(12101, this._uuid));
                return super.destroy();
              }

            }, _temp$1), (_descriptor$1 = _applyDecoratedDescriptor(_class2$1.prototype, "_native", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _applyDecoratedDescriptor(_class2$1.prototype, "_nativeAsset", [property], Object.getOwnPropertyDescriptor(_class2$1.prototype, "_nativeAsset"), _class2$1.prototype)), _class2$1)) || _class$2));
            Asset.prototype.createNode = null;
            legacyCC.Asset = Asset;

            var _dec$3, _class$3, _dec2, _class2$2, _dec3, _class3;
            let Script = exports('fa', (_dec$3 = ccclass('cc.Script'), _dec$3(_class$3 = class Script extends Asset {}) || _class$3));
            legacyCC._Script = Script;
            let JavaScript = exports('fb', (_dec2 = ccclass('cc.JavaScript'), _dec2(_class2$2 = class JavaScript extends Script {}) || _class2$2));
            legacyCC._JavaScript = JavaScript;
            let TypeScript = exports('fc', (_dec3 = ccclass('cc.TypeScript'), _dec3(_class3 = class TypeScript extends Script {}) || _class3));
            legacyCC._TypeScript = TypeScript;

            var _dec$4, _dec2$1, _dec3$1, _dec4, _class$4, _class2$3, _descriptor$2, _descriptor2$1, _descriptor3, _class3$1, _temp$2;
            const idGenerator = new IDGenerator('Comp');
            const IsOnLoadCalled$1 = CCObject.Flags.IsOnLoadCalled;
            const NullNode = null;
            let Component = exports('cc', (_dec$4 = ccclass('cc.Component'), _dec2$1 = displayName(), _dec3$1 = type(Script), _dec4 = tooltip(), _dec$4(_class$4 = (_class2$3 = (_temp$2 = _class3$1 = class Component extends CCObject {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "node", _descriptor$2, this);

                _initializerDefineProperty(this, "_enabled", _descriptor2$1, this);

                _initializerDefineProperty(this, "__prefab", _descriptor3, this);

                this._sceneGetter = null;
                this._id = idGenerator.getNewId();
              }

              get name() {
                if (this._name) {
                  return this._name;
                }

                let className = getClassName(this);
                const trimLeft = className.lastIndexOf('.');

                if (trimLeft >= 0) {
                  className = className.slice(trimLeft + 1);
                }

                return `${this.node.name}<${className}>`;
              }

              set name(value) {
                this._name = value;
              }

              get uuid() {
                return this._id;
              }

              get __scriptAsset() {
                return null;
              }

              get enabled() {
                return this._enabled;
              }

              set enabled(value) {
                if (this._enabled !== value) {
                  this._enabled = value;

                  if (this.node.activeInHierarchy) {
                    const compScheduler = legacyCC.director._compScheduler;

                    if (value) {
                      compScheduler.enableComp(this);
                    } else {
                      compScheduler.disableComp(this);
                    }
                  }
                }
              }

              get enabledInHierarchy() {
                return this._enabled && this.node && this.node.activeInHierarchy;
              }

              get _isOnLoadCalled() {
                return this._objFlags & IsOnLoadCalled$1;
              }

              _getRenderScene() {
                if (this._sceneGetter) {
                  return this._sceneGetter();
                }

                return this.node.scene._renderScene;
              }

              addComponent(typeOrClassName) {
                return this.node.addComponent(typeOrClassName);
              }

              getComponent(typeOrClassName) {
                return this.node.getComponent(typeOrClassName);
              }

              getComponents(typeOrClassName) {
                return this.node.getComponents(typeOrClassName);
              }

              getComponentInChildren(typeOrClassName) {
                return this.node.getComponentInChildren(typeOrClassName);
              }

              getComponentsInChildren(typeOrClassName) {
                return this.node.getComponentsInChildren(typeOrClassName);
              }

              destroy() {

                if (super.destroy()) {
                  if (this._enabled && this.node.activeInHierarchy) {
                    legacyCC.director._compScheduler.disableComp(this);
                  }

                  return true;
                }

                return false;
              }

              _onPreDestroy() {
                this.unscheduleAllCallbacks();

                legacyCC.director._nodeActivator.destroyComp(this);

                this.node._removeComponent(this);
              }

              _instantiate(cloned) {
                if (!cloned) {
                  cloned = legacyCC.instantiate._clone(this, this);
                }

                if (cloned) {
                  cloned.node = NullNode;
                }

                return cloned;
              }

              schedule(callback, interval = 0, repeat = legacyCC.macro.REPEAT_FOREVER, delay = 0) {
                assertID(callback, 1619);
                interval = interval || 0;
                assertID(interval >= 0, 1620);
                repeat = Number.isNaN(repeat) ? legacyCC.macro.REPEAT_FOREVER : repeat;
                delay = delay || 0;
                const scheduler = legacyCC.director.getScheduler();
                const paused = scheduler.isTargetPaused(this);
                scheduler.schedule(callback, this, interval, repeat, delay, paused);
              }

              scheduleOnce(callback, delay = 0) {
                this.schedule(callback, 0, 0, delay);
              }

              unschedule(callback_fn) {
                if (!callback_fn) {
                  return;
                }

                legacyCC.director.getScheduler().unschedule(callback_fn, this);
              }

              unscheduleAllCallbacks() {
                legacyCC.director.getScheduler().unscheduleAllForTarget(this);
              }

            }, _class3$1.system = null, _temp$2), (_applyDecoratedDescriptor(_class2$3.prototype, "__scriptAsset", [_dec2$1, _dec3$1, _dec4, disallowAnimation], Object.getOwnPropertyDescriptor(_class2$3.prototype, "__scriptAsset"), _class2$3.prototype), _descriptor$2 = _applyDecoratedDescriptor(_class2$3.prototype, "node", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return NullNode;
              }
            }), _descriptor2$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor3 = _applyDecoratedDescriptor(_class2$3.prototype, "__prefab", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$3)) || _class$4));
            const proto = Component.prototype;
            proto.update = null;
            proto.lateUpdate = null;
            proto.__preload = null;
            proto.onLoad = null;
            proto.start = null;
            proto.onEnable = null;
            proto.onDisable = null;
            proto.onDestroy = null;
            proto.onFocusInEditor = null;
            proto.onLostFocusInEditor = null;
            proto.resetInEditor = null;
            proto._getLocalBounds = null;
            proto.onRestore = null;
            Component._requireComponent = null;
            Component._executionOrder = 0;

            value(Component, '_registerEditorProps', (cls, props) => {
              const reqComp = props.requireComponent;

              if (reqComp) {
                cls._requireComponent = reqComp;
              }

              const order = props.executionOrder;

              if (order && typeof order === 'number') {
                cls._executionOrder = order;
              }
            });
            legacyCC.Component = Component;

            var _dec$5, _dec2$2, _class$5, _class2$4, _descriptor$3, _temp$3;
            let MissingScript = exports('fP', (_dec$5 = ccclass('cc.MissingScript'), _dec2$2 = inspector(), _dec$5(_class$5 = _dec2$2(_class$5 = (_class2$4 = (_temp$3 = class MissingScript extends Component {
              static safeFindClass(id) {
                const cls = _getClassById(id);

                if (cls) {
                  return cls;
                }

                legacyCC.deserialize.reportMissingClass(id);
                return undefined;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_$erialized", _descriptor$3, this);
              }

              onLoad() {
                warnID(4600, this.node.name);
              }

            }, _temp$3), (_descriptor$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_$erialized", [serializable, editorOnly], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$4)) || _class$5) || _class$5));
            legacyCC._MissingScript = MissingScript;

            const serializeTag = exports('f4', Symbol('[[Serialize]]'));
            const deserializeTag = exports('f3', Symbol('[[Deserialize]]'));

            const VERSION = 1;
            const MAGIC = 0x4E4F4343;
            const CHUNK_ALIGN_AS = 8;
            class CCON {
              constructor(document, chunks) {
                this._document = void 0;
                this._chunks = void 0;
                this._document = document;
                this._chunks = chunks;
              }

              get document() {
                return this._document;
              }

              get chunks() {
                return this._chunks;
              }

            }
            function parseCCONJson(json) {
              const cconPreface = json;
              return {
                chunks: cconPreface.chunks,
                document: cconPreface.document
              };
            }
            function decodeCCONBinary(bytes) {
              if (bytes.length < 16) {
                throw new InvalidCCONError(getError(13102));
              }

              const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
              const magic = dataView.getUint32(0, true);

              if (magic !== MAGIC) {
                throw new InvalidCCONError(getError(13100));
              }

              const version = dataView.getUint32(4, true);

              if (version !== VERSION) {
                throw new InvalidCCONError(getError(13101, version));
              }

              const dataByteLength = dataView.getUint32(8, true);

              if (dataByteLength !== dataView.byteLength) {
                throw new InvalidCCONError(getError(13102));
              }

              let chunksStart = 12;
              const jsonDataLength = dataView.getUint32(chunksStart, true);
              chunksStart += 4;
              const jsonData = new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, jsonDataLength);
              chunksStart += jsonDataLength;
              const jsonString = decodeJson(jsonData);
              let json;

              try {
                json = JSON.parse(jsonString);
              } catch (err) {
                throw new InvalidCCONError(err);
              }

              const chunks = [];

              while (chunksStart < dataView.byteLength) {
                if (chunksStart % CHUNK_ALIGN_AS !== 0) {
                  const padding = CHUNK_ALIGN_AS - chunksStart % CHUNK_ALIGN_AS;
                  chunksStart += padding;
                }

                const chunkDataLength = dataView.getUint32(chunksStart, true);
                chunksStart += 4;
                chunks.push(new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, chunkDataLength));
                chunksStart += chunkDataLength;
              }

              if (chunksStart !== dataView.byteLength) {
                throw new InvalidCCONError(getError(13102));
              }

              return new CCON(json, chunks);
            }

            function decodeJson(data) {
              if (typeof TextDecoder !== 'undefined') {
                return new TextDecoder().decode(data);
              } else if ('Buffer' in globalThis) {
                const {
                  Buffer
                } = globalThis;
                return Buffer.from(data.buffer, data.byteOffset, data.byteLength).toString();
              } else {
                throw new Error(getError(13104));
              }
            }

            class InvalidCCONError extends Error {}
            legacyCC.internal.parseCCONJson = parseCCONJson;
            legacyCC.internal.decodeCCONBinary = decodeCCONBinary;
            legacyCC.internal.CCON = CCON;

            function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue) {
              if (defaultValue instanceof legacyCC.ValueType) {
                if (!assumeHavePropIfIsValue) {
                  sources.push('if(prop){');
                }

                const ctorCode = getClassName(defaultValue);
                sources.push(`s._deserializeFastDefinedObject(o${accessorToSet},prop,${ctorCode});`);

                if (!assumeHavePropIfIsValue) {
                  sources.push(`}else o${accessorToSet}=null;`);
                }
              } else {
                sources.push(`
if (prop) {
    s._deserializeAndAssignField(o, prop, ${propNameLiteralToSet});
} else {
    o${accessorToSet}=null;
}
`);
              }
            }

            const compileDeserialize =  compileDeserializeJIT ;
            const DELIMITER = DELIMETER;
            const POSTFIX_TYPE = `${DELIMITER}type`;
            const POSTFIX_DEFAULT = `${DELIMITER}default`;
            const POSTFIX_FORMERLY_SERIALIZED_AS = `${DELIMITER}formerlySerializedAs`;

            function compileDeserializeJIT(self, klass) {
              const attrs = getClassAttrs(klass);
              const props = klass.__values__;
              const sources = ['var prop;'];
              const fastMode = BUILTIN_CLASSID_RE.test(_getClassId(klass));

              for (let p = 0; p < props.length; p++) {
                const propName = props[p];

                let accessorToSet;
                let propNameLiteralToSet;

                if (CCClass.IDENTIFIER_RE.test(propName)) {
                  propNameLiteralToSet = `"${propName}"`;
                  accessorToSet = `.${propName}`;
                } else {
                  propNameLiteralToSet = CCClass.escapeForJS(propName);
                  accessorToSet = `[${propNameLiteralToSet}]`;
                }

                let accessorToGet = accessorToSet;

                if (attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS]) {
                  const propNameToRead = attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS];

                  if (CCClass.IDENTIFIER_RE.test(propNameToRead)) {
                    accessorToGet = `.${propNameToRead}`;
                  } else {
                    accessorToGet = `[${CCClass.escapeForJS(propNameToRead)}]`;
                  }
                }

                sources.push(`prop=d${accessorToGet};`);
                sources.push(`if(typeof ${ '(prop)' }!=="undefined"){`);
                const defaultValue = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);

                if (fastMode) {
                  let isPrimitiveType;
                  const userType = attrs[propName + POSTFIX_TYPE];

                  if (defaultValue === undefined && userType) {
                    isPrimitiveType = userType instanceof PrimitiveType;
                  } else {
                    const defaultType = typeof defaultValue;
                    isPrimitiveType = defaultType === 'string' || defaultType === 'number' || defaultType === 'boolean';
                  }

                  if (isPrimitiveType) {
                    sources.push(`o${accessorToSet}=prop;`);
                  } else {
                    compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, true);
                  }
                } else {
                  sources.push(`${`if(typeof ${ '(prop)' }!=="object"){` + 'o'}${accessorToSet}=prop;` + `}else{`);
                  compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, false);
                  sources.push('}');
                }

                sources.push('}');
              }

              if (legacyCC.js.isChildClassOf(klass, legacyCC._BaseNode) || legacyCC.js.isChildClassOf(klass, legacyCC.Component)) {
                {
                  sources.push('d._id&&(o._id=d._id);');
                }
              }

              if (props[props.length - 1] === '_$erialized') {
                sources.push('o._$erialized=JSON.parse(JSON.stringify(d));');
                sources.push('s._fillPlainObject(o._$erialized,d);');
              }

              return Function('s', 'o', 'd', 'k', sources.join(''));
            }

            class DeserializerPool extends Pool$1 {
              constructor() {
                super(deserializer => {
                  deserializer.clear();
                }, 1);
              }

              get(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
                const cache = this._get();

                if (cache) {
                  cache.reset(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
                  return cache;
                } else {
                  return new _Deserializer(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
                }
              }

            }

            class _Deserializer {
              constructor(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
                this.deserializedList = void 0;
                this.deserializedData = void 0;
                this._ignoreEditorOnly = void 0;
                this.result = result;
                this.customEnv = customEnv;
                this.deserializedList = [];
                this.deserializedData = null;
                this._classFinder = classFinder;
                this._reportMissingClass = reportMissingClass;
                this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
              }

              reset(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
                this.result = result;
                this.customEnv = customEnv;
                this._classFinder = classFinder;
                this._reportMissingClass = reportMissingClass;
                this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
              }

              clear() {
                this.result = null;
                this.customEnv = null;
                this.deserializedList.length = 0;
                this.deserializedData = null;
                this._classFinder = null;
                this._reportMissingClass = null;
                this._onDereferenced = null;
              }

              deserialize(serializedData) {
                let fromCCON = false;
                let jsonObj;

                if (serializedData instanceof CCON) {
                  fromCCON = true;
                  jsonObj = serializedData.document;

                  if (serializedData.chunks.length > 0) {
                    assertIsTrue(serializedData.chunks.length === 1);
                    this._mainBinChunk = serializedData.chunks[0];
                  }
                } else {
                  jsonObj = serializedData;
                }

                this._serializedData = jsonObj;
                this._context = {
                  fromCCON
                };
                const serializedRootObject = Array.isArray(jsonObj) ? jsonObj[0] : jsonObj;

                {
                  this.deserializedData = this._deserializeObject(serializedRootObject, 0);
                }

                this._serializedData = undefined;
                this._mainBinChunk = undefined;
                this._context = undefined;
                return this.deserializedData;
              }

              _deserializeObject(serialized, globalIndex, owner, propName) {
                switch (serialized.__type__) {
                  case 'TypedArray':
                    return this._deserializeTypedArrayView(serialized);

                  case 'TypedArrayRef':
                    return this._deserializeTypedArrayViewRef(serialized);

                  default:
                    if (serialized.__type__) {
                      return this._deserializeTypeTaggedObject(serialized, globalIndex, owner, propName);
                    } else if (!Array.isArray(serialized)) {
                      return this._deserializePlainObject(serialized);
                    } else {
                      return this._deserializeArray(serialized);
                    }

                }
              }

              _deserializeTypedArrayView(value) {
                return globalThis[value.ctor].from(value.array);
              }

              _deserializeTypedArrayViewRef(value) {
                const {
                  offset,
                  length,
                  ctor: constructorName
                } = value;
                const obj = new globalThis[constructorName](this._mainBinChunk.buffer, this._mainBinChunk.byteOffset + offset, length);
                return obj;
              }

              _deserializeArray(value) {
                const obj = new Array(value.length);
                let prop;

                for (let i = 0; i < value.length; i++) {
                  prop = value[i];

                  if (typeof prop === 'object' && prop) {
                    const isAssetType = this._deserializeAndAssignField(obj, prop, `${i}`);

                    if (isAssetType) {
                      obj[i] = null;
                    }
                  } else {
                    obj[i] = prop;
                  }
                }

                return obj;
              }

              _deserializePlainObject(value) {
                const obj = {};

                this._fillPlainObject(obj, value);

                return obj;
              }

              _deserializeTypeTaggedObject(value, globalIndex, owner, propName) {
                const type = value.__type__;

                const klass = this._classFinder(type, value, owner, propName);

                if (!klass) {
                  const notReported = this._classFinder === _getClassById;

                  if (notReported) {
                    this._reportMissingClass(type);
                  }

                  return null;
                }

                const createObject = constructor => {
                  const obj = new constructor();

                  if (globalIndex >= 0) {
                    this.deserializedList[globalIndex] = obj;
                  }

                  return obj;
                };

                {
                  const obj = createObject(klass);

                  this._deserializeInto(value, obj, klass);

                  return obj;
                }
              }

              _deserializeInto(value, object, constructor, skipCustomized = false) {
                if (!skipCustomized && object[deserializeTag]) {
                  this._runCustomizedDeserialize(value, object, constructor);

                  return;
                }

                if (object._deserialize) {
                  object._deserialize(value.content, this);

                  return;
                }

                if (legacyCC.Class._isCCClass(constructor)) {
                  this._deserializeFireClass(object, value, constructor);
                } else {
                  this._deserializeFastDefinedObject(object, value, constructor);
                }
              }

              _runCustomizedDeserialize(value, object, constructor) {
                const serializationInput = {
                  readProperty: name => {
                    const serializedField = value[name];

                    if (typeof serializedField !== 'object' || !serializedField) {
                      return serializedField;
                    } else {
                      return this._deserializeObjectField(serializedField);
                    }
                  },
                  readThis: () => {
                    this._deserializeInto(value, object, constructor, true);
                  },
                  readSuper: () => {
                    const superConstructor = getSuper(constructor);

                    if (superConstructor) {
                      this._deserializeInto(value, object, superConstructor);
                    }
                  }
                };
                object[deserializeTag](serializationInput, this._context);
              }

              _deserializeFireClass(obj, serialized, klass) {
                let deserialize;

                if (klass.hasOwnProperty('__deserialize__')) {
                  deserialize = klass.__deserialize__;
                } else {
                  deserialize = compileDeserialize(this, klass);
                  value(klass, '__deserialize__', deserialize, true);
                }

                deserialize(this, obj, serialized, klass);
              }

              _deserializeAndAssignField(obj, serializedField, propName) {
                const id = serializedField.__id__;

                if (typeof id === 'number') {
                  const field = this.deserializedList[id];

                  if (field) {
                    obj[propName] = field;
                  } else {
                    var _this$_onDereferenced;

                    const source = this._serializedData[id];

                    {
                      obj[propName] = this._deserializeObject(source, id, undefined, propName);
                    }

                    (_this$_onDereferenced = this._onDereferenced) === null || _this$_onDereferenced === void 0 ? void 0 : _this$_onDereferenced.call(this, this.deserializedList, id, obj, propName);
                  }
                } else {
                  const uuid = serializedField.__uuid__;

                  if (uuid) {
                    const expectedType = serializedField.__expectedType__;
                    this.result.push(obj, propName, uuid, expectedType);
                  } else {
                    obj[propName] = this._deserializeObject(serializedField, -1);
                  }
                }

                return false;
              }

              _deserializeObjectField(serializedField) {
                const id = serializedField.__id__;

                if (typeof id === 'number') {
                  const field = this.deserializedList[id];

                  if (field) {
                    return field;
                  } else {
                    const source = this._serializedData[id];

                    const field = this._deserializeObject(source, id, undefined, undefined);

                    return field;
                  }
                } else {
                  const uuid = serializedField.__uuid__;

                  if (uuid) {
                    const _expectedType = serializedField.__expectedType__;
                    throw new Error(`Asset reference field serialization is currently not supported in custom serialization.`);
                  } else {
                    return this._deserializeObject(serializedField, -1);
                  }
                }
              }

              _fillPlainObject(instance, serialized) {
                for (const propName in serialized) {
                  if (!serialized.hasOwnProperty(propName)) {
                    continue;
                  }

                  const prop = serialized[propName];

                  if (typeof prop !== 'object') {
                    if (propName !== '__type__') {
                        instance[propName] = prop;
                      }
                  } else if (prop) {
                    const isAssetType = this._deserializeAndAssignField(instance, prop, propName);

                    if (isAssetType) {
                      instance[propName] = null;
                    }
                  } else {
                    instance[propName] = null;
                  }
                }
              }

              _deserializeFastDefinedObject(instance, serialized, klass) {
                if (klass === legacyCC.Vec2) {
                  instance.x = serialized.x || 0;
                  instance.y = serialized.y || 0;
                  return;
                } else if (klass === legacyCC.Vec3) {
                  instance.x = serialized.x || 0;
                  instance.y = serialized.y || 0;
                  instance.z = serialized.z || 0;
                  return;
                } else if (klass === legacyCC.Color) {
                  instance.r = serialized.r || 0;
                  instance.g = serialized.g || 0;
                  instance.b = serialized.b || 0;
                  const a = serialized.a;
                  instance.a = a === undefined ? 255 : a;
                  return;
                } else if (klass === legacyCC.Size) {
                  instance.width = serialized.width || 0;
                  instance.height = serialized.height || 0;
                  return;
                }

                const attrs = getClassAttrs(klass);
                const props = klass.__values__;

                if ( !props) {
                  error(`Unable to deserialize ${getClassName(klass)}. ` + 'For non-CCClass types, they can only be marked as serializable by `CCClass.fastDefine`.');
                }

                for (let i = 0; i < props.length; i++) {
                  const propName = props[i];
                  let value = serialized[propName];
                  const exists = value !== undefined || serialized.hasOwnProperty(propName);

                  if (!exists) {
                    value = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);
                  }

                  if (typeof value !== 'object') {
                    instance[propName] = value;
                  } else if (value) {
                    this._deserializeAndAssignField(instance, value, propName);
                  } else {
                    instance[propName] = null;
                  }
                }
              }

            }

            _Deserializer.pool = new DeserializerPool();
            function deserializeDynamic(data, details, options) {
              var _options$reportMissin;

              options = options || {};
              const classFinder = options.classFinder || _getClassById;
              const createAssetRefs = options.createAssetRefs || sys.platform === Platform.EDITOR_CORE;
              const customEnv = options.customEnv;
              const ignoreEditorOnly = options.ignoreEditorOnly;
              const reportMissingClass = (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : legacyCC.deserialize.reportMissingClass;
              details.init();

              const deserializer = _Deserializer.pool.get(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);

              legacyCC.game._isCloning = true;
              const res = deserializer.deserialize(data);
              legacyCC.game._isCloning = false;

              _Deserializer.pool.put(deserializer);

              if (createAssetRefs) {
                details.assignAssetsBy(EditorExtends.serialize.asAsset);
              }

              return res;
            }

            function reportMissingClass(id) {
              {
                warnID(5302, id);
              }
            }

            const SUPPORT_MIN_FORMAT_VERSION = 1;
            const EMPTY_PLACEHOLDER = 0;
            const BuiltinValueTypes = [Vec2, Vec3, Vec4, Quat, Color, Size, Rect, Mat4];

            function BuiltinValueTypeParsers_xyzw(obj, data) {
              obj.x = data[1];
              obj.y = data[2];
              obj.z = data[3];
              obj.w = data[4];
            }

            const BuiltinValueTypeSetters = [(obj, data) => {
              obj.x = data[1];
              obj.y = data[2];
            }, (obj, data) => {
              obj.x = data[1];
              obj.y = data[2];
              obj.z = data[3];
            }, BuiltinValueTypeParsers_xyzw, BuiltinValueTypeParsers_xyzw, (obj, data) => {
              obj._val = data[1];
            }, (obj, data) => {
              obj.width = data[1];
              obj.height = data[2];
            }, (obj, data) => {
              obj.x = data[1];
              obj.y = data[2];
              obj.width = data[3];
              obj.height = data[4];
            }, (obj, data) => {
              Mat4.fromArray(obj, data, 1);
            }];

            const DataTypeID = {
              SimpleType: 0,
              InstanceRef: 1,
              Array_InstanceRef: 2,
              Array_AssetRefByInnerObj: 3,
              Class: 4,
              ValueTypeCreated: 5,
              AssetRefByInnerObj: 6,
              TRS: 7,
              ValueType: 8,
              Array_Class: 9,
              CustomizedClass: 10,
              Dict: 11,
              Array: 12,
              ARRAY_LENGTH: 13
            };
            const CLASS_TYPE = 0;
            const CLASS_KEYS = 1;
            const CLASS_PROP_TYPE_OFFSET = 2;
            const MASK_CLASS = 0;
            const OBJ_DATA_MASK = 0;
            const CUSTOM_OBJ_DATA_CLASS = 0;
            const CUSTOM_OBJ_DATA_CONTENT = 1;
            const VALUETYPE_SETTER = 0;
            const DICT_JSON_LAYOUT = 0;
            const ARRAY_ITEM_VALUES = 0;
            const Refs = {
              EACH_RECORD_LENGTH: 3,
              OWNER_OFFSET: 0,
              KEY_OFFSET: 1,
              TARGET_OFFSET: 2
            };
            const File = {
              Version: 0,
              Context: 0,
              SharedUuids: 1,
              SharedStrings: 2,
              SharedClasses: 3,
              SharedMasks: 4,
              Instances: 5,
              InstanceTypes: 6,
              Refs: 7,
              DependObjs: 8,
              DependKeys: 9,
              DependUuidIndices: 10,
              ARRAY_LENGTH: 11
            };
            const PACKED_SECTIONS = File.Instances;
            class Details {
              constructor() {
                this.uuidObjList = null;
                this.uuidPropList = null;
                this.uuidList = null;
                this.uuidTypeList = [];
              }

              init(data) {
                if ( data) {
                  this.uuidObjList = data[File.DependObjs];
                  this.uuidPropList = data[File.DependKeys];
                  this.uuidList = data[File.DependUuidIndices];
                } else {
                  const used = this.uuidList;

                  if (!used) {
                    this.uuidList = [];
                    this.uuidObjList = [];
                    this.uuidPropList = [];
                    this.uuidTypeList = [];
                  }
                }
              }

              reset() {
                {
                  const used = this.uuidList;

                  if (used) {
                    this.uuidList.length = 0;
                    this.uuidObjList.length = 0;
                    this.uuidPropList.length = 0;
                    this.uuidTypeList.length = 0;
                  }
                }
              }

              push(obj, propName, uuid, type) {
                this.uuidObjList.push(obj);
                this.uuidPropList.push(propName);
                this.uuidList.push(uuid);
                this.uuidTypeList.push(type || '');
              }

            } exports('e$', Details);
            Details.pool = new Pool$1(obj => {
              obj.reset();
            }, 5);

            Details.pool.get = function () {
              return this._get() || new Details();
            };

            function dereference(refs, instances, strings) {
              const dataLength = refs.length - 1;
              let i = 0;
              const instanceOffset = refs[dataLength] * Refs.EACH_RECORD_LENGTH;

              for (; i < instanceOffset; i += Refs.EACH_RECORD_LENGTH) {
                const owner = refs[i];
                const target = instances[refs[i + Refs.TARGET_OFFSET]];
                const keyIndex = refs[i + Refs.KEY_OFFSET];

                if (keyIndex >= 0) {
                  owner[strings[keyIndex]] = target;
                } else {
                  owner[~keyIndex] = target;
                }
              }

              for (; i < dataLength; i += Refs.EACH_RECORD_LENGTH) {
                const owner = instances[refs[i]];
                const target = instances[refs[i + Refs.TARGET_OFFSET]];
                const keyIndex = refs[i + Refs.KEY_OFFSET];

                if (keyIndex >= 0) {
                  owner[strings[keyIndex]] = target;
                } else {
                  owner[~keyIndex] = target;
                }
              }
            }

            function deserializeCCObject(data, objectData) {
              const mask = data[File.SharedMasks][objectData[OBJ_DATA_MASK]];
              const clazz = mask[MASK_CLASS];
              const ctor = clazz[CLASS_TYPE];
              const obj = new ctor();
              const keys = clazz[CLASS_KEYS];
              const classTypeOffset = clazz[CLASS_PROP_TYPE_OFFSET];
              const maskTypeOffset = mask[mask.length - 1];
              let i = MASK_CLASS + 1;

              for (; i < maskTypeOffset; ++i) {
                const key = keys[mask[i]];
                obj[key] = objectData[i];
              }

              for (; i < objectData.length; ++i) {
                const key = keys[mask[i]];
                const type = clazz[mask[i] + classTypeOffset];
                const op = ASSIGNMENTS[type];
                op(data, obj, key, objectData[i]);
              }

              return obj;
            }

            function deserializeCustomCCObject(data, ctor, value) {
              const obj = new ctor();

              if (obj._deserialize) {
                obj._deserialize(value, data[File.Context]);
              } else {
                errorID(5303, getClassName(ctor));
              }

              return obj;
            }

            function assignSimple(data, owner, key, value) {
              owner[key] = value;
            }

            function assignInstanceRef(data, owner, key, value) {
              if (value >= 0) {
                owner[key] = data[File.Instances][value];
              } else {
                data[File.Refs][~value * Refs.EACH_RECORD_LENGTH] = owner;
              }
            }

            function genArrayParser(parser) {
              return (data, owner, key, value) => {
                owner[key] = value;

                for (let i = 0; i < value.length; ++i) {
                  parser(data, value, i, value[i]);
                }
              };
            }

            function parseAssetRefByInnerObj(data, owner, key, value) {
              owner[key] = null;
              data[File.DependObjs][value] = owner;
            }

            function parseClass(data, owner, key, value) {
              owner[key] = deserializeCCObject(data, value);
            }

            function parseCustomClass(data, owner, key, value) {
              const ctor = data[File.SharedClasses][value[CUSTOM_OBJ_DATA_CLASS]];
              owner[key] = deserializeCustomCCObject(data, ctor, value[CUSTOM_OBJ_DATA_CONTENT]);
            }

            function parseValueTypeCreated(data, owner, key, value) {
              BuiltinValueTypeSetters[value[VALUETYPE_SETTER]](owner[key], value);
            }

            function parseValueType(data, owner, key, value) {
              const val = new BuiltinValueTypes[value[VALUETYPE_SETTER]]();
              BuiltinValueTypeSetters[value[VALUETYPE_SETTER]](val, value);
              owner[key] = val;
            }

            function parseTRS(data, owner, key, value) {
              const typedArray = owner[key];
              typedArray.set(value);
            }

            function parseDict(data, owner, key, value) {
              const dict = value[DICT_JSON_LAYOUT];
              owner[key] = dict;

              for (let i = DICT_JSON_LAYOUT + 1; i < value.length; i += 3) {
                const subKey = value[i];
                const subType = value[i + 1];
                const subValue = value[i + 2];
                const op = ASSIGNMENTS[subType];
                op(data, dict, subKey, subValue);
              }
            }

            function parseArray(data, owner, key, value) {
              const array = value[ARRAY_ITEM_VALUES];
              owner[key] = array;

              for (let i = 0; i < array.length; ++i) {
                const subValue = array[i];
                const type = value[i + 1];

                if (type !== DataTypeID.SimpleType) {
                  const op = ASSIGNMENTS[type];
                  op(data, array, i, subValue);
                }
              }
            }

            const ASSIGNMENTS = new Array(DataTypeID.ARRAY_LENGTH);
            ASSIGNMENTS[DataTypeID.SimpleType] = assignSimple;
            ASSIGNMENTS[DataTypeID.InstanceRef] = assignInstanceRef;
            ASSIGNMENTS[DataTypeID.Array_InstanceRef] = genArrayParser(assignInstanceRef);
            ASSIGNMENTS[DataTypeID.Array_AssetRefByInnerObj] = genArrayParser(parseAssetRefByInnerObj);
            ASSIGNMENTS[DataTypeID.Class] = parseClass;
            ASSIGNMENTS[DataTypeID.ValueTypeCreated] = parseValueTypeCreated;
            ASSIGNMENTS[DataTypeID.AssetRefByInnerObj] = parseAssetRefByInnerObj;
            ASSIGNMENTS[DataTypeID.TRS] = parseTRS;
            ASSIGNMENTS[DataTypeID.ValueType] = parseValueType;
            ASSIGNMENTS[DataTypeID.Array_Class] = genArrayParser(parseClass);
            ASSIGNMENTS[DataTypeID.CustomizedClass] = parseCustomClass;
            ASSIGNMENTS[DataTypeID.Dict] = parseDict;
            ASSIGNMENTS[DataTypeID.Array] = parseArray;

            function parseInstances(data) {
              const instances = data[File.Instances];
              const instanceTypes = data[File.InstanceTypes];
              const instanceTypesLen = instanceTypes === EMPTY_PLACEHOLDER ? 0 : instanceTypes.length;
              let rootIndex = instances[instances.length - 1];
              let normalObjectCount = instances.length - instanceTypesLen;

              if (typeof rootIndex !== 'number') {
                rootIndex = 0;
              } else {
                if (rootIndex < 0) {
                  rootIndex = ~rootIndex;
                }

                --normalObjectCount;
              }

              let insIndex = 0;

              for (; insIndex < normalObjectCount; ++insIndex) {
                instances[insIndex] = deserializeCCObject(data, instances[insIndex]);
              }

              const classes = data[File.SharedClasses];

              for (let typeIndex = 0; typeIndex < instanceTypesLen; ++typeIndex, ++insIndex) {
                let type = instanceTypes[typeIndex];
                const eachData = instances[insIndex];

                if (type >= 0) {
                  const ctor = classes[type];
                  instances[insIndex] = deserializeCustomCCObject(data, ctor, eachData);
                } else {
                  type = ~type;
                  const op = ASSIGNMENTS[type];
                  op(data, instances, insIndex, eachData);
                }
              }

              return rootIndex;
            }

            function getMissingClass(hasCustomFinder, type, reportMissingClass) {
              if (!hasCustomFinder) {
                reportMissingClass(type);
              }

              return Object;
            }

            function doLookupClass(classFinder, type, container, index, silent, hasCustomFinder, reportMissingClass) {
              let klass = classFinder(type);

              if (!klass) {
                if (silent) {
                  container[index] = ((c, i, t) => function proxy() {
                    const actualClass = classFinder(t) || getMissingClass(hasCustomFinder, t, reportMissingClass);
                    c[i] = actualClass;
                    return new actualClass();
                  })(container, index, type);

                  return;
                } else {
                  klass = getMissingClass(hasCustomFinder, type, reportMissingClass);
                }
              }

              container[index] = klass;
            }

            function lookupClasses(data, silent, customFinder, reportMissingClass) {
              const classFinder = customFinder || _getClassById;
              const classes = data[File.SharedClasses];

              for (let i = 0; i < classes.length; ++i) {
                const klassLayout = classes[i];

                if (typeof klassLayout !== 'string') {
                  {
                    if (typeof klassLayout[CLASS_TYPE] === 'function') {
                      throw new Error('Can not deserialize the same JSON data again.');
                    }
                  }

                  const type = klassLayout[CLASS_TYPE];
                  doLookupClass(classFinder, type, klassLayout, CLASS_TYPE, silent, customFinder, reportMissingClass);
                } else {
                  doLookupClass(classFinder, klassLayout, classes, i, silent, customFinder, reportMissingClass);
                }
              }
            }

            function cacheMasks(data) {
              const masks = data[File.SharedMasks];

              if (masks) {
                const classes = data[File.SharedClasses];

                for (let i = 0; i < masks.length; ++i) {
                  const mask = masks[i];
                  mask[MASK_CLASS] = classes[mask[MASK_CLASS]];
                }
              }
            }

            function parseResult(data) {
              const instances = data[File.Instances];
              const sharedStrings = data[File.SharedStrings];
              const dependSharedUuids = data[File.SharedUuids];
              const dependObjs = data[File.DependObjs];
              const dependKeys = data[File.DependKeys];
              const dependUuids = data[File.DependUuidIndices];

              for (let i = 0; i < dependObjs.length; ++i) {
                const obj = dependObjs[i];

                if (typeof obj === 'number') {
                  dependObjs[i] = instances[obj];
                }

                let key = dependKeys[i];

                if (typeof key === 'number') {
                  if (key >= 0) {
                    key = sharedStrings[key];
                  } else {
                    key = ~key;
                  }

                  dependKeys[i] = key;
                }

                const uuid = dependUuids[i];

                if (typeof uuid === 'number') {
                  dependUuids[i] = dependSharedUuids[uuid];
                }
              }
            }

            function isCompiledJson(json) {
              if (Array.isArray(json)) {
                const version = json[0];
                return typeof version === 'number' || version instanceof FileInfo;
              } else {
                return false;
              }
            }
            function deserialize(data, details, options) {
              if (typeof data === 'string') {
                data = JSON.parse(data);
              }

              const borrowDetails = !details;
              details = details || Details.pool.get();
              let res;

              if ( !isCompiledJson(data)) {
                res = deserializeDynamic(data, details, options);
              } else {
                details.init(data);
                options = options || {};
                let version = data[File.Version];
                let preprocessed = false;

                if (typeof version === 'object') {
                  preprocessed = version.preprocessed;
                  version = version.version;
                }

                if (version < SUPPORT_MIN_FORMAT_VERSION) {
                  throw new Error(getError(5304, version));
                }

                options._version = version;
                options.result = details;
                data[File.Context] = options;

                if (!preprocessed) {
                  var _options$reportMissin;

                  lookupClasses(data, false, options.classFinder, (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : deserialize.reportMissingClass);
                  cacheMasks(data);
                }

                legacyCC.game._isCloning = true;
                const instances = data[File.Instances];
                const rootIndex = parseInstances(data);
                legacyCC.game._isCloning = false;

                if (data[File.Refs]) {
                  dereference(data[File.Refs], instances, data[File.SharedStrings]);
                }

                parseResult(data);
                res = instances[rootIndex];
              }

              if (borrowDetails) {
                Details.pool.put(details);
              }

              return res;
            }
            deserialize.Details = Details;
            deserialize.reportMissingClass = reportMissingClass;

            class FileInfo {
              constructor(version) {
                this.preprocessed = true;
                this.version = version;
              }

            }

            function unpackJSONs(data, classFinder, reportMissingClass) {
              if (data[File.Version] < SUPPORT_MIN_FORMAT_VERSION) {
                throw new Error(getError(5304, data[File.Version]));
              }

              lookupClasses(data, true, classFinder, reportMissingClass !== null && reportMissingClass !== void 0 ? reportMissingClass : deserialize.reportMissingClass);
              cacheMasks(data);
              const version = new FileInfo(data[File.Version]);
              const sharedUuids = data[File.SharedUuids];
              const sharedStrings = data[File.SharedStrings];
              const sharedClasses = data[File.SharedClasses];
              const sharedMasks = data[File.SharedMasks];
              const sections = data[PACKED_SECTIONS];

              for (let i = 0; i < sections.length; ++i) {
                sections[i].unshift(version, sharedUuids, sharedStrings, sharedClasses, sharedMasks);
              }

              return sections;
            }
            function packCustomObjData(type, data, hasNativeDep) {
              return [SUPPORT_MIN_FORMAT_VERSION, EMPTY_PLACEHOLDER, EMPTY_PLACEHOLDER, [type], EMPTY_PLACEHOLDER, hasNativeDep ? [data, ~0] : [data], [0], EMPTY_PLACEHOLDER, [], [], []];
            }
            function hasNativeDep(data) {
              const instances = data[File.Instances];
              const rootInfo = instances[instances.length - 1];

              if (typeof rootInfo !== 'number') {
                return false;
              } else {
                return rootInfo < 0;
              }
            }

            function getDependUuidList(json) {
              const sharedUuids = json[File.SharedUuids];
              return json[File.DependUuidIndices].map(index => sharedUuids[index]);
            }

            function parseUuidDependencies(serialized) {
              {
                return getDependUuidList(serialized);
              }
            }

            legacyCC.deserialize = deserialize;

            const Destroyed$1 = CCObject.Flags.Destroyed;
            const PersistentMask$1 = CCObject.Flags.PersistentMask;
            const objsToClearTmpVar = [];
            function instantiate(original, internalForce) {

              let clone;

              if (original instanceof CCObject) {
                if (original._instantiate) {
                  legacyCC.game._isCloning = true;
                  clone = original._instantiate(null, true);
                  legacyCC.game._isCloning = false;
                  return clone;
                } else if (original instanceof legacyCC.Asset) {
                  throw new TypeError(getError(6903));
                }
              }

              legacyCC.game._isCloning = true;
              clone = doInstantiate(original);
              legacyCC.game._isCloning = false;
              return clone;
            }

            function doInstantiate(obj, parent) {

              let clone;

              if (obj._iN$t) {
                clone = obj._iN$t;
              } else if (obj.constructor) {
                const klass = obj.constructor;
                clone = new klass();
              } else {
                clone = Object.create(null);
              }

              enumerateObject(obj, clone, parent);

              for (let i = 0, len = objsToClearTmpVar.length; i < len; ++i) {
                objsToClearTmpVar[i]._iN$t = null;
              }

              objsToClearTmpVar.length = 0;
              return clone;
            }

            function enumerateCCClass(klass, obj, clone, parent) {
              const props = klass.__values__;

              for (let p = 0; p < props.length; p++) {
                const key = props[p];
                const value = obj[key];

                if (typeof value === 'object' && value) {
                  const initValue = clone[key];

                  if (initValue instanceof ValueType && initValue.constructor === value.constructor) {
                    initValue.set(value);
                  } else {
                    clone[key] = value._iN$t || instantiateObj(value, parent);
                  }
                } else {
                  clone[key] = value;
                }
              }
            }

            function enumerateObject(obj, clone, parent) {
              js.value(obj, '_iN$t', clone, true);
              objsToClearTmpVar.push(obj);
              const klass = obj.constructor;

              if (legacyCC.Class._isCCClass(klass)) {
                enumerateCCClass(klass, obj, clone, parent);
              } else {
                for (const key in obj) {
                  if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__') {
                    continue;
                  }

                  const value = obj[key];

                  if (typeof value === 'object' && value) {
                    if (value === clone) {
                      continue;
                    }

                    clone[key] = value._iN$t || instantiateObj(value, parent);
                  } else {
                    clone[key] = value;
                  }
                }
              }

              if (obj instanceof CCObject) {
                clone._objFlags &= PersistentMask$1;
              }
            }

            function instantiateObj(obj, parent) {
              if (obj instanceof ValueType) {
                return obj.clone();
              }

              if (obj instanceof legacyCC.Asset) {
                return obj;
              }

              let clone;

              if (ArrayBuffer.isView(obj)) {
                const len = obj.length;
                clone = new obj.constructor(len);
                obj._iN$t = clone;
                objsToClearTmpVar.push(obj);

                for (let i = 0; i < len; ++i) {
                  clone[i] = obj[i];
                }

                return clone;
              }

              if (Array.isArray(obj)) {
                const len = obj.length;
                clone = new Array(len);
                obj._iN$t = clone;
                objsToClearTmpVar.push(obj);

                for (let i = 0; i < len; ++i) {
                  const value = obj[i];

                  if (typeof value === 'object' && value) {
                    clone[i] = value._iN$t || instantiateObj(value, parent);
                  } else {
                    clone[i] = value;
                  }
                }

                return clone;
              } else if (obj._objFlags & Destroyed$1) {
                return null;
              }

              const ctor = obj.constructor;

              if (legacyCC.Class._isCCClass(ctor)) {
                if (parent) {
                  if (parent instanceof legacyCC.Component) {
                    if (obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component) {
                      return obj;
                    }
                  } else if (parent instanceof legacyCC._BaseNode) {
                    if (obj instanceof legacyCC._BaseNode) {
                      if (!obj.isChildOf(parent)) {
                        return obj;
                      }
                    } else if (obj instanceof legacyCC.Component) {
                      if (obj.node && !obj.node.isChildOf(parent)) {
                        return obj;
                      }
                    }
                  }
                }

                clone = new ctor();
              } else if (ctor === Object) {
                clone = {};
              } else if (!ctor) {
                clone = Object.create(null);
              } else {
                return obj;
              }

              enumerateObject(obj, clone, parent);
              return clone;
            }

            instantiate._clone = doInstantiate;
            legacyCC.instantiate = instantiate;

            var _dec$6, _class$6, _class2$5, _descriptor$4, _descriptor2$2, _descriptor3$1, _descriptor4, _class3$2, _temp$4;
            let StorageUnit;

            (function (StorageUnit) {
              StorageUnit[StorageUnit["Uint8"] = 0] = "Uint8";
              StorageUnit[StorageUnit["Uint16"] = 1] = "Uint16";
              StorageUnit[StorageUnit["Uint32"] = 2] = "Uint32";
              StorageUnit[StorageUnit["Int8"] = 3] = "Int8";
              StorageUnit[StorageUnit["Int16"] = 4] = "Int16";
              StorageUnit[StorageUnit["Int32"] = 5] = "Int32";
              StorageUnit[StorageUnit["Float32"] = 6] = "Float32";
              StorageUnit[StorageUnit["Float64"] = 7] = "Float64";
            })(StorageUnit || (StorageUnit = {}));

            let ElementType;

            (function (ElementType) {
              ElementType[ElementType["Scalar"] = 0] = "Scalar";
              ElementType[ElementType["Vec2"] = 1] = "Vec2";
              ElementType[ElementType["Vec3"] = 2] = "Vec3";
              ElementType[ElementType["Vec4"] = 3] = "Vec4";
              ElementType[ElementType["Quat"] = 4] = "Quat";
              ElementType[ElementType["Mat4"] = 5] = "Mat4";
            })(ElementType || (ElementType = {}));

            const elementTypeBits = 3;
            function combineStorageUnitElementType(unit, elementType) {
              return (elementType << elementTypeBits) + unit;
            }
            function extractStorageUnitElementType(combined) {
              return {
                storageUnit: ~(-1 << elementTypeBits) & combined,
                elementType: combined >> elementTypeBits
              };
            }
            let CompactValueTypeArray = exports('f1', (_dec$6 = ccclass('cc.CompactValueTypeArray'), _dec$6(_class$6 = (_class2$5 = (_temp$4 = _class3$2 = class CompactValueTypeArray {
              constructor() {
                _initializerDefineProperty(this, "_byteOffset", _descriptor$4, this);

                _initializerDefineProperty(this, "_unitCount", _descriptor2$2, this);

                _initializerDefineProperty(this, "_unitElement", _descriptor3$1, this);

                _initializerDefineProperty(this, "_length", _descriptor4, this);
              }

              static lengthFor(values, elementType, unit) {
                const elementTraits = getElementTraits(elementType);
                return elementTraits.requiredUnits * values.length * getStorageConstructor(unit).BYTES_PER_ELEMENT;
              }

              static compress(values, elementType, unit, arrayBuffer, byteOffset, presumedByteOffset) {
                const elementTraits = getElementTraits(elementType);
                const storageConstructor = getStorageConstructor(unit);
                const unitCount = elementTraits.requiredUnits * values.length;
                const storage = new storageConstructor(arrayBuffer, byteOffset, unitCount);

                for (let i = 0; i < values.length; ++i) {
                  elementTraits.compress(storage, i, values[i]);
                }

                const result = new CompactValueTypeArray();
                result._unitElement = combineStorageUnitElementType(unit, elementType);
                result._byteOffset = presumedByteOffset;
                result._unitCount = unitCount;
                result._length = values.length;
                return result;
              }

              decompress(arrayBuffer) {
                const {
                  storageUnit,
                  elementType
                } = extractStorageUnitElementType(this._unitElement);
                const elementTraits = getElementTraits(elementType);
                const storageConstructor = getStorageConstructor(storageUnit);
                const storage = new storageConstructor(arrayBuffer, this._byteOffset, this._unitCount);
                const result = new Array(this._length);

                for (let i = 0; i < this._length; ++i) {
                  result[i] = elementTraits.decompress(storage, i);
                }

                return result;
              }

            }, _class3$2.StorageUnit = StorageUnit, _class3$2.ElementType = ElementType, _temp$4), (_descriptor$4 = _applyDecoratedDescriptor(_class2$5.prototype, "_byteOffset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$2 = _applyDecoratedDescriptor(_class2$5.prototype, "_unitCount", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor3$1 = _applyDecoratedDescriptor(_class2$5.prototype, "_unitElement", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return combineStorageUnitElementType(StorageUnit.Uint8, ElementType.Scalar);
              }
            }), _descriptor4 = _applyDecoratedDescriptor(_class2$5.prototype, "_length", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$5)) || _class$6));

            function getElementTraits(elementType) {
              return BuiltinElementTypeTraits[elementType];
            }

            function getStorageConstructor(unit) {
              switch (unit) {
                case StorageUnit.Uint8:
                  return Uint8Array;

                case StorageUnit.Uint16:
                  return Uint16Array;

                case StorageUnit.Uint32:
                  return Uint32Array;

                case StorageUnit.Int8:
                  return Int8Array;

                case StorageUnit.Int16:
                  return Int16Array;

                case StorageUnit.Int32:
                  return Int32Array;

                case StorageUnit.Float32:
                  return Float32Array;

                case StorageUnit.Float64:
                  return Float64Array;
              }
            }

            const BuiltinElementTypeTraits = {
              [ElementType.Scalar]: {
                requiredUnits: 1,

                compress(storage, index, value) {
                  storage[index] = value;
                },

                decompress(storage, index) {
                  return storage[index];
                }

              },
              [ElementType.Vec2]: {
                requiredUnits: 2,

                compress(storage, index, value) {
                  storage[index * 2] = value.x;
                  storage[index * 2 + 1] = value.y;
                },

                decompress(storage, index) {
                  return new Vec3(storage[index * 2], storage[index * 2 + 1]);
                }

              },
              [ElementType.Vec3]: {
                requiredUnits: 3,

                compress(storage, index, value) {
                  storage[index * 3] = value.x;
                  storage[index * 3 + 1] = value.y;
                  storage[index * 3 + 2] = value.z;
                },

                decompress(storage, index) {
                  return new Vec3(storage[index * 3], storage[index * 3 + 1], storage[index * 3 + 2]);
                }

              },
              [ElementType.Vec4]: {
                requiredUnits: 4,

                compress(storage, index, value) {
                  storage[index * 4] = value.x;
                  storage[index * 4 + 1] = value.y;
                  storage[index * 4 + 2] = value.z;
                  storage[index * 4 + 3] = value.w;
                },

                decompress(storage, index) {
                  return new Vec4(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
                }

              },
              [ElementType.Quat]: {
                requiredUnits: 4,

                compress(storage, index, value) {
                  storage[index * 4] = value.x;
                  storage[index * 4 + 1] = value.y;
                  storage[index * 4 + 2] = value.z;
                  storage[index * 4 + 3] = value.w;
                },

                decompress(storage, index) {
                  return new Quat(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
                }

              },
              [ElementType.Mat4]: {
                requiredUnits: 16,

                compress(storage, index, value) {
                  Mat4.toArray(storage, value, index * 16);
                },

                decompress(storage, index) {
                  return Mat4.fromArray(new Mat4(), storage, index * 16);
                }

              }
            };

            legacyCC._decorator = _decorator;

            function constant() {
              return 0;
            }
            function linear(k) {
              return k;
            }
            function quadIn(k) {
              return k * k;
            }
            function quadOut(k) {
              return k * (2 - k);
            }
            function quadInOut(k) {
              k *= 2;

              if (k < 1) {
                return 0.5 * k * k;
              }

              return -0.5 * (--k * (k - 2) - 1);
            }
            function cubicIn(k) {
              return k * k * k;
            }
            function cubicOut(k) {
              return --k * k * k + 1;
            }
            function cubicInOut(k) {
              k *= 2;

              if (k < 1) {
                return 0.5 * k * k * k;
              }

              return 0.5 * ((k -= 2) * k * k + 2);
            }
            function quartIn(k) {
              return k * k * k * k;
            }
            function quartOut(k) {
              return 1 - --k * k * k * k;
            }
            function quartInOut(k) {
              k *= 2;

              if (k < 1) {
                return 0.5 * k * k * k * k;
              }

              return -0.5 * ((k -= 2) * k * k * k - 2);
            }
            function quintIn(k) {
              return k * k * k * k * k;
            }
            function quintOut(k) {
              return --k * k * k * k * k + 1;
            }
            function quintInOut(k) {
              k *= 2;

              if (k < 1) {
                return 0.5 * k * k * k * k * k;
              }

              return 0.5 * ((k -= 2) * k * k * k * k + 2);
            }
            function sineIn(k) {
              if (k === 1) {
                return 1;
              }

              return 1 - Math.cos(k * Math.PI / 2);
            }
            function sineOut(k) {
              return Math.sin(k * Math.PI / 2);
            }
            function sineInOut(k) {
              return 0.5 * (1 - Math.cos(Math.PI * k));
            }
            function expoIn(k) {
              return k === 0 ? 0 : Math.pow(1024, k - 1);
            }
            function expoOut(k) {
              return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
            }
            function expoInOut(k) {
              if (k === 0) {
                return 0;
              }

              if (k === 1) {
                return 1;
              }

              k *= 2;

              if (k < 1) {
                return 0.5 * Math.pow(1024, k - 1);
              }

              return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
            }
            function circIn(k) {
              return 1 - Math.sqrt(1 - k * k);
            }
            function circOut(k) {
              return Math.sqrt(1 - --k * k);
            }
            function circInOut(k) {
              k *= 2;

              if (k < 1) {
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
              }

              return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            }
            function elasticIn(k) {
              let s;
              let a = 0.1;
              const p = 0.4;

              if (k === 0) {
                return 0;
              }

              if (k === 1) {
                return 1;
              }

              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              }

              return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            }
            function elasticOut(k) {
              let s;
              let a = 0.1;
              const p = 0.4;

              if (k === 0) {
                return 0;
              }

              if (k === 1) {
                return 1;
              }

              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              }

              return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
            }
            function elasticInOut(k) {
              let s;
              let a = 0.1;
              const p = 0.4;

              if (k === 0) {
                return 0;
              }

              if (k === 1) {
                return 1;
              }

              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              }

              k *= 2;

              if (k < 1) {
                return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
              }

              return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
            }
            function backIn(k) {
              if (k === 1) {
                return 1;
              }

              const s = 1.70158;
              return k * k * ((s + 1) * k - s);
            }
            function backOut(k) {
              if (k === 0) {
                return 0;
              }

              const s = 1.70158;
              return --k * k * ((s + 1) * k + s) + 1;
            }
            function backInOut(k) {
              const s = 1.70158 * 1.525;
              k *= 2;

              if (k < 1) {
                return 0.5 * (k * k * ((s + 1) * k - s));
              }

              return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            }
            function bounceIn(k) {
              return 1 - bounceOut(1 - k);
            }
            function bounceOut(k) {
              if (k < 1 / 2.75) {
                return 7.5625 * k * k;
              } else if (k < 2 / 2.75) {
                return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
              } else if (k < 2.5 / 2.75) {
                return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
              } else {
                return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
              }
            }
            function bounceInOut(k) {
              if (k < 0.5) {
                return bounceIn(k * 2) * 0.5;
              }

              return bounceOut(k * 2 - 1) * 0.5 + 0.5;
            }
            function smooth(k) {
              if (k <= 0) {
                return 0;
              }

              if (k >= 1) {
                return 1;
              }

              return k * k * (3 - 2 * k);
            }
            function fade(k) {
              if (k <= 0) {
                return 0;
              }

              if (k >= 1) {
                return 1;
              }

              return k * k * k * (k * (k * 6 - 15) + 10);
            }
            const quadOutIn = _makeOutIn(quadIn, quadOut);
            const cubicOutIn = _makeOutIn(cubicIn, cubicOut);
            const quartOutIn = _makeOutIn(quartIn, quartOut);
            const quintOutIn = _makeOutIn(quintIn, quintOut);
            const sineOutIn = _makeOutIn(sineIn, sineOut);
            const expoOutIn = _makeOutIn(expoIn, expoOut);
            const circOutIn = _makeOutIn(circIn, circOut);
            const elasticOutIn = _makeOutIn(elasticIn, elasticOut);
            const backOutIn = _makeOutIn(backIn, backOut);
            const bounceOutIn = _makeOutIn(bounceIn, bounceOut);

            function _makeOutIn(fnIn, fnOut) {
              return k => {
                if (k < 0.5) {
                  return fnOut(k * 2) / 2;
                }

                return fnIn(2 * k - 1) / 2 + 0.5;
              };
            }

            var easing = /*#__PURE__*/Object.freeze({
                __proto__: null,
                constant: constant,
                linear: linear,
                quadIn: quadIn,
                quadOut: quadOut,
                quadInOut: quadInOut,
                cubicIn: cubicIn,
                cubicOut: cubicOut,
                cubicInOut: cubicInOut,
                quartIn: quartIn,
                quartOut: quartOut,
                quartInOut: quartInOut,
                quintIn: quintIn,
                quintOut: quintOut,
                quintInOut: quintInOut,
                sineIn: sineIn,
                sineOut: sineOut,
                sineInOut: sineInOut,
                expoIn: expoIn,
                expoOut: expoOut,
                expoInOut: expoInOut,
                circIn: circIn,
                circOut: circOut,
                circInOut: circInOut,
                elasticIn: elasticIn,
                elasticOut: elasticOut,
                elasticInOut: elasticInOut,
                backIn: backIn,
                backOut: backOut,
                backInOut: backInOut,
                bounceIn: bounceIn,
                bounceOut: bounceOut,
                bounceInOut: bounceInOut,
                smooth: smooth,
                fade: fade,
                quadOutIn: quadOutIn,
                cubicOutIn: cubicOutIn,
                quartOutIn: quartOutIn,
                quintOutIn: quintOutIn,
                sineOutIn: sineOutIn,
                expoOutIn: expoOutIn,
                circOutIn: circOutIn,
                elasticOutIn: elasticOutIn,
                backOutIn: backOutIn,
                bounceOutIn: bounceOutIn
            });
            exports('ei', easing);

            let EasingMethod;

            (function (EasingMethod) {
              EasingMethod[EasingMethod["LINEAR"] = 0] = "LINEAR";
              EasingMethod[EasingMethod["CONSTANT"] = 1] = "CONSTANT";
              EasingMethod[EasingMethod["QUAD_IN"] = 2] = "QUAD_IN";
              EasingMethod[EasingMethod["QUAD_OUT"] = 3] = "QUAD_OUT";
              EasingMethod[EasingMethod["QUAD_IN_OUT"] = 4] = "QUAD_IN_OUT";
              EasingMethod[EasingMethod["QUAD_OUT_IN"] = 5] = "QUAD_OUT_IN";
              EasingMethod[EasingMethod["CUBIC_IN"] = 6] = "CUBIC_IN";
              EasingMethod[EasingMethod["CUBIC_OUT"] = 7] = "CUBIC_OUT";
              EasingMethod[EasingMethod["CUBIC_IN_OUT"] = 8] = "CUBIC_IN_OUT";
              EasingMethod[EasingMethod["CUBIC_OUT_IN"] = 9] = "CUBIC_OUT_IN";
              EasingMethod[EasingMethod["QUART_IN"] = 10] = "QUART_IN";
              EasingMethod[EasingMethod["QUART_OUT"] = 11] = "QUART_OUT";
              EasingMethod[EasingMethod["QUART_IN_OUT"] = 12] = "QUART_IN_OUT";
              EasingMethod[EasingMethod["QUART_OUT_IN"] = 13] = "QUART_OUT_IN";
              EasingMethod[EasingMethod["QUINT_IN"] = 14] = "QUINT_IN";
              EasingMethod[EasingMethod["QUINT_OUT"] = 15] = "QUINT_OUT";
              EasingMethod[EasingMethod["QUINT_IN_OUT"] = 16] = "QUINT_IN_OUT";
              EasingMethod[EasingMethod["QUINT_OUT_IN"] = 17] = "QUINT_OUT_IN";
              EasingMethod[EasingMethod["SINE_IN"] = 18] = "SINE_IN";
              EasingMethod[EasingMethod["SINE_OUT"] = 19] = "SINE_OUT";
              EasingMethod[EasingMethod["SINE_IN_OUT"] = 20] = "SINE_IN_OUT";
              EasingMethod[EasingMethod["SINE_OUT_IN"] = 21] = "SINE_OUT_IN";
              EasingMethod[EasingMethod["EXPO_IN"] = 22] = "EXPO_IN";
              EasingMethod[EasingMethod["EXPO_OUT"] = 23] = "EXPO_OUT";
              EasingMethod[EasingMethod["EXPO_IN_OUT"] = 24] = "EXPO_IN_OUT";
              EasingMethod[EasingMethod["EXPO_OUT_IN"] = 25] = "EXPO_OUT_IN";
              EasingMethod[EasingMethod["CIRC_IN"] = 26] = "CIRC_IN";
              EasingMethod[EasingMethod["CIRC_OUT"] = 27] = "CIRC_OUT";
              EasingMethod[EasingMethod["CIRC_IN_OUT"] = 28] = "CIRC_IN_OUT";
              EasingMethod[EasingMethod["CIRC_OUT_IN"] = 29] = "CIRC_OUT_IN";
              EasingMethod[EasingMethod["ELASTIC_IN"] = 30] = "ELASTIC_IN";
              EasingMethod[EasingMethod["ELASTIC_OUT"] = 31] = "ELASTIC_OUT";
              EasingMethod[EasingMethod["ELASTIC_IN_OUT"] = 32] = "ELASTIC_IN_OUT";
              EasingMethod[EasingMethod["ELASTIC_OUT_IN"] = 33] = "ELASTIC_OUT_IN";
              EasingMethod[EasingMethod["BACK_IN"] = 34] = "BACK_IN";
              EasingMethod[EasingMethod["BACK_OUT"] = 35] = "BACK_OUT";
              EasingMethod[EasingMethod["BACK_IN_OUT"] = 36] = "BACK_IN_OUT";
              EasingMethod[EasingMethod["BACK_OUT_IN"] = 37] = "BACK_OUT_IN";
              EasingMethod[EasingMethod["BOUNCE_IN"] = 38] = "BOUNCE_IN";
              EasingMethod[EasingMethod["BOUNCE_OUT"] = 39] = "BOUNCE_OUT";
              EasingMethod[EasingMethod["BOUNCE_IN_OUT"] = 40] = "BOUNCE_IN_OUT";
              EasingMethod[EasingMethod["BOUNCE_OUT_IN"] = 41] = "BOUNCE_OUT_IN";
              EasingMethod[EasingMethod["SMOOTH"] = 42] = "SMOOTH";
              EasingMethod[EasingMethod["FADE"] = 43] = "FADE";
            })(EasingMethod || (EasingMethod = {}));

            const easingMethodFnMap = {
              [EasingMethod.CONSTANT]: constant,
              [EasingMethod.LINEAR]: linear,
              [EasingMethod.QUAD_IN]: quadIn,
              [EasingMethod.QUAD_OUT]: quadOut,
              [EasingMethod.QUAD_IN_OUT]: quadInOut,
              [EasingMethod.QUAD_OUT_IN]: quadOutIn,
              [EasingMethod.CUBIC_IN]: cubicIn,
              [EasingMethod.CUBIC_OUT]: cubicOut,
              [EasingMethod.CUBIC_IN_OUT]: cubicInOut,
              [EasingMethod.CUBIC_OUT_IN]: cubicOutIn,
              [EasingMethod.QUART_IN]: quartIn,
              [EasingMethod.QUART_OUT]: quartOut,
              [EasingMethod.QUART_IN_OUT]: quartInOut,
              [EasingMethod.QUART_OUT_IN]: quartOutIn,
              [EasingMethod.QUINT_IN]: quintIn,
              [EasingMethod.QUINT_OUT]: quintOut,
              [EasingMethod.QUINT_IN_OUT]: quintInOut,
              [EasingMethod.QUINT_OUT_IN]: quintOutIn,
              [EasingMethod.SINE_IN]: sineIn,
              [EasingMethod.SINE_OUT]: sineOut,
              [EasingMethod.SINE_IN_OUT]: sineInOut,
              [EasingMethod.SINE_OUT_IN]: sineOutIn,
              [EasingMethod.EXPO_IN]: expoIn,
              [EasingMethod.EXPO_OUT]: expoOut,
              [EasingMethod.EXPO_IN_OUT]: expoInOut,
              [EasingMethod.EXPO_OUT_IN]: expoOutIn,
              [EasingMethod.CIRC_IN]: circIn,
              [EasingMethod.CIRC_OUT]: circOut,
              [EasingMethod.CIRC_IN_OUT]: circInOut,
              [EasingMethod.CIRC_OUT_IN]: circOutIn,
              [EasingMethod.ELASTIC_IN]: elasticIn,
              [EasingMethod.ELASTIC_OUT]: elasticOut,
              [EasingMethod.ELASTIC_IN_OUT]: elasticInOut,
              [EasingMethod.ELASTIC_OUT_IN]: elasticOutIn,
              [EasingMethod.BACK_IN]: backIn,
              [EasingMethod.BACK_OUT]: backOut,
              [EasingMethod.BACK_IN_OUT]: backInOut,
              [EasingMethod.BACK_OUT_IN]: backOutIn,
              [EasingMethod.BOUNCE_IN]: bounceIn,
              [EasingMethod.BOUNCE_OUT]: bounceOut,
              [EasingMethod.BOUNCE_IN_OUT]: bounceInOut,
              [EasingMethod.BOUNCE_OUT_IN]: bounceOutIn,
              [EasingMethod.SMOOTH]: smooth,
              [EasingMethod.FADE]: fade
            };
            function getEasingFn(easingMethod) {
              assertIsTrue(easingMethod in easingMethodFnMap);
              return easingMethodFnMap[easingMethod];
            }

            var _dec$7, _class$7, _class2$6, _descriptor$5, _descriptor2$3, _descriptor3$2, _descriptor4$1, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _temp$5, _dec2$3, _class4, _class5, _descriptor9, _descriptor10, _temp2;
            let RealKeyframeValue = (_dec$7 = ccclass('cc.RealKeyframeValue'), _dec$7(_class$7 = uniquelyReferenced(_class$7 = (_class2$6 = (_temp$5 = class RealKeyframeValue extends EditorExtendable {
              constructor({
                interpolationMode,
                tangentWeightMode,
                value,
                rightTangent,
                rightTangentWeight,
                leftTangent,
                leftTangentWeight,
                easingMethod,
                [editorExtrasTag]: editorExtras
              } = {}) {
                super();

                _initializerDefineProperty(this, "interpolationMode", _descriptor$5, this);

                _initializerDefineProperty(this, "tangentWeightMode", _descriptor2$3, this);

                _initializerDefineProperty(this, "value", _descriptor3$2, this);

                _initializerDefineProperty(this, "rightTangent", _descriptor4$1, this);

                _initializerDefineProperty(this, "rightTangentWeight", _descriptor5, this);

                _initializerDefineProperty(this, "leftTangent", _descriptor6, this);

                _initializerDefineProperty(this, "leftTangentWeight", _descriptor7, this);

                _initializerDefineProperty(this, "easingMethod", _descriptor8, this);

                this.value = value !== null && value !== void 0 ? value : this.value;
                this.rightTangent = rightTangent !== null && rightTangent !== void 0 ? rightTangent : this.rightTangent;
                this.rightTangentWeight = rightTangentWeight !== null && rightTangentWeight !== void 0 ? rightTangentWeight : this.rightTangentWeight;
                this.leftTangent = leftTangent !== null && leftTangent !== void 0 ? leftTangent : this.leftTangent;
                this.leftTangentWeight = leftTangentWeight !== null && leftTangentWeight !== void 0 ? leftTangentWeight : this.leftTangentWeight;
                this.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : this.interpolationMode;
                this.tangentWeightMode = tangentWeightMode !== null && tangentWeightMode !== void 0 ? tangentWeightMode : this.tangentWeightMode;
                this.easingMethod = easingMethod !== null && easingMethod !== void 0 ? easingMethod : this.easingMethod;

                if (editorExtras) {
                  this[editorExtrasTag] = editorExtras;
                }
              }

            }, _temp$5), (_descriptor$5 = _applyDecoratedDescriptor(_class2$6.prototype, "interpolationMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return RealInterpolationMode.LINEAR;
              }
            }), _descriptor2$3 = _applyDecoratedDescriptor(_class2$6.prototype, "tangentWeightMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return TangentWeightMode.NONE;
              }
            }), _descriptor3$2 = _applyDecoratedDescriptor(_class2$6.prototype, "value", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.0;
              }
            }), _descriptor4$1 = _applyDecoratedDescriptor(_class2$6.prototype, "rightTangent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.0;
              }
            }), _descriptor5 = _applyDecoratedDescriptor(_class2$6.prototype, "rightTangentWeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.0;
              }
            }), _descriptor6 = _applyDecoratedDescriptor(_class2$6.prototype, "leftTangent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.0;
              }
            }), _descriptor7 = _applyDecoratedDescriptor(_class2$6.prototype, "leftTangentWeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.0;
              }
            }), _descriptor8 = _applyDecoratedDescriptor(_class2$6.prototype, "easingMethod", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return EasingMethod.LINEAR;
              }
            })), _class2$6)) || _class$7) || _class$7);

            function createRealKeyframeValue(params) {
              return new RealKeyframeValue(typeof params === 'number' ? {
                value: params
              } : params);
            }

            let RealCurve = exports('dE', (_dec2$3 = ccclass('cc.RealCurve'), _dec2$3(_class4 = (_class5 = (_temp2 = class RealCurve extends KeyframeCurve {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "preExtrapolation", _descriptor9, this);

                _initializerDefineProperty(this, "postExtrapolation", _descriptor10, this);
              }

              evaluate(time) {
                const {
                  _times: times,
                  _values: values
                } = this;
                const nFrames = times.length;

                if (nFrames === 0) {
                  return 0.0;
                }

                const firstTime = times[0];
                const lastTime = times[nFrames - 1];

                if (time < firstTime) {
                  const {
                    preExtrapolation
                  } = this;
                  const preValue = values[0];

                  if (preExtrapolation === ExtrapolationMode.CLAMP || nFrames < 2) {
                    return preValue.value;
                  }

                  switch (preExtrapolation) {
                    case ExtrapolationMode.LINEAR:
                      return linearTrend(firstTime, values[0].value, times[1], values[1].value, time);

                    case ExtrapolationMode.LOOP:
                      time = wrapRepeat(time, firstTime, lastTime);
                      break;

                    case ExtrapolationMode.PING_PONG:
                      time = wrapPingPong(time, firstTime, lastTime);
                      break;

                    default:
                      return preValue.value;
                  }
                } else if (time > lastTime) {
                  const {
                    postExtrapolation
                  } = this;
                  const preFrame = values[nFrames - 1];

                  if (postExtrapolation === ExtrapolationMode.CLAMP || nFrames < 2) {
                    return preFrame.value;
                  }

                  switch (postExtrapolation) {
                    case ExtrapolationMode.LINEAR:
                      return linearTrend(lastTime, preFrame.value, times[nFrames - 2], values[nFrames - 2].value, time);

                    case ExtrapolationMode.LOOP:
                      time = wrapRepeat(time, firstTime, lastTime);
                      break;

                    case ExtrapolationMode.PING_PONG:
                      time = wrapPingPong(time, firstTime, lastTime);
                      break;

                    default:
                      return preFrame.value;
                  }
                }

                const index = binarySearchEpsilon(times, time);

                if (index >= 0) {
                  return values[index].value;
                }

                const iNext = ~index;
                assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
                const iPre = iNext - 1;
                const preTime = times[iPre];
                const preValue = values[iPre];
                const nextTime = times[iNext];
                const nextValue = values[iNext];
                assertIsTrue(nextTime > time && time > preTime);
                const dt = nextTime - preTime;
                const ratio = (time - preTime) / dt;
                return evalBetweenTwoKeyFrames(preTime, preValue, nextTime, nextValue, ratio);
              }

              addKeyFrame(time, value) {
                return super.addKeyFrame(time, createRealKeyframeValue(value));
              }

              assignSorted(times, values) {
                if (values !== undefined) {
                  assertIsTrue(Array.isArray(times));
                  this.setKeyframes(times.slice(), values.map(value => createRealKeyframeValue(value)));
                } else {
                  const keyframes = Array.from(times);
                  this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => createRealKeyframeValue(value)));
                }
              }

              isConstant(tolerance) {
                if (this._values.length <= 1) {
                  return true;
                }

                const firstVal = this._values[0].value;
                return this._values.every(frame => approx(frame.value, firstVal, tolerance));
              }

              [serializeTag](output, context) {
                if (!context.toCCON) {
                  output.writeThis();
                  return;
                }

                const {
                  _times: times,
                  _values: keyframeValues
                } = this;
                const nKeyframes = times.length;
                const dataSize = 0 + OVERFLOW_BYTES + OVERFLOW_BYTES + FRAME_COUNT_BYTES + TIME_BYTES * nKeyframes + REAL_KEY_FRAME_VALUE_MAX_SIZE * nKeyframes;
                const dataView = new DataView(new ArrayBuffer(dataSize));
                let currentOffset = 0;
                dataView.setUint8(currentOffset, this.preExtrapolation);
                currentOffset += OVERFLOW_BYTES;
                dataView.setUint8(currentOffset, this.postExtrapolation);
                currentOffset += OVERFLOW_BYTES;
                dataView.setUint32(currentOffset, nKeyframes, true);
                currentOffset += FRAME_COUNT_BYTES;
                times.forEach((time, index) => dataView.setFloat32(currentOffset + TIME_BYTES * index, time, true));
                currentOffset += TIME_BYTES * nKeyframes;

                for (const keyframeValue of keyframeValues) {
                  currentOffset = saveRealKeyFrameValue(dataView, keyframeValue, currentOffset);
                }

                const bytes = new Uint8Array(dataView.buffer, 0, currentOffset);
                output.writeProperty('bytes', bytes);
                const keyframeValueEditorExtras = keyframeValues.map(keyframeValue => keyframeValue[editorExtrasTag]);

                if (keyframeValueEditorExtras.some(extras => extras !== undefined)) {
                  output.writeProperty(`keyframeValueEditorExtras`, keyframeValueEditorExtras);
                }
              }

              [deserializeTag](input, context) {
                if (!context.fromCCON) {
                  input.readThis();
                  return;
                }

                const bytes = input.readProperty('bytes');
                const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
                let currentOffset = 0;
                this.preExtrapolation = dataView.getUint8(currentOffset);
                currentOffset += OVERFLOW_BYTES;
                this.postExtrapolation = dataView.getUint8(currentOffset);
                currentOffset += OVERFLOW_BYTES;
                const nKeyframes = dataView.getUint32(currentOffset, true);
                currentOffset += FRAME_COUNT_BYTES;
                const times = Array.from({
                  length: nKeyframes
                }, (_, index) => dataView.getFloat32(currentOffset + TIME_BYTES * index, true));
                currentOffset += TIME_BYTES * nKeyframes;
                const keyframeValues = new Array(nKeyframes);

                for (let iKeyFrame = 0; iKeyFrame < nKeyframes; ++iKeyFrame) {
                  const keyframeValue = createRealKeyframeValue({});
                  currentOffset = loadRealKeyFrameValue(dataView, keyframeValue, currentOffset);
                  keyframeValues[iKeyFrame] = keyframeValue;
                }

                assertIsTrue(currentOffset === bytes.byteLength);
                const keyframeValueEditorExtras = input.readProperty(`keyframeValueEditorExtras`);

                if (keyframeValueEditorExtras) {
                  assertIsTrue(keyframeValueEditorExtras.length === nKeyframes);
                  keyframeValueEditorExtras.forEach((extras, index) => keyframeValues[index][editorExtrasTag] = extras);
                }

                this._times = times;
                this._values = keyframeValues;
              }

            }, _temp2), (_descriptor9 = _applyDecoratedDescriptor(_class5.prototype, "preExtrapolation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ExtrapolationMode.CLAMP;
              }
            }), _descriptor10 = _applyDecoratedDescriptor(_class5.prototype, "postExtrapolation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ExtrapolationMode.CLAMP;
              }
            })), _class5)) || _class4));
            const FLAGS_EASING_METHOD_BITS_START = 8;
            const FLAG_EASING_METHOD_MASK = 0xFF << FLAGS_EASING_METHOD_BITS_START;
            var KeyframeValueFlagMask;

            (function (KeyframeValueFlagMask) {
              KeyframeValueFlagMask[KeyframeValueFlagMask["VALUE"] = 1] = "VALUE";
              KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 2] = "INTERPOLATION_MODE";
              KeyframeValueFlagMask[KeyframeValueFlagMask["TANGENT_WEIGHT_MODE"] = 4] = "TANGENT_WEIGHT_MODE";
              KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT"] = 8] = "LEFT_TANGENT";
              KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT_WEIGHT"] = 16] = "LEFT_TANGENT_WEIGHT";
              KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT"] = 32] = "RIGHT_TANGENT";
              KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT_WEIGHT"] = 64] = "RIGHT_TANGENT_WEIGHT";
            })(KeyframeValueFlagMask || (KeyframeValueFlagMask = {}));

            const OVERFLOW_BYTES = 1;
            const FRAME_COUNT_BYTES = 4;
            const TIME_BYTES = 4;
            const KEY_FRAME_VALUE_FLAGS_BYTES = 4;
            const VALUE_BYTES = 4;
            const INTERPOLATION_MODE_BYTES = 1;
            const TANGENT_WEIGHT_MODE_BYTES = 1;
            const LEFT_TANGENT_BYTES = 4;
            const LEFT_TANGENT_WEIGHT_BYTES = 4;
            const RIGHT_TANGENT_BYTES = 4;
            const RIGHT_TANGENT_WEIGHT_BYTES = 4;
            const {
              interpolationMode: DEFAULT_INTERPOLATION_MODE,
              tangentWeightMode: DEFAULT_TANGENT_WEIGHT_MODE,
              leftTangent: DEFAULT_LEFT_TANGENT,
              leftTangentWeight: DEFAULT_LEFT_TANGENT_WEIGHT,
              rightTangent: DEFAULT_RIGHT_TANGENT,
              rightTangentWeight: DEFAULT_RIGHT_TANGENT_WEIGHT
            } = createRealKeyframeValue({});
            const REAL_KEY_FRAME_VALUE_MAX_SIZE = KEY_FRAME_VALUE_FLAGS_BYTES + VALUE_BYTES + INTERPOLATION_MODE_BYTES + TANGENT_WEIGHT_MODE_BYTES + LEFT_TANGENT_BYTES + LEFT_TANGENT_WEIGHT_BYTES + RIGHT_TANGENT_BYTES + RIGHT_TANGENT_WEIGHT_BYTES + 0;

            function saveRealKeyFrameValue(dataView, keyframeValue, offset) {
              let flags = 0;
              let currentOffset = offset;
              const pFlags = currentOffset;
              currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
              const {
                value,
                interpolationMode,
                tangentWeightMode,
                rightTangent,
                rightTangentWeight,
                leftTangent,
                leftTangentWeight,
                easingMethod
              } = keyframeValue;
              dataView.setFloat32(currentOffset, value, true);
              currentOffset += VALUE_BYTES;

              if (interpolationMode !== DEFAULT_INTERPOLATION_MODE) {
                flags |= KeyframeValueFlagMask.INTERPOLATION_MODE;
                dataView.setUint8(currentOffset, interpolationMode);
                currentOffset += INTERPOLATION_MODE_BYTES;
              }

              if (tangentWeightMode !== DEFAULT_TANGENT_WEIGHT_MODE) {
                flags |= KeyframeValueFlagMask.TANGENT_WEIGHT_MODE;
                dataView.setUint8(currentOffset, tangentWeightMode);
                currentOffset += TANGENT_WEIGHT_MODE_BYTES;
              }

              if (leftTangent !== DEFAULT_LEFT_TANGENT) {
                flags |= KeyframeValueFlagMask.LEFT_TANGENT;
                dataView.setFloat32(currentOffset, leftTangent, true);
                currentOffset += LEFT_TANGENT_BYTES;
              }

              if (leftTangentWeight !== DEFAULT_LEFT_TANGENT_WEIGHT) {
                flags |= KeyframeValueFlagMask.LEFT_TANGENT_WEIGHT;
                dataView.setFloat32(currentOffset, leftTangentWeight, true);
                currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
              }

              if (rightTangent !== DEFAULT_RIGHT_TANGENT) {
                flags |= KeyframeValueFlagMask.RIGHT_TANGENT;
                dataView.setFloat32(currentOffset, rightTangent, true);
                currentOffset += RIGHT_TANGENT_BYTES;
              }

              if (rightTangentWeight !== DEFAULT_RIGHT_TANGENT_WEIGHT) {
                flags |= KeyframeValueFlagMask.RIGHT_TANGENT_WEIGHT;
                dataView.setFloat32(currentOffset, rightTangentWeight, true);
                currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
              }

              flags |= easingMethod << FLAGS_EASING_METHOD_BITS_START;
              dataView.setUint32(pFlags, flags, true);
              return currentOffset;
            }

            function loadRealKeyFrameValue(dataView, keyframeValue, offset) {
              let currentOffset = offset;
              const flags = dataView.getUint32(currentOffset, true);
              currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
              keyframeValue.value = dataView.getFloat32(currentOffset, true);
              currentOffset += VALUE_BYTES;

              if (flags & KeyframeValueFlagMask.INTERPOLATION_MODE) {
                keyframeValue.interpolationMode = dataView.getUint8(currentOffset);
                currentOffset += INTERPOLATION_MODE_BYTES;
              }

              if (flags & KeyframeValueFlagMask.TANGENT_WEIGHT_MODE) {
                keyframeValue.tangentWeightMode = dataView.getUint8(currentOffset);
                currentOffset += TANGENT_WEIGHT_MODE_BYTES;
              }

              if (flags & KeyframeValueFlagMask.LEFT_TANGENT) {
                keyframeValue.leftTangent = dataView.getFloat32(currentOffset, true);
                currentOffset += LEFT_TANGENT_BYTES;
              }

              if (flags & KeyframeValueFlagMask.LEFT_TANGENT_WEIGHT) {
                keyframeValue.leftTangentWeight = dataView.getFloat32(currentOffset, true);
                currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
              }

              if (flags & KeyframeValueFlagMask.RIGHT_TANGENT) {
                keyframeValue.rightTangent = dataView.getFloat32(currentOffset, true);
                currentOffset += RIGHT_TANGENT_BYTES;
              }

              if (flags & KeyframeValueFlagMask.RIGHT_TANGENT_WEIGHT) {
                keyframeValue.rightTangentWeight = dataView.getFloat32(currentOffset, true);
                currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
              }

              const easingMethod = (flags & FLAG_EASING_METHOD_MASK) >> FLAGS_EASING_METHOD_BITS_START;
              keyframeValue.easingMethod = easingMethod;
              return currentOffset;
            }

            function wrapRepeat(time, prevTime, nextTime) {
              return prevTime + repeat(time - prevTime, nextTime - prevTime);
            }

            function wrapPingPong(time, prevTime, nextTime) {
              return prevTime + pingPong(time - prevTime, nextTime - prevTime);
            }

            function linearTrend(prevTime, prevValue, nextTime, nextValue, time) {
              const slope = (nextValue - prevValue) / (nextTime - prevTime);
              return prevValue + (time - prevTime) * slope;
            }

            function evalBetweenTwoKeyFrames(prevTime, prevValue, nextTime, nextValue, ratio) {
              const dt = nextTime - prevTime;

              switch (prevValue.interpolationMode) {
                default:
                case RealInterpolationMode.CONSTANT:
                  return prevValue.value;

                case RealInterpolationMode.LINEAR:
                  {
                    const transformedRatio = prevValue.easingMethod === EasingMethod.LINEAR ? ratio : getEasingFn(prevValue.easingMethod)(ratio);
                    return lerp(prevValue.value, nextValue.value, transformedRatio);
                  }

                case RealInterpolationMode.CUBIC:
                  {
                    const ONE_THIRD = 1.0 / 3.0;
                    const {
                      rightTangent: prevTangent,
                      rightTangentWeight: prevTangentWeightSpecified
                    } = prevValue;
                    const prevTangentWeightEnabled = isRightTangentWeightEnabled(prevValue.tangentWeightMode);
                    const {
                      leftTangent: nextTangent,
                      leftTangentWeight: nextTangentWeightSpecified
                    } = nextValue;
                    const nextTangentWeightEnabled = isLeftTangentWeightEnabled(nextValue.tangentWeightMode);

                    if (!prevTangentWeightEnabled && !nextTangentWeightEnabled) {
                      const p1 = prevValue.value + ONE_THIRD * prevTangent * dt;
                      const p2 = nextValue.value - ONE_THIRD * nextTangent * dt;
                      return bezierInterpolate(prevValue.value, p1, p2, nextValue.value, ratio);
                    } else {
                      let prevTangentWeight = 0.0;

                      if (prevTangentWeightEnabled) {
                        prevTangentWeight = prevTangentWeightSpecified;
                      } else {
                        const x = dt;
                        const y = dt * prevTangent;
                        prevTangentWeight = Math.sqrt(x * x + y * y) * ONE_THIRD;
                      }

                      const angle0 = Math.atan(prevTangent);
                      const tx0 = Math.cos(angle0) * prevTangentWeight + prevTime;
                      const ty0 = Math.sin(angle0) * prevTangentWeight + prevValue.value;
                      let nextTangentWeight = 0.0;

                      if (nextTangentWeightEnabled) {
                        nextTangentWeight = nextTangentWeightSpecified;
                      } else {
                        const x = dt;
                        const y = dt * nextTangent;
                        nextTangentWeight = Math.sqrt(x * x + y * y) * ONE_THIRD;
                      }

                      const angle1 = Math.atan(nextTangent);
                      const tx1 = -Math.cos(angle1) * nextTangentWeight + nextTime;
                      const ty1 = -Math.sin(angle1) * nextTangentWeight + nextValue.value;
                      const dx = dt;
                      const u0x = (tx0 - prevTime) / dx;
                      const u1x = (tx1 - prevTime) / dx;
                      const u0y = ty0;
                      const u1y = ty1;
                      const coeff0 = 0.0;
                      const coeff1 = 3.0 * u0x;
                      const coeff2 = 3.0 * u1x - 6.0 * u0x;
                      const coeff3 = 3.0 * (u0x - u1x) + 1.0;
                      const solutions = [0.0, 0.0, 0.0];
                      const nSolutions = solveCubic(coeff0 - ratio, coeff1, coeff2, coeff3, solutions);
                      const param = getParamFromCubicSolution(solutions, nSolutions, ratio);
                      const y = bezierInterpolate(prevValue.value, u0y, u1y, nextValue.value, param);
                      return y;
                    }
                  }
              }
            }

            function isLeftTangentWeightEnabled(tangentWeightMode) {
              return (tangentWeightMode & TangentWeightMode.LEFT) !== 0;
            }

            function isRightTangentWeightEnabled(tangentWeightMode) {
              return (tangentWeightMode & TangentWeightMode.RIGHT) !== 0;
            }

            function bezierInterpolate(p0, p1, p2, p3, t) {
              const u = 1 - t;
              const coeff0 = u * u * u;
              const coeff1 = 3 * u * u * t;
              const coeff2 = 3 * u * t * t;
              const coeff3 = t * t * t;
              return coeff0 * p0 + coeff1 * p1 + coeff2 * p2 + coeff3 * p3;
            }

            function getParamFromCubicSolution(solutions, solutionsCount, x) {
              let param = x;

              if (solutionsCount === 1) {
                param = solutions[0];
              } else {
                param = -Infinity;

                for (let iSolution = 0; iSolution < solutionsCount; ++iSolution) {
                  const solution = solutions[iSolution];

                  if (solution >= 0.0 && solution <= 1.0) {
                    if (solution > param) {
                      param = solution;
                    }
                  }
                }

                if (param === -Infinity) {
                  param = 0.0;
                }
              }

              return param;
            }

            function bezier(C1, C2, C3, C4, t) {
              const t1 = 1 - t;
              return t1 * (t1 * (C1 + (C2 * 3 - C1) * t) + C3 * 3 * t * t) + C4 * t * t * t;
            }
            legacyCC.bezier = bezier;
            const cos = Math.cos;
            const acos = Math.acos;
            const max$2 = Math.max;
            const pi = Math.PI;
            const tau = 2 * pi;
            const sqrt = Math.sqrt;

            function crt(v) {
              if (v < 0) {
                return -Math.pow(-v, 1 / 3);
              } else {
                return Math.pow(v, 1 / 3);
              }
            }

            function cardano(curve, x) {
              const pa = x - 0;
              const pb = x - curve[0];
              const pc = x - curve[2];
              const pd = x - 1;
              const pa3 = pa * 3;
              const pb3 = pb * 3;
              const pc3 = pc * 3;
              const d = -pa + pb3 - pc3 + pd;
              const rd = 1 / d;
              const r3 = 1 / 3;
              const a = (pa3 - 6 * pb + pc3) * rd;
              const a3 = a * r3;
              const b = (-pa3 + pb3) * rd;
              const c = pa * rd;
              const p = (3 * b - a * a) * r3;
              const p3 = p * r3;
              const q = (2 * a * a * a - 9 * a * b + 27 * c) / 27;
              const q2 = q / 2;
              const discriminant = q2 * q2 + p3 * p3 * p3;
              let u1;
              let v1;
              let x1;
              let x2;
              let x3;

              if (discriminant < 0) {
                const mp3 = -p * r3;
                const mp33 = mp3 * mp3 * mp3;
                const r = sqrt(mp33);
                const t = -q / (2 * r);
                const cosphi = t < -1 ? -1 : t > 1 ? 1 : t;
                const phi = acos(cosphi);
                const crtr = crt(r);
                const t1 = 2 * crtr;
                x1 = t1 * cos(phi * r3) - a3;
                x2 = t1 * cos((phi + tau) * r3) - a3;
                x3 = t1 * cos((phi + 2 * tau) * r3) - a3;

                if (x1 >= 0 && x1 <= 1) {
                  if (x2 >= 0 && x2 <= 1) {
                    if (x3 >= 0 && x3 <= 1) {
                      return max$2(x1, x2, x3);
                    } else {
                      return max$2(x1, x2);
                    }
                  } else if (x3 >= 0 && x3 <= 1) {
                    return max$2(x1, x3);
                  } else {
                    return x1;
                  }
                } else if (x2 >= 0 && x2 <= 1) {
                  if (x3 >= 0 && x3 <= 1) {
                    return max$2(x2, x3);
                  } else {
                    return x2;
                  }
                } else {
                  return x3;
                }
              } else if (discriminant === 0) {
                u1 = q2 < 0 ? crt(-q2) : -crt(q2);
                x1 = 2 * u1 - a3;
                x2 = -u1 - a3;

                if (x1 >= 0 && x1 <= 1) {
                  if (x2 >= 0 && x2 <= 1) {
                    return max$2(x1, x2);
                  } else {
                    return x1;
                  }
                } else {
                  return x2;
                }
              } else {
                  const sd = sqrt(discriminant);
                  u1 = crt(-q2 + sd);
                  v1 = crt(q2 + sd);
                  x1 = u1 - v1 - a3;
                  return x1;
                }
            }

            function bezierByTime(controlPoints, x) {
              const percent = cardano(controlPoints, x);
              const p1y = controlPoints[1];
              const p2y = controlPoints[3];
              return ((1 - percent) * (p1y + (p2y - p1y) * percent) * 3 + percent * percent) * percent;
            }
            legacyCC.bezierByTime = bezierByTime;

            var _dec$8, _class$8, _class2$7, _descriptor$6, _descriptor2$4, _descriptor3$3, _temp$6, _dec2$4, _class4$1, _class5$1, _descriptor4$2, _descriptor5$1, _temp2$1;
            let QuatInterpolationMode;

            (function (QuatInterpolationMode) {
              QuatInterpolationMode[QuatInterpolationMode["SLERP"] = 0] = "SLERP";
              QuatInterpolationMode[QuatInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
            })(QuatInterpolationMode || (QuatInterpolationMode = exports('ga', {})));

            let QuatKeyframeValue = (_dec$8 = ccclass('cc.QuatKeyframeValue'), _dec$8(_class$8 = uniquelyReferenced(_class$8 = (_class2$7 = (_temp$6 = class QuatKeyframeValue {
              constructor({
                value,
                interpolationMode,
                easingMethod
              } = {}) {
                _initializerDefineProperty(this, "interpolationMode", _descriptor$6, this);

                _initializerDefineProperty(this, "value", _descriptor2$4, this);

                _initializerDefineProperty(this, "easingMethod", _descriptor3$3, this);

                this.value = value ? Quat.clone(value) : this.value;
                this.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : this.interpolationMode;
                this.easingMethod = easingMethod !== null && easingMethod !== void 0 ? easingMethod : this.easingMethod;
              }

            }, _temp$6), (_descriptor$6 = _applyDecoratedDescriptor(_class2$7.prototype, "interpolationMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return QuatInterpolationMode.SLERP;
              }
            }), _descriptor2$4 = _applyDecoratedDescriptor(_class2$7.prototype, "value", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Quat.clone(Quat.IDENTITY);
              }
            }), _descriptor3$3 = _applyDecoratedDescriptor(_class2$7.prototype, "easingMethod", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return EasingMethod.LINEAR;
              }
            })), _class2$7)) || _class$8) || _class$8);

            function createQuatKeyframeValue(params) {
              return new QuatKeyframeValue(params);
            }

            let QuatCurve = exports('g9', (_dec2$4 = ccclass('cc.QuatCurve'), _dec2$4(_class4$1 = (_class5$1 = (_temp2$1 = class QuatCurve extends KeyframeCurve {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "preExtrapolation", _descriptor4$2, this);

                _initializerDefineProperty(this, "postExtrapolation", _descriptor5$1, this);
              }

              evaluate(time, quat) {
                var _quat;

                (_quat = quat) !== null && _quat !== void 0 ? _quat : quat = new Quat();
                const {
                  _times: times,
                  _values: values,
                  postExtrapolation,
                  preExtrapolation
                } = this;
                const nFrames = times.length;

                if (nFrames === 0) {
                  return quat;
                }

                const firstTime = times[0];
                const lastTime = times[nFrames - 1];

                if (time < firstTime) {
                  const preValue = values[0];

                  switch (preExtrapolation) {
                    case ExtrapolationMode.LOOP:
                      time = firstTime + repeat(time - firstTime, lastTime - firstTime);
                      break;

                    case ExtrapolationMode.PING_PONG:
                      time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                      break;

                    case ExtrapolationMode.CLAMP:
                    default:
                      return Quat.copy(quat, preValue.value);
                  }
                } else if (time > lastTime) {
                  const preValue = values[nFrames - 1];

                  switch (postExtrapolation) {
                    case ExtrapolationMode.LOOP:
                      time = firstTime + repeat(time - firstTime, lastTime - firstTime);
                      break;

                    case ExtrapolationMode.PING_PONG:
                      time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                      break;

                    case ExtrapolationMode.CLAMP:
                    default:
                      return Quat.copy(quat, preValue.value);
                  }
                }

                const index = binarySearchEpsilon(times, time);

                if (index >= 0) {
                  return Quat.copy(quat, values[index].value);
                }

                const iNext = ~index;
                assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
                const iPre = iNext - 1;
                const preTime = times[iPre];
                const preValue = values[iPre];
                const nextTime = times[iNext];
                const nextValue = values[iNext];
                assertIsTrue(nextTime > time && time > preTime);
                const dt = nextTime - preTime;
                const ratio = (time - preTime) / dt;

                switch (preValue.interpolationMode) {
                  default:
                  case QuatInterpolationMode.CONSTANT:
                    return Quat.copy(quat, preValue.value);

                  case QuatInterpolationMode.SLERP:
                    {
                      const {
                        easingMethod
                      } = preValue;
                      const transformedRatio = easingMethod === EasingMethod.LINEAR ? ratio : Array.isArray(easingMethod) ? bezierByTime(easingMethod, ratio) : getEasingFn(easingMethod)(ratio);
                      return Quat.slerp(quat, preValue.value, nextValue.value, transformedRatio);
                    }
                }
              }

              addKeyFrame(time, value) {
                const keyframeValue = new QuatKeyframeValue(value);
                return super.addKeyFrame(time, keyframeValue);
              }

              assignSorted(times, values) {
                if (values !== undefined) {
                  assertIsTrue(Array.isArray(times));
                  this.setKeyframes(times.slice(), values.map(value => createQuatKeyframeValue(value)));
                } else {
                  const keyframes = Array.from(times);
                  this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => createQuatKeyframeValue(value)));
                }
              }

              [serializeTag](output, context) {
                if (!context.toCCON) {
                  output.writeThis();
                  return;
                }

                const {
                  _times: times,
                  _values: keyframeValues
                } = this;
                let interpolationModeRepeated = true;
                keyframeValues.forEach((keyframeValue, _index, [firstKeyframeValue]) => {
                  if (interpolationModeRepeated && keyframeValue.interpolationMode !== firstKeyframeValue.interpolationMode) {
                    interpolationModeRepeated = false;
                  }
                });
                const nKeyframes = times.length;
                const nFrames = nKeyframes;
                const interpolationModesSize = INTERPOLATION_MODE_BYTES$1 * (interpolationModeRepeated ? 1 : nFrames);
                const easingMethodsSize = keyframeValues.reduce((result, {
                  easingMethod
                }) => result += Array.isArray(easingMethod) ? EASING_METHOD_BYTES + EASING_METHOD_BEZIER_COMPONENT_BYTES * 4 : EASING_METHOD_BYTES, 0);
                let dataSize = 0;
                dataSize += FLAGS_BYTES + FRAME_COUNT_BYTES$1 + TIME_BYTES$1 * nFrames + VALUE_BYTES$1 * 4 * nFrames + easingMethodsSize + interpolationModesSize + 0;
                const dataView = new DataView(new ArrayBuffer(dataSize));
                let P = 0;
                let flags = 0;

                if (interpolationModeRepeated) {
                  flags |= KeyframeValueFlagMask$1.INTERPOLATION_MODE;
                }

                dataView.setUint32(P, flags, true);
                P += FLAGS_BYTES;
                dataView.setUint32(P, nFrames, true);
                P += FRAME_COUNT_BYTES$1;
                times.forEach((time, index) => dataView.setFloat32(P + TIME_BYTES$1 * index, time, true));
                P += TIME_BYTES$1 * nFrames;
                keyframeValues.forEach(({
                  value: {
                    x,
                    y,
                    z,
                    w
                  }
                }, index) => {
                  const pQuat = P + VALUE_BYTES$1 * 4 * index;
                  dataView.setFloat32(pQuat + VALUE_BYTES$1 * 0, x, true);
                  dataView.setFloat32(pQuat + VALUE_BYTES$1 * 1, y, true);
                  dataView.setFloat32(pQuat + VALUE_BYTES$1 * 2, z, true);
                  dataView.setFloat32(pQuat + VALUE_BYTES$1 * 3, w, true);
                });
                P += VALUE_BYTES$1 * 4 * nFrames;
                keyframeValues.forEach(({
                  easingMethod
                }, index) => {
                  if (!Array.isArray(easingMethod)) {
                    dataView.setUint8(P, easingMethod);
                    ++P;
                  } else {
                    dataView.setUint8(P, EASING_METHOD_BEZIER_TAG);
                    ++P;
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, easingMethod[0], true);
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, easingMethod[1], true);
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, easingMethod[2], true);
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, easingMethod[3], true);
                    P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
                  }
                });
                const INTERPOLATION_MODES_START = P;
                P += interpolationModesSize;
                let pInterpolationMode = INTERPOLATION_MODES_START;
                keyframeValues.forEach(({
                  interpolationMode
                }) => {
                  dataView.setUint8(pInterpolationMode, interpolationMode);

                  if (!interpolationModeRepeated) {
                    pInterpolationMode += INTERPOLATION_MODE_BYTES$1;
                  }
                });
                const bytes = new Uint8Array(dataView.buffer);
                output.writeProperty('bytes', bytes);
              }

              [deserializeTag](input, context) {
                if (!context.fromCCON) {
                  input.readThis();
                  return;
                }

                const bytes = input.readProperty('bytes');
                const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
                let P = 0;
                const flags = dataView.getUint32(P, true);
                P += FLAGS_BYTES;
                const interpolationModeRepeated = flags & KeyframeValueFlagMask$1.INTERPOLATION_MODE;
                const nFrames = dataView.getUint32(P, true);
                P += FRAME_COUNT_BYTES$1;
                const times = Array.from({
                  length: nFrames
                }, (_, index) => dataView.getFloat32(P + TIME_BYTES$1 * index, true));
                P += TIME_BYTES$1 * nFrames;
                const P_VALUES = P;
                P += VALUE_BYTES$1 * 4 * nFrames;
                const keyframeValues = Array.from({
                  length: nFrames
                }, (_, index) => {
                  const pQuat = P_VALUES + VALUE_BYTES$1 * 4 * index;
                  const x = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 0, true);
                  const y = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 1, true);
                  const z = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 2, true);
                  const w = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 3, true);
                  const easingMethod = dataView.getUint8(P);
                  ++P;
                  const keyframeValue = createQuatKeyframeValue({
                    value: {
                      x,
                      y,
                      z,
                      w
                    }
                  });

                  if (easingMethod !== EASING_METHOD_BEZIER_TAG) {
                    keyframeValue.easingMethod = easingMethod;
                  } else {
                    keyframeValue.easingMethod = [dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, true)];
                    P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
                  }

                  return keyframeValue;
                });

                if (interpolationModeRepeated) {
                  const interpolationMode = dataView.getUint8(P);
                  ++P;

                  for (let iKeyframe = 0; iKeyframe < nFrames; ++iKeyframe) {
                    keyframeValues[iKeyframe].interpolationMode = interpolationMode;
                  }
                } else {
                  for (let iKeyframe = 0; iKeyframe < nFrames; ++iKeyframe) {
                    const interpolationMode = dataView.getUint8(P + iKeyframe);
                    keyframeValues[iKeyframe].interpolationMode = interpolationMode;
                  }

                  P += nFrames;
                }

                this._times = times;
                this._values = keyframeValues;
              }

            }, _temp2$1), (_descriptor4$2 = _applyDecoratedDescriptor(_class5$1.prototype, "preExtrapolation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ExtrapolationMode.CLAMP;
              }
            }), _descriptor5$1 = _applyDecoratedDescriptor(_class5$1.prototype, "postExtrapolation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ExtrapolationMode.CLAMP;
              }
            })), _class5$1)) || _class4$1));
            var KeyframeValueFlagMask$1;

            (function (KeyframeValueFlagMask) {
              KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 1] = "INTERPOLATION_MODE";
            })(KeyframeValueFlagMask$1 || (KeyframeValueFlagMask$1 = {}));

            const FLAGS_BYTES = 1;
            const FRAME_COUNT_BYTES$1 = 4;
            const TIME_BYTES$1 = 4;
            const VALUE_BYTES$1 = 4;
            const INTERPOLATION_MODE_BYTES$1 = 1;
            const EASING_METHOD_BYTES = 1;
            const EASING_METHOD_BEZIER_TAG = 255;
            const EASING_METHOD_BEZIER_COMPONENT_BYTES = 4;

            var _dec$9, _class$9;
            let ObjectCurve = exports('gb', (_dec$9 = ccclass('cc.ObjectCurve'), _dec$9(_class$9 = class ObjectCurve extends KeyframeCurve {
              evaluate(time) {
                const iSearch = this.searchKeyframe(time);

                if (iSearch >= 0) {
                  return this._values[iSearch];
                }

                const iPrev = clamp(~iSearch - 1, 0, this._values.length - 1);
                return this._values[iPrev];
              }

            }) || _class$9));

            var _dec$a, _class$a, _class2$8, _descriptor$7, _class3$3, _temp$7;
            const LOOK_FORWARD = 3;
            class Keyframe {
              constructor() {
                this.time = 0;
                this.value = 0;
                this.inTangent = 0;
                this.outTangent = 0;
              }

            }
            CCClass.fastDefine('cc.Keyframe', Keyframe, {
              time: 0,
              value: 0,
              inTangent: 0,
              outTangent: 0
            });
            class OptimizedKey {
              constructor() {
                this.index = void 0;
                this.time = void 0;
                this.endTime = void 0;
                this.coefficient = void 0;
                this.index = -1;
                this.time = 0;
                this.endTime = 0;
                this.coefficient = new Float32Array(4);
              }

              evaluate(T) {
                const t = T - this.time;
                return evalOptCurve(t, this.coefficient);
              }

            }
            function evalOptCurve(t, coefs) {
              return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
            }
            let AnimationCurve = exports('dF', (_dec$a = ccclass('cc.AnimationCurve'), _dec$a(_class$a = (_class2$8 = (_temp$7 = _class3$3 = class AnimationCurve {
              get _internalCurve() {
                return this._curve;
              }

              get keyFrames() {
                return Array.from(this._curve.keyframes()).map(([time, value]) => {
                  const legacyKeyframe = new Keyframe();
                  legacyKeyframe.time = time;
                  legacyKeyframe.value = value.value;
                  legacyKeyframe.inTangent = value.leftTangent;
                  legacyKeyframe.outTangent = value.rightTangent;
                  return legacyKeyframe;
                });
              }

              set keyFrames(value) {
                this._curve.assignSorted(value.map(legacyCurve => [legacyCurve.time, {
                  interpolationMode: RealInterpolationMode.CUBIC,
                  value: legacyCurve.value,
                  leftTangent: legacyCurve.inTangent,
                  rightTangent: legacyCurve.outTangent
                }]));
              }

              get preWrapMode() {
                return toLegacyWrapMode(this._curve.preExtrapolation);
              }

              set preWrapMode(value) {
                this._curve.preExtrapolation = fromLegacyWrapMode(value);
              }

              get postWrapMode() {
                return toLegacyWrapMode(this._curve.postExtrapolation);
              }

              set postWrapMode(value) {
                this._curve.postExtrapolation = fromLegacyWrapMode(value);
              }

              constructor(keyFrames = null) {
                _initializerDefineProperty(this, "_curve", _descriptor$7, this);

                this.cachedKey = void 0;

                if (keyFrames instanceof RealCurve) {
                  this._curve = keyFrames;
                } else {
                  const curve = new RealCurve();
                  this._curve = curve;
                  curve.preExtrapolation = ExtrapolationMode.LOOP;
                  curve.postExtrapolation = ExtrapolationMode.CLAMP;

                  if (!keyFrames) {
                    curve.assignSorted([[0.0, {
                      interpolationMode: RealInterpolationMode.CUBIC,
                      value: 1.0
                    }], [1.0, {
                      interpolationMode: RealInterpolationMode.CUBIC,
                      value: 1.0
                    }]]);
                  } else {
                    curve.assignSorted(keyFrames.map(legacyKeyframe => [legacyKeyframe.time, {
                      interpolationMode: RealInterpolationMode.CUBIC,
                      value: legacyKeyframe.value,
                      leftTangent: legacyKeyframe.inTangent,
                      rightTangent: legacyKeyframe.outTangent
                    }]));
                  }
                }

                this.cachedKey = new OptimizedKey();
              }

              addKey(keyFrame) {
                if (!keyFrame) {
                  this._curve.clear();
                } else {
                  this._curve.addKeyFrame(keyFrame.time, {
                    interpolationMode: RealInterpolationMode.CUBIC,
                    value: keyFrame.value,
                    leftTangent: keyFrame.inTangent,
                    rightTangent: keyFrame.outTangent
                  });
                }
              }

              evaluate_slow(time) {
                return this._curve.evaluate(time);
              }

              evaluate(time) {
                const {
                  cachedKey,
                  _curve: curve
                } = this;
                const nKeyframes = curve.keyFramesCount;
                const lastKeyframeIndex = nKeyframes - 1;
                let wrappedTime = time;
                const extrapolationMode = time < 0 ? curve.preExtrapolation : curve.postExtrapolation;
                const startTime = curve.getKeyframeTime(0);
                const endTime = curve.getKeyframeTime(lastKeyframeIndex);

                switch (extrapolationMode) {
                  case ExtrapolationMode.LOOP:
                    wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                    break;

                  case ExtrapolationMode.PING_PONG:
                    wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                    break;

                  case ExtrapolationMode.CLAMP:
                  default:
                    wrappedTime = clamp(time, startTime, endTime);
                    break;
                }

                if (wrappedTime >= cachedKey.time && wrappedTime < cachedKey.endTime) {
                  return cachedKey.evaluate(wrappedTime);
                }

                const leftIndex = this.findIndex(cachedKey, wrappedTime);
                const rightIndex = Math.min(leftIndex + 1, lastKeyframeIndex);
                this.calcOptimizedKey(cachedKey, leftIndex, rightIndex);
                return cachedKey.evaluate(wrappedTime);
              }

              calcOptimizedKey(optKey, leftIndex, rightIndex) {
                const lhsTime = this._curve.getKeyframeTime(leftIndex);

                const rhsTime = this._curve.getKeyframeTime(rightIndex);

                const {
                  value: lhsValue,
                  leftTangent: lhsOutTangent
                } = this._curve.getKeyframeValue(leftIndex);

                const {
                  value: rhsValue,
                  rightTangent: rhsInTangent
                } = this._curve.getKeyframeValue(rightIndex);

                optKey.index = leftIndex;
                optKey.time = lhsTime;
                optKey.endTime = rhsTime;
                const dx = rhsTime - lhsTime;
                const dy = rhsValue - lhsValue;
                const length = 1 / (dx * dx);
                const d1 = lhsOutTangent * dx;
                const d2 = rhsInTangent * dx;
                optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx;
                optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length;
                optKey.coefficient[2] = lhsOutTangent;
                optKey.coefficient[3] = lhsValue;
              }

              findIndex(optKey, t) {
                const {
                  _curve: curve
                } = this;
                const nKeyframes = curve.keyFramesCount;
                const cachedIndex = optKey.index;

                if (cachedIndex !== -1) {
                  const cachedTime = curve.getKeyframeTime(cachedIndex);

                  if (t > cachedTime) {
                    for (let i = 0; i < LOOK_FORWARD; i++) {
                      const currIndex = cachedIndex + i;

                      if (currIndex + 1 < nKeyframes && curve.getKeyframeTime(currIndex + 1) > t) {
                        return currIndex;
                      }
                    }
                  } else {
                    for (let i = 0; i < LOOK_FORWARD; i++) {
                      const currIndex = cachedIndex - i;

                      if (currIndex >= 0 && curve.getKeyframeTime(currIndex - 1) <= t) {
                        return currIndex - 1;
                      }
                    }
                  }
                }

                let left = 0;
                let right = nKeyframes;
                let mid;

                while (right - left > 1) {
                  mid = Math.floor((left + right) / 2);

                  if (curve.getKeyframeTime(mid) >= t) {
                    right = mid;
                  } else {
                    left = mid;
                  }
                }

                return left;
              }

            }, _class3$3.defaultKF = [{
              time: 0,
              value: 1,
              inTangent: 0,
              outTangent: 0
            }, {
              time: 1,
              value: 1,
              inTangent: 0,
              outTangent: 0
            }], _temp$7), (_descriptor$7 = _applyDecoratedDescriptor(_class2$8.prototype, "_curve", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class2$8)) || _class$a));

            function fromLegacyWrapMode(legacyWrapMode) {
              switch (legacyWrapMode) {
                default:
                case WrapModeMask.Default:
                case WrapModeMask.Normal:
                case WrapModeMask.Clamp:
                  return ExtrapolationMode.CLAMP;

                case WrapModeMask.PingPong:
                  return ExtrapolationMode.PING_PONG;

                case WrapModeMask.Loop:
                  return ExtrapolationMode.LOOP;
              }
            }

            function toLegacyWrapMode(extrapolationMode) {
              switch (extrapolationMode) {
                default:
                case ExtrapolationMode.LINEAR:
                case ExtrapolationMode.CLAMP:
                  return WrapModeMask.Clamp;

                case ExtrapolationMode.PING_PONG:
                  return WrapModeMask.PingPong;

                case ExtrapolationMode.LOOP:
                  return WrapModeMask.Loop;
              }
            }

            function constructLegacyCurveAndConvert() {
              const curve = new RealCurve();
              curve.assignSorted([[0.0, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: 1.0
              }], [1.0, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: 1.0
              }]]);
              return curve;
            }

            replaceProperty(intersect, 'intersect', [{
              name: 'ray_aabb',
              newName: 'rayAABB'
            }, {
              name: 'ray_plane',
              newName: 'rayPlane'
            }, {
              name: 'ray_triangle',
              newName: 'rayTriangle'
            }, {
              name: 'ray_sphere',
              newName: 'raySphere'
            }, {
              name: 'ray_obb',
              newName: 'rayOBB'
            }, {
              name: 'ray_capsule',
              newName: 'rayCapsule'
            }, {
              name: 'ray_subMesh',
              newName: 'raySubMesh'
            }, {
              name: 'ray_mesh',
              newName: 'rayMesh'
            }, {
              name: 'ray_model',
              newName: 'rayModel'
            }, {
              name: 'line_plane',
              newName: 'linePlane'
            }, {
              name: 'line_triangle',
              newName: 'lineTriangle'
            }, {
              name: 'line_aabb',
              newName: 'lineAABB'
            }, {
              name: 'line_obb',
              newName: 'lineOBB'
            }, {
              name: 'line_sphere',
              newName: 'lineSphere'
            }, {
              name: 'aabb_aabb',
              newName: 'aabbWithAABB'
            }, {
              name: 'aabb_obb',
              newName: 'aabbWithOBB'
            }, {
              name: 'aabb_plane',
              newName: 'aabbPlane'
            }, {
              name: 'aabb_frustum',
              newName: 'aabbFrustum'
            }, {
              name: 'aabbFrustum_accurate',
              newName: 'aabbFrustumAccurate'
            }, {
              name: 'obb_point',
              newName: 'obbPoint'
            }, {
              name: 'obb_plane',
              newName: 'obbPlane'
            }, {
              name: 'obb_frustum',
              newName: 'obbFrustum'
            }, {
              name: 'obbFrustum_accurate',
              newName: 'obbFrustumAccurate'
            }, {
              name: 'obb_obb',
              newName: 'obbWithOBB'
            }, {
              name: 'obb_capsule',
              newName: 'obbCapsule'
            }, {
              name: 'sphere_plane',
              newName: 'spherePlane'
            }, {
              name: 'sphere_frustum',
              newName: 'sphereFrustum'
            }, {
              name: 'sphereFrustum_accurate',
              newName: 'sphereFrustumAccurate'
            }, {
              name: 'sphere_sphere',
              newName: 'sphereWithSphere'
            }, {
              name: 'sphere_aabb',
              newName: 'sphereAABB'
            }, {
              name: 'sphere_obb',
              newName: 'sphereOBB'
            }, {
              name: 'sphere_capsule',
              newName: 'sphereCapsule'
            }, {
              name: 'capsule_capsule',
              newName: 'capsuleWithCapsule'
            }]);

            function deprecatedClassMessage(oldClassName, newClassName) {
              console.warn(`${oldClassName} is deprecated, please use ${newClassName} instead.`);
            }

            class line extends Line {
              constructor() {
                super();
                deprecatedClassMessage('line', 'Line');
              }

            }
            class plane extends Plane {
              constructor() {
                super();
                deprecatedClassMessage('plane', 'Plane');
              }

            }
            class ray extends Ray {
              constructor() {
                super();
                deprecatedClassMessage('ray', 'Ray');
              }

            }
            class triangle extends Triangle {
              constructor() {
                super();
                deprecatedClassMessage('triangle', 'Triangle');
              }

            }
            class sphere extends Sphere {
              constructor() {
                super();
                deprecatedClassMessage('sphere', 'Sphere');
              }

            }
            class aabb extends AABB {
              constructor() {
                super();
                deprecatedClassMessage('aabb', 'AABB');
              }

            }
            class obb extends OBB {
              constructor() {
                super();
                deprecatedClassMessage('obb', 'OBB');
              }

            }
            class capsule extends Capsule {
              constructor() {
                super();
                deprecatedClassMessage('capsule', 'Capsule');
              }

            }
            class frustum extends Frustum {
              constructor() {
                super();
                deprecatedClassMessage('frustum', 'Frustum');
              }

            }

            var geometry = /*#__PURE__*/Object.freeze({
                __proto__: null,
                distance: distance,
                enums: enums,
                intersect: intersect,
                Line: Line,
                Plane: Plane,
                Ray: Ray,
                Triangle: Triangle,
                Sphere: Sphere,
                AABB: AABB,
                OBB: OBB,
                Capsule: Capsule,
                Frustum: Frustum,
                Keyframe: Keyframe,
                AnimationCurve: AnimationCurve,
                get ERaycastMode () { return ERaycastMode; },
                line: line,
                plane: plane,
                ray: ray,
                triangle: triangle,
                sphere: sphere,
                aabb: aabb,
                obb: obb,
                capsule: capsule,
                frustum: frustum
            });
            exports('ew', geometry);

            const layerList = {
              NONE: 0,
              IGNORE_RAYCAST: 1 << 20,
              GIZMOS: 1 << 21,
              EDITOR: 1 << 22,
              UI_3D: 1 << 23,
              SCENE_GIZMO: 1 << 24,
              UI_2D: 1 << 25,
              PROFILER: 1 << 28,
              DEFAULT: 1 << 30,
              ALL: 0xffffffff
            };
            class Layers {
              static makeMaskInclude(includes) {
                let mask = 0;

                for (const inc of includes) {
                  mask |= inc;
                }

                return mask;
              }

              static makeMaskExclude(excludes) {
                return ~Layers.makeMaskInclude(excludes);
              }

              static addLayer(name, bitNum) {
                if (bitNum === undefined) {
                  console.warn('bitNum can\'t be undefined');
                  return;
                }

                if (bitNum > 19 || bitNum < 0) {
                  console.warn('maximum layers reached.');
                  return;
                }

                Layers.Enum[name] = 1 << bitNum;
                Layers.Enum[bitNum] = name;
                Layers.BitMask[name] = 1 << bitNum;
                Layers.BitMask[bitNum] = name;
              }

              static deleteLayer(bitNum) {
                if (bitNum > 19 || bitNum < 0) {
                  console.warn('do not change buildin layers.');
                  return;
                }

                delete Layers.Enum[Layers.Enum[bitNum]];
                delete Layers.Enum[bitNum];
                delete Layers.BitMask[Layers.BitMask[bitNum]];
                delete Layers.BitMask[bitNum];
              }

              static nameToLayer(name) {
                if (name === undefined) {
                  console.warn('name can\'t be undefined');
                  return -1;
                }

                return log2(Layers.Enum[name]);
              }

              static layerToName(bitNum) {
                if (bitNum > 31 || bitNum < 0) {
                  console.warn('Unable to access unknown layer.');
                  return '';
                }

                return Layers.Enum[bitNum];
              }

            } exports('d9', Layers);
            Layers.Enum = Enum(layerList);
            Layers.BitMask = BitMask({ ...layerList
            });
            legacyCC.Layers = Layers;

            let RenderPassStage;

            (function (RenderPassStage) {
              RenderPassStage[RenderPassStage["DEFAULT"] = 100] = "DEFAULT";
              RenderPassStage[RenderPassStage["UI"] = 200] = "UI";
            })(RenderPassStage || (RenderPassStage = {}));

            legacyCC.RenderPassStage = RenderPassStage;
            let RenderPriority;

            (function (RenderPriority) {
              RenderPriority[RenderPriority["MIN"] = 0] = "MIN";
              RenderPriority[RenderPriority["MAX"] = 255] = "MAX";
              RenderPriority[RenderPriority["DEFAULT"] = 128] = "DEFAULT";
            })(RenderPriority || (RenderPriority = exports('d8', {})));

            const globalDescriptorSetLayout = {
              bindings: [],
              layouts: {}
            };
            const localDescriptorSetLayout = {
              bindings: [],
              layouts: {}
            };
            let PipelineGlobalBindings;

            (function (PipelineGlobalBindings) {
              PipelineGlobalBindings[PipelineGlobalBindings["UBO_GLOBAL"] = 0] = "UBO_GLOBAL";
              PipelineGlobalBindings[PipelineGlobalBindings["UBO_CAMERA"] = 1] = "UBO_CAMERA";
              PipelineGlobalBindings[PipelineGlobalBindings["UBO_SHADOW"] = 2] = "UBO_SHADOW";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SHADOWMAP"] = 3] = "SAMPLER_SHADOWMAP";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_ENVIRONMENT"] = 4] = "SAMPLER_ENVIRONMENT";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SPOT_LIGHTING_MAP"] = 5] = "SAMPLER_SPOT_LIGHTING_MAP";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_GBUFFER_ALBEDOMAP"] = 6] = "SAMPLER_GBUFFER_ALBEDOMAP";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_GBUFFER_POSITIONMAP"] = 7] = "SAMPLER_GBUFFER_POSITIONMAP";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_GBUFFER_NORMALMAP"] = 8] = "SAMPLER_GBUFFER_NORMALMAP";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_GBUFFER_EMISSIVEMAP"] = 9] = "SAMPLER_GBUFFER_EMISSIVEMAP";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_LIGHTING_RESULTMAP"] = 10] = "SAMPLER_LIGHTING_RESULTMAP";
              PipelineGlobalBindings[PipelineGlobalBindings["COUNT"] = 11] = "COUNT";
            })(PipelineGlobalBindings || (PipelineGlobalBindings = {}));

            const GLOBAL_UBO_COUNT = PipelineGlobalBindings.SAMPLER_SHADOWMAP;
            const GLOBAL_SAMPLER_COUNT = PipelineGlobalBindings.COUNT - GLOBAL_UBO_COUNT;
            let ModelLocalBindings;

            (function (ModelLocalBindings) {
              ModelLocalBindings[ModelLocalBindings["UBO_LOCAL"] = 0] = "UBO_LOCAL";
              ModelLocalBindings[ModelLocalBindings["UBO_FORWARD_LIGHTS"] = 1] = "UBO_FORWARD_LIGHTS";
              ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_ANIMATION"] = 2] = "UBO_SKINNING_ANIMATION";
              ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_TEXTURE"] = 3] = "UBO_SKINNING_TEXTURE";
              ModelLocalBindings[ModelLocalBindings["UBO_MORPH"] = 4] = "UBO_MORPH";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_JOINTS"] = 5] = "SAMPLER_JOINTS";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_POSITION"] = 6] = "SAMPLER_MORPH_POSITION";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_NORMAL"] = 7] = "SAMPLER_MORPH_NORMAL";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_TANGENT"] = 8] = "SAMPLER_MORPH_TANGENT";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_LIGHTMAP"] = 9] = "SAMPLER_LIGHTMAP";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_SPRITE"] = 10] = "SAMPLER_SPRITE";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION"] = 11] = "SAMPLER_REFLECTION";
              ModelLocalBindings[ModelLocalBindings["STORAGE_REFLECTION"] = 12] = "STORAGE_REFLECTION";
              ModelLocalBindings[ModelLocalBindings["COUNT"] = 13] = "COUNT";
            })(ModelLocalBindings || (ModelLocalBindings = exports('df', {})));

            const LOCAL_UBO_COUNT = ModelLocalBindings.SAMPLER_JOINTS;
            const LOCAL_SAMPLER_COUNT = ModelLocalBindings.COUNT - LOCAL_UBO_COUNT;
            let SetIndex;

            (function (SetIndex) {
              SetIndex[SetIndex["GLOBAL"] = 0] = "GLOBAL";
              SetIndex[SetIndex["MATERIAL"] = 1] = "MATERIAL";
              SetIndex[SetIndex["LOCAL"] = 2] = "LOCAL";
            })(SetIndex || (SetIndex = {}));

            const bindingMappingInfo = new BindingMappingInfo();
            bindingMappingInfo.bufferOffsets = [0, GLOBAL_UBO_COUNT + LOCAL_UBO_COUNT, GLOBAL_UBO_COUNT];
            bindingMappingInfo.samplerOffsets = [-GLOBAL_UBO_COUNT, GLOBAL_SAMPLER_COUNT + LOCAL_SAMPLER_COUNT, GLOBAL_SAMPLER_COUNT - LOCAL_UBO_COUNT];
            bindingMappingInfo.flexibleSet = 1;
            class UBOGlobal {}
            UBOGlobal.TIME_OFFSET = 0;
            UBOGlobal.NATIVE_SIZE_OFFSET = UBOGlobal.TIME_OFFSET + 4;
            UBOGlobal.SCREEN_SIZE_OFFSET = UBOGlobal.NATIVE_SIZE_OFFSET + 4;
            UBOGlobal.COUNT = UBOGlobal.SCREEN_SIZE_OFFSET + 4;
            UBOGlobal.SIZE = UBOGlobal.COUNT * 4;
            UBOGlobal.NAME = 'CCGlobal';
            UBOGlobal.BINDING = PipelineGlobalBindings.UBO_GLOBAL;
            UBOGlobal.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOGlobal.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
            UBOGlobal.LAYOUT = new UniformBlock(SetIndex.GLOBAL, UBOGlobal.BINDING, UBOGlobal.NAME, [new Uniform('cc_time', Type.FLOAT4, 1), new Uniform('cc_screenSize', Type.FLOAT4, 1), new Uniform('cc_nativeSize', Type.FLOAT4, 1)], 1);
            globalDescriptorSetLayout.layouts[UBOGlobal.NAME] = UBOGlobal.LAYOUT;
            globalDescriptorSetLayout.bindings[UBOGlobal.BINDING] = UBOGlobal.DESCRIPTOR;
            class UBOCamera {}
            UBOCamera.MAT_VIEW_OFFSET = 0;
            UBOCamera.MAT_VIEW_INV_OFFSET = UBOCamera.MAT_VIEW_OFFSET + 16;
            UBOCamera.MAT_PROJ_OFFSET = UBOCamera.MAT_VIEW_INV_OFFSET + 16;
            UBOCamera.MAT_PROJ_INV_OFFSET = UBOCamera.MAT_PROJ_OFFSET + 16;
            UBOCamera.MAT_VIEW_PROJ_OFFSET = UBOCamera.MAT_PROJ_INV_OFFSET + 16;
            UBOCamera.MAT_VIEW_PROJ_INV_OFFSET = UBOCamera.MAT_VIEW_PROJ_OFFSET + 16;
            UBOCamera.CAMERA_POS_OFFSET = UBOCamera.MAT_VIEW_PROJ_INV_OFFSET + 16;
            UBOCamera.SCREEN_SCALE_OFFSET = UBOCamera.CAMERA_POS_OFFSET + 4;
            UBOCamera.EXPOSURE_OFFSET = UBOCamera.SCREEN_SCALE_OFFSET + 4;
            UBOCamera.MAIN_LIT_DIR_OFFSET = UBOCamera.EXPOSURE_OFFSET + 4;
            UBOCamera.MAIN_LIT_COLOR_OFFSET = UBOCamera.MAIN_LIT_DIR_OFFSET + 4;
            UBOCamera.AMBIENT_SKY_OFFSET = UBOCamera.MAIN_LIT_COLOR_OFFSET + 4;
            UBOCamera.AMBIENT_GROUND_OFFSET = UBOCamera.AMBIENT_SKY_OFFSET + 4;
            UBOCamera.GLOBAL_FOG_COLOR_OFFSET = UBOCamera.AMBIENT_GROUND_OFFSET + 4;
            UBOCamera.GLOBAL_FOG_BASE_OFFSET = UBOCamera.GLOBAL_FOG_COLOR_OFFSET + 4;
            UBOCamera.GLOBAL_FOG_ADD_OFFSET = UBOCamera.GLOBAL_FOG_BASE_OFFSET + 4;
            UBOCamera.COUNT = UBOCamera.GLOBAL_FOG_ADD_OFFSET + 4;
            UBOCamera.SIZE = UBOCamera.COUNT * 4;
            UBOCamera.NAME = 'CCCamera';
            UBOCamera.BINDING = PipelineGlobalBindings.UBO_CAMERA;
            UBOCamera.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOCamera.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
            UBOCamera.LAYOUT = new UniformBlock(SetIndex.GLOBAL, UBOCamera.BINDING, UBOCamera.NAME, [new Uniform('cc_matView', Type.MAT4, 1), new Uniform('cc_matViewInv', Type.MAT4, 1), new Uniform('cc_matProj', Type.MAT4, 1), new Uniform('cc_matProjInv', Type.MAT4, 1), new Uniform('cc_matViewProj', Type.MAT4, 1), new Uniform('cc_matViewProjInv', Type.MAT4, 1), new Uniform('cc_cameraPos', Type.FLOAT4, 1), new Uniform('cc_screenScale', Type.FLOAT4, 1), new Uniform('cc_exposure', Type.FLOAT4, 1), new Uniform('cc_mainLitDir', Type.FLOAT4, 1), new Uniform('cc_mainLitColor', Type.FLOAT4, 1), new Uniform('cc_ambientSky', Type.FLOAT4, 1), new Uniform('cc_ambientGround', Type.FLOAT4, 1), new Uniform('cc_fogColor', Type.FLOAT4, 1), new Uniform('cc_fogBase', Type.FLOAT4, 1), new Uniform('cc_fogAdd', Type.FLOAT4, 1)], 1);
            globalDescriptorSetLayout.layouts[UBOCamera.NAME] = UBOCamera.LAYOUT;
            globalDescriptorSetLayout.bindings[UBOCamera.BINDING] = UBOCamera.DESCRIPTOR;
            class UBOShadow {}
            UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET = 0;
            UBOShadow.MAT_LIGHT_VIEW_OFFSET = UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET + 16;
            UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET = UBOShadow.MAT_LIGHT_VIEW_OFFSET + 16;
            UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET = UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET + 16;
            UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET = UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 4;
            UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET = UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 4;
            UBOShadow.SHADOW_COLOR_OFFSET = UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 4;
            UBOShadow.COUNT = UBOShadow.SHADOW_COLOR_OFFSET + 4;
            UBOShadow.SIZE = UBOShadow.COUNT * 4;
            UBOShadow.NAME = 'CCShadow';
            UBOShadow.BINDING = PipelineGlobalBindings.UBO_SHADOW;
            UBOShadow.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOShadow.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
            UBOShadow.LAYOUT = new UniformBlock(SetIndex.GLOBAL, UBOShadow.BINDING, UBOShadow.NAME, [new Uniform('cc_matLightPlaneProj', Type.MAT4, 1), new Uniform('cc_matLightView', Type.MAT4, 1), new Uniform('cc_matLightViewProj', Type.MAT4, 1), new Uniform('cc_shadowNFLSInfo', Type.FLOAT4, 1), new Uniform('cc_shadowWHPBInfo', Type.FLOAT4, 1), new Uniform('cc_shadowLPNNInfo', Type.FLOAT4, 1), new Uniform('cc_shadowColor', Type.FLOAT4, 1)], 1);
            globalDescriptorSetLayout.layouts[UBOShadow.NAME] = UBOShadow.LAYOUT;
            globalDescriptorSetLayout.bindings[UBOShadow.BINDING] = UBOShadow.DESCRIPTOR;
            const UNIFORM_SHADOWMAP_NAME = 'cc_shadowMap';
            const UNIFORM_SHADOWMAP_BINDING = PipelineGlobalBindings.SAMPLER_SHADOWMAP;
            const UNIFORM_SHADOWMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SHADOWMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_SHADOWMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_SHADOWMAP_BINDING, UNIFORM_SHADOWMAP_NAME, Type.SAMPLER2D, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_SHADOWMAP_NAME] = UNIFORM_SHADOWMAP_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_SHADOWMAP_BINDING] = UNIFORM_SHADOWMAP_DESCRIPTOR;
            const UNIFORM_GBUFFER_ALBEDOMAP_NAME = 'cc_gbuffer_albedoMap';
            const UNIFORM_GBUFFER_ALBEDOMAP_BINDING = PipelineGlobalBindings.SAMPLER_GBUFFER_ALBEDOMAP;
            const UNIFORM_GBUFFER_ALBEDOMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_GBUFFER_ALBEDOMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_GBUFFER_ALBEDOMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_GBUFFER_ALBEDOMAP_BINDING, UNIFORM_GBUFFER_ALBEDOMAP_NAME, Type.SAMPLER2D, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_GBUFFER_ALBEDOMAP_NAME] = UNIFORM_GBUFFER_ALBEDOMAP_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_GBUFFER_ALBEDOMAP_BINDING] = UNIFORM_GBUFFER_ALBEDOMAP_DESCRIPTOR;
            const UNIFORM_GBUFFER_POSITIONMAP_NAME = 'cc_gbuffer_positionMap';
            const UNIFORM_GBUFFER_POSITIONMAP_BINDING = PipelineGlobalBindings.SAMPLER_GBUFFER_POSITIONMAP;
            const UNIFORM_GBUFFER_POSITIONMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_GBUFFER_POSITIONMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_GBUFFER_POSITIONMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_GBUFFER_POSITIONMAP_BINDING, UNIFORM_GBUFFER_POSITIONMAP_NAME, Type.SAMPLER2D, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_GBUFFER_POSITIONMAP_NAME] = UNIFORM_GBUFFER_POSITIONMAP_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_GBUFFER_POSITIONMAP_BINDING] = UNIFORM_GBUFFER_POSITIONMAP_DESCRIPTOR;
            const UNIFORM_GBUFFER_NORMALMAP_NAME = 'cc_gbuffer_normalMap';
            const UNIFORM_GBUFFER_NORMALMAP_BINDING = PipelineGlobalBindings.SAMPLER_GBUFFER_NORMALMAP;
            const UNIFORM_GBUFFER_NORMALMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_GBUFFER_NORMALMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_GBUFFER_NORMALMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_GBUFFER_NORMALMAP_BINDING, UNIFORM_GBUFFER_NORMALMAP_NAME, Type.SAMPLER2D, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_GBUFFER_NORMALMAP_NAME] = UNIFORM_GBUFFER_NORMALMAP_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_GBUFFER_NORMALMAP_BINDING] = UNIFORM_GBUFFER_NORMALMAP_DESCRIPTOR;
            const UNIFORM_LIGHTING_RESULTMAP_NAME = 'cc_lighting_resultMap';
            const UNIFORM_LIGHTING_RESULTMAP_BINDING = PipelineGlobalBindings.SAMPLER_LIGHTING_RESULTMAP;
            const UNIFORM_LIGHTING_RESULTMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_LIGHTING_RESULTMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_LIGHTING_RESULTMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_LIGHTING_RESULTMAP_BINDING, UNIFORM_LIGHTING_RESULTMAP_NAME, Type.SAMPLER2D, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_LIGHTING_RESULTMAP_NAME] = UNIFORM_LIGHTING_RESULTMAP_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_LIGHTING_RESULTMAP_BINDING] = UNIFORM_LIGHTING_RESULTMAP_DESCRIPTOR;
            const UNIFORM_GBUFFER_EMISSIVEMAP_NAME = 'cc_gbuffer_emissiveMap';
            const UNIFORM_GBUFFER_EMISSIVEMAP_BINDING = PipelineGlobalBindings.SAMPLER_GBUFFER_EMISSIVEMAP;
            const UNIFORM_GBUFFER_EMISSIVEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_GBUFFER_EMISSIVEMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_GBUFFER_EMISSIVEMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_GBUFFER_EMISSIVEMAP_BINDING, UNIFORM_GBUFFER_EMISSIVEMAP_NAME, Type.SAMPLER2D, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_GBUFFER_EMISSIVEMAP_NAME] = UNIFORM_GBUFFER_EMISSIVEMAP_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_GBUFFER_EMISSIVEMAP_BINDING] = UNIFORM_GBUFFER_EMISSIVEMAP_DESCRIPTOR;
            const UNIFORM_ENVIRONMENT_NAME = 'cc_environment';
            const UNIFORM_ENVIRONMENT_BINDING = PipelineGlobalBindings.SAMPLER_ENVIRONMENT;
            const UNIFORM_ENVIRONMENT_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_ENVIRONMENT_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_ENVIRONMENT_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_ENVIRONMENT_BINDING, UNIFORM_ENVIRONMENT_NAME, Type.SAMPLER_CUBE, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_ENVIRONMENT_NAME] = UNIFORM_ENVIRONMENT_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_ENVIRONMENT_BINDING] = UNIFORM_ENVIRONMENT_DESCRIPTOR;
            const UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME = 'cc_spotLightingMap';
            const UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING = PipelineGlobalBindings.SAMPLER_SPOT_LIGHTING_MAP;
            const UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME, Type.SAMPLER2D, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME] = UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING] = UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_DESCRIPTOR;
            class UBOLocal {} exports('dg', UBOLocal);
            UBOLocal.MAT_WORLD_OFFSET = 0;
            UBOLocal.MAT_WORLD_IT_OFFSET = UBOLocal.MAT_WORLD_OFFSET + 16;
            UBOLocal.LIGHTINGMAP_UVPARAM = UBOLocal.MAT_WORLD_IT_OFFSET + 16;
            UBOLocal.COUNT = UBOLocal.LIGHTINGMAP_UVPARAM + 4;
            UBOLocal.SIZE = UBOLocal.COUNT * 4;
            UBOLocal.NAME = 'CCLocal';
            UBOLocal.BINDING = ModelLocalBindings.UBO_LOCAL;
            UBOLocal.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOLocal.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
            UBOLocal.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOLocal.BINDING, UBOLocal.NAME, [new Uniform('cc_matWorld', Type.MAT4, 1), new Uniform('cc_matWorldIT', Type.MAT4, 1), new Uniform('cc_lightingMapUVParam', Type.FLOAT4, 1)], 1);
            localDescriptorSetLayout.layouts[UBOLocal.NAME] = UBOLocal.LAYOUT;
            localDescriptorSetLayout.bindings[UBOLocal.BINDING] = UBOLocal.DESCRIPTOR;
            const INST_MAT_WORLD = 'a_matWorld0';
            class UBOLocalBatched {}
            UBOLocalBatched.BATCHING_COUNT = 10;
            UBOLocalBatched.MAT_WORLDS_OFFSET = 0;
            UBOLocalBatched.COUNT = 16 * UBOLocalBatched.BATCHING_COUNT;
            UBOLocalBatched.SIZE = UBOLocalBatched.COUNT * 4;
            UBOLocalBatched.NAME = 'CCLocalBatched';
            UBOLocalBatched.BINDING = ModelLocalBindings.UBO_LOCAL;
            UBOLocalBatched.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOLocalBatched.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
            UBOLocalBatched.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOLocalBatched.BINDING, UBOLocalBatched.NAME, [new Uniform('cc_matWorlds', Type.MAT4, UBOLocalBatched.BATCHING_COUNT)], 1);
            localDescriptorSetLayout.layouts[UBOLocalBatched.NAME] = UBOLocalBatched.LAYOUT;
            localDescriptorSetLayout.bindings[UBOLocalBatched.BINDING] = UBOLocalBatched.DESCRIPTOR;
            class UBOForwardLight {}
            UBOForwardLight.LIGHTS_PER_PASS = 1;
            UBOForwardLight.LIGHT_POS_OFFSET = 0;
            UBOForwardLight.LIGHT_COLOR_OFFSET = UBOForwardLight.LIGHT_POS_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET = UBOForwardLight.LIGHT_COLOR_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.LIGHT_DIR_OFFSET = UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.COUNT = UBOForwardLight.LIGHT_DIR_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.SIZE = UBOForwardLight.COUNT * 4;
            UBOForwardLight.NAME = 'CCForwardLight';
            UBOForwardLight.BINDING = ModelLocalBindings.UBO_FORWARD_LIGHTS;
            UBOForwardLight.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOForwardLight.BINDING, DescriptorType.DYNAMIC_UNIFORM_BUFFER, 1, ShaderStageFlagBit.FRAGMENT);
            UBOForwardLight.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOForwardLight.BINDING, UBOForwardLight.NAME, [new Uniform('cc_lightPos', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightColor', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightSizeRangeAngle', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightDir', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS)], 1);
            localDescriptorSetLayout.layouts[UBOForwardLight.NAME] = UBOForwardLight.LAYOUT;
            localDescriptorSetLayout.bindings[UBOForwardLight.BINDING] = UBOForwardLight.DESCRIPTOR;
            const JOINT_UNIFORM_CAPACITY = 30;
            class UBOSkinningTexture {} exports('cx', UBOSkinningTexture);
            UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0;
            UBOSkinningTexture.COUNT = UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET + 4;
            UBOSkinningTexture.SIZE = UBOSkinningTexture.COUNT * 4;
            UBOSkinningTexture.NAME = 'CCSkinningTexture';
            UBOSkinningTexture.BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
            UBOSkinningTexture.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinningTexture.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
            UBOSkinningTexture.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOSkinningTexture.BINDING, UBOSkinningTexture.NAME, [new Uniform('cc_jointTextureInfo', Type.FLOAT4, 1)], 1);
            localDescriptorSetLayout.layouts[UBOSkinningTexture.NAME] = UBOSkinningTexture.LAYOUT;
            localDescriptorSetLayout.bindings[UBOSkinningTexture.BINDING] = UBOSkinningTexture.DESCRIPTOR;
            class UBOSkinningAnimation {} exports('cp', UBOSkinningAnimation);
            UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET = 0;
            UBOSkinningAnimation.COUNT = UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET + 4;
            UBOSkinningAnimation.SIZE = UBOSkinningAnimation.COUNT * 4;
            UBOSkinningAnimation.NAME = 'CCSkinningAnimation';
            UBOSkinningAnimation.BINDING = ModelLocalBindings.UBO_SKINNING_ANIMATION;
            UBOSkinningAnimation.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinningAnimation.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
            UBOSkinningAnimation.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOSkinningAnimation.BINDING, UBOSkinningAnimation.NAME, [new Uniform('cc_jointAnimInfo', Type.FLOAT4, 1)], 1);
            localDescriptorSetLayout.layouts[UBOSkinningAnimation.NAME] = UBOSkinningAnimation.LAYOUT;
            localDescriptorSetLayout.bindings[UBOSkinningAnimation.BINDING] = UBOSkinningAnimation.DESCRIPTOR;
            const INST_JOINT_ANIM_INFO = exports('cz', 'a_jointAnimInfo');
            class UBOSkinning {} exports('cv', UBOSkinning);
            UBOSkinning.JOINTS_OFFSET = 0;
            UBOSkinning.COUNT = UBOSkinning.JOINTS_OFFSET + JOINT_UNIFORM_CAPACITY * 12;
            UBOSkinning.SIZE = UBOSkinning.COUNT * 4;
            UBOSkinning.NAME = 'CCSkinning';
            UBOSkinning.BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
            UBOSkinning.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinning.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
            UBOSkinning.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOSkinning.BINDING, UBOSkinning.NAME, [new Uniform('cc_joints', Type.FLOAT4, JOINT_UNIFORM_CAPACITY * 3)], 1);
            localDescriptorSetLayout.layouts[UBOSkinning.NAME] = UBOSkinning.LAYOUT;
            localDescriptorSetLayout.bindings[UBOSkinning.BINDING] = UBOSkinning.DESCRIPTOR;
            class UBOMorph {} exports('bw', UBOMorph);
            UBOMorph.MAX_MORPH_TARGET_COUNT = 60;
            UBOMorph.OFFSET_OF_WEIGHTS = 0;
            UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH = 4 * UBOMorph.MAX_MORPH_TARGET_COUNT;
            UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT = UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH + 4;
            UBOMorph.OFFSET_OF_VERTICES_COUNT = UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT + 4;
            UBOMorph.COUNT_BASE_4_BYTES = 4 * Math.ceil(UBOMorph.MAX_MORPH_TARGET_COUNT / 4) + 4;
            UBOMorph.SIZE = UBOMorph.COUNT_BASE_4_BYTES * 4;
            UBOMorph.NAME = 'CCMorph';
            UBOMorph.BINDING = ModelLocalBindings.UBO_MORPH;
            UBOMorph.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOMorph.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
            UBOMorph.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOMorph.BINDING, UBOMorph.NAME, [new Uniform('cc_displacementWeights', Type.FLOAT4, UBOMorph.MAX_MORPH_TARGET_COUNT / 4), new Uniform('cc_displacementTextureInfo', Type.FLOAT4, 1)], 1);
            localDescriptorSetLayout.layouts[UBOMorph.NAME] = UBOMorph.LAYOUT;
            localDescriptorSetLayout.bindings[UBOMorph.BINDING] = UBOMorph.DESCRIPTOR;
            const UNIFORM_JOINT_TEXTURE_NAME = 'cc_jointTexture';
            const UNIFORM_JOINT_TEXTURE_BINDING = exports('cy', ModelLocalBindings.SAMPLER_JOINTS);
            const UNIFORM_JOINT_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_JOINT_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
            const UNIFORM_JOINT_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_JOINT_TEXTURE_BINDING, UNIFORM_JOINT_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_JOINT_TEXTURE_NAME] = UNIFORM_JOINT_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_JOINT_TEXTURE_BINDING] = UNIFORM_JOINT_TEXTURE_DESCRIPTOR;
            const UNIFORM_POSITION_MORPH_TEXTURE_NAME = 'cc_PositionDisplacements';
            const UNIFORM_POSITION_MORPH_TEXTURE_BINDING = exports('bG', ModelLocalBindings.SAMPLER_MORPH_POSITION);
            const UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_POSITION_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
            const UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_POSITION_MORPH_TEXTURE_BINDING, UNIFORM_POSITION_MORPH_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_POSITION_MORPH_TEXTURE_NAME] = UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_POSITION_MORPH_TEXTURE_BINDING] = UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR;
            const UNIFORM_NORMAL_MORPH_TEXTURE_NAME = 'cc_NormalDisplacements';
            const UNIFORM_NORMAL_MORPH_TEXTURE_BINDING = exports('bF', ModelLocalBindings.SAMPLER_MORPH_NORMAL);
            const UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
            const UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, UNIFORM_NORMAL_MORPH_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_NORMAL_MORPH_TEXTURE_NAME] = UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_NORMAL_MORPH_TEXTURE_BINDING] = UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR;
            const UNIFORM_TANGENT_MORPH_TEXTURE_NAME = 'cc_TangentDisplacements';
            const UNIFORM_TANGENT_MORPH_TEXTURE_BINDING = exports('bE', ModelLocalBindings.SAMPLER_MORPH_TANGENT);
            const UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
            const UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, UNIFORM_TANGENT_MORPH_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_TANGENT_MORPH_TEXTURE_NAME] = UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_TANGENT_MORPH_TEXTURE_BINDING] = UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR;
            const UNIFORM_LIGHTMAP_TEXTURE_NAME = 'cc_lightingMap';
            const UNIFORM_LIGHTMAP_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_LIGHTMAP;
            const UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_LIGHTMAP_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_LIGHTMAP_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_LIGHTMAP_TEXTURE_BINDING, UNIFORM_LIGHTMAP_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_LIGHTMAP_TEXTURE_NAME] = UNIFORM_LIGHTMAP_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_LIGHTMAP_TEXTURE_BINDING] = UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR;
            const UNIFORM_SPRITE_TEXTURE_NAME = 'cc_spriteTexture';
            const UNIFORM_SPRITE_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_SPRITE;
            const UNIFORM_SPRITE_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPRITE_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_SPRITE_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_SPRITE_TEXTURE_BINDING, UNIFORM_SPRITE_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_SPRITE_TEXTURE_NAME] = UNIFORM_SPRITE_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_SPRITE_TEXTURE_BINDING] = UNIFORM_SPRITE_TEXTURE_DESCRIPTOR;
            const UNIFORM_REFLECTION_TEXTURE_NAME = 'cc_reflectionTexture';
            const UNIFORM_REFLECTION_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_REFLECTION;
            const UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_REFLECTION_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_TEXTURE_BINDING, UNIFORM_REFLECTION_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_TEXTURE_NAME] = UNIFORM_REFLECTION_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_TEXTURE_BINDING] = UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR;
            const UNIFORM_REFLECTION_STORAGE_NAME = 'cc_reflectionStorage';
            const UNIFORM_REFLECTION_STORAGE_BINDING = ModelLocalBindings.STORAGE_REFLECTION;
            const UNIFORM_REFLECTION_STORAGE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_STORAGE_BINDING, DescriptorType.STORAGE_IMAGE, 1, ShaderStageFlagBit.COMPUTE);
            const UNIFORM_REFLECTION_STORAGE_LAYOUT = new UniformStorageImage(SetIndex.LOCAL, UNIFORM_REFLECTION_STORAGE_BINDING, UNIFORM_REFLECTION_STORAGE_NAME, Type.IMAGE2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_STORAGE_NAME] = UNIFORM_REFLECTION_STORAGE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_STORAGE_BINDING] = UNIFORM_REFLECTION_STORAGE_DESCRIPTOR;
            const CAMERA_DEFAULT_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER]);
            const CAMERA_EDITOR_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.PROFILER]);
            const MODEL_ALWAYS_MASK = Layers.Enum.ALL;

            let CameraFOVAxis;

            (function (CameraFOVAxis) {
              CameraFOVAxis[CameraFOVAxis["VERTICAL"] = 0] = "VERTICAL";
              CameraFOVAxis[CameraFOVAxis["HORIZONTAL"] = 1] = "HORIZONTAL";
            })(CameraFOVAxis || (CameraFOVAxis = {}));

            let CameraProjection;

            (function (CameraProjection) {
              CameraProjection[CameraProjection["ORTHO"] = 0] = "ORTHO";
              CameraProjection[CameraProjection["PERSPECTIVE"] = 1] = "PERSPECTIVE";
            })(CameraProjection || (CameraProjection = {}));

            let CameraAperture;

            (function (CameraAperture) {
              CameraAperture[CameraAperture["F1_8"] = 0] = "F1_8";
              CameraAperture[CameraAperture["F2_0"] = 1] = "F2_0";
              CameraAperture[CameraAperture["F2_2"] = 2] = "F2_2";
              CameraAperture[CameraAperture["F2_5"] = 3] = "F2_5";
              CameraAperture[CameraAperture["F2_8"] = 4] = "F2_8";
              CameraAperture[CameraAperture["F3_2"] = 5] = "F3_2";
              CameraAperture[CameraAperture["F3_5"] = 6] = "F3_5";
              CameraAperture[CameraAperture["F4_0"] = 7] = "F4_0";
              CameraAperture[CameraAperture["F4_5"] = 8] = "F4_5";
              CameraAperture[CameraAperture["F5_0"] = 9] = "F5_0";
              CameraAperture[CameraAperture["F5_6"] = 10] = "F5_6";
              CameraAperture[CameraAperture["F6_3"] = 11] = "F6_3";
              CameraAperture[CameraAperture["F7_1"] = 12] = "F7_1";
              CameraAperture[CameraAperture["F8_0"] = 13] = "F8_0";
              CameraAperture[CameraAperture["F9_0"] = 14] = "F9_0";
              CameraAperture[CameraAperture["F10_0"] = 15] = "F10_0";
              CameraAperture[CameraAperture["F11_0"] = 16] = "F11_0";
              CameraAperture[CameraAperture["F13_0"] = 17] = "F13_0";
              CameraAperture[CameraAperture["F14_0"] = 18] = "F14_0";
              CameraAperture[CameraAperture["F16_0"] = 19] = "F16_0";
              CameraAperture[CameraAperture["F18_0"] = 20] = "F18_0";
              CameraAperture[CameraAperture["F20_0"] = 21] = "F20_0";
              CameraAperture[CameraAperture["F22_0"] = 22] = "F22_0";
            })(CameraAperture || (CameraAperture = {}));

            let CameraISO;

            (function (CameraISO) {
              CameraISO[CameraISO["ISO100"] = 0] = "ISO100";
              CameraISO[CameraISO["ISO200"] = 1] = "ISO200";
              CameraISO[CameraISO["ISO400"] = 2] = "ISO400";
              CameraISO[CameraISO["ISO800"] = 3] = "ISO800";
            })(CameraISO || (CameraISO = {}));

            let CameraShutter;

            (function (CameraShutter) {
              CameraShutter[CameraShutter["D1"] = 0] = "D1";
              CameraShutter[CameraShutter["D2"] = 1] = "D2";
              CameraShutter[CameraShutter["D4"] = 2] = "D4";
              CameraShutter[CameraShutter["D8"] = 3] = "D8";
              CameraShutter[CameraShutter["D15"] = 4] = "D15";
              CameraShutter[CameraShutter["D30"] = 5] = "D30";
              CameraShutter[CameraShutter["D60"] = 6] = "D60";
              CameraShutter[CameraShutter["D125"] = 7] = "D125";
              CameraShutter[CameraShutter["D250"] = 8] = "D250";
              CameraShutter[CameraShutter["D500"] = 9] = "D500";
              CameraShutter[CameraShutter["D1000"] = 10] = "D1000";
              CameraShutter[CameraShutter["D2000"] = 11] = "D2000";
              CameraShutter[CameraShutter["D4000"] = 12] = "D4000";
            })(CameraShutter || (CameraShutter = {}));

            const FSTOPS = [1.8, 2.0, 2.2, 2.5, 2.8, 3.2, 3.5, 4.0, 4.5, 5.0, 5.6, 6.3, 7.1, 8.0, 9.0, 10.0, 11.0, 13.0, 14.0, 16.0, 18.0, 20.0, 22.0];
            const SHUTTERS = [1.0, 1.0 / 2.0, 1.0 / 4.0, 1.0 / 8.0, 1.0 / 15.0, 1.0 / 30.0, 1.0 / 60.0, 1.0 / 125.0, 1.0 / 250.0, 1.0 / 500.0, 1.0 / 1000.0, 1.0 / 2000.0, 1.0 / 4000.0];
            const ISOS = [100.0, 200.0, 400.0, 800.0];
            const v_a = new Vec3();
            const v_b = new Vec3();

            const _tempMat1 = new Mat4();

            const SKYBOX_FLAG = ClearFlagBit.STENCIL << 1;
            const correctionMatrices = [];
            class Camera {
              constructor(device) {
                this.isWindowSize = true;
                this.screenScale = void 0;
                this._device = void 0;
                this._scene = null;
                this._node = null;
                this._name = null;
                this._enabled = false;
                this._proj = -1;
                this._aspect = void 0;
                this._orthoHeight = 10.0;
                this._fovAxis = CameraFOVAxis.VERTICAL;
                this._fov = toRadian(45);
                this._nearClip = 1.0;
                this._farClip = 1000.0;
                this._clearColor = new Color$1(0.2, 0.2, 0.2, 1);
                this._viewport = new Rect(0, 0, 1, 1);
                this._curTransform = SurfaceTransform.IDENTITY;
                this._isProjDirty = true;
                this._matView = new Mat4();
                this._matViewInv = null;
                this._matProj = new Mat4();
                this._matProjInv = new Mat4();
                this._matViewProj = new Mat4();
                this._matViewProjInv = new Mat4();
                this._frustum = new Frustum();
                this._forward = new Vec3();
                this._position = new Vec3();
                this._priority = 0;
                this._aperture = CameraAperture.F16_0;
                this._apertureValue = void 0;
                this._shutter = CameraShutter.D125;
                this._shutterValue = 0.0;
                this._iso = CameraISO.ISO100;
                this._isoValue = 0.0;
                this._ec = 0.0;
                this._window = null;
                this._width = 1;
                this._height = 1;
                this._clearFlag = ClearFlagBit.NONE;
                this._clearDepth = 1.0;
                this._visibility = CAMERA_DEFAULT_MASK;
                this._exposure = 0;
                this._clearStencil = 0;
                this._device = device;
                this._apertureValue = FSTOPS[this._aperture];
                this._shutterValue = SHUTTERS[this._shutter];
                this._isoValue = ISOS[this._iso];
                this._aspect = this.screenScale = 1;

                if (!correctionMatrices.length) {
                  const ySign = device.capabilities.clipSpaceSignY;
                  correctionMatrices[SurfaceTransform.IDENTITY] = new Mat4(1, 0, 0, 0, 0, ySign);
                  correctionMatrices[SurfaceTransform.ROTATE_90] = new Mat4(0, 1, 0, 0, -ySign, 0);
                  correctionMatrices[SurfaceTransform.ROTATE_180] = new Mat4(-1, 0, 0, 0, 0, -ySign);
                  correctionMatrices[SurfaceTransform.ROTATE_270] = new Mat4(0, -1, 0, 0, ySign, 0);
                }
              }

              _setWidth(val) {
                this._width = val;

                {
                  this._nativeObj.width = val;
                }
              }

              _setHeight(val) {
                this._height = val;

                {
                  this._nativeObj.height = val;
                }
              }

              _setScene(scene) {
                this._scene = scene;

                {
                  this._nativeObj.scene = scene ? scene.native : null;
                }
              }

              _init(info) {
                {
                  this._nativeObj = new NativeCamera();
                  if (this._scene) this._nativeObj.scene = this._scene.native;
                  this._nativeObj.frustum = this._frustum;
                }
              }

              initialize(info) {
                this._init(info);

                this.node = info.node;

                this._setWidth(1);

                this._setHeight(1);

                this.clearFlag = ClearFlagBit.NONE;
                this.clearDepth = 1.0;
                this.visibility = CAMERA_DEFAULT_MASK;
                this._name = info.name;
                this._proj = info.projection;
                this._priority = info.priority || 0;
                this._aspect = this.screenScale = 1;
                this.updateExposure();
                this.changeTargetWindow(info.window);
              }

              _destroy() {
                this._nativeObj = null;
              }

              destroy() {
                if (this._window) {
                  this._window.detachCamera(this);

                  this.window = null;
                }

                this._name = null;

                this._destroy();
              }

              attachToScene(scene) {
                this._enabled = true;

                this._setScene(scene);
              }

              detachFromScene() {
                this._enabled = false;

                this._setScene(null);
              }

              resize(width, height) {
                if (!this._window) return;

                this._setWidth(width);

                this._setHeight(height);

                this._aspect = width * this._viewport.width / (height * this._viewport.height);
                this._isProjDirty = true;
              }

              setFixedSize(width, height) {
                this._setWidth(width);

                this._setHeight(height);

                this._aspect = width * this._viewport.width / (height * this._viewport.height);
                this.isWindowSize = false;
              }

              update(forceUpdate = false) {
                if (!this._node) return;
                let viewProjDirty = false;

                if (this._node.hasChangedFlags || forceUpdate) {
                  Mat4.invert(this._matView, this._node.worldMatrix);

                  {
                    this._nativeObj.matView = this._matView;
                  }

                  this._forward.x = -this._matView.m02;
                  this._forward.y = -this._matView.m06;
                  this._forward.z = -this._matView.m10;

                  this._node.getWorldPosition(this._position);

                  {
                    this._nativeObj.position = this._position;
                    this._nativeObj.forward = this._forward;
                  }

                  viewProjDirty = true;
                }

                let orientation = this._device.surfaceTransform;

                if (this._isProjDirty || this._curTransform !== orientation) {
                  var _this$window;

                  this._curTransform = orientation;
                  const projectionSignY = this._device.capabilities.clipSpaceSignY;

                  if ((_this$window = this.window) === null || _this$window === void 0 ? void 0 : _this$window.hasOffScreenAttachments) {
                    orientation = SurfaceTransform.IDENTITY;
                  }

                  if (this._proj === CameraProjection.PERSPECTIVE) {
                    Mat4.perspective(this._matProj, this._fov, this._aspect, this._nearClip, this._farClip, this._fovAxis === CameraFOVAxis.VERTICAL, this._device.capabilities.clipSpaceMinZ, projectionSignY, orientation);
                  } else {
                    const x = this._orthoHeight * this._aspect;
                    const y = this._orthoHeight;
                    Mat4.ortho(this._matProj, -x, x, -y, y, this._nearClip, this._farClip, this._device.capabilities.clipSpaceMinZ, projectionSignY, orientation);
                  }

                  Mat4.invert(this._matProjInv, this._matProj);

                  {
                    this._nativeObj.matProj = this._matProj;
                    this._nativeObj.matProjInv = this._matProjInv;
                  }

                  viewProjDirty = true;
                  this._isProjDirty = false;
                }

                if (viewProjDirty) {
                  Mat4.multiply(this._matViewProj, this._matProj, this._matView);
                  Mat4.invert(this._matViewProjInv, this._matViewProj);

                  this._frustum.update(this._matViewProj, this._matViewProjInv);

                  {
                    this._nativeObj.matViewProj = this._matViewProj;
                    this._nativeObj.matViewProjInv = this._matViewProjInv;
                    this._nativeObj.frustum = this._frustum;
                  }
                }
              }

              set node(val) {
                this._node = val;

                {
                  this._nativeObj.node = this._node.native;
                }
              }

              get node() {
                return this._node;
              }

              set enabled(val) {
                this._enabled = val;
              }

              get enabled() {
                return this._enabled;
              }

              set orthoHeight(val) {
                this._orthoHeight = val;
                this._isProjDirty = true;
              }

              get orthoHeight() {
                return this._orthoHeight;
              }

              set projectionType(val) {
                this._proj = val;
                this._isProjDirty = true;
              }

              get projectionType() {
                return this._proj;
              }

              set fovAxis(axis) {
                this._fovAxis = axis;
                this._isProjDirty = true;
              }

              get fovAxis() {
                return this._fovAxis;
              }

              set fov(fov) {
                this._fov = fov;
                this._isProjDirty = true;
              }

              get fov() {
                return this._fov;
              }

              set nearClip(nearClip) {
                this._nearClip = nearClip;
                this._isProjDirty = true;
              }

              get nearClip() {
                return this._nearClip;
              }

              set farClip(farClip) {
                this._farClip = farClip;
                this._isProjDirty = true;
              }

              get farClip() {
                return this._farClip;
              }

              set clearColor(val) {
                this._clearColor.x = val.x;
                this._clearColor.y = val.y;
                this._clearColor.z = val.z;
                this._clearColor.w = val.w;

                {
                  this._nativeObj.clearColor = this._clearColor;
                }
              }

              get clearColor() {
                return this._clearColor;
              }

              get viewport() {
                return this._viewport;
              }

              set viewport(val) {
                const {
                  x,
                  width,
                  height
                } = val;
                const y = this._device.capabilities.clipSpaceSignY < 0 ? 1 - val.y - height : val.y;

                switch (this._device.surfaceTransform) {
                  case SurfaceTransform.ROTATE_90:
                    this._viewport.x = 1 - y - height;
                    this._viewport.y = x;
                    this._viewport.width = height;
                    this._viewport.height = width;
                    break;

                  case SurfaceTransform.ROTATE_180:
                    this._viewport.x = 1 - x - width;
                    this._viewport.y = 1 - y - height;
                    this._viewport.width = width;
                    this._viewport.height = height;
                    break;

                  case SurfaceTransform.ROTATE_270:
                    this._viewport.x = y;
                    this._viewport.y = 1 - x - width;
                    this._viewport.width = height;
                    this._viewport.height = width;
                    break;

                  case SurfaceTransform.IDENTITY:
                    this._viewport.x = x;
                    this._viewport.y = y;
                    this._viewport.width = width;
                    this._viewport.height = height;
                    break;
                }

                {
                  this._nativeObj.viewPort = this._viewport;
                }

                this.resize(this.width, this.height);
              }

              get scene() {
                return this._scene;
              }

              get name() {
                return this._name;
              }

              get width() {
                return this._width;
              }

              get height() {
                return this._height;
              }

              get aspect() {
                return this._aspect;
              }

              set matView(val) {
                this._matView = val;

                {
                  this._nativeObj.matView = this._matView;
                }
              }

              get matView() {
                return this._matView;
              }

              set matViewInv(val) {
                this._matViewInv = val;
              }

              get matViewInv() {
                return this._matViewInv || this._node.worldMatrix;
              }

              set matProj(val) {
                this._matProj = val;

                {
                  this._nativeObj.matProj = this._matProj;
                }
              }

              get matProj() {
                return this._matProj;
              }

              set matProjInv(val) {
                this._matProjInv = val;

                {
                  this._nativeObj.matProjInv = this._matProjInv;
                }
              }

              get matProjInv() {
                return this._matProjInv;
              }

              set matViewProj(val) {
                this._matViewProj = val;

                {
                  this._nativeObj.matViewProj = this._matViewProj;
                }
              }

              get matViewProj() {
                return this._matViewProj;
              }

              set matViewProjInv(val) {
                this._matViewProjInv = val;

                {
                  this._nativeObj.matViewProjInv = this._matViewProjInv;
                }
              }

              get matViewProjInv() {
                return this._matViewProjInv;
              }

              set frustum(val) {
                this._frustum = val;

                {
                  this._nativeObj.frustum = this._frustum;
                }
              }

              get frustum() {
                return this._frustum;
              }

              set window(val) {
                this._window = val;

                if ( val) {
                  this._nativeObj.window = this._window.native;
                }
              }

              get window() {
                return this._window;
              }

              set forward(val) {
                this._forward = val;

                {
                  this._nativeObj.forward = this._forward;
                }
              }

              get forward() {
                return this._forward;
              }

              set position(val) {
                this._position = val;

                {
                  this._nativeObj.position = this._position;
                }
              }

              get position() {
                return this._position;
              }

              set visibility(vis) {
                this._visibility = vis;

                {
                  this._nativeObj.visibility = this._visibility;
                }
              }

              get visibility() {
                return this._visibility;
              }

              get priority() {
                return this._priority;
              }

              set priority(val) {
                this._priority = val;
              }

              set aperture(val) {
                this._aperture = val;
                this._apertureValue = FSTOPS[this._aperture];
                this.updateExposure();
              }

              get aperture() {
                return this._aperture;
              }

              get apertureValue() {
                return this._apertureValue;
              }

              set shutter(val) {
                this._shutter = val;
                this._shutterValue = SHUTTERS[this._shutter];
                this.updateExposure();
              }

              get shutter() {
                return this._shutter;
              }

              get shutterValue() {
                return this._shutterValue;
              }

              set iso(val) {
                this._iso = val;
                this._isoValue = ISOS[this._iso];
                this.updateExposure();
              }

              get iso() {
                return this._iso;
              }

              get isoValue() {
                return this._isoValue;
              }

              set ec(val) {
                this._ec = val;
              }

              get ec() {
                return this._ec;
              }

              get exposure() {
                return this._exposure;
              }

              get clearFlag() {
                return this._clearFlag;
              }

              set clearFlag(flag) {
                this._clearFlag = flag;

                {
                  this._nativeObj.clearFlag = flag;
                }
              }

              get clearDepth() {
                return this._clearDepth;
              }

              set clearDepth(depth) {
                this._clearDepth = depth;

                {
                  this._nativeObj.clearDepth = depth;
                }
              }

              get clearStencil() {
                return this._clearStencil;
              }

              set clearStencil(stencil) {
                this._clearStencil = stencil;

                {
                  this._nativeObj.clearStencil = stencil;
                }
              }

              get native() {
                return this._nativeObj;
              }

              changeTargetWindow(window = null) {
                if (this._window) {
                  this._window.detachCamera(this);
                }

                const win = window || legacyCC.director.root.mainWindow;

                if (win) {
                  win.attachCamera(this);
                  this.window = win;
                  this.resize(win.width, win.height);
                }
              }

              detachCamera() {
                if (this._window) {
                  this._window.detachCamera(this);
                }
              }

              screenPointToRay(out, x, y) {
                if (!this._node) return null;
                const width = this.width;
                const height = this.height;
                const cx = this._viewport.x * width;
                const cy = this._viewport.y * height;
                const cw = this._viewport.width * width;
                const ch = this._viewport.height * height;
                const isProj = this._proj === CameraProjection.PERSPECTIVE;
                const ySign = this._device.capabilities.clipSpaceSignY;
                const preTransform = preTransforms[this._curTransform];
                Vec3.set(v_a, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, isProj ? 1 : -1);
                const {
                  x: ox,
                  y: oy
                } = v_a;
                v_a.x = ox * preTransform[0] + oy * preTransform[2] * ySign;
                v_a.y = ox * preTransform[1] + oy * preTransform[3] * ySign;
                Vec3.transformMat4(isProj ? v_a : out.o, v_a, this._matViewProjInv);

                if (isProj) {
                  this._node.getWorldPosition(v_b);

                  Ray.fromPoints(out, v_b, v_a);
                } else {
                  Vec3.transformQuat(out.d, Vec3.FORWARD, this._node.worldRotation);
                }

                return out;
              }

              screenToWorld(out, screenPos) {
                const width = this.width;
                const height = this.height;
                const cx = this._viewport.x * width;
                const cy = this._viewport.y * height;
                const cw = this._viewport.width * width;
                const ch = this._viewport.height * height;
                const ySign = this._device.capabilities.clipSpaceSignY;
                const preTransform = preTransforms[this._curTransform];

                if (this._proj === CameraProjection.PERSPECTIVE) {
                  Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 1.0);
                  const {
                    x,
                    y
                  } = out;
                  out.x = x * preTransform[0] + y * preTransform[2] * ySign;
                  out.y = x * preTransform[1] + y * preTransform[3] * ySign;
                  Vec3.transformMat4(out, out, this._matViewProjInv);

                  if (this._node) {
                    this._node.getWorldPosition(v_a);
                  }

                  Vec3.lerp(out, v_a, out, lerp(this._nearClip / this._farClip, 1, screenPos.z));
                } else {
                  Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, screenPos.z * 2 - 1);
                  const {
                    x,
                    y
                  } = out;
                  out.x = x * preTransform[0] + y * preTransform[2] * ySign;
                  out.y = x * preTransform[1] + y * preTransform[3] * ySign;
                  Vec3.transformMat4(out, out, this._matViewProjInv);
                }

                return out;
              }

              worldToScreen(out, worldPos) {
                const width = this.width;
                const height = this.height;
                const cx = this._viewport.x * width;
                const cy = this._viewport.y * height;
                const cw = this._viewport.width * width;
                const ch = this._viewport.height * height;
                const ySign = this._device.capabilities.clipSpaceSignY;
                const preTransform = preTransforms[this._curTransform];
                Vec3.transformMat4(out, worldPos, this._matViewProj);
                const {
                  x,
                  y
                } = out;
                out.x = x * preTransform[0] + y * preTransform[2] * ySign;
                out.y = x * preTransform[1] + y * preTransform[3] * ySign;
                out.x = cx + (out.x + 1) * 0.5 * cw;
                out.y = cy + (out.y + 1) * 0.5 * ch;
                out.z = out.z * 0.5 + 0.5;
                return out;
              }

              worldMatrixToScreen(out, worldMatrix, width, height) {
                Mat4.multiply(out, this._matViewProj, worldMatrix);
                Mat4.multiply(out, correctionMatrices[this._curTransform], out);
                const halfWidth = width / 2;
                const halfHeight = height / 2;
                Mat4.identity(_tempMat1);
                Mat4.transform(_tempMat1, _tempMat1, Vec3.set(v_a, halfWidth, halfHeight, 0));
                Mat4.scale(_tempMat1, _tempMat1, Vec3.set(v_a, halfWidth, halfHeight, 1));
                Mat4.multiply(out, _tempMat1, out);
                return out;
              }

              setExposure(ev100) {
                this._exposure = 0.833333 / 2.0 ** ev100;

                {
                  this._nativeObj.exposure = this._exposure;
                }
              }

              updateExposure() {
                const ev100 = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100.0 / this._isoValue);
                this.setExposure(ev100);
              }

            }

            let CUSTOM_PIXEL_FORMAT = 1024;
            let PixelFormat;

            (function (PixelFormat) {
              PixelFormat[PixelFormat["RGB565"] = Format.R5G6B5] = "RGB565";
              PixelFormat[PixelFormat["RGB5A1"] = Format.RGB5A1] = "RGB5A1";
              PixelFormat[PixelFormat["RGBA4444"] = Format.RGBA4] = "RGBA4444";
              PixelFormat[PixelFormat["RGB888"] = Format.RGB8] = "RGB888";
              PixelFormat[PixelFormat["RGB32F"] = Format.RGB32F] = "RGB32F";
              PixelFormat[PixelFormat["RGBA8888"] = Format.RGBA8] = "RGBA8888";
              PixelFormat[PixelFormat["RGBA32F"] = Format.RGBA32F] = "RGBA32F";
              PixelFormat[PixelFormat["A8"] = Format.A8] = "A8";
              PixelFormat[PixelFormat["I8"] = Format.L8] = "I8";
              PixelFormat[PixelFormat["AI8"] = Format.LA8] = "AI8";
              PixelFormat[PixelFormat["RGB_PVRTC_2BPPV1"] = Format.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1";
              PixelFormat[PixelFormat["RGBA_PVRTC_2BPPV1"] = Format.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1";
              PixelFormat[PixelFormat["RGB_A_PVRTC_2BPPV1"] = CUSTOM_PIXEL_FORMAT++] = "RGB_A_PVRTC_2BPPV1";
              PixelFormat[PixelFormat["RGB_PVRTC_4BPPV1"] = Format.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1";
              PixelFormat[PixelFormat["RGBA_PVRTC_4BPPV1"] = Format.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1";
              PixelFormat[PixelFormat["RGB_A_PVRTC_4BPPV1"] = CUSTOM_PIXEL_FORMAT++] = "RGB_A_PVRTC_4BPPV1";
              PixelFormat[PixelFormat["RGB_ETC1"] = Format.ETC_RGB8] = "RGB_ETC1";
              PixelFormat[PixelFormat["RGBA_ETC1"] = CUSTOM_PIXEL_FORMAT++] = "RGBA_ETC1";
              PixelFormat[PixelFormat["RGB_ETC2"] = Format.ETC2_RGB8] = "RGB_ETC2";
              PixelFormat[PixelFormat["RGBA_ETC2"] = Format.ETC2_RGBA8] = "RGBA_ETC2";
              PixelFormat[PixelFormat["RGBA_ASTC_4x4"] = Format.ASTC_RGBA_4X4] = "RGBA_ASTC_4x4";
              PixelFormat[PixelFormat["RGBA_ASTC_5x4"] = Format.ASTC_RGBA_5X4] = "RGBA_ASTC_5x4";
              PixelFormat[PixelFormat["RGBA_ASTC_5x5"] = Format.ASTC_RGBA_5X5] = "RGBA_ASTC_5x5";
              PixelFormat[PixelFormat["RGBA_ASTC_6x5"] = Format.ASTC_RGBA_6X5] = "RGBA_ASTC_6x5";
              PixelFormat[PixelFormat["RGBA_ASTC_6x6"] = Format.ASTC_RGBA_6X6] = "RGBA_ASTC_6x6";
              PixelFormat[PixelFormat["RGBA_ASTC_8x5"] = Format.ASTC_RGBA_8X5] = "RGBA_ASTC_8x5";
              PixelFormat[PixelFormat["RGBA_ASTC_8x6"] = Format.ASTC_RGBA_8X6] = "RGBA_ASTC_8x6";
              PixelFormat[PixelFormat["RGBA_ASTC_8x8"] = Format.ASTC_RGBA_8X8] = "RGBA_ASTC_8x8";
              PixelFormat[PixelFormat["RGBA_ASTC_10x5"] = Format.ASTC_RGBA_10X5] = "RGBA_ASTC_10x5";
              PixelFormat[PixelFormat["RGBA_ASTC_10x6"] = Format.ASTC_RGBA_10X6] = "RGBA_ASTC_10x6";
              PixelFormat[PixelFormat["RGBA_ASTC_10x8"] = Format.ASTC_RGBA_10X8] = "RGBA_ASTC_10x8";
              PixelFormat[PixelFormat["RGBA_ASTC_10x10"] = Format.ASTC_RGBA_10X10] = "RGBA_ASTC_10x10";
              PixelFormat[PixelFormat["RGBA_ASTC_12x10"] = Format.ASTC_RGBA_12X10] = "RGBA_ASTC_12x10";
              PixelFormat[PixelFormat["RGBA_ASTC_12x12"] = Format.ASTC_RGBA_12X12] = "RGBA_ASTC_12x12";
            })(PixelFormat || (PixelFormat = exports('cF', {})));

            let WrapMode$1;

            (function (WrapMode) {
              WrapMode[WrapMode["REPEAT"] = Address.WRAP] = "REPEAT";
              WrapMode[WrapMode["CLAMP_TO_EDGE"] = Address.CLAMP] = "CLAMP_TO_EDGE";
              WrapMode[WrapMode["MIRRORED_REPEAT"] = Address.MIRROR] = "MIRRORED_REPEAT";
              WrapMode[WrapMode["CLAMP_TO_BORDER"] = Address.BORDER] = "CLAMP_TO_BORDER";
            })(WrapMode$1 || (WrapMode$1 = exports('dH', {})));

            let Filter$1;

            (function (Filter$1) {
              Filter$1[Filter$1["NONE"] = Filter.NONE] = "NONE";
              Filter$1[Filter$1["LINEAR"] = Filter.LINEAR] = "LINEAR";
              Filter$1[Filter$1["NEAREST"] = Filter.POINT] = "NEAREST";
            })(Filter$1 || (Filter$1 = exports('cE', {})));

            var _dec$b, _class$b, _class2$9, _class3$4, _temp$8;

            function isImageBitmap(imageSource) {
              return !!(legacyCC.sys.capabilities.imageBitmap && imageSource instanceof ImageBitmap);
            }

            function isNativeImage(imageSource) {

              if ( imageSource._compressed === true) {
                return false;
              }

              return imageSource instanceof HTMLImageElement || imageSource instanceof HTMLCanvasElement || isImageBitmap(imageSource);
            }

            let ImageAsset = exports('by', (_dec$b = ccclass('cc.ImageAsset'), _dec$b(_class$b = (_class2$9 = (_temp$8 = _class3$4 = class ImageAsset extends Asset {
              get _nativeAsset() {
                return this._nativeData;
              }

              set _nativeAsset(value) {
                if (!(value instanceof HTMLElement) && !isImageBitmap(value)) {
                  value.format = value.format || this._format;
                }

                this.reset(value);
              }

              get data() {
                if (this._nativeData && isNativeImage(this._nativeData)) {
                  return this._nativeData;
                }

                return this._nativeData && this._nativeData._data;
              }

              get width() {
                return this._nativeData.width || this._width;
              }

              get height() {
                return this._nativeData.height || this._height;
              }

              get format() {
                return this._format;
              }

              get isCompressed() {
                return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_ASTC_12x12 || this._format >= PixelFormat.RGB_A_PVRTC_2BPPV1 && this._format <= PixelFormat.RGBA_ETC1;
              }

              get url() {
                return this.nativeUrl;
              }

              constructor(nativeAsset) {
                super();
                this._nativeData = void 0;
                this._exportedExts = undefined;
                this._format = PixelFormat.RGBA8888;
                this._width = 0;
                this._height = 0;
                this._nativeData = {
                  _data: null,
                  width: 0,
                  height: 0,
                  format: 0,
                  _compressed: false
                };

                if (nativeAsset !== undefined) {
                  this.reset(nativeAsset);
                }
              }

              reset(data) {
                if (isImageBitmap(data)) {
                  this._nativeData = data;
                } else if (!(data instanceof HTMLElement)) {
                  this._nativeData = data;
                  this._format = data.format;
                } else {
                  this._nativeData = data;
                }
              }

              destroy() {
                if (this.data && this.data instanceof HTMLImageElement) {
                  this.data.src = '';

                  this._setRawAsset('');

                  this.data.destroy();
                } else if (isImageBitmap(this.data)) {
                  this.data.close && this.data.close();
                }

                return super.destroy();
              }

              _serialize() {
              }

              _deserialize(data) {
                let fmtStr = '';

                if (typeof data === 'string') {
                  fmtStr = data;
                } else {
                  this._width = data.w;
                  this._height = data.h;
                  fmtStr = data.fmt;
                }

                const device = _getGlobalDevice();

                const extensionIDs = fmtStr.split('_');
                let defaultExt = '';
                let preferedExtensionIndex = Number.MAX_VALUE;
                let format = this._format;
                let ext = '';
                const SupportTextureFormats = legacyCC.macro.SUPPORT_TEXTURE_FORMATS;

                for (const extensionID of extensionIDs) {
                  const extFormat = extensionID.split('@');
                  const i = parseInt(extFormat[0], undefined);
                  const tmpExt = ImageAsset.extnames[i] || extFormat[0];
                  const index = SupportTextureFormats.indexOf(tmpExt);

                  if (index !== -1 && index < preferedExtensionIndex) {
                    const fmt = extFormat[1] ? parseInt(extFormat[1]) : this._format;

                    if (tmpExt === '.astc' && (!device || !device.hasFeature(Feature.FORMAT_ASTC))) {
                      continue;
                    } else if (tmpExt === '.pvr' && (!device || !device.hasFeature(Feature.FORMAT_PVRTC))) {
                      continue;
                    } else if ((fmt === PixelFormat.RGB_ETC1 || fmt === PixelFormat.RGBA_ETC1) && (!device || !device.hasFeature(Feature.FORMAT_ETC1))) {
                      continue;
                    } else if ((fmt === PixelFormat.RGB_ETC2 || fmt === PixelFormat.RGBA_ETC2) && (!device || !device.hasFeature(Feature.FORMAT_ETC2))) {
                      continue;
                    } else if (tmpExt === '.webp' && !legacyCC.sys.capabilities.webp) {
                      continue;
                    }

                    preferedExtensionIndex = index;
                    ext = tmpExt;
                    format = fmt;
                  } else if (!defaultExt) {
                    defaultExt = tmpExt;
                  }
                }

                if (ext) {
                  this._setRawAsset(ext);

                  this._format = format;
                } else if (defaultExt) {
                  this._setRawAsset(defaultExt);

                  warnID(3120, defaultExt, defaultExt);
                } else {
                  warnID(3121);
                }
              }

              initDefault(uuid) {
                super.initDefault(uuid);

                if (!ImageAsset._sharedPlaceHolderCanvas) {
                  const canvas = document.createElement('canvas');
                  const context = canvas.getContext('2d');
                  const l = canvas.width = canvas.height = 2;
                  context.fillStyle = '#ff00ff';
                  context.fillRect(0, 0, l, l);
                  this.reset(canvas);
                  ImageAsset._sharedPlaceHolderCanvas = canvas;
                } else {
                  this.reset(ImageAsset._sharedPlaceHolderCanvas);
                }
              }

              validate() {
                return !!this.data;
              }

            }, _class3$4.extnames = ['.png', '.jpg', '.jpeg', '.bmp', '.webp', '.pvr', '.pkm', '.astc'], _class3$4._sharedPlaceHolderCanvas = null, _temp$8), (_applyDecoratedDescriptor(_class2$9.prototype, "_nativeAsset", [override], Object.getOwnPropertyDescriptor(_class2$9.prototype, "_nativeAsset"), _class2$9.prototype)), _class2$9)) || _class$b));

            function _getGlobalDevice() {
              if (legacyCC.director.root) {
                return legacyCC.director.root.device;
              }

              return null;
            }

            legacyCC.ImageAsset = ImageAsset;

            let SamplerInfoIndex;

            (function (SamplerInfoIndex) {
              SamplerInfoIndex[SamplerInfoIndex["minFilter"] = 0] = "minFilter";
              SamplerInfoIndex[SamplerInfoIndex["magFilter"] = 1] = "magFilter";
              SamplerInfoIndex[SamplerInfoIndex["mipFilter"] = 2] = "mipFilter";
              SamplerInfoIndex[SamplerInfoIndex["addressU"] = 3] = "addressU";
              SamplerInfoIndex[SamplerInfoIndex["addressV"] = 4] = "addressV";
              SamplerInfoIndex[SamplerInfoIndex["addressW"] = 5] = "addressW";
              SamplerInfoIndex[SamplerInfoIndex["maxAnisotropy"] = 6] = "maxAnisotropy";
              SamplerInfoIndex[SamplerInfoIndex["cmpFunc"] = 7] = "cmpFunc";
              SamplerInfoIndex[SamplerInfoIndex["mipLODBias"] = 8] = "mipLODBias";
              SamplerInfoIndex[SamplerInfoIndex["total"] = 9] = "total";
            })(SamplerInfoIndex || (SamplerInfoIndex = {}));

            const defaultInfo = [Filter.LINEAR, Filter.LINEAR, Filter.NONE, Address.WRAP, Address.WRAP, Address.WRAP, 0, ComparisonFunc.NEVER, 0];
            const defaultSamplerHash = genSamplerHash(defaultInfo);
            const borderColor = new Color$1();

            const _samplerInfo = new SamplerInfo();

            function genSamplerHash(info) {
              let value = 0;
              let hash = 0;

              for (let i = 0; i < defaultInfo.length; i++) {
                value = info[i] || defaultInfo[i];

                switch (i) {
                  case SamplerInfoIndex.minFilter:
                    hash |= value;
                    break;

                  case SamplerInfoIndex.magFilter:
                    hash |= value << 2;
                    break;

                  case SamplerInfoIndex.mipFilter:
                    hash |= value << 4;
                    break;

                  case SamplerInfoIndex.addressU:
                    hash |= value << 6;
                    break;

                  case SamplerInfoIndex.addressV:
                    hash |= value << 8;
                    break;

                  case SamplerInfoIndex.addressW:
                    hash |= value << 10;
                    break;

                  case SamplerInfoIndex.maxAnisotropy:
                    hash |= value << 12;
                    break;

                  case SamplerInfoIndex.cmpFunc:
                    hash |= value << 16;
                    break;

                  case SamplerInfoIndex.mipLODBias:
                    hash |= value << 28;
                    break;
                }
              }

              return hash;
            }

            class SamplerLib {
              constructor() {
                this._cache = {};
              }

              getSampler(device, hash) {
                if (!hash) {
                  hash = defaultSamplerHash;
                }

                const cache = this._cache[hash];

                if (cache) {
                  return cache;
                }

                _samplerInfo.minFilter = hash & 3;
                _samplerInfo.magFilter = hash >> 2 & 3;
                _samplerInfo.mipFilter = hash >> 4 & 3;
                _samplerInfo.addressU = hash >> 6 & 3;
                _samplerInfo.addressV = hash >> 8 & 3;
                _samplerInfo.addressW = hash >> 10 & 3;
                _samplerInfo.maxAnisotropy = hash >> 12 & 15;
                _samplerInfo.cmpFunc = hash >> 16 & 15;
                _samplerInfo.mipLODBias = hash >> 28 & 15;
                _samplerInfo.borderColor = borderColor;
                const sampler = this._cache[hash] = device.createSampler(_samplerInfo);
                return sampler;
              }

            }

            const samplerLib = exports('bA', new SamplerLib());
            legacyCC.samplerLib = samplerLib;

            var _dec$c, _class$c, _class2$a, _descriptor$8, _descriptor2$5, _descriptor3$4, _descriptor4$3, _descriptor5$2, _descriptor6$1, _descriptor7$1, _descriptor8$1, _class3$5, _temp$9;
            const idGenerator$1 = new IDGenerator('Tex');
            let TextureBase = exports('c_', (_dec$c = ccclass('cc.TextureBase'), _dec$c(_class$c = (_class2$a = (_temp$9 = _class3$5 = class TextureBase extends Asset {
              get isCompressed() {
                return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_ASTC_12x12 || this._format >= PixelFormat.RGB_A_PVRTC_2BPPV1 && this._format <= PixelFormat.RGBA_ETC1;
              }

              get width() {
                return this._width;
              }

              get height() {
                return this._height;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_format", _descriptor$8, this);

                _initializerDefineProperty(this, "_minFilter", _descriptor2$5, this);

                _initializerDefineProperty(this, "_magFilter", _descriptor3$4, this);

                _initializerDefineProperty(this, "_mipFilter", _descriptor4$3, this);

                _initializerDefineProperty(this, "_wrapS", _descriptor5$2, this);

                _initializerDefineProperty(this, "_wrapT", _descriptor6$1, this);

                _initializerDefineProperty(this, "_wrapR", _descriptor7$1, this);

                _initializerDefineProperty(this, "_anisotropy", _descriptor8$1, this);

                this._width = 1;
                this._height = 1;
                this._id = void 0;
                this._samplerInfo = [];
                this._samplerHash = 0;
                this._gfxSampler = null;
                this._gfxDevice = null;
                this._textureHash = 0;
                this._id = idGenerator$1.getNewId();
                this._gfxDevice = this._getGFXDevice();
                this._textureHash = murmurhash2_32_gc(this._id, 666);
              }

              getId() {
                return this._id;
              }

              getPixelFormat() {
                return this._format;
              }

              getAnisotropy() {
                return this._anisotropy;
              }

              setWrapMode(wrapS, wrapT, wrapR) {
                this._wrapS = wrapS;
                this._samplerInfo[SamplerInfoIndex.addressU] = wrapS;
                this._wrapT = wrapT;
                this._samplerInfo[SamplerInfoIndex.addressV] = wrapT;

                if (wrapR !== undefined) {
                  this._wrapR = wrapR;
                  this._samplerInfo[SamplerInfoIndex.addressW] = wrapR;
                }

                this._samplerHash = genSamplerHash(this._samplerInfo);

                if (this._gfxDevice) {
                  this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
                }
              }

              setFilters(minFilter, magFilter) {
                this._minFilter = minFilter;
                this._samplerInfo[SamplerInfoIndex.minFilter] = minFilter;
                this._magFilter = magFilter;
                this._samplerInfo[SamplerInfoIndex.magFilter] = magFilter;
                this._samplerHash = genSamplerHash(this._samplerInfo);

                if (this._gfxDevice) {
                  this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
                }
              }

              setMipFilter(mipFilter) {
                this._mipFilter = mipFilter;
                this._samplerInfo[SamplerInfoIndex.mipFilter] = mipFilter;
                this._samplerHash = genSamplerHash(this._samplerInfo);

                if (this._gfxDevice) {
                  this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
                }
              }

              setAnisotropy(anisotropy) {
                this._anisotropy = anisotropy;
                this._samplerInfo[SamplerInfoIndex.maxAnisotropy] = anisotropy;
                this._samplerHash = genSamplerHash(this._samplerInfo);

                if (this._gfxDevice) {
                  this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
                }
              }

              destroy() {
                var _legacyCC$director$ro;

                const destroyed = super.destroy();

                if (destroyed && ((_legacyCC$director$ro = legacyCC.director.root) === null || _legacyCC$director$ro === void 0 ? void 0 : _legacyCC$director$ro.batcher2D)) {
                  legacyCC.director.root.batcher2D._releaseDescriptorSetCache(this._textureHash);
                }

                return destroyed;
              }

              getHash() {
                return this._textureHash;
              }

              getGFXTexture() {
                return null;
              }

              getSamplerHash() {
                return this._samplerHash;
              }

              getGFXSampler() {
                if (!this._gfxSampler) {
                  if (this._gfxDevice) {
                    this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
                  } else {
                    errorID(9302);
                  }
                }

                return this._gfxSampler;
              }

              _serialize(ctxForExporting) {

                return '';
              }

              _deserialize(serializedData, handle) {
                const data = serializedData;
                const fields = data.split(',');
                fields.unshift('');

                if (fields.length >= 5) {
                  this.setFilters(parseInt(fields[1]), parseInt(fields[2]));
                  this.setWrapMode(parseInt(fields[3]), parseInt(fields[4]));
                }

                if (fields.length >= 7) {
                  this.setMipFilter(parseInt(fields[5]));
                  this.setAnisotropy(parseInt(fields[6]));
                }
              }

              _getGFXDevice() {
                if (legacyCC.director.root) {
                  return legacyCC.director.root.device;
                }

                return null;
              }

              _getGFXFormat() {
                return this._getGFXPixelFormat(this._format);
              }

              _setGFXFormat(format) {
                this._format = format === undefined ? PixelFormat.RGBA8888 : format;
              }

              _getGFXPixelFormat(format) {
                if (format === PixelFormat.RGBA_ETC1) {
                  format = PixelFormat.RGB_ETC1;
                } else if (format === PixelFormat.RGB_A_PVRTC_4BPPV1) {
                  format = PixelFormat.RGB_PVRTC_4BPPV1;
                } else if (format === PixelFormat.RGB_A_PVRTC_2BPPV1) {
                  format = PixelFormat.RGB_PVRTC_2BPPV1;
                }

                return format;
              }

            }, _class3$5.PixelFormat = PixelFormat, _class3$5.WrapMode = WrapMode$1, _class3$5.Filter = Filter$1, _temp$9), (_descriptor$8 = _applyDecoratedDescriptor(_class2$a.prototype, "_format", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return PixelFormat.RGBA8888;
              }
            }), _descriptor2$5 = _applyDecoratedDescriptor(_class2$a.prototype, "_minFilter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Filter$1.LINEAR;
              }
            }), _descriptor3$4 = _applyDecoratedDescriptor(_class2$a.prototype, "_magFilter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Filter$1.LINEAR;
              }
            }), _descriptor4$3 = _applyDecoratedDescriptor(_class2$a.prototype, "_mipFilter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Filter$1.NONE;
              }
            }), _descriptor5$2 = _applyDecoratedDescriptor(_class2$a.prototype, "_wrapS", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return WrapMode$1.REPEAT;
              }
            }), _descriptor6$1 = _applyDecoratedDescriptor(_class2$a.prototype, "_wrapT", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return WrapMode$1.REPEAT;
              }
            }), _descriptor7$1 = _applyDecoratedDescriptor(_class2$a.prototype, "_wrapR", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return WrapMode$1.REPEAT;
              }
            }), _descriptor8$1 = _applyDecoratedDescriptor(_class2$a.prototype, "_anisotropy", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$a)) || _class$c));
            legacyCC.TextureBase = TextureBase;

            const dependMap = new WeakMap();
            const nativeDependMap = new WeakSet();
            const onLoadedInvokedMap = new WeakSet();

            function deserializeAsset(json, options) {
              let classFinder;

              {
                classFinder = MissingScript.safeFindClass;
              }

              const tdInfo = Details.pool.get();
              let asset;

              try {
                asset = deserialize(json, tdInfo, {
                  classFinder,
                  customEnv: options
                });
              } catch (e) {
                error(e);
                Details.pool.put(tdInfo);
                throw e;
              }

              asset._uuid = options.__uuid__ || '';

              const uuidList = tdInfo.uuidList;
              const objList = tdInfo.uuidObjList;
              const propList = tdInfo.uuidPropList;
              const typeList = tdInfo.uuidTypeList || [];
              const depends = [];

              for (let i = 0; i < uuidList.length; i++) {
                const dependUuid = uuidList[i];
                depends[i] = {
                  uuid: decodeUuid(dependUuid),
                  owner: objList[i],
                  prop: propList[i],
                  type: js._getClassById(typeList[i])
                };
              }

              dependMap.set(asset, depends);

              if (asset._native) {
                nativeDependMap.add(asset);
              }

              Details.pool.put(tdInfo);
              return asset;
            }

            class DependUtil {
              constructor() {
                this._depends = new Cache();
              }

              init() {
                this._depends.clear();
              }

              getNativeDep(uuid) {
                const depend = this._depends.get(uuid);

                if (depend && depend.nativeDep) {
                  return { ...depend.nativeDep
                  };
                }

                return null;
              }

              getDeps(uuid) {
                if (this._depends.has(uuid)) {
                  return this._depends.get(uuid).deps;
                }

                return [];
              }

              getDepsRecursively(uuid) {
                const exclude = Object.create(null);
                const depends = [];

                this._descend(uuid, exclude, depends);

                return depends;
              }

              remove(uuid) {
                this._depends.remove(uuid);
              }

              parse(uuid, json) {
                let out = null;

                if (Array.isArray(json) || json.__type__ || json instanceof CCON) {
                  if (this._depends.has(uuid)) {
                    return this._depends.get(uuid);
                  }

                  if (Array.isArray(json) && ( !hasNativeDep(json))) {
                    out = {
                      deps: this._parseDepsFromJson(json)
                    };
                  } else {
                    try {
                      const asset = deserializeAsset(json, {
                        __uuid__: uuid
                      });
                      out = this._parseDepsFromAsset(asset);

                      if (out.nativeDep) {
                        out.nativeDep.uuid = uuid;
                      }

                      parsed.add(`${uuid}@import`, asset);
                    } catch (e) {
                      files.remove(`${uuid}@import`);
                      out = {
                        deps: []
                      };
                    }
                  }
                } else {
                  if ( this._depends.has(uuid)) {
                    out = this._depends.get(uuid);

                    if (out.parsedFromExistAsset) {
                      return out;
                    }
                  }

                  out = this._parseDepsFromAsset(json);
                }

                this._depends.add(uuid, out);

                return out;
              }

              _parseDepsFromAsset(asset) {
                const out = {
                  deps: [],
                  parsedFromExistAsset: true
                };
                const deps = dependMap.get(asset);
                assertIsNonNullable(deps);

                for (let i = 0, l = deps.length; i < l; i++) {
                  out.deps.push(deps[i].uuid);
                }

                if (nativeDependMap.has(asset)) {
                  out.nativeDep = asset._nativeDep;
                }

                return out;
              }

              _parseDepsFromJson(json) {
                const depends = parseUuidDependencies(json);
                depends.forEach((uuid, index) => depends[index] = decodeUuid(uuid));
                return depends;
              }

              _descend(uuid, exclude, depends) {
                const deps = this.getDeps(uuid);

                for (let i = 0; i < deps.length; i++) {
                  const depend = deps[i];

                  if (!exclude[depend]) {
                    exclude[depend] = true;
                    depends.push(depend);

                    this._descend(depend, exclude, depends);
                  }
                }
              }

            }
            var dependUtil = new DependUtil();

            var _dec$d, _class$d, _temp$a;
            const _regions = [new BufferTextureCopy()];

            function getMipLevel(width, height) {
              let size = Math.max(width, height);
              let level = 0;

              while (size) {
                size >>= 1;
                level++;
              }

              return level;
            }

            function isPOT(n) {
              return n && (n & n - 1) === 0;
            }

            function canGenerateMipmap(device, w, h) {
              const needCheckPOT = device.gfxAPI === API.WEBGL;

              if (needCheckPOT) {
                return isPOT(w) && isPOT(h);
              }

              return true;
            }

            let SimpleTexture = (_dec$d = ccclass('cc.SimpleTexture'), _dec$d(_class$d = (_temp$a = class SimpleTexture extends TextureBase {
              constructor(...args) {
                super(...args);
                this._gfxTexture = null;
                this._mipmapLevel = 1;
                this._textureWidth = 0;
                this._textureHeight = 0;
              }

              get mipmapLevel() {
                return this._mipmapLevel;
              }

              getGFXTexture() {
                return this._gfxTexture;
              }

              destroy() {
                this._tryDestroyTexture();

                return super.destroy();
              }

              updateImage() {
                this.updateMipmaps(0);
              }

              updateMipmaps(firstLevel = 0, count) {}

              uploadData(source, level = 0, arrayIndex = 0) {
                if (!this._gfxTexture || this._mipmapLevel <= level) {
                  return;
                }

                const gfxDevice = this._getGFXDevice();

                if (!gfxDevice) {
                  return;
                }

                const region = _regions[0];
                region.texExtent.width = this._textureWidth >> level;
                region.texExtent.height = this._textureHeight >> level;
                region.texSubres.mipLevel = level;
                region.texSubres.baseArrayLayer = arrayIndex;

                if (ArrayBuffer.isView(source)) {
                  gfxDevice.copyBuffersToTexture([source], this._gfxTexture, _regions);
                } else {
                  gfxDevice.copyTexImagesToTexture([source], this._gfxTexture, _regions);
                }
              }

              _assignImage(image, level, arrayIndex) {
                const data = image.data;

                if (!data) {
                  return;
                }

                this.uploadData(data, level, arrayIndex);

                this._checkTextureLoaded();

                if (macro.CLEANUP_IMAGE_CACHE) {
                  const deps = dependUtil.getDeps(this._uuid);
                  const index = deps.indexOf(image._uuid);

                  if (index !== -1) {
                    fastRemoveAt(deps, index);
                    image.decRef();
                  }
                }
              }

              _checkTextureLoaded() {
                this._textureReady();
              }

              _textureReady() {
                this.loaded = true;
                this.emit('load');
              }

              _setMipmapLevel(value) {
                this._mipmapLevel = value < 1 ? 1 : value;
              }

              _getGfxTextureCreateInfo(presumed) {
                return null;
              }

              _tryReset() {
                this._tryDestroyTexture();

                if (this._mipmapLevel === 0) {
                  return;
                }

                const device = this._getGFXDevice();

                if (!device) {
                  return;
                }

                this._createTexture(device);
              }

              _createTexture(device) {
                if (this._width === 0 || this._height === 0) {
                  return;
                }

                let flags = TextureFlagBit.NONE;

                if (this._mipFilter !== Filter$1.NONE && canGenerateMipmap(device, this._width, this._height)) {
                  this._mipmapLevel = getMipLevel(this._width, this._height);
                  flags = TextureFlagBit.GEN_MIPMAP;
                }

                const textureCreateInfo = this._getGfxTextureCreateInfo({
                  usage: TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST,
                  format: this._getGFXFormat(),
                  levelCount: this._mipmapLevel,
                  flags: flags | TextureFlagBit.IMMUTABLE
                });

                if (!textureCreateInfo) {
                  return;
                }

                const texture = device.createTexture(textureCreateInfo);
                this._textureWidth = textureCreateInfo.width;
                this._textureHeight = textureCreateInfo.height;
                this._gfxTexture = texture;
              }

              _tryDestroyTexture() {
                if (this._gfxTexture) {
                  this._gfxTexture.destroy();

                  this._gfxTexture = null;
                }
              }

            }, _temp$a)) || _class$d);
            legacyCC.SimpleTexture = SimpleTexture;

            var _dec$e, _dec2$5, _class$e, _class2$b, _descriptor$9, _temp$b;
            let Texture2D = exports('bz', (_dec$e = ccclass('cc.Texture2D'), _dec2$5 = type([ImageAsset]), _dec$e(_class$e = (_class2$b = (_temp$b = class Texture2D extends SimpleTexture {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_mipmaps", _descriptor$9, this);
              }

              get mipmaps() {
                return this._mipmaps;
              }

              set mipmaps(value) {
                this._mipmaps = value;

                this._setMipmapLevel(this._mipmaps.length);

                if (this._mipmaps.length > 0) {
                  const imageAsset = this._mipmaps[0];
                  this.reset({
                    width: imageAsset.width,
                    height: imageAsset.height,
                    format: imageAsset.format,
                    mipmapLevel: this._mipmaps.length
                  });

                  this._mipmaps.forEach((mipmap, level) => {
                    this._assignImage(mipmap, level);
                  });
                } else {
                  this.reset({
                    width: 0,
                    height: 0,
                    mipmapLevel: this._mipmaps.length
                  });
                }
              }

              get image() {
                return this._mipmaps.length === 0 ? null : this._mipmaps[0];
              }

              set image(value) {
                this.mipmaps = value ? [value] : [];
              }

              initialize() {
                this.mipmaps = this._mipmaps;
              }

              onLoaded() {
                this.initialize();
              }

              reset(info) {
                this._width = info.width;
                this._height = info.height;

                this._setGFXFormat(info.format);

                this._setMipmapLevel(info.mipmapLevel || 1);

                this._tryReset();
              }

              create(width, height, format = PixelFormat.RGBA8888, mipmapLevel = 1) {
                this.reset({
                  width,
                  height,
                  format,
                  mipmapLevel
                });
              }

              toString() {
                return this._mipmaps.length !== 0 ? this._mipmaps[0].url : '';
              }

              updateMipmaps(firstLevel = 0, count) {
                if (firstLevel >= this._mipmaps.length) {
                  return;
                }

                const nUpdate = Math.min(count === undefined ? this._mipmaps.length : count, this._mipmaps.length - firstLevel);

                for (let i = 0; i < nUpdate; ++i) {
                  const level = firstLevel + i;

                  this._assignImage(this._mipmaps[level], level);
                }
              }

              getHtmlElementObj() {
                return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null;
              }

              destroy() {
                this._mipmaps = [];
                return super.destroy();
              }

              description() {
                const url = this._mipmaps[0] ? this._mipmaps[0].url : '';
                return `<cc.Texture2D | Name = ${url} | Dimension = ${this.width} x ${this.height}>`;
              }

              releaseTexture() {
                this.destroy();
              }

              _serialize(ctxForExporting) {

                return null;
              }

              _deserialize(serializedData, handle) {
                const data = serializedData;

                super._deserialize(data.base, handle);

                this._mipmaps = new Array(data.mipmaps.length);

                for (let i = 0; i < data.mipmaps.length; ++i) {
                  this._mipmaps[i] = new ImageAsset();

                  if (!data.mipmaps[i]) {
                    continue;
                  }

                  const mipmapUUID = data.mipmaps[i];
                  handle.result.push(this._mipmaps, `${i}`, mipmapUUID, js._getClassId(ImageAsset));
                }
              }

              _getGfxTextureCreateInfo(presumed) {
                const texInfo = new TextureInfo(TextureType.TEX2D);
                texInfo.width = this._width;
                texInfo.height = this._height;
                return Object.assign(texInfo, presumed);
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                const imageAsset = new ImageAsset();
                imageAsset.initDefault();
                this.image = imageAsset;
              }

              validate() {
                return this.mipmaps && this.mipmaps.length !== 0;
              }

            }, _temp$b), (_descriptor$9 = _applyDecoratedDescriptor(_class2$b.prototype, "_mipmaps", [_dec2$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$b)) || _class$e));
            legacyCC.Texture2D = Texture2D;

            var _dec$f, _class$f, _class2$c, _descriptor$a, _descriptor2$6, _class3$6, _temp$c;
            var FaceIndex;

            (function (FaceIndex) {
              FaceIndex[FaceIndex["right"] = 0] = "right";
              FaceIndex[FaceIndex["left"] = 1] = "left";
              FaceIndex[FaceIndex["top"] = 2] = "top";
              FaceIndex[FaceIndex["bottom"] = 3] = "bottom";
              FaceIndex[FaceIndex["front"] = 4] = "front";
              FaceIndex[FaceIndex["back"] = 5] = "back";
            })(FaceIndex || (FaceIndex = {}));

            let TextureCube = exports('f9', (_dec$f = ccclass('cc.TextureCube'), _dec$f(_class$f = (_class2$c = (_temp$c = _class3$6 = class TextureCube extends SimpleTexture {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "isRGBE", _descriptor$a, this);

                _initializerDefineProperty(this, "_mipmaps", _descriptor2$6, this);
              }

              get mipmaps() {
                return this._mipmaps;
              }

              set mipmaps(value) {
                this._mipmaps = value;

                this._setMipmapLevel(this._mipmaps.length);

                if (this._mipmaps.length > 0) {
                  const imageAsset = this._mipmaps[0].front;
                  this.reset({
                    width: imageAsset.width,
                    height: imageAsset.height,
                    format: imageAsset.format,
                    mipmapLevel: this._mipmaps.length
                  });

                  this._mipmaps.forEach((mipmap, level) => {
                    _forEachFace(mipmap, (face, faceIndex) => {
                      this._assignImage(face, level, faceIndex);
                    });
                  });
                } else {
                  this.reset({
                    width: 0,
                    height: 0,
                    mipmapLevel: this._mipmaps.length
                  });
                }
              }

              get image() {
                return this._mipmaps.length === 0 ? null : this._mipmaps[0];
              }

              set image(value) {
                this.mipmaps = value ? [value] : [];
              }

              static fromTexture2DArray(textures, out) {
                const mipmaps = [];
                const nMipmaps = textures.length / 6;

                for (let i = 0; i < nMipmaps; i++) {
                  const x = i * 6;
                  mipmaps.push({
                    front: textures[x + FaceIndex.front].image,
                    back: textures[x + FaceIndex.back].image,
                    left: textures[x + FaceIndex.left].image,
                    right: textures[x + FaceIndex.right].image,
                    top: textures[x + FaceIndex.top].image,
                    bottom: textures[x + FaceIndex.bottom].image
                  });
                }

                out = out || new TextureCube();
                out.mipmaps = mipmaps;
                return out;
              }

              onLoaded() {
                this.mipmaps = this._mipmaps;
              }

              reset(info) {
                this._width = info.width;
                this._height = info.height;

                this._setGFXFormat(info.format);

                this._setMipmapLevel(info.mipmapLevel || 1);

                this._tryReset();
              }

              updateMipmaps(firstLevel = 0, count) {
                if (firstLevel >= this._mipmaps.length) {
                  return;
                }

                const nUpdate = Math.min(count === undefined ? this._mipmaps.length : count, this._mipmaps.length - firstLevel);

                for (let i = 0; i < nUpdate; ++i) {
                  const level = firstLevel + i;

                  _forEachFace(this._mipmaps[level], (face, faceIndex) => {
                    this._assignImage(face, level, faceIndex);
                  });
                }
              }

              destroy() {
                this._mipmaps = [];
                return super.destroy();
              }

              releaseTexture() {
                this.mipmaps = [];
              }

              _serialize(ctxForExporting) {

                return null;
              }

              _deserialize(serializedData, handle) {
                const data = serializedData;

                super._deserialize(data.base, handle);

                this.isRGBE = data.rgbe;
                this._mipmaps = new Array(data.mipmaps.length);

                for (let i = 0; i < data.mipmaps.length; ++i) {
                  this._mipmaps[i] = {
                    front: new ImageAsset(),
                    back: new ImageAsset(),
                    left: new ImageAsset(),
                    right: new ImageAsset(),
                    top: new ImageAsset(),
                    bottom: new ImageAsset()
                  };
                  const mipmap = data.mipmaps[i];

                  const imageAssetClassId = js._getClassId(ImageAsset);

                  handle.result.push(this._mipmaps[i], `front`, mipmap.front, imageAssetClassId);
                  handle.result.push(this._mipmaps[i], `back`, mipmap.back, imageAssetClassId);
                  handle.result.push(this._mipmaps[i], `left`, mipmap.left, imageAssetClassId);
                  handle.result.push(this._mipmaps[i], `right`, mipmap.right, imageAssetClassId);
                  handle.result.push(this._mipmaps[i], `top`, mipmap.top, imageAssetClassId);
                  handle.result.push(this._mipmaps[i], `bottom`, mipmap.bottom, imageAssetClassId);
                }
              }

              _getGfxTextureCreateInfo(presumed) {
                const texInfo = new TextureInfo(TextureType.CUBE);
                texInfo.width = this._width;
                texInfo.height = this._height;
                texInfo.layerCount = 6;
                Object.assign(texInfo, presumed);
                return texInfo;
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                const imageAsset = new ImageAsset();
                imageAsset.initDefault();
                this.mipmaps = [{
                  front: imageAsset,
                  back: imageAsset,
                  top: imageAsset,
                  bottom: imageAsset,
                  left: imageAsset,
                  right: imageAsset
                }];
              }

              validate() {
                return this._mipmaps.length !== 0 && !this._mipmaps.find(x => !(x.top && x.bottom && x.front && x.back && x.left && x.right));
              }

            }, _class3$6.FaceIndex = FaceIndex, _temp$c), (_descriptor$a = _applyDecoratedDescriptor(_class2$c.prototype, "isRGBE", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$6 = _applyDecoratedDescriptor(_class2$c.prototype, "_mipmaps", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$c)) || _class$f));
            legacyCC.TextureCube = TextureCube;

            function _forEachFace(mipmap, callback) {
              callback(mipmap.front, FaceIndex.front);
              callback(mipmap.back, FaceIndex.back);
              callback(mipmap.left, FaceIndex.left);
              callback(mipmap.right, FaceIndex.right);
              callback(mipmap.top, FaceIndex.top);
              callback(mipmap.bottom, FaceIndex.bottom);
            }

            const effects = exports('fQ', [{
              "name": "billboard",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "billboard|vert:vs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "billboard|vert:vs_main|tinted-fs:add",
                "hash": 308883658,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 50,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 38
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "builtin",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 1,
                  "members": [{
                    "name": "cc_size_rotation",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 2,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 3
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 1
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 2
                }]
              }]
            }, {
              "name": "clear-stencil",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "clear-stencil|sprite-vs:vert|sprite-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "clear-stencil|sprite-vs:vert|sprite-fs:frag",
                "hash": 3507038093,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 0,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
                  },
                  "globals": {
                    "blocks": [],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": []
                  }
                },
                "defines": [],
                "blocks": [],
                "samplerTextures": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }]
              }]
            }, {
              "name": "graphics",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 1,
                      "blendDst": 4,
                      "blendSrcAlpha": 1,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "graphics|vs:vert|fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "graphics|vs:vert|fs:frag",
                "hash": 3113634185,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 46,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": []
                  }
                },
                "defines": [],
                "blocks": [],
                "samplerTextures": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 1
                }, {
                  "name": "a_dist",
                  "type": 13,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 2
                }]
              }]
            }, {
              "name": "particle-gpu",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
                "hash": 3001336778,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 60,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 38
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": []
                  }
                },
                "defines": [{
                  "name": "CC_RENDER_MODE",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "COLOR_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "ROTATION_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "SIZE_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "FORCE_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "VELOCITY_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "TEXTURE_ANIMATION_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_WORLD_SPACE",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "SampleConstants",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_sampleInfo",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "TickConstants",
                  "defines": [],
                  "binding": 2,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_worldRot",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "u_timeDelta",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "ColorConstant",
                  "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
                  "binding": 3,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_color_mode",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "RotationConstant",
                  "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
                  "binding": 4,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_rotation_mode",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "SizeConstant",
                  "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
                  "binding": 5,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_size_mode",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "ForceConstant",
                  "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
                  "binding": 6,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_force_mode",
                    "type": 5,
                    "count": 1
                  }, {
                    "name": "u_force_space",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "VelocityConstant",
                  "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
                  "binding": 7,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_velocity_mode",
                    "type": 5,
                    "count": 1
                  }, {
                    "name": "u_velocity_space",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "AnimationConstant",
                  "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
                  "binding": 8,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_anim_info",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 9,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "color_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 10
                }, {
                  "name": "rotation_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 11
                }, {
                  "name": "size_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 12
                }, {
                  "name": "force_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 13
                }, {
                  "name": "velocity_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 14
                }, {
                  "name": "texture_animation_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 15
                }, {
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 16
                }],
                "attributes": [{
                  "name": "a_position_starttime",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 0
                }, {
                  "name": "a_size_uv",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 1
                }, {
                  "name": "a_rotation_uv",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 2
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_dir_life",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 4
                }, {
                  "name": "a_rndSeed",
                  "type": 13,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 5
                }, {
                  "name": "a_texCoord",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 6
                }, {
                  "name": "a_texCoord3",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 7
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 8
                }, {
                  "name": "a_color1",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 9
                }]
              }]
            }, {
              "name": "particle-trail",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "particle-trail|particle-trail:vs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "frameTile_velLenScale": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "particle-trail|particle-trail:vs_main|tinted-fs:add",
                "hash": 2637621064,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 49,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 38
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": []
                  }
                },
                "defines": [{
                  "name": "CC_RENDER_MODE",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_DRAW_WIRE_FRAME",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_WORLD_SPACE",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 1
                }, {
                  "name": "a_texCoord1",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 2
                }, {
                  "name": "a_texCoord2",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 3
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 4
                }]
              }]
            }, {
              "name": "particle",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                "hash": 1675533382,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 49,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 38
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": []
                  }
                },
                "defines": [{
                  "name": "CC_RENDER_MODE",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_USE_WORLD_SPACE",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord1",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 2
                }, {
                  "name": "a_texCoord2",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 3
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 4
                }, {
                  "name": "a_color1",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 8
                }, {
                  "name": "a_texCoord3",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 6
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 7
                }]
              }]
            }, {
              "name": "spine",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "spine|sprite-vs:vert|sprite-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  },
                  "properties": {
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "spine|sprite-vs:vert|sprite-fs:frag",
                "hash": 1867464226,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 46,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 1
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": ["USE_LOCAL"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_spriteTexture",
                      "defines": []
                    }]
                  }
                },
                "defines": [{
                  "name": "USE_LOCAL",
                  "type": "boolean"
                }, {
                  "name": "TWO_COLORED",
                  "type": "boolean"
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "ALPHA_TEST_DATA",
                  "defines": ["USE_ALPHA_TEST"],
                  "binding": 0,
                  "stageFlags": 16,
                  "members": [{
                    "name": "alphaThreshold",
                    "type": 13,
                    "count": 1
                  }]
                }],
                "samplerTextures": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 1
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 2
                }, {
                  "name": "a_color2",
                  "type": 16,
                  "count": 1,
                  "defines": ["TWO_COLORED"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }]
              }]
            }, {
              "name": "sprite",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "sprite|sprite-vs:vert|sprite-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  },
                  "properties": {
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "sprite|sprite-vs:vert|sprite-fs:frag",
                "hash": 1559944983,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 46,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 1
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": ["USE_LOCAL"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_spriteTexture",
                      "defines": ["USE_TEXTURE"]
                    }]
                  }
                },
                "defines": [{
                  "name": "USE_LOCAL",
                  "type": "boolean"
                }, {
                  "name": "SAMPLE_FROM_RT",
                  "type": "boolean"
                }, {
                  "name": "USE_PIXEL_ALIGNMENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_EMBEDDED_ALPHA",
                  "type": "boolean"
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }, {
                  "name": "USE_TEXTURE",
                  "type": "boolean"
                }, {
                  "name": "IS_GRAY",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "ALPHA_TEST_DATA",
                  "defines": ["USE_ALPHA_TEST"],
                  "binding": 0,
                  "stageFlags": 16,
                  "members": [{
                    "name": "alphaThreshold",
                    "type": 13,
                    "count": 1
                  }]
                }],
                "samplerTextures": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 1
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 2
                }]
              }]
            }, {
              "name": "standard",
              "techniques": [{
                "name": "opaque",
                "passes": [{
                  "program": "standard|standard-vs|standard-fs",
                  "properties": {
                    "tilingOffset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "mainColor": {
                      "value": [1, 1, 1, 1],
                      "type": 16,
                      "handleInfo": ["albedo", 0, 16]
                    },
                    "albedoScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["albedoScaleAndCutoff", 0, 15]
                    },
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["albedoScaleAndCutoff", 3, 13]
                    },
                    "occlusion": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["pbrParams", 0, 13]
                    },
                    "roughness": {
                      "value": [0.8],
                      "type": 13,
                      "handleInfo": ["pbrParams", 1, 13]
                    },
                    "metallic": {
                      "value": [0.6],
                      "type": 13,
                      "handleInfo": ["pbrParams", 2, 13]
                    },
                    "SpecularIntensity": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["pbrParams", 3, 13]
                    },
                    "normalStrenth": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["miscParams", 0, 13]
                    },
                    "emissive": {
                      "value": [0, 0, 0, 1],
                      "type": 16
                    },
                    "emissiveScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["emissiveScaleParam", 0, 15]
                    },
                    "mainTexture": {
                      "value": "grey",
                      "type": 28,
                      "handleInfo": ["albedoMap", 0, 28]
                    },
                    "normalMap": {
                      "value": "normal",
                      "type": 28
                    },
                    "pbrMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "metallicRoughnessMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "occlusionMap": {
                      "value": "white",
                      "type": 28
                    },
                    "emissiveMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "albedo": {
                      "type": 16,
                      "value": [1, 1, 1, 1]
                    },
                    "albedoScaleAndCutoff": {
                      "type": 16,
                      "value": [1, 1, 1, 0.5]
                    },
                    "pbrParams": {
                      "type": 16,
                      "value": [1, 0.8, 0.6, 0.5]
                    },
                    "miscParams": {
                      "type": 16,
                      "value": [1, 0, 0, 0]
                    },
                    "emissiveScaleParam": {
                      "type": 16,
                      "value": [1, 1, 1, 0]
                    },
                    "albedoMap": {
                      "type": 28,
                      "value": "grey"
                    }
                  }
                }, {
                  "phase": "deferred",
                  "propertyIndex": 0,
                  "blendState": {
                    "targets": [{
                      "blend": false
                    }, {
                      "blend": false
                    }, {
                      "blend": false
                    }, {
                      "blend": false
                    }]
                  },
                  "program": "standard|standard-vs|standard-fs",
                  "properties": {
                    "tilingOffset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "mainColor": {
                      "value": [1, 1, 1, 1],
                      "type": 16,
                      "handleInfo": ["albedo", 0, 16]
                    },
                    "albedoScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["albedoScaleAndCutoff", 0, 15]
                    },
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["albedoScaleAndCutoff", 3, 13]
                    },
                    "occlusion": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["pbrParams", 0, 13]
                    },
                    "roughness": {
                      "value": [0.8],
                      "type": 13,
                      "handleInfo": ["pbrParams", 1, 13]
                    },
                    "metallic": {
                      "value": [0.6],
                      "type": 13,
                      "handleInfo": ["pbrParams", 2, 13]
                    },
                    "SpecularIntensity": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["pbrParams", 3, 13]
                    },
                    "normalStrenth": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["miscParams", 0, 13]
                    },
                    "emissive": {
                      "value": [0, 0, 0, 1],
                      "type": 16
                    },
                    "emissiveScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["emissiveScaleParam", 0, 15]
                    },
                    "mainTexture": {
                      "value": "grey",
                      "type": 28,
                      "handleInfo": ["albedoMap", 0, 28]
                    },
                    "normalMap": {
                      "value": "normal",
                      "type": 28
                    },
                    "pbrMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "metallicRoughnessMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "occlusionMap": {
                      "value": "white",
                      "type": 28
                    },
                    "emissiveMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "albedo": {
                      "type": 16,
                      "value": [1, 1, 1, 1]
                    },
                    "albedoScaleAndCutoff": {
                      "type": 16,
                      "value": [1, 1, 1, 0.5]
                    },
                    "pbrParams": {
                      "type": 16,
                      "value": [1, 0.8, 0.6, 0.5]
                    },
                    "miscParams": {
                      "type": 16,
                      "value": [1, 0, 0, 0]
                    },
                    "emissiveScaleParam": {
                      "type": 16,
                      "value": [1, 1, 1, 0]
                    },
                    "albedoMap": {
                      "type": 28,
                      "value": "grey"
                    }
                  }
                }, {
                  "phase": "forward-add",
                  "propertyIndex": 0,
                  "embeddedMacros": {
                    "CC_FORWARD_ADD": true
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 1,
                      "blendDst": 1,
                      "blendSrcAlpha": 0,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "standard|standard-vs|standard-fs",
                  "depthStencilState": {
                    "depthFunc": 2,
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "tilingOffset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "mainColor": {
                      "value": [1, 1, 1, 1],
                      "type": 16,
                      "handleInfo": ["albedo", 0, 16]
                    },
                    "albedoScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["albedoScaleAndCutoff", 0, 15]
                    },
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["albedoScaleAndCutoff", 3, 13]
                    },
                    "occlusion": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["pbrParams", 0, 13]
                    },
                    "roughness": {
                      "value": [0.8],
                      "type": 13,
                      "handleInfo": ["pbrParams", 1, 13]
                    },
                    "metallic": {
                      "value": [0.6],
                      "type": 13,
                      "handleInfo": ["pbrParams", 2, 13]
                    },
                    "SpecularIntensity": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["pbrParams", 3, 13]
                    },
                    "normalStrenth": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["miscParams", 0, 13]
                    },
                    "emissive": {
                      "value": [0, 0, 0, 1],
                      "type": 16
                    },
                    "emissiveScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["emissiveScaleParam", 0, 15]
                    },
                    "mainTexture": {
                      "value": "grey",
                      "type": 28,
                      "handleInfo": ["albedoMap", 0, 28]
                    },
                    "normalMap": {
                      "value": "normal",
                      "type": 28
                    },
                    "pbrMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "metallicRoughnessMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "occlusionMap": {
                      "value": "white",
                      "type": 28
                    },
                    "emissiveMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "albedo": {
                      "type": 16,
                      "value": [1, 1, 1, 1]
                    },
                    "albedoScaleAndCutoff": {
                      "type": 16,
                      "value": [1, 1, 1, 0.5]
                    },
                    "pbrParams": {
                      "type": 16,
                      "value": [1, 0.8, 0.6, 0.5]
                    },
                    "miscParams": {
                      "type": 16,
                      "value": [1, 0, 0, 0]
                    },
                    "emissiveScaleParam": {
                      "type": 16,
                      "value": [1, 1, 1, 0]
                    },
                    "albedoMap": {
                      "type": 28,
                      "value": "grey"
                    }
                  }
                }, {
                  "phase": "shadow-caster",
                  "propertyIndex": 0,
                  "rasterizerState": {
                    "cullMode": 1
                  },
                  "program": "standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
                  "properties": {
                    "tilingOffset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "mainColor": {
                      "value": [1, 1, 1, 1],
                      "type": 16,
                      "handleInfo": ["albedo", 0, 16]
                    },
                    "albedoScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["albedoScaleAndCutoff", 0, 15]
                    },
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["albedoScaleAndCutoff", 3, 13]
                    },
                    "occlusion": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["pbrParams", 0, 13]
                    },
                    "roughness": {
                      "value": [0.8],
                      "type": 13,
                      "handleInfo": ["pbrParams", 1, 13]
                    },
                    "metallic": {
                      "value": [0.6],
                      "type": 13,
                      "handleInfo": ["pbrParams", 2, 13]
                    },
                    "normalStrenth": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["pbrParams", 3, 13]
                    },
                    "emissive": {
                      "value": [0, 0, 0, 1],
                      "type": 16
                    },
                    "emissiveScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["emissiveScaleParam", 0, 15]
                    },
                    "mainTexture": {
                      "value": "grey",
                      "type": 28,
                      "handleInfo": ["albedoMap", 0, 28]
                    },
                    "albedo": {
                      "type": 16,
                      "value": [1, 1, 1, 1]
                    },
                    "albedoScaleAndCutoff": {
                      "type": 16,
                      "value": [1, 1, 1, 0.5]
                    },
                    "pbrParams": {
                      "type": 16,
                      "value": [1, 0.8, 0.6, 1]
                    },
                    "emissiveScaleParam": {
                      "type": 16,
                      "value": [1, 1, 1, 0]
                    },
                    "albedoMap": {
                      "type": 28,
                      "value": "grey"
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "standard|standard-vs|standard-fs",
                "hash": 3887038508,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 217,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 60
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplerTextures": [{
                      "name": "cc_shadowMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_spotLightingMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_environment",
                      "defines": ["CC_USE_IBL"]
                    }]
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }, {
                      "name": "CCForwardLight",
                      "defines": ["CC_FORWARD_ADD"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "cc_lightingMap",
                      "defines": ["USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
                    }]
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_FOG",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_FORWARD_ADD",
                  "type": "boolean"
                }, {
                  "name": "CC_RECEIVE_SHADOW",
                  "type": "boolean"
                }, {
                  "name": "USE_VERTEX_COLOR",
                  "type": "boolean"
                }, {
                  "name": "USE_NORMAL_MAP",
                  "type": "boolean"
                }, {
                  "name": "HAS_SECOND_UV",
                  "type": "boolean"
                }, {
                  "name": "SAMPLE_FROM_RT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_IBL",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "USE_ALBEDO_MAP",
                  "type": "boolean"
                }, {
                  "name": "ALBEDO_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "NORMAL_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "PBR_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "USE_PBR_MAP",
                  "type": "boolean"
                }, {
                  "name": "USE_METALLIC_ROUGHNESS_MAP",
                  "type": "boolean"
                }, {
                  "name": "USE_OCCLUSION_MAP",
                  "type": "boolean"
                }, {
                  "name": "USE_EMISSIVE_MAP",
                  "type": "boolean"
                }, {
                  "name": "EMISSIVE_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }, {
                  "name": "ALPHA_TEST_CHANNEL",
                  "type": "string",
                  "options": ["a", "r"]
                }, {
                  "name": "CC_PIPELINE_TYPE",
                  "type": "number",
                  "range": [0, 1]
                }, {
                  "name": "CC_STANDARD_TRANSPARENT",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 17,
                  "members": [{
                    "name": "tilingOffset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedo",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedoScaleAndCutoff",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "pbrParams",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "miscParams",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissive",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissiveScaleParam",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "albedoMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_ALBEDO_MAP"],
                  "stageFlags": 16,
                  "binding": 1
                }, {
                  "name": "normalMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_NORMAL_MAP"],
                  "stageFlags": 16,
                  "binding": 2
                }, {
                  "name": "pbrMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_PBR_MAP"],
                  "stageFlags": 16,
                  "binding": 3
                }, {
                  "name": "metallicRoughnessMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_METALLIC_ROUGHNESS_MAP"],
                  "stageFlags": 16,
                  "binding": 4
                }, {
                  "name": "occlusionMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_OCCLUSION_MAP"],
                  "stageFlags": 16,
                  "binding": 5
                }, {
                  "name": "emissiveMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_EMISSIVE_MAP"],
                  "stageFlags": 16,
                  "binding": 6
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "type": 13,
                  "count": 1,
                  "defines": ["CC_USE_MORPH"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "type": "u32vec4",
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "location": 4
                }, {
                  "name": "a_weights",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "type": 13,
                  "count": 1,
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 12
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_VERTEX_COLOR"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 13
                }, {
                  "name": "a_texCoord1",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 14
                }]
              }, {
                "name": "standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
                "hash": 3621922986,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 180,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 23
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }]
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "HAS_SECOND_UV",
                  "type": "boolean"
                }, {
                  "name": "USE_ALBEDO_MAP",
                  "type": "boolean"
                }, {
                  "name": "ALBEDO_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }, {
                  "name": "ALPHA_TEST_CHANNEL",
                  "type": "string",
                  "options": ["a", "r"]
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 17,
                  "members": [{
                    "name": "tilingOffset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedo",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedoScaleAndCutoff",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "pbrParams",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "miscParams",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissive",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissiveScaleParam",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "albedoMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_ALBEDO_MAP"],
                  "stageFlags": 16,
                  "binding": 1
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "type": 13,
                  "count": 1,
                  "defines": ["CC_USE_MORPH"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "type": "u32vec4",
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "location": 4
                }, {
                  "name": "a_weights",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "type": 13,
                  "count": 1,
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 12
                }, {
                  "name": "a_texCoord1",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 13
                }]
              }]
            }, {
              "name": "terrain",
              "techniques": [{
                "name": "opaque",
                "passes": [{
                  "program": "terrain|terrain-vs|terrain-fs",
                  "properties": {
                    "UVScale": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "lightMapUVParam": {
                      "value": [0, 0, 0, 0],
                      "type": 16
                    },
                    "metallic": {
                      "value": [0, 0, 0, 0],
                      "type": 16
                    },
                    "roughness": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "weightMap": {
                      "value": "black",
                      "type": 28
                    },
                    "detailMap0": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap1": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap2": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap3": {
                      "value": "grey",
                      "type": 28
                    },
                    "normalMap0": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap1": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap2": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap3": {
                      "value": "normal",
                      "type": 28
                    },
                    "lightMap": {
                      "value": "grey",
                      "type": 28
                    }
                  }
                }, {
                  "phase": "deferred",
                  "propertyIndex": 0,
                  "blendState": {
                    "targets": [{
                      "blend": false
                    }, {
                      "blend": false
                    }, {
                      "blend": false
                    }, {
                      "blend": false
                    }]
                  },
                  "program": "terrain|terrain-vs|terrain-fs",
                  "properties": {
                    "UVScale": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "lightMapUVParam": {
                      "value": [0, 0, 0, 0],
                      "type": 16
                    },
                    "metallic": {
                      "value": [0, 0, 0, 0],
                      "type": 16
                    },
                    "roughness": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "weightMap": {
                      "value": "black",
                      "type": 28
                    },
                    "detailMap0": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap1": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap2": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap3": {
                      "value": "grey",
                      "type": 28
                    },
                    "normalMap0": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap1": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap2": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap3": {
                      "value": "normal",
                      "type": 28
                    },
                    "lightMap": {
                      "value": "grey",
                      "type": 28
                    }
                  }
                }, {
                  "phase": "forward-add",
                  "propertyIndex": 0,
                  "embeddedMacros": {
                    "CC_FORWARD_ADD": true
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 1,
                      "blendDst": 1,
                      "blendSrcAlpha": 0,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "terrain|terrain-vs|terrain-fs",
                  "depthStencilState": {
                    "depthFunc": 2,
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "UVScale": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "lightMapUVParam": {
                      "value": [0, 0, 0, 0],
                      "type": 16
                    },
                    "metallic": {
                      "value": [0, 0, 0, 0],
                      "type": 16
                    },
                    "roughness": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "weightMap": {
                      "value": "black",
                      "type": 28
                    },
                    "detailMap0": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap1": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap2": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap3": {
                      "value": "grey",
                      "type": 28
                    },
                    "normalMap0": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap1": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap2": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap3": {
                      "value": "normal",
                      "type": 28
                    },
                    "lightMap": {
                      "value": "grey",
                      "type": 28
                    }
                  }
                }, {
                  "phase": "shadow-add",
                  "propertyIndex": 0,
                  "rasterizerState": {
                    "cullMode": 2
                  },
                  "program": "terrain|shadow-caster-vs:vert|shadow-caster-fs:frag"
                }]
              }],
              "shaders": [{
                "name": "terrain|terrain-vs|terrain-fs",
                "hash": 1309646336,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 64,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 55
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplerTextures": [{
                      "name": "cc_shadowMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_spotLightingMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_environment",
                      "defines": ["CC_USE_IBL"]
                    }]
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }, {
                      "name": "CCForwardLight",
                      "defines": ["CC_FORWARD_ADD"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_lightingMap",
                      "defines": ["USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
                    }]
                  }
                },
                "defines": [{
                  "name": "CC_USE_FOG",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_FORWARD_ADD",
                  "type": "boolean"
                }, {
                  "name": "CC_RECEIVE_SHADOW",
                  "type": "boolean"
                }, {
                  "name": "USE_NORMALMAP",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_IBL",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "LAYERS",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "USE_PBR",
                  "type": "boolean"
                }, {
                  "name": "CC_PIPELINE_TYPE",
                  "type": "number",
                  "range": [0, 1]
                }, {
                  "name": "CC_STANDARD_TRANSPARENT",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "TexCoords",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "UVScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "lightMapUVParam",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "PbrParams",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "metallic",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "roughness",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "weightMap",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }, {
                  "name": "detailMap0",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 3
                }, {
                  "name": "detailMap1",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 4
                }, {
                  "name": "detailMap2",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 5
                }, {
                  "name": "detailMap3",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 6
                }, {
                  "name": "normalMap0",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 7
                }, {
                  "name": "normalMap1",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 8
                }, {
                  "name": "normalMap2",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 9
                }, {
                  "name": "normalMap3",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 10
                }, {
                  "name": "lightMap",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 11
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }]
              }, {
                "name": "terrain|shadow-caster-vs:vert|shadow-caster-fs:frag",
                "hash": 1471860764,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 62,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": []
                  }
                },
                "defines": [],
                "blocks": [],
                "samplerTextures": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }]
              }]
            }, {
              "name": "unlit",
              "techniques": [{
                "name": "opaque",
                "passes": [{
                  "program": "unlit|unlit-vs:vert|unlit-fs:frag",
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "tilingOffset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "mainColor": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "colorScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["colorScaleAndCutoff", 0, 15]
                    },
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["colorScaleAndCutoff", 3, 13]
                    },
                    "color": {
                      "type": 16,
                      "handleInfo": ["mainColor", 0, 16]
                    },
                    "colorScaleAndCutoff": {
                      "type": 16,
                      "value": [1, 1, 1, 0.5]
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "unlit|unlit-vs:vert|unlit-fs:frag",
                "hash": 1017648509,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 195,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }]
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_FOG",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_FORWARD_ADD",
                  "type": "boolean"
                }, {
                  "name": "USE_VERTEX_COLOR",
                  "type": "boolean"
                }, {
                  "name": "USE_TEXTURE",
                  "type": "boolean"
                }, {
                  "name": "SAMPLE_FROM_RT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }, {
                  "name": "ALPHA_TEST_CHANNEL",
                  "type": "string",
                  "options": ["a", "r", "g", "b"]
                }],
                "blocks": [{
                  "name": "TexCoords",
                  "defines": ["USE_TEXTURE"],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "tilingOffset",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "Constant",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "mainColor",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "colorScaleAndCutoff",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_TEXTURE"],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "type": 13,
                  "count": 1,
                  "defines": ["CC_USE_MORPH"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "type": "u32vec4",
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "location": 4
                }, {
                  "name": "a_weights",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "type": 13,
                  "count": 1,
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 12
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_VERTEX_COLOR"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 13
                }]
              }]
            }, {
              "name": "deferred-lighting",
              "techniques": [{
                "passes": [{
                  "phase": "deferred-lighting",
                  "program": "deferred-lighting|lighting-vs|lighting-fs",
                  "depthStencilState": {
                    "depthFunc": 4,
                    "depthTest": true,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "deferred-lighting|lighting-vs|lighting-fs",
                "hash": 1887156831,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 37,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 53
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplerTextures": [{
                      "name": "cc_shadowMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_spotLightingMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_environment",
                      "defines": ["CC_USE_IBL"]
                    }, {
                      "name": "cc_gbuffer_albedoMap",
                      "defines": []
                    }, {
                      "name": "cc_gbuffer_positionMap",
                      "defines": []
                    }, {
                      "name": "cc_gbuffer_normalMap",
                      "defines": []
                    }, {
                      "name": "cc_gbuffer_emissiveMap",
                      "defines": []
                    }]
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCForwardLight",
                      "defines": []
                    }],
                    "samplerTextures": []
                  }
                },
                "defines": [{
                  "name": "CC_RECEIVE_SHADOW",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_IBL",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "CC_FORWARD_ADD",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "CC_PIPELINE_TYPE",
                  "type": "number",
                  "range": [0, 1]
                }, {
                  "name": "CC_STANDARD_TRANSPARENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_FOG",
                  "type": "number",
                  "range": [0, 4]
                }],
                "blocks": [],
                "samplerTextures": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }]
              }]
            }, {
              "name": "planar-shadow",
              "techniques": [{
                "passes": [{
                  "phase": "planarShadow",
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false,
                    "stencilTestFront": true,
                    "stencilFuncFront": 5,
                    "stencilPassOpFront": 2,
                    "stencilRefBack": 128,
                    "stencilRefFront": 128,
                    "stencilReadMaskBack": 128,
                    "stencilReadMaskFront": 128,
                    "stencilWriteMaskBack": 128,
                    "stencilWriteMaskFront": 128
                  }
                }]
              }],
              "shaders": [{
                "name": "planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
                "hash": 649108546,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 210,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 53
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }]
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [],
                "samplerTextures": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "type": 13,
                  "count": 1,
                  "defines": ["CC_USE_MORPH"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "type": "u32vec4",
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "location": 4
                }, {
                  "name": "a_weights",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "type": 13,
                  "count": 1,
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 12
                }]
              }]
            }, {
              "name": "post-process",
              "techniques": [{
                "passes": [{
                  "phase": "post-process",
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "post-process|post-process-vs|post-process-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "post-process|post-process-vs|post-process-fs",
                "hash": 1780456825,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 145,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 37
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [{
                      "name": "cc_lighting_resultMap",
                      "defines": []
                    }]
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }]
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }],
                "blocks": [],
                "samplerTextures": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "type": 13,
                  "count": 1,
                  "defines": ["CC_USE_MORPH"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "type": "u32vec4",
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "location": 4
                }, {
                  "name": "a_weights",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }]
              }]
            }, {
              "name": "skybox",
              "techniques": [{
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "skybox|sky-vs:vert|sky-fs:frag",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "skybox|sky-vs:vert|sky-fs:frag",
                "hash": 3169038185,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 37,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 37
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [{
                      "name": "cc_environment",
                      "defines": []
                    }]
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_IBL",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "USE_RGBE_CUBEMAP",
                  "type": "boolean"
                }],
                "blocks": [],
                "samplerTextures": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }]
              }]
            }, {
              "name": "profiler",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "profiler|profiler-vs:vert|profiler-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "profiler|profiler-vs:vert|profiler-fs:frag",
                "hash": 3552712539,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 58,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 37
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "offset",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "PerFrameInfo",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 1,
                  "members": [{
                    "name": "digits",
                    "type": 16,
                    "count": 20
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 1
                }]
              }]
            }, {
              "name": "splash-screen",
              "techniques": [{
                "name": "default",
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "resolution": {
                      "value": [640, 960],
                      "type": 14,
                      "handleInfo": ["u_buffer0", 0, 14]
                    },
                    "precent": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["u_buffer0", 2, 13]
                    },
                    "scale": {
                      "value": [200, 500],
                      "type": 14,
                      "handleInfo": ["u_buffer1", 0, 14]
                    },
                    "translate": {
                      "value": [320, 480],
                      "type": 14,
                      "handleInfo": ["u_buffer1", 2, 14]
                    },
                    "u_buffer0": {
                      "type": 16,
                      "value": [640, 960, 0.5, 0]
                    },
                    "u_buffer1": {
                      "type": 16,
                      "value": [200, 500, 320, 480]
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
                "hash": 1349506124,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 6,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
                  },
                  "globals": {
                    "blocks": [],
                    "samplerTextures": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": []
                  }
                },
                "defines": [],
                "blocks": [{
                  "name": "Constant",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_buffer0",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "u_buffer1",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "u_projection",
                    "type": 25,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 1
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 1
                }]
              }]
            }]);

            const dtMask = 0xf0000000;
            const typeMask = 0x0fc00000;
            const setMask = 0x00300000;
            const bindingMask = 0x000fc000;
            const offsetMask = 0x00003fff;
            let PropertyType;

            (function (PropertyType) {
              PropertyType[PropertyType["BUFFER"] = 0] = "BUFFER";
              PropertyType[PropertyType["TEXTURE"] = 1] = "TEXTURE";
            })(PropertyType || (PropertyType = {}));

            const genHandle = (pt, set, binding, type, offset = 0) => pt << 28 & dtMask | type << 22 & typeMask | set << 20 & setMask | binding << 14 & bindingMask | offset & offsetMask;
            const getPropertyTypeFromHandle = handle => (handle & dtMask) >>> 28;
            const getTypeFromHandle = handle => (handle & typeMask) >>> 22;
            const getSetIndexFromHandle = handle => (handle & setMask) >>> 20;
            const getBindingFromHandle = handle => (handle & bindingMask) >>> 14;
            const getOffsetFromHandle = handle => handle & offsetMask;
            const customizeType = (handle, type) => handle & ~typeMask | type << 22 & typeMask;
            const type2reader = {
              [Type.UNKNOWN]: (a, v, idx = 0) => console.warn('illegal uniform handle'),
              [Type.INT]: (a, v, idx = 0) => a[idx],
              [Type.INT2]: (a, v, idx = 0) => Vec2.fromArray(v, a, idx),
              [Type.INT3]: (a, v, idx = 0) => Vec3.fromArray(v, a, idx),
              [Type.INT4]: (a, v, idx = 0) => Vec4.fromArray(v, a, idx),
              [Type.FLOAT]: (a, v, idx = 0) => a[idx],
              [Type.FLOAT2]: (a, v, idx = 0) => Vec2.fromArray(v, a, idx),
              [Type.FLOAT3]: (a, v, idx = 0) => Vec3.fromArray(v, a, idx),
              [Type.FLOAT4]: (a, v, idx = 0) => Vec4.fromArray(v, a, idx),
              [Type.MAT3]: (a, v, idx = 0) => Mat3.fromArray(v, a, idx),
              [Type.MAT4]: (a, v, idx = 0) => Mat4.fromArray(v, a, idx)
            };
            const type2writer = {
              [Type.UNKNOWN]: (a, v, idx = 0) => console.warn('illegal uniform handle'),
              [Type.INT]: (a, v, idx = 0) => a[idx] = v,
              [Type.INT2]: (a, v, idx = 0) => Vec2.toArray(a, v, idx),
              [Type.INT3]: (a, v, idx = 0) => Vec3.toArray(a, v, idx),
              [Type.INT4]: (a, v, idx = 0) => Vec4.toArray(a, v, idx),
              [Type.FLOAT]: (a, v, idx = 0) => a[idx] = v,
              [Type.FLOAT2]: (a, v, idx = 0) => Vec2.toArray(a, v, idx),
              [Type.FLOAT3]: (a, v, idx = 0) => Vec3.toArray(a, v, idx),
              [Type.FLOAT4]: (a, v, idx = 0) => Vec4.toArray(a, v, idx),
              [Type.MAT3]: (a, v, idx = 0) => Mat3.toArray(a, v, idx),
              [Type.MAT4]: (a, v, idx = 0) => Mat4.toArray(a, v, idx)
            };
            const defaultValues = [Object.freeze([0]), Object.freeze([0, 0]), Object.freeze([0, 0, 0, 0]), Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])];
            function getDefaultFromType(type) {
              switch (type) {
                case Type.BOOL:
                case Type.INT:
                case Type.UINT:
                case Type.FLOAT:
                  return defaultValues[0];

                case Type.BOOL2:
                case Type.INT2:
                case Type.UINT2:
                case Type.FLOAT2:
                  return defaultValues[1];

                case Type.BOOL4:
                case Type.INT4:
                case Type.UINT4:
                case Type.FLOAT4:
                  return defaultValues[2];

                case Type.MAT4:
                  return defaultValues[3];

                case Type.SAMPLER2D:
                  return 'default-texture';

                case Type.SAMPLER_CUBE:
                  return 'default-cube-texture';
              }

              return defaultValues[0];
            }
            function overrideMacros(target, source) {
              const entries = Object.entries(source);
              let isDifferent = false;

              for (let i = 0; i < entries.length; i++) {
                if (target[entries[i][0]] !== entries[i][1]) {
                  target[entries[i][0]] = entries[i][1];
                  isDifferent = true;
                }
              }

              return isDifferent;
            }

            const _dsLayoutInfo = new DescriptorSetLayoutInfo();

            function getBitCount(cnt) {
              return Math.ceil(Math.log2(Math.max(cnt, 2)));
            }

            function mapDefine(info, def) {
              switch (info.type) {
                case 'boolean':
                  return typeof def === 'number' ? def.toString() : def ? '1' : '0';

                case 'string':
                  return def !== undefined ? def : info.options[0];

                case 'number':
                  return def !== undefined ? def.toString() : info.range[0].toString();

                default:
                  console.warn(`unknown define type '${info.type}'`);
                  return '-1';
              }
            }

            function prepareDefines(defs, tDefs) {
              const macros = [];

              for (let i = 0; i < tDefs.length; i++) {
                const tmpl = tDefs[i];
                const name = tmpl.name;
                const v = defs[name];
                const value = mapDefine(tmpl, v);
                const isDefault = !v || v === '0';
                macros.push({
                  name,
                  value,
                  isDefault
                });
              }

              return macros;
            }

            function getShaderInstanceName(name, macros) {
              return name + macros.reduce((acc, cur) => cur.isDefault ? acc : `${acc}|${cur.name}${cur.value}`, '');
            }

            function insertBuiltinBindings(tmpl, tmplInfo, source, type, outBindings) {
              const target = tmpl.builtins[type];
              const tempBlocks = [];

              for (let i = 0; i < target.blocks.length; i++) {
                const b = target.blocks[i];
                const info = source.layouts[b.name];
                const binding = info && source.bindings.find(bd => bd.binding === info.binding);

                if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_BUFFER_TYPE)) {
                  console.warn(`builtin UBO '${b.name}' not available!`);
                  continue;
                }

                tempBlocks.push(info);
                if (outBindings && !outBindings.includes(binding)) outBindings.push(binding);
              }

              Array.prototype.unshift.apply(tmplInfo.gfxBlocks, tempBlocks);
              const tempSamplerTextures = [];

              for (let i = 0; i < target.samplerTextures.length; i++) {
                const s = target.samplerTextures[i];
                const info = source.layouts[s.name];
                const binding = info && source.bindings.find(bd => bd.binding === info.binding);

                if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_SAMPLER_TYPE)) {
                  console.warn(`builtin samplerTexture '${s.name}' not available!`);
                  continue;
                }

                tempSamplerTextures.push(info);
                if (outBindings && !outBindings.includes(binding)) outBindings.push(binding);
              }

              Array.prototype.unshift.apply(tmplInfo.gfxSamplerTextures, tempSamplerTextures);
              if (outBindings) outBindings.sort((a, b) => a.binding - b.binding);
            }

            function getSize(block) {
              return block.members.reduce((s, m) => s + GetTypeSize(m.type) * m.count, 0);
            }

            function genHandles(tmpl) {
              const handleMap = {};

              for (let i = 0; i < tmpl.blocks.length; i++) {
                const block = tmpl.blocks[i];
                const members = block.members;
                let offset = 0;

                for (let j = 0; j < members.length; j++) {
                  const uniform = members[j];
                  handleMap[uniform.name] = genHandle(PropertyType.BUFFER, SetIndex.MATERIAL, block.binding, uniform.type, offset);
                  offset += (GetTypeSize(uniform.type) >> 2) * uniform.count;
                }
              }

              for (let i = 0; i < tmpl.samplerTextures.length; i++) {
                const samplerTexture = tmpl.samplerTextures[i];
                handleMap[samplerTexture.name] = genHandle(PropertyType.TEXTURE, SetIndex.MATERIAL, samplerTexture.binding, samplerTexture.type);
              }

              return handleMap;
            }

            function dependencyCheck(dependencies, defines) {
              for (let i = 0; i < dependencies.length; i++) {
                const d = dependencies[i];

                if (d[0] === '!') {
                  if (defines[d.slice(1)]) {
                    return false;
                  }
                } else if (!defines[d]) {
                  return false;
                }
              }

              return true;
            }

            function getActiveAttributes(tmpl, tmplInfo, defines) {
              const out = [];
              const attributes = tmpl.attributes;
              const gfxAttributes = tmplInfo.gfxAttributes;

              for (let i = 0; i < attributes.length; i++) {
                if (!dependencyCheck(attributes[i].defines, defines)) {
                  continue;
                }

                out.push(gfxAttributes[i]);
              }

              return out;
            }

            class ProgramLib {
              constructor() {
                this._templates = {};
                this._cache = {};
                this._templateInfos = {};
              }

              register(effect) {
                for (let i = 0; i < effect.shaders.length; i++) {
                  const tmpl = this.define(effect.shaders[i]);
                  tmpl.effectName = effect.name;
                }
              }

              define(shader) {
                const curTmpl = this._templates[shader.name];

                if (curTmpl && curTmpl.hash === shader.hash) {
                  return curTmpl;
                }

                const tmpl = { ...shader
                };
                let offset = 0;

                for (let i = 0; i < tmpl.defines.length; i++) {
                  const def = tmpl.defines[i];
                  let cnt = 1;

                  if (def.type === 'number') {
                    const range = def.range;
                    cnt = getBitCount(range[1] - range[0] + 1);

                    def._map = value => value - range[0];
                  } else if (def.type === 'string') {
                    cnt = getBitCount(def.options.length);

                    def._map = value => Math.max(0, def.options.findIndex(s => s === value));
                  } else if (def.type === 'boolean') {
                    def._map = value => value ? 1 : 0;
                  }

                  def._offset = offset;
                  offset += cnt;
                }

                if (offset > 31) {
                  tmpl.uber = true;
                }

                tmpl.constantMacros = '';

                for (const key in tmpl.builtins.statistics) {
                  tmpl.constantMacros += `#define ${key} ${tmpl.builtins.statistics[key]}\n`;
                }

                this._templates[shader.name] = tmpl;

                if (!this._templateInfos[tmpl.hash]) {
                  const tmplInfo = {};
                  tmplInfo.samplerStartBinding = tmpl.blocks.length;
                  tmplInfo.gfxBlocks = [];
                  tmplInfo.gfxSamplerTextures = [];
                  tmplInfo.bindings = [];
                  tmplInfo.blockSizes = [];

                  for (let i = 0; i < tmpl.blocks.length; i++) {
                    const block = tmpl.blocks[i];
                    tmplInfo.blockSizes.push(getSize(block));
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(block.binding, block.descriptorType || DescriptorType.UNIFORM_BUFFER, 1, block.stageFlags));
                    tmplInfo.gfxBlocks.push(new UniformBlock(SetIndex.MATERIAL, block.binding, block.name, block.members.map(m => new Uniform(m.name, m.type, m.count)), 1));
                  }

                  for (let i = 0; i < tmpl.samplerTextures.length; i++) {
                    const samplerTexture = tmpl.samplerTextures[i];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(samplerTexture.binding, samplerTexture.descriptorType || DescriptorType.SAMPLER_TEXTURE, samplerTexture.count, samplerTexture.stageFlags));
                    tmplInfo.gfxSamplerTextures.push(new UniformSamplerTexture(SetIndex.MATERIAL, samplerTexture.binding, samplerTexture.name, samplerTexture.type, samplerTexture.count));
                  }

                  tmplInfo.gfxAttributes = [];

                  for (let i = 0; i < tmpl.attributes.length; i++) {
                    const attr = tmpl.attributes[i];
                    tmplInfo.gfxAttributes.push(new Attribute(attr.name, attr.format, attr.isNormalized, 0, attr.isInstanced, attr.location));
                  }

                  insertBuiltinBindings(tmpl, tmplInfo, localDescriptorSetLayout, 'locals');
                  tmplInfo.gfxStages = [];
                  tmplInfo.gfxStages.push(new ShaderStage(ShaderStageFlagBit.VERTEX, ''));
                  tmplInfo.gfxStages.push(new ShaderStage(ShaderStageFlagBit.FRAGMENT, ''));
                  tmplInfo.handleMap = genHandles(tmpl);
                  tmplInfo.setLayouts = [];
                  this._templateInfos[tmpl.hash] = tmplInfo;
                }

                return tmpl;
              }

              getTemplate(name) {
                return this._templates[name];
              }

              getTemplateInfo(name) {
                const hash = this._templates[name].hash;
                return this._templateInfos[hash];
              }

              getDescriptorSetLayout(device, name, isLocal = false) {
                const tmpl = this._templates[name];
                const tmplInfo = this._templateInfos[tmpl.hash];

                if (!tmplInfo.setLayouts.length) {
                  _dsLayoutInfo.bindings = tmplInfo.bindings;
                  tmplInfo.setLayouts[SetIndex.MATERIAL] = device.createDescriptorSetLayout(_dsLayoutInfo);
                  _dsLayoutInfo.bindings = localDescriptorSetLayout.bindings;
                  tmplInfo.setLayouts[SetIndex.LOCAL] = device.createDescriptorSetLayout(_dsLayoutInfo);
                }

                return tmplInfo.setLayouts[isLocal ? SetIndex.LOCAL : SetIndex.MATERIAL];
              }

              hasProgram(name) {
                return this._templates[name] !== undefined;
              }

              getKey(name, defines) {
                const tmpl = this._templates[name];
                const tmplDefs = tmpl.defines;

                if (tmpl.uber) {
                  let key = '';

                  for (let i = 0; i < tmplDefs.length; i++) {
                    const tmplDef = tmplDefs[i];
                    const value = defines[tmplDef.name];

                    if (!value || !tmplDef._map) {
                      continue;
                    }

                    const mapped = tmplDef._map(value);

                    const offset = tmplDef._offset;
                    key += `${offset}${mapped}|`;
                  }

                  return `${key}${tmpl.hash}`;
                }

                let key = 0;

                for (let i = 0; i < tmplDefs.length; i++) {
                  const tmplDef = tmplDefs[i];
                  const value = defines[tmplDef.name];

                  if (!value || !tmplDef._map) {
                    continue;
                  }

                  const mapped = tmplDef._map(value);

                  const offset = tmplDef._offset;
                  key |= mapped << offset;
                }

                return `${key.toString(16)}|${tmpl.hash}`;
              }

              destroyShaderByDefines(defines) {
                const names = Object.keys(defines);

                if (!names.length) {
                  return;
                }

                const regexes = names.map(cur => {
                  let val = defines[cur];

                  if (typeof val === 'boolean') {
                    val = val ? '1' : '0';
                  }

                  return new RegExp(`${cur}${val}`);
                });
                const keys = Object.keys(this._cache).filter(k => regexes.every(re => re.test(this._cache[k].name)));

                for (let i = 0; i < keys.length; i++) {
                  const k = keys[i];
                  const prog = this._cache[k];
                  debug(`destroyed shader ${prog.name}`);
                  prog.destroy();
                  delete this._cache[k];
                }
              }

              getGFXShader(device, name, defines, pipeline, key) {
                Object.assign(defines, pipeline.macros);
                if (!key) key = this.getKey(name, defines);
                const res = this._cache[key];

                if (res) {
                  return res;
                }

                const tmpl = this._templates[name];
                const tmplInfo = this._templateInfos[tmpl.hash];

                if (!tmplInfo.pipelineLayout) {
                  this.getDescriptorSetLayout(device, name);
                  insertBuiltinBindings(tmpl, tmplInfo, globalDescriptorSetLayout, 'globals');
                  tmplInfo.setLayouts[SetIndex.GLOBAL] = pipeline.descriptorSetLayout;
                  tmplInfo.pipelineLayout = device.createPipelineLayout(new PipelineLayoutInfo(tmplInfo.setLayouts));
                }

                const macroArray = prepareDefines(defines, tmpl.defines);
                const prefix = pipeline.constantMacros + tmpl.constantMacros + macroArray.reduce((acc, cur) => `${acc}#define ${cur.name} ${cur.value}\n`, '');
                let src = tmpl.glsl3;
                const deviceShaderVersion = getDeviceShaderVersion(device);

                if (deviceShaderVersion) {
                  src = tmpl[deviceShaderVersion];
                } else {
                  console.error('Invalid GFX API!');
                }

                tmplInfo.gfxStages[0].source = prefix + src.vert;
                tmplInfo.gfxStages[1].source = prefix + src.frag;
                const attributes = getActiveAttributes(tmpl, tmplInfo, defines);
                const instanceName = getShaderInstanceName(name, macroArray);
                const shaderInfo = new ShaderInfo(instanceName, tmplInfo.gfxStages, attributes, tmplInfo.gfxBlocks);
                shaderInfo.samplerTextures = tmplInfo.gfxSamplerTextures;
                return this._cache[key] = device.createShader(shaderInfo);
              }

            }

            function getDeviceShaderVersion(device) {
              switch (device.gfxAPI) {
                case API.GLES2:
                case API.WEBGL:
                  return 'glsl1';

                case API.GLES3:
                case API.WEBGL2:
                  return 'glsl3';

                default:
                  return 'glsl4';
              }
            }
            const programLib = new ProgramLib();
            legacyCC.programLib = programLib;

            const glsl1 = [[{
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nattribute vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute float a_dist;\nvarying float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\nprecision highp float;\nvarying vec4 v_color;\nvarying float v_dist;\nvec4 frag () {\nvec4 o = v_color;\n#ifdef GL_OES_standard_derivatives\nfloat aa = fwidth(v_dist);\n#else\nfloat aa = 0.05;\n#endif\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform vec4 u_sampleInfo;\nuniform vec4 u_worldRot;\nuniform vec4 u_timeDelta;\nattribute vec4 a_position_starttime;\nattribute vec4 a_size_uv;\nattribute vec4 a_rotation_uv;\nattribute vec4 a_color;\nattribute vec4 a_dir_life;\nattribute float a_rndSeed;\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\nseed = mod(seed, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nuniform int u_color_mode;\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nuniform int u_rotation_mode;\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nuniform int u_size_mode;\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nuniform int u_force_mode;\nuniform int u_force_space;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nuniform int u_velocity_mode;\nuniform int u_velocity_space;\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nuniform vec4 u_anim_info;\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 toQuat(vec3 rotation) {\nvec3 rotTmp = rotation;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\nreturn rot;\n}\nmat3 QuatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 Mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 EulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\nvec4 rot = toQuat(startRotation);\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = EulerToQuat(euler);\nmat3 mLocal = QuatToMat3(quat);\nmat3 mStart = QuatToMat3(rot);\nrot = Mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = EulerToQuat(euler);\nmat3 mLocal = QuatToMat3(quat);\nmat3 mStart = QuatToMat3(rot);\nrot = Mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture2D(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture2D(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture2D(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
              "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
            }], [{
              "vert": "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\nattribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
              "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 v_light;\nvarying vec2 uv0;\n#if TWO_COLORED\nattribute vec4 a_color2;\nvarying vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 v_light;\n#if TWO_COLORED\nvarying vec4 v_dark;\n#endif\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture2D(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture2D(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\n#if SAMPLE_FROM_RT\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture2D(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 color;\n#if USE_TEXTURE\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\nuniform highp vec4 cc_lightingMapUVParam;\n#endif\nuniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\nattribute vec4 a_color;\nvarying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\nv_luv.z = cc_lightingMapUVParam.z;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\nv_luv.z = a_lightingMapUVParam.z;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if USE_NORMAL_MAP\nv_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(pos);\n#else\nv_fog_factor = 1.0;\n#endif\nv_shadowPos = cc_matLightViewProj * pos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
              "frag": "\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 miscParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nvarying float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowWHPBInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\nvarying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture2D(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if USE_NORMAL_MAP\nvec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\ns.normal =\n(nmmp.x * miscParams.x) * normalize(v_tangent) +\n(nmmp.y * miscParams.x) * normalize(v_bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\ns.position = v_position;\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture2D(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.w;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture2D(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = clamp(pbr.x, 0.0, 0.96);\ns.roughness = clamp(pbr.y, 0.04, 1.0);\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_STANDARD_TRANSPARENT)\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\ngl_FragData[1] = vec4(s.position, s.roughness);\ngl_FragData[2] = vec4(s.normal, s.metallic);\ngl_FragData[3] = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\n#endif\nuniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nuniform highp mat4 cc_matLightView;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture2D(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nvec4 viewStartPos = cc_matLightView * v_worldPos;\nfloat dist = length(viewStartPos.xyz);\nfloat linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\nreturn vec4(linearDepth, 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform highp mat4 cc_matWorld;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\n#if USE_NORMALMAP\nvarying mediump vec3 v_tangent;\nvarying mediump vec3 v_binormal;\n#endif\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 luv;\nvarying mediump vec3 diffuse;\nuniform vec4 UVScale;\nuniform vec4 lightMapUVParam;\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\nluv.z = lightMapUVParam.z;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(vec4(worldPos, 1.0));\n#else\nv_fog_factor = 1.0;\n#endif\n#if USE_NORMALMAP\nv_tangent = vec3(1.0, 0.0, 0.0);\nv_binormal = vec3(0.0, 0.0, 1.0);\nv_binormal = cross(v_tangent, a_normal);\nv_tangent = cross(a_normal, v_binormal);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
              "frag": "\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowWHPBInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\n#if USE_NORMALMAP\nvarying mediump vec3 v_tangent;\nvarying mediump vec3 v_binormal;\n#endif\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 diffuse;\nvarying mediump vec3 luv;\nuniform vec4 metallic;\nuniform vec4 roughness;\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture2D(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture2D(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\nbaseColor += texture2D(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture2D(detailMap0, uv0);\n#endif\ns.position = v_position;\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture2D(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\nbaseNormal += texture2D(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture2D(normalMap0, uv0);\n#endif\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(v_tangent) +\nnmmp.y * normalize(v_binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.metallic = 0.0;\n#if LAYERS == 1\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(lightMap, luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_STANDARD_TRANSPARENT)\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\ngl_FragData[1] = vec4(s.position, s.roughness);\ngl_FragData[2] = vec4(s.normal, s.metallic);\ngl_FragData[3] = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "\nprecision highp float;\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matLightViewProj;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nvarying vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying float v_fog_factor;\n#if USE_VERTEX_COLOR\nattribute lowp vec4 a_color;\nvarying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform vec4 tilingOffset;\n#endif\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(matWorld * position);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(matWorld * position);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(matWorld * position);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(matWorld * position);\n#else\nv_fog_factor = 1.0;\n#endif\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nuniform vec4 mainColor;\nuniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\nvarying lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no *= v_color;\n#endif\n#if USE_TEXTURE\no *= texture2D(mainTexture, v_uv);\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\no = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\nreturn CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
              "frag": "\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp mat4 cc_matLightViewProj;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowWHPBInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying vec2 v_uv;\nuniform sampler2D cc_gbuffer_albedoMap;\nuniform sampler2D cc_gbuffer_positionMap;\nuniform sampler2D cc_gbuffer_normalMap;\nuniform sampler2D cc_gbuffer_emissiveMap;\nvoid main () {\nStandardSurface s;\nvec4 albedoMap = texture2D(cc_gbuffer_albedoMap,v_uv);\nvec4 positionMap = texture2D(cc_gbuffer_positionMap,v_uv);\nvec4 normalMap = texture2D(cc_gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture2D(cc_gbuffer_emissiveMap,v_uv);\ns.albedo = albedoMap;\ns.position = positionMap.xyz;\ns.roughness = positionMap.w;\ns.normal = normalMap.xyz;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\n#if CC_USE_FOG == 0\nfogFactor = LinearFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 1\nfogFactor = ExpFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 2\nfogFactor = ExpSquaredFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 3\nfogFactor = LayeredFog(vec4(s.position, 1));\n#else\nfogFactor = 1.0;\n#endif\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(s.position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\nCCStandardShadingAdditive(s, shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, fogFactor), color.a);\ngl_FragColor = CCFragOutput(color);\n}"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nuniform highp mat4 cc_matLightPlaneProj;\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\nposition = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\nposition.z -= 0.0001;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nuniform lowp vec4 cc_shadowColor;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvec4 frag () {\nreturn CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\nvarying vec2 v_uv;\nuniform sampler2D cc_lighting_resultMap;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\nvec4 texColor = texture2D(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\ngl_FragColor = fxaa(cc_lighting_resultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}"
            }], [{
              "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\nvarying mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nmat4 matProj = cc_matProj;\nif (matProj[3].w > 0.0) {\nvec2 scale = vec2(48.0, 24.0);\nmatProj[0].xy *= scale;\nmatProj[1].xy *= scale;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\n}\nvec4 pos = matProj * matViewRotOnly * viewDir;\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nvarying mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec2 v_uv;\nuniform vec4 offset;\nuniform vec4 digits[20];\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nvec4 position = cc_matViewProj * vec4(a_position, 1.0);\nposition.xy += offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying float v_percent;\nuniform vec4 u_buffer0;\nuniform vec4 u_buffer1;\nuniform mat4 u_projection;\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nv_percent = u_buffer0.z;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvarying vec2 v_uv;\nvarying float v_percent;\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture2D(mainTexture, v_uv);\nfloat precent = clamp(v_percent, 0.0, 1.0);\ncolor.xyz *= precent;\nreturn color;\n}\nvoid main() { gl_FragColor = frag(); }"
            }]];

            const glsl3 = [[{
              "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nlayout(std140) uniform builtin {\nvec4 cc_size_rotation;\n};\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nin vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin float a_dist;\nout float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nin vec4 v_color;\nin float v_dist;\nvec4 frag () {\nvec4 o = v_color;\nfloat aa = fwidth(v_dist);\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(std140) uniform SampleConstants {\nvec4 u_sampleInfo;\n};\nlayout(std140) uniform TickConstants {\nvec4 u_worldRot;\nvec4 u_timeDelta;\n};\nin vec4 a_position_starttime;\nin vec4 a_size_uv;\nin vec4 a_rotation_uv;\nin vec4 a_color;\nin vec4 a_dir_life;\nin float a_rndSeed;\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord;\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\nseed = mod(seed, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nlayout(std140) uniform ColorConstant {\nint u_color_mode;\n};\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nlayout(std140) uniform RotationConstant {\nint u_rotation_mode;\n};\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nlayout(std140) uniform SizeConstant {\nint u_size_mode;\n};\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nlayout(std140) uniform ForceConstant {\nint u_force_mode;\nint u_force_space;\n};\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nlayout(std140) uniform VelocityConstant {\nint u_velocity_mode;\nint u_velocity_space;\n};\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nlayout(std140) uniform AnimationConstant {\nvec4 u_anim_info;\n};\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 toQuat(vec3 rotation) {\nvec3 rotTmp = rotation;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\nreturn rot;\n}\nmat3 QuatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 Mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 EulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\nvec4 rot = toQuat(startRotation);\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = EulerToQuat(euler);\nmat3 mLocal = QuatToMat3(quat);\nmat3 mStart = QuatToMat3(rot);\nrot = Mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = EulerToQuat(euler);\nmat3 mLocal = QuatToMat3(quat);\nmat3 mStart = QuatToMat3(rot);\nrot = Mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nout vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\n#if CC_DRAW_WIRE_FRAME\nin vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\nin vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 v_light;\nout vec2 uv0;\n#if TWO_COLORED\nin vec4 a_color2;\nout vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 v_light;\n#if TWO_COLORED\nin vec4 v_dark;\n#endif\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\n#if SAMPLE_FROM_RT\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 color;\n#if USE_TEXTURE\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nout float v_fog_factor;\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\nin vec4 a_color;\nout vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\nout vec3 v_tangent;\nout vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nout vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\nv_luv.z = cc_lightingMapUVParam.z;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\nv_luv.z = a_lightingMapUVParam.z;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if USE_NORMAL_MAP\nv_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(pos);\n#else\nv_fog_factor = 1.0;\n#endif\nv_shadowPos = cc_matLightViewProj * pos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nin float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\nin vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nin vec3 v_tangent;\nin vec3 v_bitangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(cc_lightingMap, v_luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if USE_NORMAL_MAP\nvec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\ns.normal =\n(nmmp.x * miscParams.x) * normalize(v_tangent) +\n(nmmp.y * miscParams.x) * normalize(v_bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\ns.position = v_position;\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.w;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = clamp(pbr.x, 0.0, 0.96);\ns.roughness = clamp(pbr.y, 0.04, 1.0);\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_STANDARD_TRANSPARENT)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(s.position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nvec4 viewStartPos = cc_matLightView * v_worldPos;\nfloat dist = length(viewStartPos.xyz);\nfloat linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\nreturn vec4(linearDepth, 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nout float v_fog_factor;\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout highp vec3 v_position;\nout mediump vec3 v_normal;\n#if USE_NORMALMAP\nout mediump vec3 v_tangent;\nout mediump vec3 v_binormal;\n#endif\nout mediump vec2 uvw;\nout mediump vec2 uv0;\nout mediump vec2 uv1;\nout mediump vec2 uv2;\nout mediump vec2 uv3;\nout mediump vec3 luv;\nout mediump vec3 diffuse;\nlayout(std140) uniform TexCoords {\nvec4 UVScale;\nvec4 lightMapUVParam;\n};\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\nluv.z = lightMapUVParam.z;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(vec4(worldPos, 1.0));\n#else\nv_fog_factor = 1.0;\n#endif\n#if USE_NORMALMAP\nv_tangent = vec3(1.0, 0.0, 0.0);\nv_binormal = vec3(0.0, 0.0, 1.0);\nv_binormal = cross(v_tangent, a_normal);\nv_tangent = cross(a_normal, v_binormal);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nin float v_fog_factor;\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nin highp vec3 v_position;\nin mediump vec3 v_normal;\n#if USE_NORMALMAP\nin mediump vec3 v_tangent;\nin mediump vec3 v_binormal;\n#endif\nin mediump vec2 uvw;\nin mediump vec2 uv0;\nin mediump vec2 uv1;\nin mediump vec2 uv2;\nin mediump vec2 uv3;\nin mediump vec3 diffuse;\nin mediump vec3 luv;\nlayout(std140) uniform PbrParams {\nvec4 metallic;\nvec4 roughness;\n};\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\nbaseColor += texture(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture(detailMap0, uv0);\n#endif\ns.position = v_position;\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\nbaseNormal += texture(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture(normalMap0, uv0);\n#endif\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(v_tangent) +\nnmmp.y * normalize(v_binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.metallic = 0.0;\n#if LAYERS == 1\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(lightMap, luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_STANDARD_TRANSPARENT)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(s.position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nin vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nout float v_fog_factor;\n#if USE_VERTEX_COLOR\nin lowp vec4 a_color;\nout lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nout vec2 v_uv;\nlayout(std140) uniform TexCoords {\nvec4 tilingOffset;\n};\n#endif\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(matWorld * position);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(matWorld * position);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(matWorld * position);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(matWorld * position);\n#else\nv_fog_factor = 1.0;\n#endif\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nin vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\nvec4 mainColor;\nvec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\nin lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no *= v_color;\n#endif\n#if USE_TEXTURE\no *= texture(mainTexture, v_uv);\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\no = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\nreturn CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nout vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nin vec2 v_uv;\nuniform sampler2D cc_gbuffer_albedoMap;\nuniform sampler2D cc_gbuffer_positionMap;\nuniform sampler2D cc_gbuffer_normalMap;\nuniform sampler2D cc_gbuffer_emissiveMap;\nlayout(location = 0) out vec4 fragColor;\nvoid main () {\nStandardSurface s;\nvec4 albedoMap = texture(cc_gbuffer_albedoMap,v_uv);\nvec4 positionMap = texture(cc_gbuffer_positionMap,v_uv);\nvec4 normalMap = texture(cc_gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture(cc_gbuffer_emissiveMap,v_uv);\ns.albedo = albedoMap;\ns.position = positionMap.xyz;\ns.roughness = positionMap.w;\ns.normal = normalMap.xyz;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\n#if CC_USE_FOG == 0\nfogFactor = LinearFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 1\nfogFactor = ExpFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 2\nfogFactor = ExpSquaredFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 3\nfogFactor = LayeredFog(vec4(s.position, 1));\n#else\nfogFactor = 1.0;\n#endif\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(s.position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\nCCStandardShadingAdditive(s, shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, fogFactor), color.a);\nfragColor = CCFragOutput(color);\n}"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\nposition = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\nposition.z -= 0.0001;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvec4 frag () {\nreturn CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nin vec2 v_uv;\nuniform sampler2D cc_lighting_resultMap;\nlayout(location = 0) out vec4 fragColor;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture(tex, v_rgbSE).xyz;\nvec4 texColor = texture(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\nfragColor = fxaa(cc_lighting_resultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}"
            }], [{
              "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\nout mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nmat4 matProj = cc_matProj;\nif (matProj[3].w > 0.0) {\nvec2 scale = vec2(48.0, 24.0);\nmatProj[0].xy *= scale;\nmatProj[1].xy *= scale;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\n}\nvec4 pos = matProj * matViewRotOnly * viewDir;\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nin mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec2 v_uv;\nlayout(std140) uniform Constants {\nvec4 offset;\n};\nlayout(std140) uniform PerFrameInfo {\nvec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nvec4 position = cc_matViewProj * vec4(a_position, 1.0);\nposition.xy += offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture(mainTexture, v_uv));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout float v_percent;\nlayout(std140) uniform Constant {\nvec4 u_buffer0;\nvec4 u_buffer1;\nmat4 u_projection;\n};\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nv_percent = u_buffer0.z;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nin vec2 v_uv;\nin float v_percent;\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture(mainTexture, v_uv);\nfloat precent = clamp(v_percent, 0.0, 1.0);\ncolor.xyz *= precent;\nreturn color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }]];

            const glsl4 = [[{
              "vert": "\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(set = 1, binding = 1) uniform builtin {\nvec4 cc_size_rotation;\n};\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 3) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 2) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(location = 0) in vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec4 v_color;\nlayout(location = 2) in float a_dist;\nlayout(location = 1) out float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nlayout(location = 0) in vec4 v_color;\nlayout(location = 1) in float v_dist;\nvec4 frag () {\nvec4 o = v_color;\nfloat aa = fwidth(v_dist);\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(set = 1, binding = 1) uniform SampleConstants {\nvec4 u_sampleInfo;\n};\nlayout(set = 1, binding = 2) uniform TickConstants {\nvec4 u_worldRot;\nvec4 u_timeDelta;\n};\nlayout(location = 0) in vec4 a_position_starttime;\nlayout(location = 1) in vec4 a_size_uv;\nlayout(location = 2) in vec4 a_rotation_uv;\nlayout(location = 3) in vec4 a_color;\nlayout(location = 4) in vec4 a_dir_life;\nlayout(location = 5) in float a_rndSeed;\n#if CC_RENDER_MODE == 4\nlayout(location = 6) in vec3 a_texCoord;\nlayout(location = 7) in vec3 a_texCoord3;\nlayout(location = 8) in vec3 a_normal;\nlayout(location = 9) in vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\nseed = mod(seed, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nlayout(set = 1, binding = 10) uniform sampler2D color_over_time_tex0;\nlayout(set = 1, binding = 3) uniform ColorConstant {\nint u_color_mode;\n};\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nlayout(set = 1, binding = 11) uniform sampler2D rotation_over_time_tex0;\nlayout(set = 1, binding = 4) uniform RotationConstant {\nint u_rotation_mode;\n};\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nlayout(set = 1, binding = 12) uniform sampler2D size_over_time_tex0;\nlayout(set = 1, binding = 5) uniform SizeConstant {\nint u_size_mode;\n};\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nlayout(set = 1, binding = 13) uniform sampler2D force_over_time_tex0;\nlayout(set = 1, binding = 6) uniform ForceConstant {\nint u_force_mode;\nint u_force_space;\n};\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nlayout(set = 1, binding = 14) uniform sampler2D velocity_over_time_tex0;\nlayout(set = 1, binding = 7) uniform VelocityConstant {\nint u_velocity_mode;\nint u_velocity_space;\n};\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nlayout(set = 1, binding = 15) uniform sampler2D texture_animation_tex0;\nlayout(set = 1, binding = 8) uniform AnimationConstant {\nvec4 u_anim_info;\n};\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 toQuat(vec3 rotation) {\nvec3 rotTmp = rotation;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\nreturn rot;\n}\nmat3 QuatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 Mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 EulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\nvec4 rot = toQuat(startRotation);\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = EulerToQuat(euler);\nmat3 mLocal = QuatToMat3(quat);\nmat3 mStart = QuatToMat3(rot);\nrot = Mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = EulerToQuat(euler);\nmat3 mLocal = QuatToMat3(quat);\nmat3 mStart = QuatToMat3(rot);\nrot = Mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 16) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 9) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nlayout(location = 2) out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\n#if CC_DRAW_WIRE_FRAME\nlayout(location = 2) in vec3 vBarycentric;\n#endif\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\nlayout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nlayout(location = 6) in vec3 a_texCoord3;\nlayout(location = 7) in vec3 a_normal;\nlayout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 v_light;\nlayout(location = 1) out vec2 uv0;\n#if TWO_COLORED\nlayout(location = 3) in vec4 a_color2;\nlayout(location = 2) out vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\nlayout(set = 1, binding = 0) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nlayout(location = 0) in vec4 v_light;\n#if TWO_COLORED\nlayout(location = 2) in vec4 v_dark;\n#endif\nlayout(location = 1) in vec2 uv0;\nlayout(set = 2, binding = 10) uniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\n#if SAMPLE_FROM_RT\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nlayout(set = 1, binding = 0) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nlayout(location = 0) in vec4 color;\n#if USE_TEXTURE\nlayout(location = 1) in vec2 uv0;\nlayout(set = 2, binding = 10) uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nlayout(location = 8) in vec4 a_matWorld0;\nlayout(location = 9) in vec4 a_matWorld1;\nlayout(location = 10) in vec4 a_matWorld2;\n#if USE_LIGHTMAP\nlayout(location = 11) in vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nlayout(location = 12) in float a_dyn_batch_id;\nlayout(set = 2, binding = 0) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nlayout(location = 0) out float v_fog_factor;\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nlayout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\nlayout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\nlayout(location = 13) in vec4 a_color;\nlayout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\nlayout(location = 7) out vec3 v_tangent;\nlayout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\nlayout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nlayout(location = 9) out vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\nv_luv.z = cc_lightingMapUVParam.z;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\nv_luv.z = a_lightingMapUVParam.z;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if USE_NORMAL_MAP\nv_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(pos);\n#else\nv_fog_factor = 1.0;\n#endif\nv_shadowPos = cc_matLightViewProj * pos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nlayout(location = 0) in float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nlayout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\nlayout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nlayout(set = 0, binding = 4) uniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nlayout(location = 9) in vec3 v_luv;\nlayout(set = 2, binding = 9) uniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if USE_VERTEX_COLOR\nlayout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nlayout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nlayout(location = 7) in vec3 v_tangent;\nlayout(location = 8) in vec3 v_bitangent;\nlayout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nlayout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nlayout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nlayout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nlayout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(cc_lightingMap, v_luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if USE_NORMAL_MAP\nvec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\ns.normal =\n(nmmp.x * miscParams.x) * normalize(v_tangent) +\n(nmmp.y * miscParams.x) * normalize(v_bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\ns.position = v_position;\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.w;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = clamp(pbr.x, 0.0, 0.96);\ns.roughness = clamp(pbr.y, 0.04, 1.0);\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(set = 2, binding = 1) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_STANDARD_TRANSPARENT)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(s.position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\nlayout(location = 8) in vec4 a_matWorld0;\nlayout(location = 9) in vec4 a_matWorld1;\nlayout(location = 10) in vec4 a_matWorld2;\n#if USE_LIGHTMAP\nlayout(location = 11) in vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nlayout(location = 12) in float a_dyn_batch_id;\nlayout(set = 2, binding = 0) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\nlayout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 miscParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\nlayout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nvec4 viewStartPos = cc_matLightView * v_worldPos;\nfloat dist = length(viewStartPos.xyz);\nfloat linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\nreturn vec4(linearDepth, 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nlayout(location = 0) out float v_fog_factor;\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nlayout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\nlayout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 2) out highp vec3 v_position;\nlayout(location = 3) out mediump vec3 v_normal;\n#if USE_NORMALMAP\nlayout(location = 4) out mediump vec3 v_tangent;\nlayout(location = 5) out mediump vec3 v_binormal;\n#endif\nlayout(location = 6) out mediump vec2 uvw;\nlayout(location = 7) out mediump vec2 uv0;\nlayout(location = 8) out mediump vec2 uv1;\nlayout(location = 9) out mediump vec2 uv2;\nlayout(location = 10) out mediump vec2 uv3;\nlayout(location = 11) out mediump vec3 luv;\nlayout(location = 12) out mediump vec3 diffuse;\nlayout(set = 1, binding = 0) uniform TexCoords {\nvec4 UVScale;\nvec4 lightMapUVParam;\n};\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\nluv.z = lightMapUVParam.z;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(vec4(worldPos, 1.0));\n#else\nv_fog_factor = 1.0;\n#endif\n#if USE_NORMALMAP\nv_tangent = vec3(1.0, 0.0, 0.0);\nv_binormal = vec3(0.0, 0.0, 1.0);\nv_binormal = cross(v_tangent, a_normal);\nv_tangent = cross(a_normal, v_binormal);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nlayout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\nlayout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nlayout(set = 0, binding = 4) uniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nlayout(location = 0) in float v_fog_factor;\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nlayout(location = 13) in vec3 v_luv;\nlayout(set = 2, binding = 9) uniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nlayout(location = 2) in highp vec3 v_position;\nlayout(location = 3) in mediump vec3 v_normal;\n#if USE_NORMALMAP\nlayout(location = 4) in mediump vec3 v_tangent;\nlayout(location = 5) in mediump vec3 v_binormal;\n#endif\nlayout(location = 6) in mediump vec2 uvw;\nlayout(location = 7) in mediump vec2 uv0;\nlayout(location = 8) in mediump vec2 uv1;\nlayout(location = 9) in mediump vec2 uv2;\nlayout(location = 10) in mediump vec2 uv3;\nlayout(location = 12) in mediump vec3 diffuse;\nlayout(location = 11) in mediump vec3 luv;\nlayout(set = 1, binding = 1) uniform PbrParams {\nvec4 metallic;\nvec4 roughness;\n};\nlayout(set = 1, binding = 2) uniform sampler2D weightMap;\nlayout(set = 1, binding = 3) uniform sampler2D detailMap0;\nlayout(set = 1, binding = 4) uniform sampler2D detailMap1;\nlayout(set = 1, binding = 5) uniform sampler2D detailMap2;\nlayout(set = 1, binding = 6) uniform sampler2D detailMap3;\nlayout(set = 1, binding = 7) uniform sampler2D normalMap0;\nlayout(set = 1, binding = 8) uniform sampler2D normalMap1;\nlayout(set = 1, binding = 9) uniform sampler2D normalMap2;\nlayout(set = 1, binding = 10) uniform sampler2D normalMap3;\nlayout(set = 1, binding = 11) uniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\nbaseColor += texture(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture(detailMap0, uv0);\n#endif\ns.position = v_position;\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\nbaseNormal += texture(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture(normalMap0, uv0);\n#endif\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(v_tangent) +\nnmmp.y * normalize(v_binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.metallic = 0.0;\n#if LAYERS == 1\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(lightMap, luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(set = 2, binding = 1) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_STANDARD_TRANSPARENT)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(s.position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 0) out vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nlayout(location = 0) in vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nlayout(location = 8) in vec4 a_matWorld0;\nlayout(location = 9) in vec4 a_matWorld1;\nlayout(location = 10) in vec4 a_matWorld2;\n#if USE_LIGHTMAP\nlayout(location = 11) in vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nlayout(location = 12) in float a_dyn_batch_id;\nlayout(set = 2, binding = 0) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nlayout(location = 0) out float v_fog_factor;\n#if USE_VERTEX_COLOR\nlayout(location = 13) in lowp vec4 a_color;\nlayout(location = 1) out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nlayout(location = 2) out vec2 v_uv;\nlayout(set = 1, binding = 0) uniform TexCoords {\nvec4 tilingOffset;\n};\n#endif\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(matWorld * position);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(matWorld * position);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(matWorld * position);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(matWorld * position);\n#else\nv_fog_factor = 1.0;\n#endif\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nlayout(location = 0) in float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nlayout(location = 2) in vec2 v_uv;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\n#endif\nlayout(set = 1, binding = 1) uniform Constant {\nvec4 mainColor;\nvec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\nlayout(location = 1) in lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no *= v_color;\n#endif\n#if USE_TEXTURE\no *= texture(mainTexture, v_uv);\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\no = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\nreturn CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(location = 0) out vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nlayout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\nlayout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z- cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat bias = cc_shadowWHPBInfo.w;\nfloat offsetDepth = clipPos.z - bias;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth - cc_shadowWHPBInfo.w, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(offsetDepth, closestDepth);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat offsetDepth = depth - cc_shadowWHPBInfo.w;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(offsetDepth, closestDepth);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(offsetDepth, closestDepth);\n}\n}\n}\nreturn shadow / 9.0;\n}\n#endif\n#if CC_USE_IBL\nlayout(set = 0, binding = 4) uniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nvec3 projWorldPos = shadowPos.xyz + (1.0 - NL) * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\nelse if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\nelse shadow = CCGetShadowFactorHard(pos);\nshadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n}\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(set = 2, binding = 1) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(pos, s.position);\nelse if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(pos, s.position);\nelse shadow = CCGetSpotLightShadowFactorHard(pos, s.position);\n}\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout (set = 0, binding = 6) uniform sampler2D cc_gbuffer_albedoMap;\nlayout (set = 0, binding = 7) uniform sampler2D cc_gbuffer_positionMap;\nlayout (set = 0, binding = 8) uniform sampler2D cc_gbuffer_normalMap;\nlayout (set = 0, binding = 9) uniform sampler2D cc_gbuffer_emissiveMap;\nlayout(location = 0) out vec4 fragColor;\nvoid main () {\nStandardSurface s;\nvec4 albedoMap = texture(cc_gbuffer_albedoMap,v_uv);\nvec4 positionMap = texture(cc_gbuffer_positionMap,v_uv);\nvec4 normalMap = texture(cc_gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture(cc_gbuffer_emissiveMap,v_uv);\ns.albedo = albedoMap;\ns.position = positionMap.xyz;\ns.roughness = positionMap.w;\ns.normal = normalMap.xyz;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\n#if CC_USE_FOG == 0\nfogFactor = LinearFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 1\nfogFactor = ExpFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 2\nfogFactor = ExpSquaredFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 3\nfogFactor = LayeredFog(vec4(s.position, 1));\n#else\nfogFactor = 1.0;\n#endif\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(s.position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\nCCStandardShadingAdditive(s, shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, fogFactor), color.a);\nfragColor = CCFragOutput(color);\n}"
            }], [{
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nlayout(location = 8) in vec4 a_matWorld0;\nlayout(location = 9) in vec4 a_matWorld1;\nlayout(location = 10) in vec4 a_matWorld2;\n#if USE_LIGHTMAP\nlayout(location = 11) in vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nlayout(location = 12) in float a_dyn_batch_id;\nlayout(set = 2, binding = 0) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\nposition = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\nposition.z -= 0.0001;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvec4 frag () {\nreturn CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(location = 0) out vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(location = 0) in vec2 v_uv;\nlayout (set = 0, binding = 10) uniform sampler2D cc_lighting_resultMap;\nlayout(location = 0) out vec4 fragColor;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture(tex, v_rgbSE).xyz;\nvec4 texColor = texture(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\nfragColor = fxaa(cc_lighting_resultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}"
            }], [{
              "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\nlayout(location = 0) out mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nmat4 matProj = cc_matProj;\nif (matProj[3].w > 0.0) {\nvec2 scale = vec2(48.0, 24.0);\nmatProj[0].xy *= scale;\nmatProj[1].xy *= scale;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\n}\nvec4 pos = matProj * matViewRotOnly * viewDir;\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(set = 0, binding = 4) uniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nlayout(location = 0) in mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec2 v_uv;\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 offset;\n};\nlayout(set = 1, binding = 1) uniform PerFrameInfo {\nvec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nvec4 position = cc_matViewProj * vec4(a_position, 1.0);\nposition.xy += offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture(mainTexture, v_uv));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(location = 0) in vec2 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out float v_percent;\nlayout(set = 1, binding = 0) uniform Constant {\nvec4 u_buffer0;\nvec4 u_buffer1;\nmat4 u_projection;\n};\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nv_percent = u_buffer0.z;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in float v_percent;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture(mainTexture, v_uv);\nfloat precent = clamp(v_percent, 0.0, 1.0);\ncolor.xyz *= precent;\nreturn color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }]];

            const assembly = (() => {
              {
                return {
                  glsl1,
                  glsl3,
                  glsl4
                };
              }
            })();

            class BuiltinResMgr {
              constructor() {
                this._device = null;
                this._resources = {};
              }

              initBuiltinRes(device) {
                this._device = device;
                const resources = this._resources;
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const imgAsset = new ImageAsset(canvas);
                const l = canvas.width = canvas.height = 2;
                context.fillStyle = '#000';
                context.fillRect(0, 0, l, l);
                const blackTexture = new Texture2D();
                blackTexture._uuid = 'black-texture';
                blackTexture.image = imgAsset;
                resources[blackTexture._uuid] = blackTexture;
                context.fillStyle = 'rgba(0,0,0,0)';
                context.fillRect(0, 0, l, l);
                const emptyTexture = new Texture2D();
                emptyTexture._uuid = 'empty-texture';
                emptyTexture.image = imgAsset;
                resources[emptyTexture._uuid] = emptyTexture;
                const blackCubeTexture = new TextureCube();
                blackCubeTexture._uuid = 'black-cube-texture';
                blackCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
                blackCubeTexture.image = {
                  front: new ImageAsset(canvas),
                  back: new ImageAsset(canvas),
                  left: new ImageAsset(canvas),
                  right: new ImageAsset(canvas),
                  top: new ImageAsset(canvas),
                  bottom: new ImageAsset(canvas)
                };
                resources[blackCubeTexture._uuid] = blackCubeTexture;
                context.fillStyle = '#777';
                context.fillRect(0, 0, l, l);
                const greyTexture = new Texture2D();
                greyTexture._uuid = 'grey-texture';
                greyTexture.image = imgAsset;
                resources[greyTexture._uuid] = greyTexture;
                context.fillStyle = '#fff';
                context.fillRect(0, 0, l, l);
                const whiteTexture = new Texture2D();
                whiteTexture._uuid = 'white-texture';
                whiteTexture.image = imgAsset;
                resources[whiteTexture._uuid] = whiteTexture;
                const whiteCubeTexture = new TextureCube();
                whiteCubeTexture._uuid = 'white-cube-texture';
                whiteCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
                whiteCubeTexture.image = {
                  front: new ImageAsset(canvas),
                  back: new ImageAsset(canvas),
                  left: new ImageAsset(canvas),
                  right: new ImageAsset(canvas),
                  top: new ImageAsset(canvas),
                  bottom: new ImageAsset(canvas)
                };
                resources[whiteCubeTexture._uuid] = whiteCubeTexture;
                context.fillStyle = '#7f7fff';
                context.fillRect(0, 0, l, l);
                const normalTexture = new Texture2D();
                normalTexture._uuid = 'normal-texture';
                normalTexture.image = imgAsset;
                resources[normalTexture._uuid] = normalTexture;
                canvas.width = canvas.height = 16;
                context.fillStyle = '#ddd';
                context.fillRect(0, 0, 16, 16);
                context.fillStyle = '#555';
                context.fillRect(0, 0, 8, 8);
                context.fillStyle = '#555';
                context.fillRect(8, 8, 8, 8);
                const defaultTexture = new Texture2D();
                defaultTexture._uuid = 'default-texture';
                defaultTexture.image = imgAsset;
                resources[defaultTexture._uuid] = defaultTexture;
                const defaultCubeTexture = new TextureCube();
                defaultCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
                defaultCubeTexture._uuid = 'default-cube-texture';
                defaultCubeTexture.image = {
                  front: new ImageAsset(canvas),
                  back: new ImageAsset(canvas),
                  left: new ImageAsset(canvas),
                  right: new ImageAsset(canvas),
                  top: new ImageAsset(canvas),
                  bottom: new ImageAsset(canvas)
                };
                resources[defaultCubeTexture._uuid] = defaultCubeTexture;

                if (legacyCC.SpriteFrame) {
                  const spriteFrame = new legacyCC.SpriteFrame();
                  const image = imgAsset;
                  const texture = new Texture2D();
                  texture.image = image;
                  spriteFrame.texture = texture;
                  spriteFrame._uuid = 'default-spriteframe';
                  resources[spriteFrame._uuid] = spriteFrame;
                }

                const shaderVersionKey = getDeviceShaderVersion(device);

                if (!shaderVersionKey) {
                  return Promise.reject(Error('Failed to initialize builtin shaders: unknown device.'));
                }

                const shaderSources = assembly[shaderVersionKey];

                if (!shaderSources) {
                  return Promise.reject(Error(`Current device is requiring builtin shaders of version ${shaderVersionKey} ` + `but shaders of that version are not assembled in this build.`));
                }

                return Promise.resolve().then(() => {
                  effects.forEach((e, effectIndex) => {
                    const effect = Object.assign(new legacyCC.EffectAsset(), e);
                    effect.shaders.forEach((shaderInfo, shaderIndex) => {
                      const shaderSource = shaderSources[effectIndex][shaderIndex];

                      if (shaderSource) {
                        shaderInfo[shaderVersionKey] = shaderSource;
                      }
                    });
                    effect.hideInEditor = true;
                    effect.onLoaded();
                  });

                  this._initMaterials();
                });
              }

              get(uuid) {
                return this._resources[uuid];
              }

              _initMaterials() {
                const resources = this._resources;
                const materialsToBeCompiled = [];
                const standardMtl = new legacyCC.Material();
                standardMtl._uuid = 'standard-material';
                standardMtl.initialize({
                  effectName: 'standard'
                });
                resources[standardMtl._uuid] = standardMtl;
                materialsToBeCompiled.push(standardMtl);
                const missingEfxMtl = new legacyCC.Material();
                missingEfxMtl._uuid = 'missing-effect-material';
                missingEfxMtl.initialize({
                  effectName: 'unlit',
                  defines: {
                    USE_COLOR: true
                  }
                });
                missingEfxMtl.setProperty('mainColor', legacyCC.color('#ffff00'));
                resources[missingEfxMtl._uuid] = missingEfxMtl;
                materialsToBeCompiled.push(missingEfxMtl);
                const missingMtl = new legacyCC.Material();
                missingMtl._uuid = 'missing-material';
                missingMtl.initialize({
                  effectName: 'unlit',
                  defines: {
                    USE_COLOR: true
                  }
                });
                missingMtl.setProperty('mainColor', legacyCC.color('#ff00ff'));
                resources[missingMtl._uuid] = missingMtl;
                materialsToBeCompiled.push(missingMtl);
                const clearStencilMtl = new legacyCC.Material();
                clearStencilMtl._uuid = 'default-clear-stencil';
                clearStencilMtl.initialize({
                  defines: {
                    USE_TEXTURE: false
                  },
                  effectName: 'clear-stencil'
                });
                resources[clearStencilMtl._uuid] = clearStencilMtl;
                materialsToBeCompiled.push(clearStencilMtl);
                const spriteMtl = new legacyCC.Material();
                spriteMtl._uuid = 'ui-base-material';
                spriteMtl.initialize({
                  defines: {
                    USE_TEXTURE: false
                  },
                  effectName: 'sprite'
                });
                resources[spriteMtl._uuid] = spriteMtl;
                materialsToBeCompiled.push(spriteMtl);
                const spriteColorMtl = new legacyCC.Material();
                spriteColorMtl._uuid = 'ui-sprite-material';
                spriteColorMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    CC_USE_EMBEDDED_ALPHA: false,
                    IS_GRAY: false
                  },
                  effectName: 'sprite'
                });
                resources[spriteColorMtl._uuid] = spriteColorMtl;
                materialsToBeCompiled.push(spriteColorMtl);
                const alphaTestMaskMtl = new legacyCC.Material();
                alphaTestMaskMtl._uuid = 'ui-alpha-test-material';
                alphaTestMaskMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    USE_ALPHA_TEST: true,
                    CC_USE_EMBEDDED_ALPHA: false,
                    IS_GRAY: false
                  },
                  effectName: 'sprite'
                });
                resources[alphaTestMaskMtl._uuid] = alphaTestMaskMtl;
                materialsToBeCompiled.push(alphaTestMaskMtl);
                const spriteGrayMtl = new legacyCC.Material();
                spriteGrayMtl._uuid = 'ui-sprite-gray-material';
                spriteGrayMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    CC_USE_EMBEDDED_ALPHA: false,
                    IS_GRAY: true
                  },
                  effectName: 'sprite'
                });
                resources[spriteGrayMtl._uuid] = spriteGrayMtl;
                materialsToBeCompiled.push(spriteGrayMtl);
                const spriteAlphaMtl = new legacyCC.Material();
                spriteAlphaMtl._uuid = 'ui-sprite-alpha-sep-material';
                spriteAlphaMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    CC_USE_EMBEDDED_ALPHA: true,
                    IS_GRAY: false
                  },
                  effectName: 'sprite'
                });
                resources[spriteAlphaMtl._uuid] = spriteAlphaMtl;
                materialsToBeCompiled.push(spriteAlphaMtl);
                const spriteAlphaGrayMtl = new legacyCC.Material();
                spriteAlphaGrayMtl._uuid = 'ui-sprite-gray-alpha-sep-material';
                spriteAlphaGrayMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    CC_USE_EMBEDDED_ALPHA: true,
                    IS_GRAY: true
                  },
                  effectName: 'sprite'
                });
                resources[spriteAlphaGrayMtl._uuid] = spriteAlphaGrayMtl;
                materialsToBeCompiled.push(spriteAlphaGrayMtl);
                const defaultGraphicsMtl = new legacyCC.Material();
                defaultGraphicsMtl._uuid = 'ui-graphics-material';
                defaultGraphicsMtl.initialize({
                  effectName: 'graphics'
                });
                resources[defaultGraphicsMtl._uuid] = defaultGraphicsMtl;
                materialsToBeCompiled.push(defaultGraphicsMtl);
                const defaultParticleMtl = new legacyCC.Material();
                defaultParticleMtl._uuid = 'default-particle-material';
                defaultParticleMtl.initialize({
                  effectName: 'particle'
                });
                resources[defaultParticleMtl._uuid] = defaultParticleMtl;
                materialsToBeCompiled.push(defaultParticleMtl);
                const defaultParticleGPUMtl = new legacyCC.Material();
                defaultParticleGPUMtl._uuid = 'default-particle-gpu-material';
                defaultParticleGPUMtl.initialize({
                  effectName: 'particle-gpu'
                });
                resources[defaultParticleGPUMtl._uuid] = defaultParticleGPUMtl;
                materialsToBeCompiled.push(defaultParticleGPUMtl);
                const defaultTrailMtl = new legacyCC.Material();
                defaultTrailMtl._uuid = 'default-trail-material';
                defaultTrailMtl.initialize({
                  effectName: 'particle-trail'
                });
                resources[defaultTrailMtl._uuid] = defaultTrailMtl;
                materialsToBeCompiled.push(defaultTrailMtl);
                const defaultBillboardMtl = new legacyCC.Material();
                defaultBillboardMtl._uuid = 'default-billboard-material';
                defaultBillboardMtl.initialize({
                  effectName: 'billboard'
                });
                resources[defaultBillboardMtl._uuid] = defaultBillboardMtl;
                materialsToBeCompiled.push(defaultBillboardMtl);
                const spineTwoColorMtl = new legacyCC.Material();
                spineTwoColorMtl._uuid = 'default-spine-material';
                spineTwoColorMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    CC_USE_EMBEDDED_ALPHA: false,
                    IS_GRAY: false
                  },
                  effectName: 'spine'
                });
                resources[spineTwoColorMtl._uuid] = spineTwoColorMtl;
                materialsToBeCompiled.push(spineTwoColorMtl);
                legacyCC.game.on(legacyCC.Game.EVENT_GAME_INITED, () => {
                  for (let i = 0; i < materialsToBeCompiled.length; ++i) {
                    const mat = materialsToBeCompiled[i];

                    for (let j = 0; j < mat.passes.length; ++j) {
                      mat.passes[j].tryCompile();
                    }
                  }
                });
              }

            }

            const builtinResMgr = exports('c3', legacyCC.builtinResMgr = new BuiltinResMgr());

            const getPhaseID = (() => {
              const phases = new Map();
              let phaseNum = 0;
              return phaseName => {
                if (typeof phaseName === 'number') {
                  return phaseName;
                }

                if (!phases.has(phaseName)) {
                  phases.set(phaseName, 1 << phaseNum);
                  phaseNum++;
                }

                return phases.get(phaseName);
              };
            })();

            const _bufferInfo = new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE);

            const _bufferViewInfo = new BufferViewInfo(null);

            const _dsInfo = new DescriptorSetInfo(null);

            let BatchingSchemes;

            (function (BatchingSchemes) {
              BatchingSchemes[BatchingSchemes["NONE"] = 0] = "NONE";
              BatchingSchemes[BatchingSchemes["INSTANCING"] = 1] = "INSTANCING";
              BatchingSchemes[BatchingSchemes["VB_MERGING"] = 2] = "VB_MERGING";
            })(BatchingSchemes || (BatchingSchemes = {}));

            class Pass {
              static fillPipelineInfo(pass, info) {
                if (info.priority !== undefined) {
                  pass._setPriority(info.priority);
                }

                if (info.primitive !== undefined) {
                  pass._setPrimitive(info.primitive);
                }

                if (info.stage !== undefined) {
                  pass._setStage(info.stage);
                }

                if (info.dynamicStates !== undefined) {
                  pass._setDynamicState(info.dynamicStates);
                }

                if (info.phase !== undefined) {
                  pass._setPhase(getPhaseID(info.phase));
                }

                const bs = pass._bs;

                if (info.blendState) {
                  const bsInfo = info.blendState;
                  const {
                    targets
                  } = bsInfo;

                  if (targets) {
                    targets.forEach((t, i) => {
                      bs.setTarget(i, t);
                    });
                  }

                  if (bsInfo.isA2C !== undefined) {
                    bs.isA2C = bsInfo.isA2C;
                  }

                  if (bsInfo.isIndepend !== undefined) {
                    bs.isIndepend = bsInfo.isIndepend;
                  }

                  if (bsInfo.blendColor !== undefined) {
                    bs.blendColor = bsInfo.blendColor;
                  }
                }

                pass._rs.assign(info.rasterizerState);

                pass._dss.assign(info.depthStencilState);
              }

              static getPassHash(pass) {
                const shaderKey = programLib.getKey(pass.program, pass.defines);
                let res = `${shaderKey},${pass._primitive},${pass._dynamicStates}`;
                res += serializeBlendState(pass._bs);
                res += serializeDepthStencilState(pass._dss);
                res += serializeRasterizerState(pass._rs);
                return murmurhash2_32_gc(res, 666);
              }

              get native() {
                return this._nativeObj;
              }

              constructor(root) {
                this._rootBuffer = null;
                this._buffers = [];
                this._descriptorSet = null;
                this._pipelineLayout = null;
                this._passIndex = 0;
                this._propertyIndex = 0;
                this._programName = '';
                this._dynamics = {};
                this._propertyHandleMap = {};
                this._rootBlock = null;
                this._blocks = [];
                this._shaderInfo = null;
                this._defines = {};
                this._properties = {};
                this._shader = null;
                this._bs = new BlendState$1();
                this._dss = new DepthStencilState$1();
                this._rs = new RasterizerState$1();
                this._priority = RenderPriority.DEFAULT;
                this._stage = RenderPassStage.DEFAULT;
                this._phase = getPhaseID('default');
                this._primitive = PrimitiveMode.TRIANGLE_LIST;
                this._batchingScheme = BatchingSchemes.NONE;
                this._dynamicStates = DynamicStateFlagBit.NONE;
                this._hash = 0;
                this._root = void 0;
                this._device = void 0;
                this._passHandle = NULL_HANDLE;
                this._rootBufferDirty = false;
                this._root = root;
                this._device = root.device;
              }

              initialize(info) {
                this._doInit(info);

                this.resetUBOs();
                this.resetTextures();
                this.tryCompile();
              }

              getHandle(name, offset = 0, targetType = Type.UNKNOWN) {
                let handle = this._propertyHandleMap[name];

                if (!handle) {
                  return 0;
                }

                if (targetType) {
                  handle = customizeType(handle, targetType);
                } else if (offset) {
                  handle = customizeType(handle, getTypeFromHandle(handle) - offset);
                }

                return handle + offset;
              }

              getBinding(name) {
                const handle = this.getHandle(name);

                if (!handle) {
                  return -1;
                }

                return Pass.getBindingFromHandle(handle);
              }

              setUniform(handle, value) {
                const binding = Pass.getBindingFromHandle(handle);
                const type = Pass.getTypeFromHandle(handle);
                const ofs = Pass.getOffsetFromHandle(handle);
                const block = this._blocks[binding];
                type2writer[type](block, value, ofs);

                this._setRootBufferDirty(true);
              }

              getUniform(handle, out) {
                const binding = Pass.getBindingFromHandle(handle);
                const type = Pass.getTypeFromHandle(handle);
                const ofs = Pass.getOffsetFromHandle(handle);
                const block = this._blocks[binding];
                return type2reader[type](block, out, ofs);
              }

              setUniformArray(handle, value) {
                const binding = Pass.getBindingFromHandle(handle);
                const type = Pass.getTypeFromHandle(handle);
                const stride = GetTypeSize(type) >> 2;
                const block = this._blocks[binding];
                let ofs = Pass.getOffsetFromHandle(handle);

                for (let i = 0; i < value.length; i++, ofs += stride) {
                  if (value[i] === null) {
                    continue;
                  }

                  type2writer[type](block, value[i], ofs);
                }

                this._setRootBufferDirty(true);
              }

              bindTexture(binding, value, index) {
                this._descriptorSet.bindTexture(binding, value, index || 0);
              }

              bindSampler(binding, value, index) {
                this._descriptorSet.bindSampler(binding, value, index || 0);
              }

              setDynamicState(state, value) {
                const ds = this._dynamics[state];

                if (ds && ds.value === value) {
                  return;
                }

                ds.value = value;
                ds.dirty = true;
              }

              overridePipelineStates(original, overrides) {
                console.warn('base pass cannot override states, please use pass instance instead.');
              }

              _setRootBufferDirty(val) {
                this._rootBufferDirty = val;

                {
                  this._nativeObj.setRootBufferDirty(val);
                }
              }

              update() {
                if (!this._descriptorSet) {
                  errorID(12006);
                  return;
                }

                if (this._rootBuffer && this._rootBufferDirty) {
                  this._rootBuffer.update(this._rootBlock);

                  this._setRootBufferDirty(false);
                }

                this._descriptorSet.update();

                {
                  this._nativeObj.update();
                }
              }

              _initNative() {
                if ( !this._nativeObj) {
                  this._nativeObj = new NativePass();
                  this._passHandle = PassPool.alloc();
                  this._nativePriority = PassPool.getTypedArray(this._passHandle, PassView.PRIORITY);
                  this._nativeStage = PassPool.getTypedArray(this._passHandle, PassView.STAGE);
                  this._nativePhase = PassPool.getTypedArray(this._passHandle, PassView.PHASE);
                  this._nativePrimitive = PassPool.getTypedArray(this._passHandle, PassView.PRIMITIVE);
                  this._nativeBatchingScheme = PassPool.getTypedArray(this._passHandle, PassView.BATCHING_SCHEME);
                  this._nativeDynamicStates = PassPool.getTypedArray(this._passHandle, PassView.DYNAMIC_STATE);
                  this._nativeHash = PassPool.getTypedArray(this._passHandle, PassView.HASH);

                  this._nativeObj.initWithData(PassPool.getBuffer(this._passHandle));
                }
              }

              _destroy() {
                {
                  this._nativeObj = null;

                  if (this._passHandle) {
                    PassPool.free(this._passHandle);
                  }
                }
              }

              destroy() {
                for (let i = 0; i < this._shaderInfo.blocks.length; i++) {
                  const u = this._shaderInfo.blocks[i];

                  this._buffers[u.binding].destroy();
                }

                this._buffers = [];

                if (this._rootBuffer) {
                  this._rootBuffer.destroy();

                  this._rootBuffer = null;
                }

                this._descriptorSet.destroy();

                this._rs.destroy();

                this._dss.destroy();

                this._bs.destroy();

                this._destroy();
              }

              resetUniform(name) {
                const handle = this.getHandle(name);

                if (!handle) {
                  return;
                }

                const type = Pass.getTypeFromHandle(handle);
                const binding = Pass.getBindingFromHandle(handle);
                const ofs = Pass.getOffsetFromHandle(handle);
                const block = this._blocks[binding];
                const info = this._properties[name];
                const value = info && info.value || getDefaultFromType(type);
                type2writer[type](block, value, ofs);

                this._setRootBufferDirty(true);
              }

              resetTexture(name, index) {
                const handle = this.getHandle(name);

                if (!handle) {
                  return;
                }

                const type = Pass.getTypeFromHandle(handle);
                const binding = Pass.getBindingFromHandle(handle);
                const info = this._properties[name];
                const value = info && info.value;
                const texName = value ? `${value}-texture` : getDefaultFromType(type);
                const textureBase = builtinResMgr.get(texName);
                const texture = textureBase && textureBase.getGFXTexture();
                const samplerHash = info && info.samplerHash !== undefined ? info.samplerHash : textureBase && textureBase.getSamplerHash();
                const sampler = samplerLib.getSampler(this._device, samplerHash);

                this._descriptorSet.bindSampler(binding, sampler, index);

                this._descriptorSet.bindTexture(binding, texture, index);
              }

              resetUBOs() {
                for (let i = 0; i < this._shaderInfo.blocks.length; i++) {
                  const u = this._shaderInfo.blocks[i];
                  const block = this._blocks[u.binding];
                  let ofs = 0;

                  for (let j = 0; j < u.members.length; j++) {
                    const cur = u.members[j];
                    const info = this._properties[cur.name];
                    const givenDefault = info && info.value;
                    const value = givenDefault || getDefaultFromType(cur.type);
                    const size = (GetTypeSize(cur.type) >> 2) * cur.count;

                    for (let k = 0; k + value.length <= size; k += value.length) {
                      block.set(value, ofs + k);
                    }

                    ofs += size;
                  }
                }

                this._setRootBufferDirty(true);
              }

              resetTextures() {
                for (let i = 0; i < this._shaderInfo.samplerTextures.length; i++) {
                  const u = this._shaderInfo.samplerTextures[i];

                  for (let j = 0; j < u.count; j++) {
                    this.resetTexture(u.name, j);
                  }
                }
              }

              tryCompile() {
                const {
                  pipeline
                } = this._root;

                if (!pipeline) {
                  return false;
                }

                this._syncBatchingScheme();

                const shader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline);

                if (!shader) {
                  console.warn(`create shader ${this._programName} failed`);
                  return false;
                }

                this._shader = shader;

                this._setPipelineLayout(programLib.getTemplateInfo(this._programName).pipelineLayout);

                this._setHash(Pass.getPassHash(this));

                return true;
              }

              getShaderVariant(patches = null) {
                if (!this._shader && !this.tryCompile()) {
                  console.warn('pass resources incomplete');
                  return null;
                }

                if (!patches) {
                  return this._shader;
                }

                const {
                  pipeline
                } = this._root;

                for (let i = 0; i < patches.length; i++) {
                  const patch = patches[i];
                  this._defines[patch.name] = patch.value;
                }

                const shader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline);

                for (let i = 0; i < patches.length; i++) {
                  const patch = patches[i];
                  delete this._defines[patch.name];
                }

                return shader;
              }

              beginChangeStatesSilently() {}

              endChangeStatesSilently() {}

              _setPriority(val) {
                this._priority = val;

                {
                  this._nativePriority[0] = val;
                }
              }

              _setStage(val) {
                this._stage = val;

                {
                  this._nativeStage[0] = val;
                }
              }

              _setPhase(val) {
                this._phase = val;

                {
                  this._nativePhase[0] = val;
                }
              }

              _setPrimitive(val) {
                this._primitive = val;

                {
                  this._nativePrimitive[0] = val;
                }
              }

              _setState(bs, dss, rs, ds) {
                this._bs = bs;
                this._dss = dss;
                this._rs = rs;
                this._descriptorSet = ds;

                {
                  this._nativeObj.blendState = bs.native;
                  this._nativeObj.depthStencilState = dss.native;
                  this._nativeObj.rasterizerState = rs.native;
                  this._nativeObj.descriptorSet = ds;
                }
              }

              _doInit(info, copyDefines = false) {
                this._initNative();

                this._setPriority(RenderPriority.DEFAULT);

                this._setStage(RenderPassStage.DEFAULT);

                this._setPhase(getPhaseID('default'));

                this._setPrimitive(PrimitiveMode.TRIANGLE_LIST);

                this._passIndex = info.passIndex;
                this._propertyIndex = info.propertyIndex !== undefined ? info.propertyIndex : info.passIndex;
                this._programName = info.program;
                this._defines = copyDefines ? { ...info.defines
                } : info.defines;
                this._shaderInfo = programLib.getTemplate(info.program);
                this._properties = info.properties || this._properties;
                const device = this._device;
                Pass.fillPipelineInfo(this, info);

                if (info.stateOverrides) {
                  Pass.fillPipelineInfo(this, info.stateOverrides);
                }

                _dsInfo.layout = programLib.getDescriptorSetLayout(this._device, info.program);
                this._descriptorSet = this._device.createDescriptorSet(_dsInfo);

                this._setState(this._bs, this._dss, this._rs, this._descriptorSet);

                const blocks = this._shaderInfo.blocks;
                const tmplInfo = programLib.getTemplateInfo(info.program);
                const {
                  blockSizes,
                  handleMap
                } = tmplInfo;
                const alignment = device.capabilities.uboOffsetAlignment;
                const startOffsets = [];
                let lastSize = 0;
                let lastOffset = 0;

                for (let i = 0; i < blocks.length; i++) {
                  const size = blockSizes[i];
                  startOffsets.push(lastOffset);
                  lastOffset += Math.ceil(size / alignment) * alignment;
                  lastSize = size;
                }

                const totalSize = startOffsets[startOffsets.length - 1] + lastSize;

                if (totalSize) {
                  _bufferInfo.size = Math.ceil(totalSize / 16) * 16;
                  this._rootBuffer = device.createBuffer(_bufferInfo);
                  this._rootBlock = new ArrayBuffer(totalSize);

                  {
                    this._nativeObj.setRootBufferAndBlock(this._rootBuffer, this._rootBlock);
                  }
                }

                for (let i = 0, count = 0; i < blocks.length; i++) {
                  const {
                    binding
                  } = blocks[i];
                  const size = blockSizes[i];
                  _bufferViewInfo.buffer = this._rootBuffer;
                  _bufferViewInfo.offset = startOffsets[count++];
                  _bufferViewInfo.range = Math.ceil(size / 16) * 16;
                  const bufferView = this._buffers[binding] = device.createBuffer(_bufferViewInfo);
                  this._blocks[binding] = new Float32Array(this._rootBlock, _bufferViewInfo.offset, size / Float32Array.BYTES_PER_ELEMENT);

                  this._descriptorSet.bindBuffer(binding, bufferView);
                }

                const directHandleMap = this._propertyHandleMap = handleMap;
                const indirectHandleMap = {};

                for (const name in this._properties) {
                  const prop = this._properties[name];

                  if (!prop.handleInfo) {
                    continue;
                  }

                  indirectHandleMap[name] = this.getHandle.apply(this, prop.handleInfo);
                }

                Object.assign(directHandleMap, indirectHandleMap);
              }

              _syncBatchingScheme() {
                if (this._defines.USE_INSTANCING) {
                  if (this._device.hasFeature(Feature.INSTANCED_ARRAYS)) {
                    this._setBatchingScheme(BatchingSchemes.INSTANCING);
                  } else {
                    this._defines.USE_INSTANCING = false;

                    this._setBatchingScheme(BatchingSchemes.NONE);
                  }
                } else if (this._defines.USE_BATCHING) {
                  this._setBatchingScheme(BatchingSchemes.VB_MERGING);
                } else {
                  this._setBatchingScheme(BatchingSchemes.NONE);
                }
              }

              _setBatchingScheme(val) {
                this._batchingScheme = val;

                {
                  this._nativeBatchingScheme[0] = val;
                }
              }

              _setDynamicState(val) {
                this._dynamicStates = val;

                {
                  this._nativeDynamicStates[0] = val;
                }
              }

              _setHash(val) {
                this._hash = val;

                {
                  this._nativeHash[0] = val;
                }
              }

              _setPipelineLayout(pipelineLayout) {
                this._pipelineLayout = pipelineLayout;

                {
                  this._nativeObj.setPipelineLayout(pipelineLayout);
                }
              }

              _initPassFromTarget(target, dss, bs, hashFactor) {
                this._initNative();

                this._setPriority(target.priority);

                this._setStage(target.stage);

                this._setPhase(target.phase);

                this._setBatchingScheme(target.batchingScheme);

                this._setPrimitive(target.primitive);

                this._setDynamicState(target.dynamicStates);

                this._setState(bs, dss, target.rasterizerState, target.descriptorSet);

                this._passIndex = target.passIndex;
                this._propertyIndex = target.propertyIndex;
                this._programName = target.program;
                this._defines = target.defines;
                this._shaderInfo = target._shaderInfo;
                this._properties = target._properties;
                this._blocks = target._blocks;
                this._dynamics = target._dynamics;
                this._shader = target._shader;

                this._setPipelineLayout(programLib.getTemplateInfo(this._programName).pipelineLayout);

                this._setHash(target._hash ^ hashFactor);
              }

              get root() {
                return this._root;
              }

              get device() {
                return this._device;
              }

              get shaderInfo() {
                return this._shaderInfo;
              }

              get localSetLayout() {
                return programLib.getDescriptorSetLayout(this._device, this._programName, true);
              }

              get program() {
                return this._programName;
              }

              get properties() {
                return this._properties;
              }

              get defines() {
                return this._defines;
              }

              get passIndex() {
                return this._passIndex;
              }

              get propertyIndex() {
                return this._propertyIndex;
              }

              get dynamics() {
                return this._dynamics;
              }

              get blocks() {
                return this._blocks;
              }

              get rootBufferDirty() {
                return this._rootBufferDirty;
              }

              get priority() {
                return this._priority;
              }

              get primitive() {
                return this._primitive;
              }

              get stage() {
                return this._stage;
              }

              get phase() {
                return this._phase;
              }

              get rasterizerState() {
                return this._rs;
              }

              get depthStencilState() {
                return this._dss;
              }

              get blendState() {
                return this._bs;
              }

              get dynamicStates() {
                return this._dynamicStates;
              }

              get batchingScheme() {
                return this._batchingScheme;
              }

              get descriptorSet() {
                return this._descriptorSet;
              }

              get hash() {
                return this._hash;
              }

              get pipelineLayout() {
                return this._pipelineLayout;
              }

            } exports('db', Pass);
            Pass.PropertyType = PropertyType;
            Pass.getPropertyTypeFromHandle = getPropertyTypeFromHandle;
            Pass.getTypeFromHandle = getTypeFromHandle;
            Pass.getBindingFromHandle = getBindingFromHandle;
            Pass.getOffsetFromHandle = getOffsetFromHandle;

            function serializeBlendState(bs) {
              let res = `,bs,${bs.isA2C}`;

              for (const t of bs.targets) {
                res += `,bt,${t.blend},${t.blendEq},${t.blendAlphaEq},${t.blendColorMask}`;
                res += `,${t.blendSrc},${t.blendDst},${t.blendSrcAlpha},${t.blendDstAlpha}`;
              }

              return res;
            }

            function serializeRasterizerState(rs) {
              return `,rs,${rs.cullMode},${rs.depthBias},${rs.isFrontFaceCCW}`;
            }

            function serializeDepthStencilState(dss) {
              let res = `,dss,${dss.depthTest},${dss.depthWrite},${dss.depthFunc}`;
              res += `,${dss.stencilTestFront},${dss.stencilFuncFront},${dss.stencilRefFront},${dss.stencilReadMaskFront}`;
              res += `,${dss.stencilFailOpFront},${dss.stencilZFailOpFront},${dss.stencilPassOpFront},${dss.stencilWriteMaskFront}`;
              res += `,${dss.stencilTestBack},${dss.stencilFuncBack},${dss.stencilRefBack},${dss.stencilReadMaskBack}`;
              res += `,${dss.stencilFailOpBack},${dss.stencilZFailOpBack},${dss.stencilPassOpBack},${dss.stencilWriteMaskBack}`;
              return res;
            }

            const _dsInfo$1 = new DescriptorSetInfo(null);

            const MAX_PASS_COUNT = 8;
            class SubModel {
              constructor() {
                this._device = null;
                this._passes = null;
                this._shaders = null;
                this._subMesh = null;
                this._patches = null;
                this._priority = RenderPriority.DEFAULT;
                this._inputAssembler = null;
                this._descriptorSet = null;
                this._planarInstanceShader = null;
                this._planarShader = null;
                this._reflectionTex = null;
                this._reflectionSampler = null;
              }

              _destroyDescriptorSet() {
                this._descriptorSet.destroy();

                {
                  this._nativeObj.setDescriptorSet(null);
                }

                this._descriptorSet = null;
              }

              _destroyInputAssembler() {
                this._inputAssembler.destroy();

                {
                  this._nativeObj.setInputAssembler(null);
                }

                this._inputAssembler = null;
              }

              _createDescriptorSet(descInfo) {
                this._descriptorSet = this._device.createDescriptorSet(descInfo);

                {
                  this._nativeObj.setDescriptorSet(this._descriptorSet);
                }
              }

              set passes(passes) {
                const passLengh = passes.length;

                if (passLengh > MAX_PASS_COUNT) {
                  errorID(12004, MAX_PASS_COUNT);
                  return;
                }

                this._passes = passes;

                this._flushPassInfo();

                if (this._descriptorSet) {
                  this._destroyDescriptorSet();

                  _dsInfo$1.layout = passes[0].localSetLayout;

                  this._createDescriptorSet(_dsInfo$1);
                }
              }

              get passes() {
                return this._passes;
              }

              get shaders() {
                return this._shaders;
              }

              set subMesh(subMesh) {
                this._setSubMesh(subMesh);

                this._inputAssembler.destroy();

                this._inputAssembler.initialize(subMesh.iaInfo);

                if (this._passes[0].batchingScheme === BatchingSchemes.VB_MERGING) {
                  this.subMesh.genFlatBuffers();
                }
              }

              get subMesh() {
                return this._subMesh;
              }

              set priority(val) {
                this._priority = val;

                {
                  this._nativeObj.setPriority(val);
                }
              }

              get priority() {
                return this._priority;
              }

              get inputAssembler() {
                return this._inputAssembler;
              }

              get descriptorSet() {
                return this._descriptorSet;
              }

              get patches() {
                return this._patches;
              }

              get planarInstanceShader() {
                return this._planarInstanceShader;
              }

              get planarShader() {
                return this._planarShader;
              }

              _setInputAssembler(iaInfo) {
                this._inputAssembler = this._device.createInputAssembler(iaInfo);

                {
                  this._nativeObj.setInputAssembler(this._inputAssembler);
                }
              }

              _setSubMesh(subMesh) {
                this._subMesh = subMesh;

                {
                  this._nativeObj.setSubMeshBuffers(subMesh.flatBuffers);
                }
              }

              get native() {
                return this._nativeObj;
              }

              _init() {
                {
                  this._nativeObj = new NativeSubModel();
                }
              }

              initialize(subMesh, passes, patches = null) {
                this._device = legacyCC.director.root.device;
                _dsInfo$1.layout = passes[0].localSetLayout;

                this._init();

                this._setInputAssembler(subMesh.iaInfo);

                this._createDescriptorSet(_dsInfo$1);

                this._setSubMesh(subMesh);

                this._patches = patches;
                this._passes = passes;

                this._flushPassInfo();

                if (passes[0].batchingScheme === BatchingSchemes.VB_MERGING) {
                  this.subMesh.genFlatBuffers();
                }

                this.priority = RenderPriority.DEFAULT;

                if (passes[0].phase === getPhaseID('reflection')) {
                  let texWidth = this._device.width;
                  let texHeight = this._device.height;
                  const minSize = 512;

                  if (texHeight < texWidth) {
                    texWidth = minSize * texWidth / texHeight;
                    texHeight = minSize;
                  } else {
                    texWidth = minSize;
                    texHeight = minSize * texHeight / texWidth;
                  }

                  this._reflectionTex = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.STORAGE | TextureUsageBit.TRANSFER_SRC | TextureUsageBit.SAMPLED, Format.RGBA8, texWidth, texHeight, TextureFlagBit.IMMUTABLE));
                  this.descriptorSet.bindTexture(UNIFORM_REFLECTION_TEXTURE_BINDING, this._reflectionTex);
                  const samplerInfo = [Filter.LINEAR, Filter.LINEAR, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP];
                  const samplerHash = genSamplerHash(samplerInfo);
                  this._reflectionSampler = samplerLib.getSampler(this._device, samplerHash);
                  this.descriptorSet.bindSampler(UNIFORM_REFLECTION_TEXTURE_BINDING, this._reflectionSampler);
                  this.descriptorSet.bindTexture(UNIFORM_REFLECTION_STORAGE_BINDING, this._reflectionTex);
                }
              }

              _initNativePlanarShadowShader(shadowInfo) {
                this._planarShader = shadowInfo.getPlanarShader(this._patches);

                {
                  this._nativeObj.setPlanarShader(this._planarShader);
                }
              }

              initPlanarShadowShader() {
                const pipeline = legacyCC.director.root.pipeline;
                const shadowInfo = pipeline.pipelineSceneData.shadows;

                this._initNativePlanarShadowShader(shadowInfo);
              }

              _initNativePlanarShadowInstanceShader(shadowInfo) {
                this._planarInstanceShader = shadowInfo.getPlanarInstanceShader(this._patches);

                {
                  this._nativeObj.setPlanarInstanceShader(this._planarInstanceShader);
                }
              }

              initPlanarShadowInstanceShader() {
                const pipeline = legacyCC.director.root.pipeline;
                const shadowInfo = pipeline.pipelineSceneData.shadows;

                this._initNativePlanarShadowInstanceShader(shadowInfo);
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this._destroyDescriptorSet();

                this._destroyInputAssembler();

                this.priority = RenderPriority.DEFAULT;
                this._patches = null;
                this._subMesh = null;
                this._passes = null;
                this._shaders = null;
                if (this._reflectionTex) this._reflectionTex.destroy();
                this._reflectionTex = null;
                if (this._reflectionSampler) this._reflectionSampler.destroy();
                this._reflectionSampler = null;

                this._destroy();
              }

              update() {
                for (let i = 0; i < this._passes.length; ++i) {
                  const pass = this._passes[i];
                  pass.update();
                }

                this._descriptorSet.update();
              }

              onPipelineStateChanged() {
                const passes = this._passes;

                if (!passes) {
                  return;
                }

                for (let i = 0; i < passes.length; i++) {
                  const pass = passes[i];
                  pass.beginChangeStatesSilently();
                  pass.tryCompile();
                  pass.endChangeStatesSilently();
                }

                this._flushPassInfo();
              }

              onMacroPatchesStateChanged(patches) {
                this._patches = patches;
                const passes = this._passes;

                if (!passes) {
                  return;
                }

                for (let i = 0; i < passes.length; i++) {
                  const pass = passes[i];
                  pass.beginChangeStatesSilently();
                  pass.tryCompile();
                  pass.endChangeStatesSilently();
                }

                this._flushPassInfo();
              }

              _flushPassInfo() {
                const passes = this._passes;

                if (!passes) {
                  return;
                }

                if (!this._shaders) {
                  this._shaders = [];
                }

                this._shaders.length = passes.length;

                for (let i = 0, len = passes.length; i < len; i++) {
                  this._shaders[i] = passes[i].getShaderVariant(this.patches);
                }

                {
                  const passesNative = passes.map(_pass => _pass.native);

                  this._nativeObj.setPasses(passesNative);

                  this._nativeObj.setShaders(this._shaders);
                }
              }

            }

            const INITIAL_CAPACITY = 32;
            const MAX_CAPACITY = 1024;
            class InstancedBuffer {
              static get(pass, extraKey = 0) {
                const buffers = InstancedBuffer._buffers;
                if (!buffers.has(pass)) buffers.set(pass, {});
                const record = buffers.get(pass);
                return record[extraKey] || (record[extraKey] = new InstancedBuffer(pass));
              }

              constructor(pass) {
                this.instances = [];
                this.pass = void 0;
                this.hasPendingModels = false;
                this.dynamicOffsets = [];
                this._device = void 0;
                this._device = pass.device;
                this.pass = pass;
              }

              destroy() {
                for (let i = 0; i < this.instances.length; ++i) {
                  const instance = this.instances[i];
                  instance.vb.destroy();
                  instance.ia.destroy();
                }

                this.instances.length = 0;
              }

              merge(subModel, attrs, passIdx, shaderImplant = null) {
                const stride = attrs.buffer.length;

                if (!stride) {
                  return;
                }

                const sourceIA = subModel.inputAssembler;
                const lightingMap = subModel.descriptorSet.getTexture(UNIFORM_LIGHTMAP_TEXTURE_BINDING);
                let shader = shaderImplant;

                if (!shader) {
                  shader = subModel.shaders[passIdx];
                }

                const descriptorSet = subModel.descriptorSet;

                for (let i = 0; i < this.instances.length; ++i) {
                  const instance = this.instances[i];

                  if (instance.ia.indexBuffer !== sourceIA.indexBuffer || instance.count >= MAX_CAPACITY) {
                    continue;
                  }

                  if (instance.lightingMap !== lightingMap) {
                    continue;
                  }

                  if (instance.stride !== stride) {
                    return;
                  }

                  if (instance.count >= instance.capacity) {
                    instance.capacity <<= 1;
                    const newSize = instance.stride * instance.capacity;
                    const oldData = instance.data;
                    instance.data = new Uint8Array(newSize);
                    instance.data.set(oldData);
                    instance.vb.resize(newSize);
                  }

                  if (instance.shader !== shader) {
                    instance.shader = shader;
                  }

                  if (instance.descriptorSet !== descriptorSet) {
                    instance.descriptorSet = descriptorSet;
                  }

                  instance.data.set(attrs.buffer, instance.stride * instance.count++);
                  this.hasPendingModels = true;
                  return;
                }

                const vb = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, stride * INITIAL_CAPACITY, stride));

                const data = new Uint8Array(stride * INITIAL_CAPACITY);
                const vertexBuffers = sourceIA.vertexBuffers.slice();
                const attributes = sourceIA.attributes.slice();
                const indexBuffer = sourceIA.indexBuffer;

                for (let i = 0; i < attrs.attributes.length; i++) {
                  const attr = attrs.attributes[i];
                  const newAttr = new Attribute(attr.name, attr.format, attr.isNormalized, vertexBuffers.length, true);
                  attributes.push(newAttr);
                }

                data.set(attrs.buffer);
                vertexBuffers.push(vb);
                const iaInfo = new InputAssemblerInfo(attributes, vertexBuffers, indexBuffer);

                const ia = this._device.createInputAssembler(iaInfo);

                this.instances.push({
                  count: 1,
                  capacity: INITIAL_CAPACITY,
                  vb,
                  data,
                  ia,
                  stride,
                  shader,
                  descriptorSet,
                  lightingMap
                });
                this.hasPendingModels = true;
              }

              uploadBuffers(cmdBuff) {
                for (let i = 0; i < this.instances.length; ++i) {
                  const instance = this.instances[i];

                  if (!instance.count) {
                    continue;
                  }

                  instance.ia.instanceCount = instance.count;
                  cmdBuff.updateBuffer(instance.vb, instance.data);
                }
              }

              clear() {
                for (let i = 0; i < this.instances.length; ++i) {
                  const instance = this.instances[i];
                  instance.count = 0;
                }

                this.hasPendingModels = false;
              }

            }
            InstancedBuffer._buffers = new Map();

            const m4_1 = new Mat4();

            const _subModelPool = new Pool(() => new SubModel(), 32);

            const shadowMapPatches = [{
              name: 'CC_RECEIVE_SHADOW',
              value: true
            }];
            let ModelType;

            (function (ModelType) {
              ModelType[ModelType["DEFAULT"] = 0] = "DEFAULT";
              ModelType[ModelType["SKINNING"] = 1] = "SKINNING";
              ModelType[ModelType["BAKED_SKINNING"] = 2] = "BAKED_SKINNING";
              ModelType[ModelType["BATCH_2D"] = 3] = "BATCH_2D";
              ModelType[ModelType["PARTICLE_BATCH"] = 4] = "PARTICLE_BATCH";
              ModelType[ModelType["LINE"] = 5] = "LINE";
            })(ModelType || (ModelType = exports('cq', {})));

            function uploadMat4AsVec4x3(mat, v1, v2, v3) {
              v1[0] = mat.m00;
              v1[1] = mat.m01;
              v1[2] = mat.m02;
              v1[3] = mat.m12;
              v2[0] = mat.m04;
              v2[1] = mat.m05;
              v2[2] = mat.m06;
              v2[3] = mat.m13;
              v3[0] = mat.m08;
              v3[1] = mat.m09;
              v3[2] = mat.m10;
              v3[3] = mat.m14;
            }

            const lightmapSamplerHash = genSamplerHash([Filter.LINEAR, Filter.LINEAR, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP]);
            const lightmapSamplerWithMipHash = genSamplerHash([Filter.LINEAR, Filter.LINEAR, Filter.LINEAR, Address.CLAMP, Address.CLAMP, Address.CLAMP]);
            class Model {
              get subModels() {
                return this._subModels;
              }

              get inited() {
                return this._inited;
              }

              get worldBounds() {
                return this._worldBounds;
              }

              get modelBounds() {
                return this._modelBounds;
              }

              get localBuffer() {
                return this._localBuffer;
              }

              get updateStamp() {
                return this._updateStamp;
              }

              get isInstancingEnabled() {
                return this._instMatWorldIdx >= 0;
              }

              get receiveShadow() {
                return this._receiveShadow;
              }

              set receiveShadow(val) {
                this._setReceiveShadow(val);

                this.onMacroPatchesStateChanged();
              }

              get castShadow() {
                return this._castShadow;
              }

              set castShadow(val) {
                this._castShadow = val;

                {
                  this._nativeObj.setCastShadow(val);
                }
              }

              get node() {
                return this._node;
              }

              set node(n) {
                this._node = n;

                {
                  this._nativeObj.setNode(n.native);
                }
              }

              get transform() {
                return this._transform;
              }

              set transform(n) {
                this._transform = n;

                {
                  this._nativeObj.setTransform(n.native);
                }
              }

              get visFlags() {
                return this._visFlags;
              }

              set visFlags(val) {
                this._visFlags = val;

                {
                  this._nativeObj.seVisFlag(val);
                }
              }

              get enabled() {
                return this._enabled;
              }

              set enabled(val) {
                this._enabled = val;

                {
                  this._nativeObj.setEnabled(val);
                }
              }

              get native() {
                return this._nativeObj;
              }

              constructor() {
                this.type = ModelType.DEFAULT;
                this.scene = null;
                this.isDynamicBatching = false;
                this.instancedAttributes = {
                  buffer: null,
                  views: [],
                  attributes: []
                };
                this._worldBounds = null;
                this._modelBounds = null;
                this._subModels = [];
                this._node = null;
                this._transform = null;
                this._device = void 0;
                this._inited = false;
                this._descriptorSetCount = 1;
                this._updateStamp = -1;
                this._transformUpdated = true;
                this._localData = new Float32Array(UBOLocal.COUNT);
                this._localBuffer = null;
                this._instMatWorldIdx = -1;
                this._lightmap = null;
                this._lightmapUVParam = new Vec4();
                this._receiveShadow = false;
                this._castShadow = false;
                this._enabled = true;
                this._visFlags = Layers.Enum.NONE;
                this._device = legacyCC.director.root.device;
              }

              _setReceiveShadow(val) {
                this._receiveShadow = val;

                {
                  this._nativeObj.setReceiveShadow(val);
                }
              }

              _init() {
                {
                  this._nativeObj = new NativeModel();
                }
              }

              initialize() {
                if (this._inited) {
                  return;
                }

                this._init();

                this._setReceiveShadow(true);

                this.castShadow = false;
                this.enabled = true;
                this.visFlags = Layers.Enum.NONE;
                this._inited = true;
              }

              _destroySubmodel(subModel) {
                subModel.destroy();
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                const subModels = this._subModels;

                for (let i = 0; i < subModels.length; i++) {
                  const subModel = this._subModels[i];

                  this._destroySubmodel(subModel);
                }

                if (this._localBuffer) {
                  this._localBuffer.destroy();

                  this._localBuffer = null;
                }

                this._worldBounds = null;
                this._modelBounds = null;
                this._subModels.length = 0;
                this._inited = false;
                this._transformUpdated = true;
                this._transform = null;
                this._node = null;
                this.isDynamicBatching = false;

                this._destroy();
              }

              attachToScene(scene) {
                this.scene = scene;
              }

              detachFromScene() {
                this.scene = null;
              }

              updateTransform(stamp) {
                const node = this.transform;

                if (node.hasChangedFlags || node._dirtyFlags) {
                  node.updateWorldTransform();
                  this._transformUpdated = true;
                  const worldBounds = this._worldBounds;

                  if (this._modelBounds && worldBounds) {
                    this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
                  }
                }
              }

              updateWorldBound() {
                const node = this.transform;

                if (node !== null) {
                  node.updateWorldTransform();
                  this._transformUpdated = true;
                  const worldBounds = this._worldBounds;

                  if (this._modelBounds && worldBounds) {
                    this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
                  }
                }
              }

              _applyLocalData() {
              }

              _applyLocalBuffer() {
                {
                  this._nativeObj.setLocalBuffer(this._localBuffer);
                }
              }

              updateUBOs(stamp) {
                const subModels = this._subModels;

                for (let i = 0; i < subModels.length; i++) {
                  subModels[i].update();
                }

                this._updateStamp = stamp;

                if (!this._transformUpdated) {
                  return;
                }

                this._transformUpdated = false;
                const worldMatrix = this.transform._mat;
                const idx = this._instMatWorldIdx;

                if (idx >= 0) {
                  const attrs = this.instancedAttributes.views;
                  uploadMat4AsVec4x3(worldMatrix, attrs[idx], attrs[idx + 1], attrs[idx + 2]);
                } else if (this._localBuffer) {
                  Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET);
                  Mat4.inverseTranspose(m4_1, worldMatrix);

                  Mat4.toArray(this._localData, m4_1, UBOLocal.MAT_WORLD_IT_OFFSET);

                  this._localBuffer.update(this._localData);

                  this._applyLocalData();

                  this._applyLocalBuffer();
                }
              }

              _updateNativeBounds() {
                {
                  this._nativeObj.setBounds(this._worldBounds.native);
                }
              }

              createBoundingShape(minPos, maxPos) {
                if (!minPos || !maxPos) {
                  return;
                }

                this._modelBounds = AABB.fromPoints(AABB.create(), minPos, maxPos);
                this._worldBounds = AABB.clone(this._modelBounds);

                this._updateNativeBounds();
              }

              _createSubModel() {
                return new SubModel();
              }

              initSubModel(idx, subMeshData, mat) {
                this.initialize();

                if (this._subModels[idx] == null) {
                  this._subModels[idx] = this._createSubModel();
                } else {
                  this._subModels[idx].destroy();
                }

                this._subModels[idx].initialize(subMeshData, mat.passes, this.getMacroPatches(idx));

                this._subModels[idx].initPlanarShadowShader();

                this._subModels[idx].initPlanarShadowInstanceShader();

                this._updateAttributesAndBinding(idx);

                {
                  this._nativeObj.setSubModel(idx, this._subModels[idx].native);
                }
              }

              setSubModelMesh(idx, subMesh) {
                if (!this._subModels[idx]) {
                  return;
                }

                this._subModels[idx].subMesh = subMesh;
              }

              setSubModelMaterial(idx, mat) {
                if (!this._subModels[idx]) {
                  return;
                }

                this._subModels[idx].passes = mat.passes;

                this._updateAttributesAndBinding(idx);
              }

              onGlobalPipelineStateChanged() {
                const subModels = this._subModels;

                for (let i = 0; i < subModels.length; i++) {
                  subModels[i].onPipelineStateChanged();
                }
              }

              onMacroPatchesStateChanged() {
                const subModels = this._subModels;

                for (let i = 0; i < subModels.length; i++) {
                  subModels[i].onMacroPatchesStateChanged(this.getMacroPatches(i));
                }
              }

              updateLightingmap(texture, uvParam) {
                Vec4.toArray(this._localData, uvParam, UBOLocal.LIGHTINGMAP_UVPARAM);

                this._applyLocalData();

                this._lightmap = texture;
                this._lightmapUVParam = uvParam;

                if (texture === null) {
                  texture = builtinResMgr.get('empty-texture');
                }

                const gfxTexture = texture.getGFXTexture();

                if (gfxTexture) {
                  const sampler = samplerLib.getSampler(this._device, texture.mipmaps.length > 1 ? lightmapSamplerWithMipHash : lightmapSamplerHash);
                  const subModels = this._subModels;

                  for (let i = 0; i < subModels.length; i++) {
                    const {
                      descriptorSet
                    } = subModels[i];
                    descriptorSet.bindTexture(UNIFORM_LIGHTMAP_TEXTURE_BINDING, gfxTexture);
                    descriptorSet.bindSampler(UNIFORM_LIGHTMAP_TEXTURE_BINDING, sampler);
                    descriptorSet.update();
                  }
                }
              }

              getMacroPatches(subModelIndex) {
                return this.receiveShadow ? shadowMapPatches : null;
              }

              _updateAttributesAndBinding(subModelIndex) {
                const subModel = this._subModels[subModelIndex];

                if (!subModel) {
                  return;
                }

                this._initLocalDescriptors(subModelIndex);

                this._updateLocalDescriptors(subModelIndex, subModel.descriptorSet);

                const shader = subModel.passes[0].getShaderVariant(subModel.patches);

                this._updateInstancedAttributes(shader.attributes, subModel.passes[0]);
              }

              _getInstancedAttributeIndex(name) {
                const {
                  attributes
                } = this.instancedAttributes;

                for (let i = 0; i < attributes.length; i++) {
                  if (attributes[i].name === name) {
                    return i;
                  }
                }

                return -1;
              }

              _setInstMatWorldIdx(idx) {
                this._instMatWorldIdx = idx;

                {
                  this._nativeObj.setInstMatWorldIdx(idx);
                }
              }

              _updateInstancedAttributes(attributes, pass) {
                if (!pass.device.hasFeature(Feature.INSTANCED_ARRAYS)) {
                  return;
                }

                let size = 0;

                for (let j = 0; j < attributes.length; j++) {
                  const attribute = attributes[j];

                  if (!attribute.isInstanced) {
                    continue;
                  }

                  size += FormatInfos[attribute.format].size;
                }

                const attrs = this.instancedAttributes;
                attrs.buffer = new Uint8Array(size);
                attrs.views.length = attrs.attributes.length = 0;
                let offset = 0;

                for (let j = 0; j < attributes.length; j++) {
                  const attribute = attributes[j];

                  if (!attribute.isInstanced) {
                    continue;
                  }

                  const attr = new Attribute();
                  attr.format = attribute.format;
                  attr.name = attribute.name;
                  attr.isNormalized = attribute.isNormalized;
                  attr.location = attribute.location;
                  attrs.attributes.push(attr);
                  const info = FormatInfos[attribute.format];
                  const typeViewArray = new (getTypedArrayConstructor(info))(attrs.buffer.buffer, offset, info.count);
                  attrs.views.push(typeViewArray);
                  offset += info.size;
                }

                if (pass.batchingScheme === BatchingSchemes.INSTANCING) {
                  InstancedBuffer.get(pass).destroy();
                }

                this._setInstMatWorldIdx(this._getInstancedAttributeIndex(INST_MAT_WORLD));

                this._transformUpdated = true;

                {
                  this._nativeObj.setInstancedAttrBlock(attrs.buffer.buffer, attrs.views, attrs.attributes);
                }
              }

              _initLocalDescriptors(subModelIndex) {
                if (!this._localBuffer) {
                  this._localBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));

                  this._applyLocalBuffer();
                }
              }

              _updateLocalDescriptors(subModelIndex, descriptorSet) {
                if (this._localBuffer) descriptorSet.bindBuffer(UBOLocal.BINDING, this._localBuffer);
              }

            } exports('bQ', Model);

            let NodeSpace;

            (function (NodeSpace) {
              NodeSpace[NodeSpace["LOCAL"] = 0] = "LOCAL";
              NodeSpace[NodeSpace["WORLD"] = 1] = "WORLD";
            })(NodeSpace || (NodeSpace = {}));

            let TransformBit;

            (function (TransformBit) {
              TransformBit[TransformBit["NONE"] = 0] = "NONE";
              TransformBit[TransformBit["POSITION"] = 1] = "POSITION";
              TransformBit[TransformBit["ROTATION"] = 2] = "ROTATION";
              TransformBit[TransformBit["SCALE"] = 4] = "SCALE";
              TransformBit[TransformBit["RS"] = TransformBit.ROTATION | TransformBit.SCALE] = "RS";
              TransformBit[TransformBit["TRS"] = TransformBit.POSITION | TransformBit.ROTATION | TransformBit.SCALE] = "TRS";
              TransformBit[TransformBit["TRS_MASK"] = ~TransformBit.TRS] = "TRS_MASK";
            })(TransformBit || (TransformBit = exports('c2', {})));

            legacyCC.internal.TransformBit = TransformBit;

            class RenderScene {
              get root() {
                return this._root;
              }

              get name() {
                return this._name;
              }

              get cameras() {
                return this._cameras;
              }

              get mainLight() {
                return this._mainLight;
              }

              get sphereLights() {
                return this._sphereLights;
              }

              get spotLights() {
                return this._spotLights;
              }

              get models() {
                return this._models;
              }

              get native() {
                return this._nativeObj;
              }

              get batches() {
                return this._batches;
              }

              static registerCreateFunc(root) {
                root._createSceneFun = _root => new RenderScene(_root);
              }

              constructor(root) {
                this._root = void 0;
                this._name = '';
                this._cameras = [];
                this._models = [];
                this._batches = [];
                this._directionalLights = [];
                this._sphereLights = [];
                this._spotLights = [];
                this._mainLight = null;
                this._modelId = 0;
                this._root = root;

                this._createNativeObject();
              }

              initialize(info) {
                this._name = info.name;

                this._createNativeObject();

                return true;
              }

              update(stamp) {
                {
                  const nativeBatches = [];

                  for (let i = 0, len = this._batches.length; i < len; ++i) {
                    nativeBatches.push(this._batches[i].native);
                  }

                  this._nativeObj.updateBatches(nativeBatches);

                  this._nativeObj.update(stamp);

                  return;
                }
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this.removeCameras();
                this.removeSphereLights();
                this.removeSpotLights();
                this.removeModels();

                this._destroy();
              }

              addCamera(cam) {
                cam.attachToScene(this);

                this._cameras.push(cam);
              }

              removeCamera(camera) {
                for (let i = 0; i < this._cameras.length; ++i) {
                  if (this._cameras[i] === camera) {
                    this._cameras.splice(i, 1);

                    camera.detachFromScene();
                    return;
                  }
                }
              }

              removeCameras() {
                for (const camera of this._cameras) {
                  camera.detachFromScene();
                }

                this._cameras.splice(0);
              }

              setMainLight(dl) {
                this._mainLight = dl;

                {
                  this._nativeObj.setMainLight(dl ? dl.native : null);
                }
              }

              unsetMainLight(dl) {
                if (this._mainLight === dl) {
                  const dlList = this._directionalLights;

                  if (dlList.length) {
                    this.setMainLight(dlList[dlList.length - 1]);

                    if (this._mainLight.node) {
                      this._mainLight.node.hasChangedFlags |= TransformBit.ROTATION;
                    }

                    return;
                  }

                  this.setMainLight(null);
                }
              }

              addDirectionalLight(dl) {
                dl.attachToScene(this);

                this._directionalLights.push(dl);
              }

              removeDirectionalLight(dl) {
                for (let i = 0; i < this._directionalLights.length; ++i) {
                  if (this._directionalLights[i] === dl) {
                    dl.detachFromScene();

                    this._directionalLights.splice(i, 1);

                    return;
                  }
                }
              }

              addSphereLight(pl) {
                pl.attachToScene(this);

                this._sphereLights.push(pl);

                {
                  this._nativeObj.addSphereLight(pl.native);
                }
              }

              removeSphereLight(pl) {
                for (let i = 0; i < this._sphereLights.length; ++i) {
                  if (this._sphereLights[i] === pl) {
                    pl.detachFromScene();

                    this._sphereLights.splice(i, 1);

                    {
                      this._nativeObj.removeSphereLight(pl.native);
                    }

                    return;
                  }
                }
              }

              addSpotLight(sl) {
                sl.attachToScene(this);

                this._spotLights.push(sl);

                {
                  this._nativeObj.addSpotLight(sl.native);
                }
              }

              removeSpotLight(sl) {
                for (let i = 0; i < this._spotLights.length; ++i) {
                  if (this._spotLights[i] === sl) {
                    sl.detachFromScene();

                    this._spotLights.splice(i, 1);

                    {
                      this._nativeObj.removeSpotLight(sl.native);
                    }

                    return;
                  }
                }
              }

              removeSphereLights() {
                for (let i = 0; i < this._sphereLights.length; ++i) {
                  this._sphereLights[i].detachFromScene();
                }

                this._sphereLights.length = 0;

                {
                  this._nativeObj.removeSphereLights();
                }
              }

              removeSpotLights() {
                for (let i = 0; i < this._spotLights.length; ++i) {
                  this._spotLights[i].detachFromScene();
                }

                this._spotLights = [];

                {
                  this._nativeObj.removeSpotLights();
                }
              }

              addModel(m) {
                m.attachToScene(this);

                this._models.push(m);

                {
                  switch (m.type) {
                    case ModelType.SKINNING:
                      this._nativeObj.addSkinningModel(m.native);

                      break;

                    case ModelType.BAKED_SKINNING:
                      this._nativeObj.addBakedSkinningModel(m.native);

                      break;

                    case ModelType.DEFAULT:
                    default:
                      this._nativeObj.addModel(m.native);

                  }
                }
              }

              removeModel(model) {
                for (let i = 0; i < this._models.length; ++i) {
                  if (this._models[i] === model) {
                    model.detachFromScene();

                    this._models.splice(i, 1);

                    {
                      this._nativeObj.removeModel(i);
                    }

                    return;
                  }
                }
              }

              removeModels() {
                for (const m of this._models) {
                  m.detachFromScene();
                  m.destroy();
                }

                this._models.length = 0;

                {
                  this._nativeObj.removeModels();
                }
              }

              addBatch(batch) {
                this._batches.push(batch);
              }

              removeBatch(batch) {
                for (let i = 0; i < this._batches.length; ++i) {
                  if (this._batches[i] === batch) {
                    this._batches.splice(i, 1);

                    {
                      this._nativeObj.removeBatch(i);
                    }

                    return;
                  }
                }
              }

              removeBatches() {
                this._batches.length = 0;

                {
                  this._nativeObj.removeBatches();
                }
              }

              onGlobalPipelineStateChanged() {
                for (const m of this._models) {
                  m.onGlobalPipelineStateChanged();
                }
              }

              generateModelId() {
                return this._modelId++;
              }

              _createNativeObject() {
                {
                  this._nativeObj = new NativeRenderScene();
                }
              }

            }

            removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
              name: 'raycastUI2DNode'
            }, {
              name: 'raycastUINode'
            }]);
            removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
              name: 'raycastAll',
              suggest: 'using intersect.rayModel in geometry'
            }, {
              name: 'raycastAllModels',
              suggest: 'using intersect.rayModel in geometry'
            }, {
              name: 'raycastSingleModel',
              suggest: 'using intersect.rayModel in geometry'
            }, {
              name: 'raycastAllCanvas',
              suggest: 'using intersect.rayAABB in geometry'
            }, {
              name: 'rayResultCanvas'
            }, {
              name: 'rayResultModels'
            }, {
              name: 'rayResultAll'
            }, {
              name: 'rayResultSingleModel'
            }]);
            const CameraVisFlags = {};
            removeProperty(CameraVisFlags, 'CameraVisFlags', [{
              name: 'GENERAL'
            }]);
            replaceProperty(CameraVisFlags, 'CameraVisFlags', [{
              name: 'PROFILER',
              newName: 'PROFILER',
              target: Layers.BitMask,
              targetName: 'PROFILER'
            }, {
              name: 'GIZMOS',
              newName: 'GIZMOS',
              target: Layers.BitMask,
              targetName: 'GIZMOS'
            }, {
              name: 'EDITOR',
              newName: 'EDITOR',
              target: Layers.BitMask,
              targetName: 'EDITOR'
            }, {
              name: 'UI',
              newName: 'UI',
              target: Layers.BitMask,
              targetName: 'UI_3D'
            }, {
              name: 'UI2D',
              newName: 'UI2D',
              target: Layers.BitMask,
              targetName: 'UI_2D'
            }]);
            legacyCC.CameraVisFlags = CameraVisFlags;
            const VisibilityFlags = {};
            removeProperty(VisibilityFlags, 'VisibilityFlags', [{
              name: 'GENERAL'
            }]);
            replaceProperty(VisibilityFlags, 'VisibilityFlags', [{
              name: 'ALWALS',
              newName: 'ALWALS',
              target: Layers.Enum,
              targetName: 'ALWALS'
            }, {
              name: 'PROFILER',
              newName: 'PROFILER',
              target: Layers.Enum,
              targetName: 'PROFILER'
            }, {
              name: 'GIZMOS',
              newName: 'GIZMOS',
              target: Layers.Enum,
              targetName: 'GIZMOS'
            }, {
              name: 'EDITOR',
              newName: 'EDITOR',
              target: Layers.Enum,
              targetName: 'EDITOR'
            }, {
              name: 'UI',
              newName: 'UI',
              target: Layers.Enum,
              targetName: 'UI_3D'
            }, {
              name: 'UI2D',
              newName: 'UI2D',
              target: Layers.Enum,
              targetName: 'UI_2D'
            }]);
            legacyCC.VisibilityFlags = VisibilityFlags;
            replaceProperty(Pass.prototype, 'Pass.prototype', [{
              name: 'getBindingTypeFromHandle',
              newName: 'getDescriptorTypeFromHandle'
            }]);
            removeProperty(Camera.prototype, 'Camera.prototype', [{
              name: 'getSplitFrustum'
            }]);

            function ColorTemperatureToRGB(rgb, kelvin) {
              if (kelvin < 1000.0) {
                kelvin = 1000.0;
              } else if (kelvin > 15000.0) {
                kelvin = 15000.0;
              }

              const kSqr = kelvin * kelvin;
              const u = (0.860117757 + 1.54118254e-4 * kelvin + 1.28641212e-7 * kSqr) / (1.0 + 8.42420235e-4 * kelvin + 7.08145163e-7 * kSqr);
              const v = (0.317398726 + 4.22806245e-5 * kelvin + 4.20481691e-8 * kSqr) / (1.0 - 2.89741816e-5 * kelvin + 1.61456053e-7 * kSqr);
              const d = 2.0 * u - 8.0 * v + 4.0;
              const x = 3.0 * u / d;
              const y = 2.0 * v / d;
              const z = 1.0 - x - y;
              const X = 1.0 / y * x;
              const Z = 1.0 / y * z;
              rgb.x = 3.2404542 * X + -1.5371385 + -0.4985314 * Z;
              rgb.y = -0.9692660 * X + 1.8760108 + 0.0415560 * Z;
              rgb.z = 0.0556434 * X + -0.2040259 + 1.0572252 * Z;
            }
            let LightType;

            (function (LightType) {
              LightType[LightType["DIRECTIONAL"] = 0] = "DIRECTIONAL";
              LightType[LightType["SPHERE"] = 1] = "SPHERE";
              LightType[LightType["SPOT"] = 2] = "SPOT";
              LightType[LightType["UNKNOWN"] = 3] = "UNKNOWN";
            })(LightType || (LightType = exports('c9', {})));

            const nt2lm = exports('ch', size => 4 * Math.PI * Math.PI * size * size);
            class Light {
              constructor() {
                this._baked = false;
                this._color = new Vec3(1, 1, 1);
                this._colorTemp = 6550.0;
                this._colorTempRGB = new Vec3(1, 1, 1);
                this._scene = null;
                this._node = null;
                this._name = null;
                this._useColorTemperature = false;
                this._type = LightType.UNKNOWN;
              }

              _init() {
                {
                  switch (this._type) {
                    case LightType.DIRECTIONAL:
                      this._nativeObj = new NativeDirectionalLight();
                      break;

                    case LightType.SPHERE:
                      this._nativeObj = new NativeSphereLight();
                      break;

                    case LightType.SPOT:
                      this._nativeObj = new NativeSpotLight();
                      break;
                  }

                  this._nativeObj.setType(this._type);
                }
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              get baked() {
                return this._baked;
              }

              set baked(val) {
                this._baked = val;
              }

              set color(color) {
                this._color.set(color);

                {
                  this._nativeObj.setColor(color);
                }
              }

              get color() {
                return this._color;
              }

              set useColorTemperature(enable) {
                this._useColorTemperature = enable;

                {
                  this._nativeObj.setUseColorTemperature(enable);
                }
              }

              get useColorTemperature() {
                return this._useColorTemperature;
              }

              set colorTemperature(val) {
                this._colorTemp = val;
                ColorTemperatureToRGB(this._colorTempRGB, this._colorTemp);

                {
                  this._nativeObj.setColorTemperatureRGB(this._colorTempRGB);
                }
              }

              get colorTemperature() {
                return this._colorTemp;
              }

              get colorTemperatureRGB() {
                return this._colorTempRGB;
              }

              set node(n) {
                this._node = n;

                if (this._node) {
                  this._node.hasChangedFlags |= TransformBit.ROTATION;

                  {
                    this._nativeObj.setNode(n ? n.native : null);
                  }
                }
              }

              get node() {
                return this._node;
              }

              get type() {
                return this._type;
              }

              get name() {
                return this._name;
              }

              set name(n) {
                this._name = n;
              }

              get scene() {
                return this._scene;
              }

              get native() {
                return this._nativeObj;
              }

              initialize() {
                this._init();

                this.color = new Vec3(1, 1, 1);
                this.colorTemperature = 6550.0;
              }

              attachToScene(scene) {
                this._scene = scene;
              }

              detachFromScene() {
                this._scene = null;
              }

              destroy() {
                this._name = null;
                this._node = null;

                this._destroy();
              }

              update() {}

            } exports('cd', Light);

            const _forward = new Vec3(0, 0, -1);

            const _v3 = new Vec3();

            class DirectionalLight extends Light {
              set direction(dir) {
                Vec3.normalize(this._dir, dir);

                {
                  this._nativeObj.setDirection(dir);
                }
              }

              get direction() {
                return this._dir;
              }

              set illuminance(illum) {
                this._illuminance = illum;

                {
                  this._nativeObj.setIlluminance(illum);
                }
              }

              get illuminance() {
                return this._illuminance;
              }

              constructor() {
                super();
                this._dir = new Vec3(1.0, -1.0, -1.0);
                this._illuminance = Ambient.SUN_ILLUM;
                this._type = LightType.DIRECTIONAL;
              }

              initialize() {
                super.initialize();
                this.illuminance = Ambient.SUN_ILLUM;
                this.direction = new Vec3(1.0, -1.0, -1.0);
              }

              update() {
                if (this._node && this._node.hasChangedFlags) {
                  this.direction = Vec3.transformQuat(_v3, _forward, this._node.worldRotation);
                }
              }

            } exports('cg', DirectionalLight);

            var _dec$g, _class$g, _class2$d, _descriptor$b, _descriptor2$7, _descriptor3$5, _descriptor4$4, _class3$7, _temp$d;
            let EffectAsset = exports('ek', (_dec$g = ccclass('cc.EffectAsset'), _dec$g(_class$g = (_class2$d = (_temp$d = _class3$7 = class EffectAsset extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "techniques", _descriptor$b, this);

                _initializerDefineProperty(this, "shaders", _descriptor2$7, this);

                _initializerDefineProperty(this, "combinations", _descriptor3$5, this);

                _initializerDefineProperty(this, "hideInEditor", _descriptor4$4, this);
              }

              static register(asset) {
                EffectAsset._effects[asset.name] = asset;
              }

              static remove(asset) {
                if (typeof asset !== 'string') {
                  if (EffectAsset._effects[asset.name] && EffectAsset._effects[asset.name].equals(asset)) {
                    delete EffectAsset._effects[asset.name];
                  }
                } else {
                  if (EffectAsset._effects[asset]) {
                    delete EffectAsset._effects[asset];
                    return;
                  }

                  for (const n in EffectAsset._effects) {
                    if (EffectAsset._effects[n]._uuid === asset) {
                      delete EffectAsset._effects[n];
                      return;
                    }
                  }
                }
              }

              static get(name) {
                if (EffectAsset._effects[name]) {
                  return EffectAsset._effects[name];
                }

                for (const n in EffectAsset._effects) {
                  if (EffectAsset._effects[n]._uuid === name) {
                    return EffectAsset._effects[n];
                  }
                }

                return null;
              }

              static getAll() {
                return EffectAsset._effects;
              }

              onLoaded() {
                programLib.register(this);
                EffectAsset.register(this);

                {
                  legacyCC.game.once(legacyCC.Game.EVENT_ENGINE_INITED, this._precompile, this);
                }
              }

              _precompile() {
                const root = legacyCC.director.root;

                for (let i = 0; i < this.shaders.length; i++) {
                  const shader = this.shaders[i];
                  const combination = this.combinations[i];

                  if (!combination) {
                    continue;
                  }

                  const defines = Object.keys(combination).reduce((out, name) => out.reduce((acc, cur) => {
                    const choices = combination[name];

                    for (let i = 0; i < choices.length; ++i) {
                      const defines = { ...cur
                      };
                      defines[name] = choices[i];
                      acc.push(defines);
                    }

                    return acc;
                  }, []), [{}]);
                  defines.forEach(defines => programLib.getGFXShader(root.device, shader.name, defines, root.pipeline));
                }
              }

              destroy() {
                EffectAsset.remove(this);
                return super.destroy();
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                const effect = EffectAsset.get('unlit');
                this.name = 'unlit';
                this.shaders = effect.shaders;
                this.combinations = effect.combinations;
                this.techniques = effect.techniques;
              }

              validate() {
                return this.techniques.length > 0 && this.shaders.length > 0;
              }

            }, _class3$7._effects = {}, _temp$d), (_descriptor$b = _applyDecoratedDescriptor(_class2$d.prototype, "techniques", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2$7 = _applyDecoratedDescriptor(_class2$d.prototype, "shaders", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor3$5 = _applyDecoratedDescriptor(_class2$d.prototype, "combinations", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor4$4 = _applyDecoratedDescriptor(_class2$d.prototype, "hideInEditor", [serializable, editorOnly], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            })), _class2$d)) || _class$g));
            legacyCC.EffectAsset = EffectAsset;

            var _dec$h, _dec2$6, _class$h, _class2$e, _descriptor$c, _descriptor2$8, _descriptor3$6, _descriptor4$5, _descriptor5$3, _temp$e;
            let Material = exports('cB', (_dec$h = ccclass('cc.Material'), _dec2$6 = type(EffectAsset), _dec$h(_class$h = (_class2$e = (_temp$e = class Material extends Asset {
              static getHash(material) {
                let hash = 0;

                for (const pass of material.passes) {
                  hash ^= pass.hash;
                }

                return hash;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_effectAsset", _descriptor$c, this);

                _initializerDefineProperty(this, "_techIdx", _descriptor2$8, this);

                _initializerDefineProperty(this, "_defines", _descriptor3$6, this);

                _initializerDefineProperty(this, "_states", _descriptor4$5, this);

                _initializerDefineProperty(this, "_props", _descriptor5$3, this);

                this._passes = [];
                this._hash = 0;
              }

              get effectAsset() {
                return this._effectAsset;
              }

              get effectName() {
                return this._effectAsset ? this._effectAsset.name : '';
              }

              get technique() {
                return this._techIdx;
              }

              get passes() {
                return this._passes;
              }

              get hash() {
                return this._hash;
              }

              get parent() {
                return null;
              }

              get owner() {
                return null;
              }

              initialize(info) {
                if (this._passes.length) {
                  warnID(12005);
                  return;
                }

                if (!this._defines) {
                  this._defines = [];
                }

                if (!this._states) {
                  this._states = [];
                }

                if (!this._props) {
                  this._props = [];
                }

                if (info.technique !== undefined) {
                  this._techIdx = info.technique;
                }

                if (info.effectAsset) {
                  this._effectAsset = info.effectAsset;
                } else if (info.effectName) {
                  this._effectAsset = EffectAsset.get(info.effectName);
                }

                if (info.defines) {
                  this._prepareInfo(info.defines, this._defines);
                }

                if (info.states) {
                  this._prepareInfo(info.states, this._states);
                }

                this._update();
              }

              reset(info) {
                this.initialize(info);
              }

              destroy() {
                this._doDestroy();

                return super.destroy();
              }

              recompileShaders(overrides, passIdx) {
                console.warn(`Shaders in material asset '${this.name}' cannot be modified at runtime, please instantiate the material first.`);
              }

              overridePipelineStates(overrides, passIdx) {
                console.warn(`Pipeline states in material asset '${this.name}' cannot be modified at runtime, please instantiate the material first.`);
              }

              onLoaded() {
                this._update();
              }

              resetUniforms(clearPasses = true) {
                this._props.length = this._passes.length;

                for (let i = 0; i < this._props.length; i++) {
                  this._props[i] = {};
                }

                if (!clearPasses) {
                  return;
                }

                for (const pass of this._passes) {
                  pass.resetUBOs();
                  pass.resetTextures();
                }
              }

              setProperty(name, val, passIdx) {
                let success = false;

                if (passIdx === undefined) {
                  const passes = this._passes;
                  const len = passes.length;

                  for (let i = 0; i < len; i++) {
                    const pass = passes[i];

                    if (this._uploadProperty(pass, name, val)) {
                      this._props[pass.propertyIndex][name] = val;
                      success = true;
                    }
                  }
                } else {
                  if (passIdx >= this._passes.length) {
                    console.warn(`illegal pass index: ${passIdx}.`);
                    return;
                  }

                  const pass = this._passes[passIdx];

                  if (this._uploadProperty(pass, name, val)) {
                    this._props[pass.propertyIndex][name] = val;
                    success = true;
                  }
                }

                if (!success) {
                  console.warn(`illegal property name: ${name}.`);
                }
              }

              getProperty(name, passIdx) {
                if (passIdx === undefined) {
                  const propsArray = this._props;
                  const len = propsArray.length;

                  for (let i = 0; i < len; i++) {
                    const props = propsArray[i];

                    if (name in props) {
                      return props[name];
                    }
                  }
                } else {
                  if (passIdx >= this._props.length) {
                    console.warn(`illegal pass index: ${passIdx}.`);
                    return null;
                  }

                  const props = this._props[this._passes[passIdx].propertyIndex];

                  if (name in props) {
                    return props[name];
                  }
                }

                return null;
              }

              copy(mat) {
                this._techIdx = mat._techIdx;
                this._props.length = mat._props.length;

                for (let i = 0; i < mat._props.length; i++) {
                  this._props[i] = { ...mat._props[i]
                  };
                }

                this._defines.length = mat._defines.length;

                for (let i = 0; i < mat._defines.length; i++) {
                  this._defines[i] = { ...mat._defines[i]
                  };
                }

                this._states.length = mat._states.length;

                for (let i = 0; i < mat._states.length; i++) {
                  this._states[i] = { ...mat._states[i]
                  };
                }

                this._effectAsset = mat._effectAsset;

                this._update();
              }

              _prepareInfo(patch, cur) {
                let patchArray = patch;

                if (!Array.isArray(patchArray)) {
                  const len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
                  patchArray = Array(len).fill(patchArray);
                }

                for (let i = 0; i < patchArray.length; ++i) {
                  Object.assign(cur[i] || (cur[i] = {}), patchArray[i]);
                }
              }

              _createPasses() {
                const tech = this._effectAsset.techniques[this._techIdx || 0];

                if (!tech) {
                  return [];
                }

                const passNum = tech.passes.length;
                const passes = [];

                for (let k = 0; k < passNum; ++k) {
                  const passInfo = tech.passes[k];
                  const propIdx = passInfo.passIndex = k;
                  const defines = passInfo.defines = this._defines[propIdx] || (this._defines[propIdx] = {});
                  const states = passInfo.stateOverrides = this._states[propIdx] || (this._states[propIdx] = {});

                  if (passInfo.propertyIndex !== undefined) {
                    Object.assign(defines, this._defines[passInfo.propertyIndex]);
                    Object.assign(states, this._states[passInfo.propertyIndex]);
                  }

                  if (passInfo.embeddedMacros !== undefined) {
                    Object.assign(defines, passInfo.embeddedMacros);
                  }

                  if (passInfo.switch && !defines[passInfo.switch]) {
                    continue;
                  }

                  const pass = new Pass(legacyCC.director.root);
                  pass.initialize(passInfo);
                  passes.push(pass);
                }

                return passes;
              }

              _update(keepProps = true) {
                if (this._effectAsset) {
                  this._passes = this._createPasses();
                  const totalPasses = this._effectAsset.techniques[this._techIdx].passes.length;
                  this._props.length = totalPasses;

                  if (keepProps) {
                    this._passes.forEach((pass, i) => {
                      let props = this._props[i];

                      if (!props) {
                        props = this._props[i] = {};
                      }

                      if (pass.propertyIndex !== undefined) {
                        Object.assign(props, this._props[pass.propertyIndex]);
                      }

                      for (const p in props) {
                        this._uploadProperty(pass, p, props[p]);
                      }
                    });
                  } else {
                    for (let i = 0; i < this._props.length; i++) {
                      this._props[i] = {};
                    }
                  }
                }

                this._hash = Material.getHash(this);
              }

              _uploadProperty(pass, name, val) {
                const handle = pass.getHandle(name);

                if (!handle) {
                  return false;
                }

                const propertyType = Pass.getPropertyTypeFromHandle(handle);

                if (propertyType === PropertyType.BUFFER) {
                  if (Array.isArray(val)) {
                    pass.setUniformArray(handle, val);
                  } else if (val !== null) {
                    pass.setUniform(handle, val);
                  } else {
                    pass.resetUniform(name);
                  }
                } else if (propertyType === PropertyType.TEXTURE) {
                  if (Array.isArray(val)) {
                    for (let i = 0; i < val.length; i++) {
                      this._bindTexture(pass, handle, val[i], i);
                    }
                  } else if (val) {
                    this._bindTexture(pass, handle, val);
                  } else {
                    pass.resetTexture(name);
                  }
                }

                return true;
              }

              _bindTexture(pass, handle, val, index) {
                const binding = Pass.getBindingFromHandle(handle);

                if (val instanceof Texture) {
                  pass.bindTexture(binding, val, index);
                } else if (val instanceof TextureBase) {
                  const texture = val.getGFXTexture();

                  if (!texture || !texture.width || !texture.height) {
                    return;
                  }

                  pass.bindTexture(binding, texture, index);
                  pass.bindSampler(binding, val.getGFXSampler(), index);
                }
              }

              _doDestroy() {
                if (this._passes && this._passes.length) {
                  for (const pass of this._passes) {
                    pass.destroy();
                  }
                }

                this._passes.length = 0;
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                this.initialize({
                  effectName: 'unlit',
                  defines: {
                    USE_COLOR: true
                  }
                });
                this.setProperty('mainColor', new Color('#ff00ff'));
              }

              validate() {
                return !!this._effectAsset && !this._effectAsset.isDefault && this.passes.length > 0;
              }

            }, _temp$e), (_descriptor$c = _applyDecoratedDescriptor(_class2$e.prototype, "_effectAsset", [_dec2$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$8 = _applyDecoratedDescriptor(_class2$e.prototype, "_techIdx", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor3$6 = _applyDecoratedDescriptor(_class2$e.prototype, "_defines", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor4$5 = _applyDecoratedDescriptor(_class2$e.prototype, "_states", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor5$3 = _applyDecoratedDescriptor(_class2$e.prototype, "_props", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$e)) || _class$h));
            legacyCC.Material = Material;

            const ShadowSize = Enum({
              Low_256x256: 256,
              Medium_512x512: 512,
              High_1024x1024: 1024,
              Ultra_2048x2048: 2048
            });
            const ShadowType = Enum({
              Planar: 0,
              ShadowMap: 1
            });
            const PCFType = Enum({
              HARD: 0,
              SOFT: 1,
              SOFT_2X: 2
            });
            const SHADOW_TYPE_NONE = ShadowType.ShadowMap + 1;
            class Shadows {
              get enabled() {
                return this._enabled;
              }

              set enabled(val) {
                this._setEnable(val);

                this.activate();
              }

              get normal() {
                return this._normal;
              }

              set normal(val) {
                Vec3.copy(this._normal, val);

                {
                  this._nativeObj.normal = this._normal;
                }
              }

              get distance() {
                return this._distance;
              }

              set distance(val) {
                this._distance = val;

                {
                  this._nativeObj.distance = val;
                }
              }

              get shadowColor() {
                return this._shadowColor;
              }

              set shadowColor(color) {
                this._shadowColor = color;

                {
                  this._nativeObj.color = color;
                }
              }

              get type() {
                return this._type;
              }

              set type(val) {
                this._setType(val);

                this.activate();
              }

              get near() {
                return this._near;
              }

              set near(val) {
                this._near = val;

                {
                  this._nativeObj.nearValue = val;
                }
              }

              get far() {
                return this._far;
              }

              set far(val) {
                this._far = val;

                {
                  this._nativeObj.farValue = val;
                }
              }

              get orthoSize() {
                return this._orthoSize;
              }

              set orthoSize(val) {
                this._orthoSize = val;

                {
                  this._nativeObj.orthoSize = val;
                }
              }

              get size() {
                return this._size;
              }

              set size(val) {
                this._size.set(val);

                {
                  this._nativeObj.size = val;
                }
              }

              get pcf() {
                return this._pcf;
              }

              set pcf(val) {
                this._pcf = val;

                {
                  this._nativeObj.pcfType = val;
                }
              }

              get shadowMapDirty() {
                return this._shadowMapDirty;
              }

              set shadowMapDirty(val) {
                this._shadowMapDirty = val;

                {
                  this._nativeObj.shadowMapDirty = val;
                }
              }

              get bias() {
                return this._bias;
              }

              set bias(val) {
                this._bias = val;

                {
                  this._nativeObj.bias = val;
                }
              }

              get normalBias() {
                return this._normalBias;
              }

              set normalBias(val) {
                this._normalBias = val;

                {
                  this._nativeObj.normalBias = val;
                }
              }

              get saturation() {
                return this._saturation;
              }

              set saturation(val) {
                this._saturation = val;

                {
                  this._nativeObj.saturation = val;
                }
              }

              get autoAdapt() {
                return this._autoAdapt;
              }

              set autoAdapt(val) {
                this._autoAdapt = val;

                {
                  this._nativeObj.autoAdapt = val;
                }
              }

              get matLight() {
                return this._matLight;
              }

              get material() {
                return this._material;
              }

              get instancingMaterial() {
                return this._instancingMaterial;
              }

              get native() {
                return this._nativeObj;
              }

              constructor() {
                this.sphere = new Sphere(0.0, 0.0, 0.0, 0.01);
                this.maxReceived = 4;
                this._normal = new Vec3(0, 1, 0);
                this._shadowColor = new Color(0, 0, 0, 76);
                this._matLight = new Mat4();
                this._material = null;
                this._instancingMaterial = null;
                this._size = new Vec2(512, 512);
                this._enabled = false;
                this._distance = 0;
                this._type = SHADOW_TYPE_NONE;
                this._near = 0;
                this._far = 0;
                this._orthoSize = 1;
                this._pcf = 0;
                this._shadowMapDirty = false;
                this._bias = 0;
                this._normalBias = 0;
                this._autoAdapt = true;
                this._saturation = 0.75;

                {
                  this._nativeObj = new NativeShadow();
                }
              }

              getPlanarShader(patches) {
                if (!this._material) {
                  this._material = new Material();

                  this._material.initialize({
                    effectName: 'planar-shadow'
                  });

                  {
                    this._nativeObj.planarPass = this._material.passes[0].native;
                  }
                }

                return this._material.passes[0].getShaderVariant(patches);
              }

              getPlanarInstanceShader(patches) {
                if (!this._instancingMaterial) {
                  this._instancingMaterial = new Material();

                  this._instancingMaterial.initialize({
                    effectName: 'planar-shadow',
                    defines: {
                      USE_INSTANCING: true
                    }
                  });

                  {
                    this._nativeObj.instancePass = this._instancingMaterial.passes[0].native;
                  }
                }

                return this._instancingMaterial.passes[0].getShaderVariant(patches);
              }

              _setEnable(val) {
                this._enabled = val;

                {
                  this._nativeObj.enabled = val;
                  if (!val) this._setType(SHADOW_TYPE_NONE);
                }
              }

              _setType(val) {
                this._type = this.enabled ? val : SHADOW_TYPE_NONE;

                {
                  this._nativeObj.shadowType = this._type;
                }
              }

              initialize(shadowsInfo) {
                this.near = shadowsInfo.near;
                this.far = shadowsInfo.far;
                this.orthoSize = shadowsInfo.orthoSize;
                this.size = shadowsInfo.size;
                this.pcf = shadowsInfo.pcf;
                this.normal = shadowsInfo.normal;
                this.distance = shadowsInfo.distance;
                this.shadowColor = shadowsInfo.shadowColor;
                this.bias = shadowsInfo.bias;
                this.normalBias = shadowsInfo.normalBias;
                this.maxReceived = shadowsInfo.maxReceived;
                this.autoAdapt = shadowsInfo.autoAdapt;

                this._setEnable(shadowsInfo.enabled);

                this._setType(shadowsInfo.type);

                this.saturation = shadowsInfo.saturation;
              }

              activate() {
                if (this.enabled) {
                  if (this.type === ShadowType.ShadowMap) {
                    this._updatePipeline();
                  } else {
                    this._updatePlanarInfo();
                  }
                } else {
                  const root = legacyCC.director.root;
                  const pipeline = root.pipeline;
                  pipeline.macros.CC_RECEIVE_SHADOW = 0;
                  root.onGlobalPipelineStateChanged();
                }
              }

              _updatePlanarInfo() {
                if (!this._material) {
                  this._material = new Material();

                  this._material.initialize({
                    effectName: 'planar-shadow'
                  });

                  {
                    this._nativeObj.planarPass = this._material.passes[0].native;
                  }
                }

                if (!this._instancingMaterial) {
                  this._instancingMaterial = new Material();

                  this._instancingMaterial.initialize({
                    effectName: 'planar-shadow',
                    defines: {
                      USE_INSTANCING: true
                    }
                  });

                  {
                    this._nativeObj.instancePass = this._instancingMaterial.passes[0].native;
                  }
                }

                const root = legacyCC.director.root;
                const pipeline = root.pipeline;
                pipeline.macros.CC_RECEIVE_SHADOW = 0;
                root.onGlobalPipelineStateChanged();
              }

              _updatePipeline() {
                const root = legacyCC.director.root;
                const pipeline = root.pipeline;
                pipeline.macros.CC_RECEIVE_SHADOW = 1;
                root.onGlobalPipelineStateChanged();
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this._destroy();

                if (this._material) {
                  this._material.destroy();
                }

                if (this._instancingMaterial) {
                  this._instancingMaterial.destroy();
                }

                this.sphere.destroy();
              }

            }
            Shadows.MAX_FAR = 2000.0;
            Shadows.COEFFICIENT_OF_EXPANSION = 2.0 * Math.sqrt(3.0);
            legacyCC.Shadows = Shadows;

            class PassInstance extends Pass {
              get parent() {
                return this._parent;
              }

              constructor(parent, owner) {
                super(parent.root);
                this._parent = void 0;
                this._owner = void 0;
                this._dontNotify = false;
                this._parent = parent;
                this._owner = owner;

                this._doInit(this._parent, true);

                for (let i = 0; i < this._shaderInfo.blocks.length; i++) {
                  const u = this._shaderInfo.blocks[i];
                  const block = this._blocks[u.binding];
                  const parentBlock = this._parent.blocks[u.binding];
                  block.set(parentBlock);
                }

                this._setRootBufferDirty(true);

                const paren = this._parent;

                for (let i = 0; i < this._shaderInfo.samplerTextures.length; i++) {
                  const u = this._shaderInfo.samplerTextures[i];

                  for (let j = 0; j < u.count; j++) {
                    const sampler = paren._descriptorSet.getSampler(u.binding, j);

                    const texture = paren._descriptorSet.getTexture(u.binding, j);

                    this._descriptorSet.bindSampler(u.binding, sampler, j);

                    this._descriptorSet.bindTexture(u.binding, texture, j);
                  }
                }

                super.tryCompile();
              }

              overridePipelineStates(original, overrides) {
                this._bs.reset();

                this._rs.reset();

                this._dss.reset();

                Pass.fillPipelineInfo(this, original);
                Pass.fillPipelineInfo(this, overrides);

                this._onStateChange();
              }

              tryCompile(defineOverrides) {
                if (defineOverrides) {
                  if (!overrideMacros(this._defines, defineOverrides)) {
                    return false;
                  }
                }

                const res = super.tryCompile();

                this._onStateChange();

                return res;
              }

              beginChangeStatesSilently() {
                this._dontNotify = true;
              }

              endChangeStatesSilently() {
                this._dontNotify = false;
              }

              _syncBatchingScheme() {
                this._defines.USE_BATCHING = this._defines.USE_INSTANCING = false;

                this._setBatchingScheme(BatchingSchemes.NONE);
              }

              _onStateChange() {
                this._setHash(Pass.getPassHash(this));

                this._owner.onPassStateChange(this._dontNotify);
              }

            }

            class MaterialInstance extends Material {
              get parent() {
                return this._parent;
              }

              get owner() {
                return this._owner;
              }

              constructor(info) {
                super();
                this._passes = [];
                this._parent = void 0;
                this._owner = void 0;
                this._subModelIdx = 0;
                this._parent = info.parent;
                this._owner = info.owner || null;
                this._subModelIdx = info.subModelIdx || 0;
                this.copy(this._parent);
              }

              recompileShaders(overrides, passIdx) {
                if (!this._passes || !this.effectAsset) {
                  return;
                }

                if (passIdx === undefined) {
                  for (const pass of this._passes) {
                    pass.tryCompile(overrides);
                  }
                } else {
                  this._passes[passIdx].tryCompile(overrides);
                }
              }

              overridePipelineStates(overrides, passIdx) {
                if (!this._passes || !this.effectAsset) {
                  return;
                }

                const passInfos = this.effectAsset.techniques[this.technique].passes;

                if (passIdx === undefined) {
                  for (let i = 0; i < this._passes.length; i++) {
                    const pass = this._passes[i];
                    const state = this._states[i] || (this._states[i] = {});

                    for (const key in overrides) {
                      state[key] = overrides[key];
                    }

                    pass.overridePipelineStates(passInfos[pass.passIndex], state);
                  }
                } else {
                  const state = this._states[passIdx] || (this._states[passIdx] = {});

                  for (const key in overrides) {
                    state[key] = overrides[key];
                  }

                  this._passes[passIdx].overridePipelineStates(passInfos[passIdx], state);
                }
              }

              destroy() {
                this._doDestroy();

                return true;
              }

              onPassStateChange(dontNotify) {
                this._hash = Material.getHash(this);

                if (!dontNotify && this._owner) {
                  this._owner._onRebuildPSO(this._subModelIdx, this);
                }
              }

              _createPasses() {
                const passes = [];
                const parentPasses = this._parent.passes;

                if (!parentPasses) {
                  return passes;
                }

                for (let k = 0; k < parentPasses.length; ++k) {
                  passes.push(new PassInstance(parentPasses[k], this));
                }

                return passes;
              }

            } exports('d2', MaterialInstance);

            let skybox_mesh = null;
            let skybox_material = null;
            class Skybox {
              get model() {
                return this._model;
              }

              get enabled() {
                return this._enabled;
              }

              set enabled(val) {
                this._setEnabled(val);

                if (val) this.activate();else this._updatePipeline();
              }

              get useIBL() {
                return this._useIBL;
              }

              set useIBL(val) {
                this._setUseIBL(val);

                this._updatePipeline();
              }

              get isRGBE() {
                return this._isRGBE;
              }

              set isRGBE(val) {
                if (val) {
                  if (skybox_material) {
                    skybox_material.recompileShaders({
                      USE_RGBE_CUBEMAP: val
                    });
                  }

                  if (this._model) {
                    this._model.setSubModelMaterial(0, skybox_material);
                  }
                }

                this._setIsRGBE(val);

                this._updatePipeline();
              }

              get envmap() {
                return this._envmap;
              }

              set envmap(val) {
                this._envmap = val || this._default;

                if (this._envmap) {
                  legacyCC.director.root.pipeline.pipelineSceneData.ambient.albedoArray[3] = this._envmap.mipmapLevel;

                  this._updateGlobalBinding();
                }
              }

              get native() {
                return this._nativeObj;
              }

              constructor() {
                this._envmap = null;
                this._globalDSManager = null;
                this._model = null;
                this._default = null;
                this._enabled = false;
                this._useIBL = false;
                this._isRGBE = false;

                {
                  this._nativeObj = new NaitveSkybox();
                }
              }

              _setEnabled(val) {
                this._enabled = val;

                {
                  this._nativeObj.enabled = val;
                }
              }

              _setUseIBL(val) {
                this._useIBL = val;

                {
                  this._nativeObj.useIBL = val;
                }
              }

              _setIsRGBE(val) {
                this._isRGBE = val;

                {
                  this._nativeObj.isRGBE = val;
                }
              }

              initialize(skyboxInfo) {
                this._setEnabled(skyboxInfo.enabled);

                this._setUseIBL(skyboxInfo.useIBL);

                this._setIsRGBE(skyboxInfo.isRGBE);

                this._envmap = skyboxInfo.envmap;
              }

              activate() {
                const pipeline = legacyCC.director.root.pipeline;
                const ambient = pipeline.pipelineSceneData.ambient;
                this._globalDSManager = pipeline.globalDSManager;
                this._default = builtinResMgr.get('default-cube-texture');

                if (!this._model) {
                  this._model = legacyCC.director.root.createModel(legacyCC.renderer.scene.Model);

                  this._model._initLocalDescriptors = () => {};

                  {
                    this._nativeObj.model = this._model.native;
                  }
                }

                if (!this._envmap) {
                  this._envmap = this._default;
                }

                ambient.albedoArray[3] = this._envmap.mipmapLevel;

                if (!skybox_material) {
                  const mat = new Material();
                  mat.initialize({
                    effectName: 'skybox',
                    defines: {
                      USE_RGBE_CUBEMAP: this.isRGBE
                    }
                  });
                  skybox_material = new MaterialInstance({
                    parent: mat
                  });
                } else {
                  skybox_material.recompileShaders({
                    USE_RGBE_CUBEMAP: this.isRGBE
                  });
                }

                if (this.enabled) {
                  if (!skybox_mesh) {
                    skybox_mesh = legacyCC.utils.createMesh(legacyCC.primitives.box({
                      width: 2,
                      height: 2,
                      length: 2
                    }));
                  }

                  this._model.initSubModel(0, skybox_mesh.renderingSubMeshes[0], skybox_material);
                }

                this._updateGlobalBinding();

                this._updatePipeline();
              }

              _updatePipeline() {
                const value = this.useIBL ? this.isRGBE ? 2 : 1 : 0;
                const root = legacyCC.director.root;
                const pipeline = root.pipeline;
                const current = pipeline.macros.CC_USE_IBL;

                if (current === value) {
                  return;
                }

                pipeline.macros.CC_USE_IBL = value;
                root.onGlobalPipelineStateChanged();
              }

              _updateGlobalBinding() {
                const texture = this.envmap.getGFXTexture();
                const sampler = samplerLib.getSampler(legacyCC.director._device, this.envmap.getSamplerHash());

                this._globalDSManager.bindSampler(UNIFORM_ENVIRONMENT_BINDING, sampler);

                this._globalDSManager.bindTexture(UNIFORM_ENVIRONMENT_BINDING, texture);

                this._globalDSManager.update();
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this._destroy();
              }

            }
            legacyCC.Skybox = Skybox;

            class SphereLight extends Light {
              _init() {
                super._init();

                {
                  this._nativeObj.setPosition(this._pos);

                  this._nativeObj.setAABB(this._aabb.native);
                }
              }

              _destroy() {
                super._destroy();
              }

              get position() {
                return this._pos;
              }

              set size(size) {
                this._size = size;

                {
                  this._nativeObj.setSize(size);
                }
              }

              get size() {
                return this._size;
              }

              set range(range) {
                this._range = range;

                {
                  this._nativeObj.setRange(range);
                }

                this._needUpdate = true;
              }

              get range() {
                return this._range;
              }

              set luminance(lum) {
                this._luminance = lum;

                {
                  this._nativeObj.setIlluminance(lum);
                }
              }

              get luminance() {
                return this._luminance;
              }

              get aabb() {
                return this._aabb;
              }

              constructor() {
                super();
                this._needUpdate = false;
                this._size = 0.15;
                this._range = 1.0;
                this._luminance = 0;
                this._pos = void 0;
                this._aabb = void 0;
                this._aabb = AABB.create();
                this._pos = new Vec3();
                this._type = LightType.SPHERE;
              }

              initialize() {
                super.initialize();
                const size = 0.15;
                this.size = size;
                this.range = 1.0;
                this.luminance = 1700 / nt2lm(size);
              }

              update() {
                if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
                  this._node.getWorldPosition(this._pos);

                  const range = this._range;
                  AABB.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, range, range, range);
                  this._needUpdate = false;
                }
              }

            } exports('ci', SphereLight);

            const _forward$1 = new Vec3(0, 0, -1);

            const _qt = new Quat();

            const _matView = new Mat4();

            const _matProj = new Mat4();

            const _matViewProj = new Mat4();

            const _matViewProjInv = new Mat4();

            class SpotLight extends Light {
              _init() {
                super._init();

                {
                  const nativeSpotLight = this._nativeObj;
                  nativeSpotLight.setAABB(this._aabb.native);
                  nativeSpotLight.setFrustum(this._frustum);
                  nativeSpotLight.setDirection(this._dir);
                  nativeSpotLight.setPosition(this._pos);
                }
              }

              _destroy() {
                super._destroy();
              }

              _setDirection(dir) {
                this._dir.set(dir);

                {
                  this._nativeObj.setDirection(dir);
                }
              }

              get position() {
                return this._pos;
              }

              set size(size) {
                this._size = size;

                {
                  this._nativeObj.setSize(size);
                }
              }

              get size() {
                return this._size;
              }

              set range(range) {
                this._range = range;

                {
                  this._nativeObj.setRange(range);
                }

                this._needUpdate = true;
              }

              get range() {
                return this._range;
              }

              set luminance(lum) {
                this._luminance = lum;

                {
                  this._nativeObj.setIlluminance(lum);
                }
              }

              get luminance() {
                return this._luminance;
              }

              get direction() {
                return this._dir;
              }

              get spotAngle() {
                return this._spotAngle;
              }

              set spotAngle(val) {
                this._angle = val;
                this._spotAngle = Math.cos(val * 0.5);

                {
                  this._nativeObj.setAngle(this._spotAngle);
                }

                this._needUpdate = true;
              }

              set aspect(val) {
                this._aspect = val;

                {
                  this._nativeObj.setAspect(val);
                }

                this._needUpdate = true;
              }

              get aspect() {
                return this._aspect;
              }

              get aabb() {
                return this._aabb;
              }

              get frustum() {
                return this._frustum;
              }

              constructor() {
                super();
                this._dir = new Vec3(1.0, -1.0, -1.0);
                this._range = 5.0;
                this._spotAngle = Math.cos(Math.PI / 6);
                this._pos = void 0;
                this._aabb = void 0;
                this._frustum = void 0;
                this._angle = 0;
                this._needUpdate = false;
                this._size = 0.15;
                this._luminance = 0;
                this._aspect = 0;
                this._aabb = AABB.create();
                this._frustum = Frustum.create();
                this._pos = new Vec3();
                this._type = LightType.SPOT;
              }

              initialize() {
                super.initialize();
                const size = 0.15;
                this.size = size;
                this.aspect = 1.0;
                this.luminance = 1700 / nt2lm(size);
                this.range = Math.cos(Math.PI / 6);

                this._setDirection(new Vec3(1.0, -1.0, -1.0));
              }

              update() {
                if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
                  this._node.getWorldPosition(this._pos);

                  Vec3.transformQuat(this._dir, _forward$1, this._node.getWorldRotation(_qt));
                  Vec3.normalize(this._dir, this._dir);
                  AABB.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range);

                  this._node.getWorldRT(_matView);

                  Mat4.invert(_matView, _matView);
                  Mat4.perspective(_matProj, this._angle, 1.0, 0.001, this._range);
                  Mat4.multiply(_matViewProj, _matProj, _matView);

                  this._frustum.update(_matViewProj, _matViewProjInv);

                  this._needUpdate = false;
                }
              }

            } exports('ck', SpotLight);

            var index = /*#__PURE__*/Object.freeze({
                __proto__: null,
                Ambient: Ambient,
                get CameraFOVAxis () { return CameraFOVAxis; },
                get CameraProjection () { return CameraProjection; },
                get CameraAperture () { return CameraAperture; },
                get CameraISO () { return CameraISO; },
                get CameraShutter () { return CameraShutter; },
                SKYBOX_FLAG: SKYBOX_FLAG,
                Camera: Camera,
                CameraVisFlags: CameraVisFlags,
                VisibilityFlags: VisibilityFlags,
                DirectionalLight: DirectionalLight,
                ColorTemperatureToRGB: ColorTemperatureToRGB,
                get LightType () { return LightType; },
                nt2lm: nt2lm,
                Light: Light,
                get ModelType () { return ModelType; },
                Model: Model,
                ShadowSize: ShadowSize,
                ShadowType: ShadowType,
                PCFType: PCFType,
                Shadows: Shadows,
                RenderScene: RenderScene,
                Skybox: Skybox,
                SphereLight: SphereLight,
                SpotLight: SpotLight,
                SubModel: SubModel,
                NativeNode: NativeNode,
                NativeScene: NativeScene,
                NativeModel: NativeModel,
                NativeSkinningModel: NativeSkinningModel,
                NativeBakedSkinningModel: NativeBakedSkinningModel,
                NativeLight: NativeLight,
                NativeDirectionalLight: NativeDirectionalLight,
                NativeSpotLight: NativeSpotLight,
                NativeSphereLight: NativeSphereLight,
                NaitveSkybox: NaitveSkybox,
                NativeFog: NativeFog,
                NativeAmbient: NativeAmbient,
                NativeShadow: NativeShadow,
                NativeCamera: NativeCamera,
                NativeRenderWindow: NativeRenderWindow,
                NativeRenderScene: NativeRenderScene,
                NativeDrawBatch2D: NativeDrawBatch2D,
                NativePass: NativePass,
                NativeSubModel: NativeSubModel,
                NativeRoot: NativeRoot,
                NativePipelineSharedSceneData: NativePipelineSharedSceneData,
                NativeAABB: NativeAABB
            });

            function createIA(device, data) {
              if (!data.positions) {
                console.error('The data must have positions field');
                return null;
              }

              const verts = [];
              const vcount = data.positions.length / 3;

              for (let i = 0; i < vcount; ++i) {
                verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]);

                if (data.normals) {
                  verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]);
                }

                if (data.uvs) {
                  verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]);
                }

                if (data.colors) {
                  verts.push(data.colors[3 * i], data.colors[3 * i + 1], data.colors[3 * i + 2]);
                }
              }

              const vfmt = [];
              vfmt.push(new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F));

              if (data.normals) {
                vfmt.push(new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F));
              }

              if (data.uvs) {
                vfmt.push(new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F));
              }

              if (data.colors) {
                vfmt.push(new Attribute(AttributeName.ATTR_COLOR, Format.RGB32F));
              }

              const vb = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, verts.length * 4, verts.length * 4 / vcount));
              vb.update(new Float32Array(verts));
              let ib = null;

              if (data.indices) {
                ib = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, data.indices.length * 2, 2));
                ib.update(new Uint16Array(data.indices));
              }

              return device.createInputAssembler(new InputAssemblerInfo(vfmt, [vb], ib));
            }

            let RenderQueue;

            (function (RenderQueue) {
              RenderQueue[RenderQueue["OPAQUE"] = 0] = "OPAQUE";
              RenderQueue[RenderQueue["TRANSPARENT"] = 1] = "TRANSPARENT";
              RenderQueue[RenderQueue["OVERLAY"] = 2] = "OVERLAY";
            })(RenderQueue || (RenderQueue = {}));

            let PassStage;

            (function (PassStage) {
              PassStage[PassStage["DEFAULT"] = 1] = "DEFAULT";
              PassStage[PassStage["FORWARD"] = 2] = "FORWARD";
              PassStage[PassStage["SHADOWCAST"] = 4] = "SHADOWCAST";
            })(PassStage || (PassStage = {}));

            function nearestPOT(num) {
              --num;
              num |= num >> 16;
              num |= num >> 8;
              num |= num >> 4;
              num |= num >> 2;
              num |= num >> 1;
              ++num;
              return num;
            }

            function roundUp(n, alignment) {
              return Math.ceil(n / alignment) * alignment;
            }

            class TextureBufferPool {
              constructor(device) {
                this._device = void 0;
                this._format = Format.UNKNOWN;
                this._formatSize = 0;
                this._chunks = [];
                this._chunkCount = 0;
                this._handles = [];
                this._region0 = new BufferTextureCopy();
                this._region1 = new BufferTextureCopy();
                this._region2 = new BufferTextureCopy();
                this._roundUpFn = null;
                this._bufferViewCtor = Uint8Array;
                this._channels = 4;
                this._alignment = 1;
                this._device = device;
              }

              initialize(info) {
                const formatInfo = FormatInfos[info.format];
                this._format = info.format;
                this._formatSize = formatInfo.size;
                this._channels = formatInfo.count;
                this._bufferViewCtor = getTypedArrayConstructor(formatInfo);
                this._roundUpFn = info.roundUpFn || null;
                this._alignment = info.alignment || 1;

                if (info.inOrderFree) {
                  this.alloc = this._McDonaldAlloc;
                }
              }

              destroy() {
                for (let i = 0; i < this._chunkCount; ++i) {
                  const chunk = this._chunks[i];
                  chunk.texture.destroy();
                }

                this._chunks.length = 0;
                this._handles.length = 0;
              }

              alloc(size, chunkIdx) {
                size = roundUp(size, this._alignment);
                let index = -1;
                let start = -1;

                if (chunkIdx !== undefined) {
                  index = chunkIdx;
                  start = this._findAvailableSpace(size, index);
                }

                if (start < 0) {
                  for (let i = 0; i < this._chunkCount; ++i) {
                    index = i;
                    start = this._findAvailableSpace(size, index);

                    if (start >= 0) {
                      break;
                    }
                  }
                }

                if (start >= 0) {
                  const chunk = this._chunks[index];
                  chunk.start += size;
                  const handle = {
                    chunkIdx: index,
                    start,
                    end: start + size,
                    texture: chunk.texture
                  };

                  this._handles.push(handle);

                  return handle;
                }

                const targetSize = Math.sqrt(size / this._formatSize);
                const texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));

                const newChunk = this._chunks[this.createChunk(texLength)];

                newChunk.start += size;
                const texHandle = {
                  chunkIdx: this._chunkCount - 1,
                  start: 0,
                  end: size,
                  texture: newChunk.texture
                };

                this._handles.push(texHandle);

                return texHandle;
              }

              free(handle) {
                for (let i = 0; i < this._handles.length; ++i) {
                  if (this._handles[i] === handle) {
                    this._chunks[handle.chunkIdx].end = handle.end;

                    this._handles.splice(i, 1);

                    return;
                  }
                }
              }

              createChunk(length) {
                const texSize = length * length * this._formatSize;
                debug(`TextureBufferPool: Allocate chunk ${this._chunkCount}, size: ${texSize}, format: ${this._format}`);

                const texture = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, this._format, length, length, TextureFlagBit.IMMUTABLE));

                const chunk = {
                  texture,
                  size: texSize,
                  start: 0,
                  end: texSize
                };
                this._chunks[this._chunkCount] = chunk;
                return this._chunkCount++;
              }

              update(handle, buffer) {
                const buffers = [];
                const regions = [];
                const start = handle.start / this._formatSize;
                let remainSize = buffer.byteLength / this._formatSize;
                let offsetX = start % handle.texture.width;
                let offsetY = Math.floor(start / handle.texture.width);
                let copySize = Math.min(handle.texture.width - offsetX, remainSize);
                let begin = 0;

                if (offsetX > 0) {
                  this._region0.texOffset.x = offsetX;
                  this._region0.texOffset.y = offsetY;
                  this._region0.texExtent.width = copySize;
                  this._region0.texExtent.height = 1;
                  buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
                  regions.push(this._region0);
                  offsetX = 0;
                  offsetY += 1;
                  remainSize -= copySize;
                  begin += copySize;
                }

                if (remainSize > 0) {
                  this._region1.texOffset.x = offsetX;
                  this._region1.texOffset.y = offsetY;

                  if (remainSize > handle.texture.width) {
                    this._region1.texExtent.width = handle.texture.width;
                    this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width);
                    copySize = this._region1.texExtent.width * this._region1.texExtent.height;
                  } else {
                    copySize = remainSize;
                    this._region1.texExtent.width = copySize;
                    this._region1.texExtent.height = 1;
                  }

                  buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
                  regions.push(this._region1);
                  offsetX = 0;
                  offsetY += this._region1.texExtent.height;
                  remainSize -= copySize;
                  begin += copySize;
                }

                if (remainSize > 0) {
                  this._region2.texOffset.x = offsetX;
                  this._region2.texOffset.y = offsetY;
                  this._region2.texExtent.width = remainSize;
                  this._region2.texExtent.height = 1;
                  buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, remainSize * this._channels));
                  regions.push(this._region2);
                }

                this._device.copyBuffersToTexture(buffers, handle.texture, regions);
              }

              _findAvailableSpace(size, chunkIdx) {
                const chunk = this._chunks[chunkIdx];
                let isFound = false;
                let start = chunk.start;

                if (start + size <= chunk.size) {
                  isFound = true;
                } else {
                  start = 0;

                  const handles = this._handles.filter(h => h.chunkIdx === chunkIdx).sort((a, b) => a.start - b.start);

                  for (let i = 0; i < handles.length; i++) {
                    const handle = handles[i];

                    if (start + size <= handle.start) {
                      isFound = true;
                      break;
                    }

                    start = handle.end;
                  }

                  if (!isFound && start + size <= chunk.size) {
                    isFound = true;
                  }
                }

                return isFound ? start : -1;
              }

              _McDonaldAlloc(size) {
                size = roundUp(size, this._alignment);

                for (let i = 0; i < this._chunkCount; ++i) {
                  const chunk = this._chunks[i];
                  let isFound = false;
                  let start = chunk.start;

                  if (start + size <= chunk.end) {
                    isFound = true;
                  } else if (start > chunk.end) {
                    if (start + size <= chunk.size) {
                      isFound = true;
                    } else if (size <= chunk.end) {
                      chunk.start = start = 0;
                      isFound = true;
                    }
                  } else if (start === chunk.end) {
                    chunk.start = start = 0;
                    chunk.end = chunk.size;

                    if (size <= chunk.end) {
                      isFound = true;
                    }
                  }

                  if (isFound) {
                    chunk.start += size;
                    const handle = {
                      chunkIdx: i,
                      start,
                      end: start + size,
                      texture: chunk.texture
                    };

                    this._handles.push(handle);

                    return handle;
                  }
                }

                const targetSize = Math.sqrt(size / this._formatSize);
                const texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));

                const newChunk = this._chunks[this.createChunk(texLength)];

                newChunk.start += size;
                const texHandle = {
                  chunkIdx: this._chunkCount,
                  start: 0,
                  end: size,
                  texture: newChunk.texture
                };

                this._handles.push(texHandle);

                return texHandle;
              }

            } exports('cm', TextureBufferPool);

            const addStage = config.addStage;

            var renderer = /*#__PURE__*/Object.freeze({
                __proto__: null,
                addStage: addStage,
                scene: index,
                createIA: createIA,
                get RenderQueue () { return RenderQueue; },
                get PassStage () { return PassStage; },
                get PropertyType () { return PropertyType; },
                genHandle: genHandle,
                getPropertyTypeFromHandle: getPropertyTypeFromHandle,
                getTypeFromHandle: getTypeFromHandle,
                getSetIndexFromHandle: getSetIndexFromHandle,
                getBindingFromHandle: getBindingFromHandle,
                getOffsetFromHandle: getOffsetFromHandle,
                customizeType: customizeType,
                type2reader: type2reader,
                type2writer: type2writer,
                getDefaultFromType: getDefaultFromType,
                overrideMacros: overrideMacros,
                get BatchingSchemes () { return BatchingSchemes; },
                Pass: Pass,
                getDeviceShaderVersion: getDeviceShaderVersion,
                programLib: programLib,
                get SamplerInfoIndex () { return SamplerInfoIndex; },
                defaultSamplerHash: defaultSamplerHash,
                genSamplerHash: genSamplerHash,
                samplerLib: samplerLib,
                nearestPOT: nearestPOT,
                TextureBufferPool: TextureBufferPool,
                MaterialInstance: MaterialInstance,
                PassInstance: PassInstance,
                get PoolType () { return PoolType; },
                NULL_HANDLE: NULL_HANDLE,
                get NodeView () { return NodeView; },
                NodePool: NodePool,
                get PassView () { return PassView; },
                PassPool: PassPool,
                get AABBView () { return AABBView; },
                AABBPool: AABBPool
            });
            exports('eu', renderer);

            const FogType = Enum({
              LINEAR: 0,
              EXP: 1,
              EXP_SQUARED: 2,
              LAYERED: 3
            });
            const FOG_TYPE_NONE = FogType.LAYERED + 1;
            class Fog {
              set enabled(val) {
                this._setEnable(val);

                if (!val) this._type = FOG_TYPE_NONE;
                val ? this.activate() : this._updatePipeline();
              }

              get enabled() {
                return this._enabled;
              }

              set fogColor(val) {
                this._fogColor.set(val);

                Color.toArray(this._colorArray, this._fogColor);

                {
                  this._nativeObj.color = this._fogColor;
                }
              }

              get fogColor() {
                return this._fogColor;
              }

              get type() {
                return this._type;
              }

              set type(val) {
                this._setType(val);

                if (this.enabled) this._updatePipeline();
              }

              get fogDensity() {
                return this._fogDensity;
              }

              set fogDensity(val) {
                this._fogDensity = val;

                {
                  this._nativeObj.density = val;
                }
              }

              get fogStart() {
                return this._fogStart;
              }

              set fogStart(val) {
                this._fogStart = val;

                {
                  this._nativeObj.start = val;
                }
              }

              get fogEnd() {
                return this._fogEnd;
              }

              set fogEnd(val) {
                this._fogEnd = val;

                {
                  this._nativeObj.end = val;
                }
              }

              get fogAtten() {
                return this._fogAtten;
              }

              set fogAtten(val) {
                this._fogAtten = val;

                {
                  this._nativeObj.atten = val;
                }
              }

              get fogTop() {
                return this._fogTop;
              }

              set fogTop(val) {
                this._fogTop = val;

                {
                  this._nativeObj.top = val;
                }
              }

              get fogRange() {
                return this._fogRange;
              }

              set fogRange(val) {
                this._fogRange = val;

                {
                  this._nativeObj.range = val;
                }
              }

              get colorArray() {
                return this._colorArray;
              }

              get native() {
                return this._nativeObj;
              }

              constructor() {
                this._fogColor = new Color('#C8C8C8');
                this._colorArray = new Float32Array([0.2, 0.2, 0.2, 1.0]);
                this._enabled = false;
                this._type = 0;
                this._fogDensity = 0.3;
                this._fogStart = 0.5;
                this._fogEnd = 300;
                this._fogAtten = 5;
                this._fogTop = 1.5;
                this._fogRange = 1.2;

                {
                  this._nativeObj = new NativeFog();
                }
              }

              _setType(val) {
                this._type = this.enabled ? val : FOG_TYPE_NONE;

                {
                  this._nativeObj.type = this._type;
                }
              }

              _setEnable(val) {
                this._enabled = val;

                {
                  this._nativeObj.enabled = val;
                }
              }

              initialize(fogInfo) {
                this.fogColor = fogInfo.fogColor;

                this._setEnable(fogInfo.enabled);

                this._setType(fogInfo.type);

                this.fogDensity = fogInfo.fogDensity;
                this.fogStart = fogInfo.fogStart;
                this.fogEnd = fogInfo.fogEnd;
                this.fogAtten = fogInfo.fogAtten;
                this.fogTop = fogInfo.fogTop;
                this.fogRange = fogInfo.fogRange;
              }

              activate() {
                this._updatePipeline();
              }

              _updatePipeline() {
                const root = legacyCC.director.root;
                const value = this.enabled ? this.type : FOG_TYPE_NONE;
                const pipeline = root.pipeline;

                if (pipeline.macros.CC_USE_FOG === value) {
                  return;
                }

                pipeline.macros.CC_USE_FOG = value;
                root.onGlobalPipelineStateChanged();
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this._destroy();
              }

            }
            legacyCC.Fog = Fog;

            class PipelineSceneData {
              _init() {
                {
                  this._nativeObj = new NativePipelineSharedSceneData();
                  this._nativeObj.fog = this.fog.native;
                  this._nativeObj.ambient = this.ambient.native;
                  this._nativeObj.skybox = this.skybox.native;
                  this._nativeObj.shadow = this.shadows.native;
                }
              }

              get native() {
                return this._nativeObj;
              }

              get isHDR() {
                return this._isHDR;
              }

              set isHDR(val) {
                this._isHDR = val;

                {
                  this._nativeObj.isHDR = val;
                }
              }

              get shadingScale() {
                return this._shadingScale;
              }

              set shadingScale(val) {
                this._shadingScale = val;

                {
                  this._nativeObj.shadingScale = val;
                }
              }

              get fpScale() {
                return this._fpScale;
              }

              set fpScale(val) {
                this._fpScale = val;

                {
                  this._fpScale = val;
                }
              }

              constructor() {
                this.fog = new Fog();
                this.ambient = new Ambient();
                this.skybox = new Skybox();
                this.shadows = new Shadows();
                this.renderObjects = [];
                this.shadowObjects = [];
                this.shadowFrameBufferMap = new Map();
                this._isHDR = false;
                this._shadingScale = 1.0;
                this._fpScale = 1.0 / 1024.0;

                this._init();

                this.shadingScale = 1.0;
                this.fpScale = 1.0 / 1024.0;
              }

              activate(device, pipeline) {
                this._device = device;
                this._pipeline = pipeline;
                return true;
              }

              onGlobalPipelineStateChanged() {}

              destroy() {
                this.ambient.destroy();
                this.skybox.destroy();
                this.fog.destroy();
                this.shadows.destroy();

                {
                  this._nativeObj = null;
                }
              }

            }

            function deepFlatten(strList, array) {
              for (const item of array) {
                if (Array.isArray(item)) {
                  deepFlatten(strList, item);
                } else {
                    strList.push(item);
                  }
              }
            }

            function flattenCodeArray(array) {
              const separator =  '';
              const strList = [];
              deepFlatten(strList, array);
              return strList.join(separator);
            }

            const Destroyed$2 = CCObject.Flags.Destroyed;
            const PersistentMask$2 = CCObject.Flags.PersistentMask;
            const DEFAULT = `${DELIMETER}default`;
            const IDENTIFIER_RE$1 = CCClass.IDENTIFIER_RE;
            const VAR = 'var ';
            const LOCAL_OBJ = 'o';
            const LOCAL_TEMP_OBJ = 't';
            const LOCAL_ARRAY = 'a';
            const LINE_INDEX_OF_NEW_OBJ = 0;
            const DEFAULT_MODULE_CACHE = {
              'cc.ClickEvent': false,
              'cc.PrefabInfo': false
            };
            const escapeForJS$1 = CCClass.escapeForJS;

            class Declaration {
              constructor(varName, expression) {
                this.varName = void 0;
                this.expression = void 0;
                this.varName = varName;
                this.expression = expression;
              }

              toString() {
                return `${VAR + this.varName}=${this.expression};`;
              }

            }

            function mergeDeclaration(statement, expression) {
              if (expression instanceof Declaration) {
                return new Declaration(expression.varName, statement + expression.expression);
              } else {
                return statement + expression;
              }
            }

            function writeAssignment(codeArray, statement, expression) {
              if (Array.isArray(expression)) {
                expression[0] = mergeDeclaration(statement, expression[0]);
                codeArray.push(expression);
              } else {
                codeArray.push(`${mergeDeclaration(statement, expression)};`);
              }
            }

            class Assignments {
              constructor(targetExpression) {
                this._exps = void 0;
                this._targetExp = void 0;
                this._exps = [];
                this._targetExp = targetExpression;
              }

              append(key, expression) {
                this._exps.push([key, expression]);
              }

              writeCode(codeArray) {
                let targetVar;

                if (this._exps.length > 1) {
                  codeArray.push(`${LOCAL_TEMP_OBJ}=${this._targetExp};`);
                  targetVar = LOCAL_TEMP_OBJ;
                } else if (this._exps.length === 1) {
                  targetVar = this._targetExp;
                } else {
                  return;
                }

                for (let i = 0; i < this._exps.length; i++) {
                  const pair = this._exps[i];
                  writeAssignment(codeArray, `${targetVar + getPropAccessor(pair[0])}=`, pair[1]);
                }
              }

            }

            Assignments.pool = void 0;
            Assignments.pool = new Pool$1(obj => {
              obj._exps.length = 0;
              obj._targetExp = null;
            }, 1);

            Assignments.pool.get = function (targetExpression) {
              const cache = this._get() || new Assignments();
              cache._targetExp = targetExpression;
              return cache;
            };

            function getPropAccessor(key) {
              return IDENTIFIER_RE$1.test(key) ? `.${key}` : `[${escapeForJS$1(key)}]`;
            }

            class Parser {
              constructor(obj, parent) {
                this.parent = void 0;
                this.objsToClear_iN$t = void 0;
                this.codeArray = void 0;
                this.objs = void 0;
                this.funcs = void 0;
                this.funcModuleCache = void 0;
                this.globalVariables = void 0;
                this.globalVariableId = void 0;
                this.localVariableId = void 0;
                this.result = void 0;
                this.parent = parent;
                this.objsToClear_iN$t = [];
                this.codeArray = [];
                this.objs = [];
                this.funcs = [];
                this.funcModuleCache = createMap();
                mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE);
                this.globalVariables = [];
                this.globalVariableId = 0;
                this.localVariableId = 0;
                this.codeArray.push(`${VAR + LOCAL_OBJ},${LOCAL_TEMP_OBJ};`, 'if(R){', `${LOCAL_OBJ}=R;`, '}else{', `${LOCAL_OBJ}=R=new ${this.getFuncModule(obj.constructor, true)}();`, '}');
                obj._iN$t = {
                  globalVar: 'R'
                };
                this.objsToClear_iN$t.push(obj);
                this.enumerateObject(this.codeArray, obj);
                let globalVariablesDeclaration;

                if (this.globalVariables.length > 0) {
                  globalVariablesDeclaration = `${VAR + this.globalVariables.join(',')};`;
                }

                const code = flattenCodeArray(['return (function(R){', globalVariablesDeclaration || [], this.codeArray, 'return o;', '})']);
                this.result = Function('O', 'F', code)(this.objs, this.funcs);

                for (let i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) {
                  this.objsToClear_iN$t[i]._iN$t = null;
                }

                this.objsToClear_iN$t.length = 0;
              }

              getFuncModule(func, usedInNew) {
                const clsName = getClassName(func);

                if (clsName) {
                  const cache = this.funcModuleCache[clsName];

                  if (cache) {
                    return cache;
                  } else if (cache === undefined) {
                    let clsNameIsModule = clsName.indexOf('.') !== -1;

                    if (clsNameIsModule) {
                      try {
                        clsNameIsModule = func === Function(`return ${clsName}`)();

                        if (clsNameIsModule) {
                          this.funcModuleCache[clsName] = clsName;
                          return clsName;
                        }
                      } catch (e) {}
                    }
                  }
                }

                let index = this.funcs.indexOf(func);

                if (index < 0) {
                  index = this.funcs.length;
                  this.funcs.push(func);
                }

                let res = `F[${index}]`;

                if (usedInNew) {
                  res = `(${res})`;
                }

                this.funcModuleCache[clsName] = res;
                return res;
              }

              getObjRef(obj) {
                let index = this.objs.indexOf(obj);

                if (index < 0) {
                  index = this.objs.length;
                  this.objs.push(obj);
                }

                return `O[${index}]`;
              }

              setValueType(codeArray, defaultValue, srcValue, targetExpression) {
                const assignments = Assignments.pool.get(targetExpression);
                let fastDefinedProps = defaultValue.constructor.__props__;

                if (!fastDefinedProps) {
                  fastDefinedProps = Object.keys(defaultValue);
                }

                for (let i = 0; i < fastDefinedProps.length; i++) {
                  const propName = fastDefinedProps[i];
                  const prop = srcValue[propName];

                  if (defaultValue[propName] === prop) {
                    continue;
                  }

                  const expression = this.enumerateField(srcValue, propName, prop);
                  assignments.append(propName, expression);
                }

                assignments.writeCode(codeArray);
                Assignments.pool.put(assignments);
              }

              enumerateCCClass(codeArray, obj, klass) {
                const props = klass.__values__;
                const attrs = getClassAttrs(klass);

                for (let p = 0; p < props.length; p++) {
                  const key = props[p];
                  const val = obj[key];
                  let defaultValue = attrs[key + DEFAULT];

                  if (equalsToDefault(defaultValue, val)) {
                    continue;
                  }

                  if (typeof val === 'object' && val instanceof legacyCC.ValueType) {
                    defaultValue = CCClass.getDefault(defaultValue);

                    if (defaultValue && defaultValue.constructor === val.constructor) {
                      const targetExpression = LOCAL_OBJ + getPropAccessor(key);
                      this.setValueType(codeArray, defaultValue, val, targetExpression);
                      continue;
                    }
                  }

                  this.setObjProp(codeArray, obj, key, val);
                }
              }

              instantiateArray(value) {
                if (value.length === 0) {
                  return '[]';
                }

                const arrayVar = LOCAL_ARRAY + ++this.localVariableId;
                const declaration = new Declaration(arrayVar, `new Array(${value.length})`);
                const codeArray = [declaration];
                value._iN$t = {
                  globalVar: '',
                  source: codeArray
                };
                this.objsToClear_iN$t.push(value);

                for (let i = 0; i < value.length; ++i) {
                  const statement = `${arrayVar}[${i}]=`;
                  const expression = this.enumerateField(value, i, value[i]);
                  writeAssignment(codeArray, statement, expression);
                }

                return codeArray;
              }

              instantiateTypedArray(value) {
                const type = value.constructor.name;

                if (value.length === 0) {
                  return `new ${type}`;
                }

                const arrayVar = LOCAL_ARRAY + ++this.localVariableId;
                const declaration = new Declaration(arrayVar, `new ${type}(${value.length})`);
                const codeArray = [declaration];
                value._iN$t = {
                  globalVar: '',
                  source: codeArray
                };
                this.objsToClear_iN$t.push(value);

                for (let i = 0; i < value.length; ++i) {
                  if (value[i] !== 0) {
                    const statement = `${arrayVar}[${i}]=`;
                    writeAssignment(codeArray, statement, value[i]);
                  }
                }

                return codeArray;
              }

              enumerateField(obj, key, value) {
                if (typeof value === 'object' && value) {
                  const _iN$t = value._iN$t;

                  if (_iN$t) {
                    let globalVar = _iN$t.globalVar;

                    if (!globalVar) {
                      globalVar = _iN$t.globalVar = `v${++this.globalVariableId}`;
                      this.globalVariables.push(globalVar);
                      const line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
                      _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(`${globalVar}=`, line);
                    }

                    return globalVar;
                  } else if (ArrayBuffer.isView(value)) {
                    return this.instantiateTypedArray(value);
                  } else if (Array.isArray(value)) {
                    return this.instantiateArray(value);
                  } else {
                    return this.instantiateObj(value);
                  }
                } else if (typeof value === 'function') {
                  return this.getFuncModule(value);
                } else if (typeof value === 'string') {
                  return escapeForJS$1(value);
                } else {
                  if (key === '_objFlags' && obj instanceof CCObject) {
                    value &= PersistentMask$2;
                  }

                  return value;
                }
              }

              setObjProp(codeArray, obj, key, value) {
                const statement = `${LOCAL_OBJ + getPropAccessor(key)}=`;
                const expression = this.enumerateField(obj, key, value);
                writeAssignment(codeArray, statement, expression);
              }

              enumerateObject(codeArray, obj) {
                const klass = obj.constructor;

                if (legacyCC.Class._isCCClass(klass)) {
                  this.enumerateCCClass(codeArray, obj, klass);
                } else {
                  for (const key in obj) {
                    if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__') {
                      continue;
                    }

                    const value = obj[key];

                    if (typeof value === 'object' && value && value === obj._iN$t) {
                      continue;
                    }

                    this.setObjProp(codeArray, obj, key, value);
                  }
                }
              }

              instantiateObj(obj) {
                if (obj instanceof legacyCC.ValueType) {
                  return CCClass.getNewValueTypeCode(obj);
                }

                if (obj instanceof legacyCC.Asset) {
                  return this.getObjRef(obj);
                }

                if (obj._objFlags & Destroyed$2) {
                  return null;
                }

                let createCode;
                const ctor = obj.constructor;

                if (legacyCC.Class._isCCClass(ctor)) {
                  if (this.parent) {
                    if (this.parent instanceof legacyCC.Component) {
                      if (obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component) {
                        return this.getObjRef(obj);
                      }
                    } else if (this.parent instanceof legacyCC._BaseNode) {
                      if (obj instanceof legacyCC._BaseNode) {
                        if (!obj.isChildOf(this.parent)) {
                          return this.getObjRef(obj);
                        }
                      } else if (obj instanceof legacyCC.Component) {
                        if (!obj.node.isChildOf(this.parent)) {
                          return this.getObjRef(obj);
                        }
                      }
                    }
                  }

                  createCode = new Declaration(LOCAL_OBJ, `new ${this.getFuncModule(ctor, true)}()`);
                } else if (ctor === Object) {
                  createCode = new Declaration(LOCAL_OBJ, '{}');
                } else if (!ctor) {
                  createCode = new Declaration(LOCAL_OBJ, 'Object.create(null)');
                } else {
                  return this.getObjRef(obj);
                }

                const codeArray = [createCode];
                obj._iN$t = {
                  globalVar: '',
                  source: codeArray
                };
                this.objsToClear_iN$t.push(obj);
                this.enumerateObject(codeArray, obj);
                return ['(function(){', codeArray, 'return o;})();'];
              }

            }

            function equalsToDefault(def, value) {
              if (typeof def === 'function') {
                try {
                  def = def();
                } catch (e) {
                  return false;
                }
              }

              if (def === value) {
                return true;
              }

              if (def && value && typeof def === 'object' && typeof value === 'object' && def.constructor === value.constructor) {
                if (def instanceof legacyCC.ValueType) {
                  if (def.equals(value)) {
                    return true;
                  }
                } else if (Array.isArray(def)) {
                  return def.length === 0 && value.length === 0;
                } else if (def.constructor === Object) {
                  return isEmptyObject(def) && isEmptyObject(value);
                }
              }

              return false;
            }
            function compile(node) {
              const root = node instanceof legacyCC._BaseNode && node;
              const parser = new Parser(node, root);
              return parser.result;
            }

            class NodeUIProperties {
              get uiTransformComp() {
                if (!this._uiTransformComp) {
                  this._uiTransformComp = this._node.getComponent('cc.UITransform');
                }

                return this._uiTransformComp;
              }

              set uiTransformComp(value) {
                this._uiTransformComp = value;
              }

              get uiComp() {
                return this._uiComp;
              }

              set uiComp(comp) {
                if (this._uiComp && comp) {
                  warnID(12002);
                  return;
                }

                this._uiComp = comp;
              }

              constructor(node) {
                this._uiComp = null;
                this.opacity = 1;
                this.localOpacity = 1;
                this._uiTransformComp = null;
                this._node = void 0;
                this.uiTransformDirty = true;
                this._node = node;
              }

            }

            let SystemEventType;

            (function (SystemEventType) {
              SystemEventType["TOUCH_START"] = "touch-start";
              SystemEventType["TOUCH_MOVE"] = "touch-move";
              SystemEventType["TOUCH_END"] = "touch-end";
              SystemEventType["TOUCH_CANCEL"] = "touch-cancel";
              SystemEventType["MOUSE_DOWN"] = "mouse-down";
              SystemEventType["MOUSE_MOVE"] = "mouse-move";
              SystemEventType["MOUSE_UP"] = "mouse-up";
              SystemEventType["MOUSE_WHEEL"] = "mouse-wheel";
              SystemEventType["MOUSE_ENTER"] = "mouse-enter";
              SystemEventType["MOUSE_LEAVE"] = "mouse-leave";
              SystemEventType["KEY_DOWN"] = "keydown";
              SystemEventType["KEY_UP"] = "keyup";
              SystemEventType["DEVICEMOTION"] = "devicemotion";
              SystemEventType["TRANSFORM_CHANGED"] = "transform-changed";
              SystemEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
              SystemEventType["SIZE_CHANGED"] = "size-changed";
              SystemEventType["ANCHOR_CHANGED"] = "anchor-changed";
              SystemEventType["COLOR_CHANGED"] = "color-changed";
              SystemEventType["CHILD_ADDED"] = "child-added";
              SystemEventType["CHILD_REMOVED"] = "child-removed";
              SystemEventType["PARENT_CHANGED"] = "parent-changed";
              SystemEventType["NODE_DESTROYED"] = "node-destroyed";
              SystemEventType["LAYER_CHANGED"] = "layer-changed";
              SystemEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
            })(SystemEventType || (SystemEventType = exports('dv', {})));

            ccenum(SystemEventType);
            legacyCC.SystemEventType = SystemEventType;

            class EventListener {
              static create(argObj) {
                assertID(argObj && argObj.event, 1900);
                const listenerType = argObj.event;
                delete argObj.event;
                let listener = null;

                if (listenerType === legacyCC.EventListener.TOUCH_ONE_BY_ONE) {
                  listener = new TouchOneByOneEventListener();
                } else if (listenerType === legacyCC.EventListener.TOUCH_ALL_AT_ONCE) {
                  listener = new TouchAllAtOnceEventListener();
                } else if (listenerType === legacyCC.EventListener.MOUSE) {
                  listener = new MouseEventListener();
                } else if (listenerType === legacyCC.EventListener.KEYBOARD) {
                  listener = new KeyboardEventListener();
                } else if (listenerType === legacyCC.EventListener.ACCELERATION) {
                  listener = new AccelerationEventListener(argObj.callback);
                  delete argObj.callback;
                }

                if (listener) {
                  for (const key of Object.keys(argObj)) {
                    listener[key] = argObj[key];
                  }
                }

                return listener;
              }

              get onEvent() {
                return this._onEvent;
              }

              constructor(type, listenerID, callback) {
                this._cameraPriority = 0;
                this.owner = null;
                this.mask = null;
                this._previousIn = false;
                this._target = null;
                this._onEvent = void 0;
                this._type = void 0;
                this._listenerID = void 0;
                this._registered = false;
                this._fixedPriority = 0;
                this._node = null;
                this._paused = true;
                this._isEnabled = true;
                this._onEvent = callback;
                this._type = type || 0;
                this._listenerID = listenerID || '';
              }

              _setPaused(paused) {
                this._paused = paused;
              }

              _isPaused() {
                return this._paused;
              }

              _setRegistered(registered) {
                this._registered = registered;
              }

              _isRegistered() {
                return this._registered;
              }

              _getType() {
                return this._type;
              }

              _getListenerID() {
                return this._listenerID;
              }

              _setFixedPriority(fixedPriority) {
                this._fixedPriority = fixedPriority;
              }

              _getFixedPriority() {
                return this._fixedPriority;
              }

              _setSceneGraphPriority(node) {
                this._target = node;
                this._node = node;
              }

              _getSceneGraphPriority() {
                return this._node;
              }

              checkAvailable() {
                return this._onEvent !== null;
              }

              clone() {
                return null;
              }

              setEnabled(enabled) {
                this._isEnabled = enabled;
              }

              isEnabled() {
                return this._isEnabled;
              }

            }
            EventListener.UNKNOWN = 0;
            EventListener.TOUCH_ONE_BY_ONE = 1;
            EventListener.TOUCH_ALL_AT_ONCE = 2;
            EventListener.KEYBOARD = 3;
            EventListener.MOUSE = 4;
            EventListener.ACCELERATION = 6;
            EventListener.CUSTOM = 8;
            EventListener.ListenerID = {
              MOUSE: '__cc_mouse',
              TOUCH_ONE_BY_ONE: '__cc_touch_one_by_one',
              TOUCH_ALL_AT_ONCE: '__cc_touch_all_at_once',
              KEYBOARD: '__cc_keyboard',
              ACCELERATION: '__cc_acceleration'
            };
            const ListenerID = EventListener.ListenerID;
            class MouseEventListener extends EventListener {
              constructor() {
                super(EventListener.MOUSE, ListenerID.MOUSE, null);
                this.onMouseDown = null;
                this.onMouseUp = null;
                this.onMouseMove = null;
                this.onMouseScroll = null;

                this._onEvent = event => this._callback(event);
              }

              _callback(event) {
                switch (event.type) {
                  case SystemEventType.MOUSE_DOWN:
                    if (this.onMouseDown) {
                      this.onMouseDown(event);
                    }

                    break;

                  case SystemEventType.MOUSE_UP:
                    if (this.onMouseUp) {
                      this.onMouseUp(event);
                    }

                    break;

                  case SystemEventType.MOUSE_MOVE:
                    if (this.onMouseMove) {
                      this.onMouseMove(event);
                    }

                    break;

                  case SystemEventType.MOUSE_WHEEL:
                    if (this.onMouseScroll) {
                      this.onMouseScroll(event);
                    }

                    break;
                }
              }

              clone() {
                const eventListener = new MouseEventListener();
                eventListener.onMouseDown = this.onMouseDown;
                eventListener.onMouseUp = this.onMouseUp;
                eventListener.onMouseMove = this.onMouseMove;
                eventListener.onMouseScroll = this.onMouseScroll;
                return eventListener;
              }

              checkAvailable() {
                return true;
              }

            }
            class TouchOneByOneEventListener extends EventListener {
              constructor() {
                super(EventListener.TOUCH_ONE_BY_ONE, ListenerID.TOUCH_ONE_BY_ONE, null);
                this.swallowTouches = false;
                this.onTouchBegan = null;
                this.onTouchMoved = null;
                this.onTouchEnded = null;
                this.onTouchCancelled = null;
                this._claimedTouches = [];
              }

              setSwallowTouches(needSwallow) {
                this.swallowTouches = needSwallow;
              }

              isSwallowTouches() {
                return this.swallowTouches;
              }

              clone() {
                const eventListener = new TouchOneByOneEventListener();
                eventListener.onTouchBegan = this.onTouchBegan;
                eventListener.onTouchMoved = this.onTouchMoved;
                eventListener.onTouchEnded = this.onTouchEnded;
                eventListener.onTouchCancelled = this.onTouchCancelled;
                eventListener.swallowTouches = this.swallowTouches;
                return eventListener;
              }

              checkAvailable() {
                if (!this.onTouchBegan) {
                  logID(1801);
                  return false;
                }

                return true;
              }

            }
            class TouchAllAtOnceEventListener extends EventListener {
              constructor() {
                super(EventListener.TOUCH_ALL_AT_ONCE, ListenerID.TOUCH_ALL_AT_ONCE, null);
                this.onTouchesBegan = null;
                this.onTouchesMoved = null;
                this.onTouchesEnded = null;
                this.onTouchesCancelled = null;
              }

              clone() {
                const eventListener = new TouchAllAtOnceEventListener();
                eventListener.onTouchesBegan = this.onTouchesBegan;
                eventListener.onTouchesMoved = this.onTouchesMoved;
                eventListener.onTouchesEnded = this.onTouchesEnded;
                eventListener.onTouchesCancelled = this.onTouchesCancelled;
                return eventListener;
              }

              checkAvailable() {
                if (this.onTouchesBegan === null && this.onTouchesMoved === null && this.onTouchesEnded === null && this.onTouchesCancelled === null) {
                  logID(1802);
                  return false;
                }

                return true;
              }

            }
            class AccelerationEventListener extends EventListener {
              constructor(callback) {
                super(EventListener.ACCELERATION, ListenerID.ACCELERATION, null);
                this._onAccelerationEvent = null;

                this._onEvent = event => this._callback(event);

                this._onAccelerationEvent = callback;
              }

              _callback(event) {
                if (this._onAccelerationEvent) {
                  this._onAccelerationEvent(event.acc, event);
                }
              }

              checkAvailable() {
                assertID(this._onAccelerationEvent, 1803);
                return true;
              }

              clone() {
                return new AccelerationEventListener(this._onAccelerationEvent);
              }

            }
            class KeyboardEventListener extends EventListener {
              constructor() {
                super(EventListener.KEYBOARD, ListenerID.KEYBOARD, null);
                this.onKeyDown = undefined;
                this.onKeyPressed = undefined;
                this.onKeyReleased = undefined;

                this._onEvent = event => this._callback(event);
              }

              _callback(event) {
                var _this$onKeyPressed, _this$onKeyReleased;

                switch (event.type) {
                  case SystemEventType.KEY_DOWN:
                    (_this$onKeyPressed = this.onKeyPressed) === null || _this$onKeyPressed === void 0 ? void 0 : _this$onKeyPressed.call(this, event.keyCode, event);
                    break;

                  case SystemEventType.KEY_UP:
                    (_this$onKeyReleased = this.onKeyReleased) === null || _this$onKeyReleased === void 0 ? void 0 : _this$onKeyReleased.call(this, event.keyCode, event);
                    break;
                }
              }

              clone() {
                const eventListener = new KeyboardEventListener();
                eventListener.onKeyDown = this.onKeyDown;
                eventListener.onKeyPressed = this.onKeyPressed;
                eventListener.onKeyReleased = this.onKeyReleased;
                return eventListener;
              }

              checkAvailable() {
                if (this.onKeyDown === null && this.onKeyPressed === null && this.onKeyReleased === null) {
                  logID(1800);
                  return false;
                }

                return true;
              }

            }
            legacyCC.EventListener = EventListener;

            const ListenerID$1 = EventListener.ListenerID;

            function checkUINode(node) {
              if (node && node.getComponent('cc.UITransform')) {
                return true;
              }

              return false;
            }

            const touchEvents = [SystemEventType.TOUCH_START, SystemEventType.TOUCH_MOVE, SystemEventType.TOUCH_END, SystemEventType.TOUCH_CANCEL];
            const mouseEvents = [SystemEventType.MOUSE_DOWN, SystemEventType.MOUSE_MOVE, SystemEventType.MOUSE_UP, SystemEventType.MOUSE_WHEEL];
            const keyboardEvents = [SystemEventType.KEY_DOWN, SystemEventType.KEY_UP];

            class _EventListenerVector {
              constructor() {
                this.gt0Index = 0;
                this._fixedListeners = [];
                this._sceneGraphListeners = [];
              }

              size() {
                return this._fixedListeners.length + this._sceneGraphListeners.length;
              }

              empty() {
                return this._fixedListeners.length === 0 && this._sceneGraphListeners.length === 0;
              }

              push(listener) {
                if (listener._getFixedPriority() === 0) {
                  this._sceneGraphListeners.push(listener);
                } else {
                  this._fixedListeners.push(listener);
                }
              }

              clearSceneGraphListeners() {
                this._sceneGraphListeners.length = 0;
              }

              clearFixedListeners() {
                this._fixedListeners.length = 0;
              }

              clear() {
                this._sceneGraphListeners.length = 0;
                this._fixedListeners.length = 0;
              }

              getFixedPriorityListeners() {
                return this._fixedListeners;
              }

              getSceneGraphPriorityListeners() {
                return this._sceneGraphListeners;
              }

            }

            function __getListenerID(event) {
              const type = event.type;

              if (type === SystemEventType.DEVICEMOTION) {
                return ListenerID$1.ACCELERATION;
              }

              if (keyboardEvents.includes(type)) {
                return ListenerID$1.KEYBOARD;
              }

              if (mouseEvents.includes(type)) {
                return ListenerID$1.MOUSE;
              }

              if (touchEvents.includes(type)) {
                logID(2000);
              }

              return '';
            }

            const DIRTY_NONE = 0;
            const DIRTY_FIXED_PRIORITY = 1 << 0;
            const DIRTY_SCENE_GRAPH_PRIORITY = 1 << 1;

            class EventManager {
              constructor() {
                this._listenersMap = {};
                this._priorityDirtyFlagMap = {};
                this._nodeListenersMap = {};
                this._toAddedListeners = [];
                this._toRemovedListeners = [];
                this._dirtyListeners = {};
                this._inDispatch = 0;
                this._isEnabled = false;
                this._internalCustomListenerIDs = [];
                this._currentTouch = null;
                this._currentTouchListener = null;
              }

              pauseTarget(node, recursive = false) {
                if (!(node instanceof legacyCC._BaseNode)) {
                  warnID(3506);
                  return;
                }

                const listeners = this._nodeListenersMap[node.uuid];

                if (listeners) {
                  for (let i = 0, len = listeners.length; i < len; i++) {
                    const listener = listeners[i];

                    listener._setPaused(true);

                    if (listener instanceof TouchOneByOneEventListener && listener._claimedTouches.includes(this._currentTouch)) {
                      this._clearCurTouch();
                    }
                  }
                }

                if (recursive === true) {
                  const locChildren = node.children;

                  if (locChildren) {
                    for (let i = 0; i < locChildren.length; ++i) {
                      const locChild = locChildren[i];
                      this.pauseTarget(locChild, true);
                    }
                  }
                }
              }

              resumeTarget(node, recursive = false) {
                if (!(node instanceof legacyCC._BaseNode)) {
                  warnID(3506);
                  return;
                }

                const listeners = this._nodeListenersMap[node.uuid];

                if (listeners) {
                  for (let i = 0; i < listeners.length; ++i) {
                    const listener = listeners[i];

                    listener._setPaused(false);
                  }
                }

                this._setDirtyForNode(node);

                if (recursive === true && node.children.length > 0) {
                  const locChildren = node.children;

                  if (locChildren) {
                    for (let i = 0; i < locChildren.length; ++i) {
                      const locChild = locChildren[i];
                      this.resumeTarget(locChild, true);
                    }
                  }
                }
              }

              frameUpdateListeners() {
                const locListenersMap = this._listenersMap;
                const locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;

                for (const selKey in locListenersMap) {
                  if (locListenersMap[selKey].empty()) {
                    delete locPriorityDirtyFlagMap[selKey];
                    delete locListenersMap[selKey];
                  }
                }

                const locToAddedListeners = this._toAddedListeners;

                if (locToAddedListeners.length !== 0) {
                  for (let i = 0, len = locToAddedListeners.length; i < len; i++) {
                    this._forceAddEventListener(locToAddedListeners[i]);
                  }

                  locToAddedListeners.length = 0;
                }

                if (this._toRemovedListeners.length !== 0) {
                  this._cleanToRemovedListeners();
                }
              }

              hasEventListener(listenerID) {
                return !!this._getListeners(listenerID);
              }

              addListener(listener, nodeOrPriority) {
                assertID(listener && nodeOrPriority, 3503);

                if (!(legacyCC.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof legacyCC._BaseNode)) {
                  warnID(3506);
                  return null;
                }

                if (!(listener instanceof legacyCC.EventListener)) {
                  assertID(!legacyCC.js.isNumber(nodeOrPriority), 3504);
                  listener = legacyCC.EventListener.create(listener);
                } else if (listener._isRegistered()) {
                  logID(3505);
                  return null;
                }

                if (!listener.checkAvailable()) {
                  return null;
                }

                if (legacyCC.js.isNumber(nodeOrPriority)) {
                  if (nodeOrPriority === 0) {
                    logID(3500);
                    return null;
                  }

                  listener._setSceneGraphPriority(null);

                  listener._setFixedPriority(nodeOrPriority);

                  listener._setRegistered(true);

                  listener._setPaused(false);

                  this._addListener(listener);
                } else {
                  if (!checkUINode(nodeOrPriority)) {
                    logID(3512);
                    return null;
                  }

                  listener._setSceneGraphPriority(nodeOrPriority);

                  listener._setFixedPriority(0);

                  listener._setRegistered(true);

                  this._addListener(listener);
                }

                return listener;
              }

              addCustomListener(eventName, callback) {
                const listener = EventListener.create({
                  event: legacyCC.EventListener.CUSTOM,
                  eventName,
                  callback
                });
                this.addListener(listener, 1);
                return listener;
              }

              removeListener(listener) {
                if (listener == null) {
                  return;
                }

                let isFound = false;
                const locListener = this._listenersMap;

                if (listener === this._currentTouchListener) {
                  this._currentTouchListener = this._currentTouch = null;
                }

                for (const selKey in locListener) {
                  const listeners = locListener[selKey];
                  const fixedPriorityListeners = listeners.getFixedPriorityListeners();
                  const sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                  isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener);

                  if (isFound) {
                    this._setDirty(listener._getListenerID(), DIRTY_SCENE_GRAPH_PRIORITY);
                  } else {
                    isFound = this._removeListenerInVector(fixedPriorityListeners, listener);

                    if (isFound) {
                      this._setDirty(listener._getListenerID(), DIRTY_FIXED_PRIORITY);
                    }
                  }

                  if (listeners.empty()) {
                    delete this._priorityDirtyFlagMap[listener._getListenerID()];
                    delete locListener[selKey];
                  }

                  if (isFound) {
                    break;
                  }
                }

                if (!isFound) {
                  const locToAddedListeners = this._toAddedListeners;

                  for (let i = locToAddedListeners.length - 1; i >= 0; i--) {
                    const selListener = locToAddedListeners[i];

                    if (selListener === listener) {
                      legacyCC.js.array.removeAt(locToAddedListeners, i);

                      selListener._setRegistered(false);

                      break;
                    }
                  }
                }
              }

              removeListeners(listenerType, recursive = false) {
                if (!(legacyCC.js.isNumber(listenerType) || listenerType instanceof legacyCC._BaseNode)) {
                  warnID(3506);
                  return;
                }

                if (listenerType._id !== undefined) {
                  const listeners = this._nodeListenersMap[listenerType._id];

                  if (listeners) {
                    const listenersCopy = legacyCC.js.array.copy(listeners);

                    for (let i = 0; i < listenersCopy.length; ++i) {
                      const listenerCopy = listenersCopy[i];
                      this.removeListener(listenerCopy);
                    }

                    delete this._nodeListenersMap[listenerType._id];
                  }

                  const locToAddedListeners = this._toAddedListeners;

                  for (let i = 0; i < locToAddedListeners.length;) {
                    const listener = locToAddedListeners[i];

                    if (listener._getSceneGraphPriority() === listenerType) {
                      listener._setSceneGraphPriority(null);

                      listener._setRegistered(false);

                      locToAddedListeners.splice(i, 1);
                    } else {
                      ++i;
                    }
                  }

                  if (recursive === true) {
                    const locChildren = listenerType.getChildren();

                    for (let i = 0; i < locChildren.length; ++i) {
                      const locChild = locChildren[i];
                      this.removeListeners(locChild, true);
                    }
                  }
                } else if (listenerType === legacyCC.EventListener.TOUCH_ONE_BY_ONE) {
                  this._removeListenersForListenerID(ListenerID$1.TOUCH_ONE_BY_ONE);
                } else if (listenerType === legacyCC.EventListener.TOUCH_ALL_AT_ONCE) {
                  this._removeListenersForListenerID(ListenerID$1.TOUCH_ALL_AT_ONCE);
                } else if (listenerType === legacyCC.EventListener.MOUSE) {
                  this._removeListenersForListenerID(ListenerID$1.MOUSE);
                } else if (listenerType === legacyCC.EventListener.ACCELERATION) {
                  this._removeListenersForListenerID(ListenerID$1.ACCELERATION);
                } else if (listenerType === legacyCC.EventListener.KEYBOARD) {
                  this._removeListenersForListenerID(ListenerID$1.KEYBOARD);
                } else {
                  logID(3501);
                }
              }

              removeCustomListeners(customEventName) {
                this._removeListenersForListenerID(customEventName);
              }

              removeAllListeners() {
                const locListeners = this._listenersMap;
                const locInternalCustomEventIDs = this._internalCustomListenerIDs;

                for (const selKey in locListeners) {
                  if (locInternalCustomEventIDs.indexOf(selKey) === -1) {
                    this._removeListenersForListenerID(selKey);
                  }
                }
              }

              setPriority(listener, fixedPriority) {
                if (listener == null) {
                  return;
                }

                const locListeners = this._listenersMap;

                for (const selKey in locListeners) {
                  const selListeners = locListeners[selKey];
                  const fixedPriorityListeners = selListeners.getFixedPriorityListeners();

                  if (fixedPriorityListeners) {
                    const found = fixedPriorityListeners.indexOf(listener);

                    if (found !== -1) {
                      if (listener._getSceneGraphPriority() != null) {
                        logID(3502);
                      }

                      if (listener._getFixedPriority() !== fixedPriority) {
                        listener._setFixedPriority(fixedPriority);

                        this._setDirty(listener._getListenerID(), DIRTY_FIXED_PRIORITY);
                      }

                      return;
                    }
                  }
                }
              }

              setEnabled(enabled) {
                this._isEnabled = enabled;
              }

              isEnabled() {
                return this._isEnabled;
              }

              dispatchEvent(event) {
                if (!this._isEnabled) {
                  return;
                }

                this._updateDirtyFlagForSceneGraph();

                this._inDispatch++;

                if (!event || !event.getType) {
                  errorID(3511);
                  return;
                }

                if (touchEvents.includes(event.getType())) {
                  this._dispatchTouchEvent(event);

                  this._inDispatch--;
                  return;
                }

                const listenerID = __getListenerID(event);

                this._sortEventListeners(listenerID);

                const selListeners = this._listenersMap[listenerID];

                if (selListeners != null) {
                  this._dispatchEventToListeners(selListeners, this._onListenerCallback, event);

                  this._onUpdateListeners(selListeners);
                }

                this._inDispatch--;
              }

              _onListenerCallback(listener, event) {
                event.currentTarget = listener._target;
                const onEvent = listener.onEvent;

                if (onEvent) {
                  onEvent(event);
                }

                return event.isStopped();
              }

              dispatchCustomEvent(eventName, optionalUserData) {
                const ev = new legacyCC.Event.EventCustom(eventName);
                ev.setUserData(optionalUserData);
                this.dispatchEvent(ev);
              }

              _setDirtyForNode(node) {
                const selListeners = this._nodeListenersMap[node._id];

                if (selListeners !== undefined) {
                  for (let j = 0, len = selListeners.length; j < len; j++) {
                    const selListener = selListeners[j];

                    const listenerID = selListener._getListenerID();

                    if (!this._dirtyListeners[listenerID]) {
                      this._dirtyListeners[listenerID] = true;
                    }
                  }
                }

                if (node.children.length > 0) {
                  const _children = node.children;

                  for (let i = 0, len = _children ? _children.length : 0; i < len; i++) {
                    this._setDirtyForNode(_children[i]);
                  }
                }
              }

              _addListener(listener) {
                if (this._inDispatch === 0) {
                  this._forceAddEventListener(listener);
                } else {
                  this._toAddedListeners.push(listener);
                }
              }

              _forceAddEventListener(listener) {
                const listenerID = listener._getListenerID();

                let listeners = this._listenersMap[listenerID];

                if (!listeners) {
                  listeners = new _EventListenerVector();
                  this._listenersMap[listenerID] = listeners;
                }

                listeners.push(listener);

                if (listener._getFixedPriority() === 0) {
                  this._setDirty(listenerID, DIRTY_SCENE_GRAPH_PRIORITY);

                  const node = listener._getSceneGraphPriority();

                  if (node === null) {
                    logID(3507);
                  }

                  this._associateNodeAndEventListener(node, listener);

                  if (node.activeInHierarchy) {
                    this.resumeTarget(node);
                  }
                } else {
                  this._setDirty(listenerID, DIRTY_FIXED_PRIORITY);
                }
              }

              _getListeners(listenerID) {
                return this._listenersMap[listenerID];
              }

              _updateDirtyFlagForSceneGraph() {
                const locDirtyListeners = this._dirtyListeners;

                for (const selKey in locDirtyListeners) {
                  this._setDirty(selKey, DIRTY_SCENE_GRAPH_PRIORITY);

                  locDirtyListeners[selKey] = false;
                }
              }

              _removeAllListenersInVector(listenerVector) {
                if (!listenerVector) {
                  return;
                }

                let selListener;

                for (let i = listenerVector.length - 1; i >= 0; i--) {
                  selListener = listenerVector[i];

                  selListener._setRegistered(false);

                  if (selListener._getSceneGraphPriority() != null) {
                    this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);

                    selListener._setSceneGraphPriority(null);
                  }

                  if (this._inDispatch === 0) {
                    legacyCC.js.array.removeAt(listenerVector, i);
                  }
                }
              }

              _removeListenersForListenerID(listenerID) {
                const listeners = this._listenersMap[listenerID];

                if (listeners) {
                  const fixedPriorityListeners = listeners.getFixedPriorityListeners();
                  const sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();

                  this._removeAllListenersInVector(sceneGraphPriorityListeners);

                  this._removeAllListenersInVector(fixedPriorityListeners);

                  delete this._priorityDirtyFlagMap[listenerID];

                  if (!this._inDispatch) {
                    listeners.clear();
                    delete this._listenersMap[listenerID];
                  }
                }

                const locToAddedListeners = this._toAddedListeners;

                for (let i = locToAddedListeners.length - 1; i >= 0; i--) {
                  const listener = locToAddedListeners[i];

                  if (listener && listener._getListenerID() === listenerID) {
                    legacyCC.js.array.removeAt(locToAddedListeners, i);
                  }
                }
              }

              _sortEventListeners(listenerID) {
                let dirtyFlag = DIRTY_NONE;
                const locFlagMap = this._priorityDirtyFlagMap;

                if (locFlagMap[listenerID]) {
                  dirtyFlag = locFlagMap[listenerID];
                }

                if (dirtyFlag !== DIRTY_NONE) {
                  locFlagMap[listenerID] = DIRTY_NONE;

                  if (dirtyFlag & DIRTY_FIXED_PRIORITY) {
                    this._sortListenersOfFixedPriority(listenerID);
                  }

                  if (dirtyFlag & DIRTY_SCENE_GRAPH_PRIORITY) {
                    const rootEntity = legacyCC.director.getScene();

                    if (rootEntity) {
                      this._sortListenersOfSceneGraphPriority(listenerID);
                    }
                  }
                }
              }

              _sortListenersOfSceneGraphPriority(listenerID) {
                const listeners = this._getListeners(listenerID);

                if (!listeners) {
                  return;
                }

                const sceneGraphListener = listeners.getSceneGraphPriorityListeners();

                if (!sceneGraphListener || sceneGraphListener.length === 0) {
                  return;
                }

                const eventListeners = listeners.getSceneGraphPriorityListeners();
                eventListeners.forEach(listener => {
                  const node = listener._getSceneGraphPriority();

                  const trans = node._uiProps.uiTransformComp;
                  listener._cameraPriority = trans.cameraPriority;
                });
                eventListeners.sort(this._sortEventListenersOfSceneGraphPriorityDes);
              }

              _sortEventListenersOfSceneGraphPriorityDes(l1, l2) {
                const node1 = l1._getSceneGraphPriority();

                const node2 = l2._getSceneGraphPriority();

                if (!l2 || !node2 || !node2._activeInHierarchy || !node2._uiProps.uiTransformComp) {
                  return -1;
                } else if (!l1 || !node1 || !node1._activeInHierarchy || !node1._uiProps.uiTransformComp) {
                  return 1;
                }

                let p1 = node1;
                let p2 = node2;
                let ex = false;

                if (l1._cameraPriority !== l2._cameraPriority) {
                  return l2._cameraPriority - l1._cameraPriority;
                }

                while (p1.parent._id !== p2.parent._id) {
                  p1 = p1.parent.parent === null ? (ex = true) && node2 : p1.parent;
                  p2 = p2.parent.parent === null ? (ex = true) && node1 : p2.parent;
                }

                if (p1._id === p2._id) {
                  if (p1._id === node2._id) {
                    return -1;
                  }

                  if (p1._id === node1._id) {
                    return 1;
                  }
                }

                const priority1 = p1.getSiblingIndex();
                const priority2 = p2.getSiblingIndex();
                return ex ? priority1 - priority2 : priority2 - priority1;
              }

              _sortListenersOfFixedPriority(listenerID) {
                const listeners = this._listenersMap[listenerID];

                if (!listeners) {
                  return;
                }

                const fixedListeners = listeners.getFixedPriorityListeners();

                if (!fixedListeners || fixedListeners.length === 0) {
                  return;
                }

                fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
                let index = 0;

                for (const len = fixedListeners.length; index < len;) {
                  if (fixedListeners[index]._getFixedPriority() >= 0) {
                    break;
                  }

                  ++index;
                }

                listeners.gt0Index = index;
              }

              _sortListenersOfFixedPriorityAsc(l1, l2) {
                return l1._getFixedPriority() - l2._getFixedPriority();
              }

              _onUpdateListeners(listeners) {
                const fixedPriorityListeners = listeners.getFixedPriorityListeners();
                const sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                const toRemovedListeners = this._toRemovedListeners;

                if (sceneGraphPriorityListeners) {
                  for (let i = sceneGraphPriorityListeners.length - 1; i >= 0; i--) {
                    const selListener = sceneGraphPriorityListeners[i];

                    if (!selListener._isRegistered()) {
                      legacyCC.js.array.removeAt(sceneGraphPriorityListeners, i);
                      const idx = toRemovedListeners.indexOf(selListener);

                      if (idx !== -1) {
                        toRemovedListeners.splice(idx, 1);
                      }
                    }
                  }
                }

                if (fixedPriorityListeners) {
                  for (let i = fixedPriorityListeners.length - 1; i >= 0; i--) {
                    const selListener = fixedPriorityListeners[i];

                    if (!selListener._isRegistered()) {
                      legacyCC.js.array.removeAt(fixedPriorityListeners, i);
                      const idx = toRemovedListeners.indexOf(selListener);

                      if (idx !== -1) {
                        toRemovedListeners.splice(idx, 1);
                      }
                    }
                  }
                }

                if (sceneGraphPriorityListeners && sceneGraphPriorityListeners.length === 0) {
                  listeners.clearSceneGraphListeners();
                }

                if (fixedPriorityListeners && fixedPriorityListeners.length === 0) {
                  listeners.clearFixedListeners();
                }
              }

              _updateTouchListeners(event) {
                const locInDispatch = this._inDispatch;
                assertID(locInDispatch > 0, 3508);

                if (locInDispatch > 1) {
                  return;
                }

                let listeners;
                listeners = this._listenersMap[ListenerID$1.TOUCH_ONE_BY_ONE];

                if (listeners) {
                  this._onUpdateListeners(listeners);
                }

                listeners = this._listenersMap[ListenerID$1.TOUCH_ALL_AT_ONCE];

                if (listeners) {
                  this._onUpdateListeners(listeners);
                }

                assertID(locInDispatch === 1, 3509);
                const locToAddedListeners = this._toAddedListeners;

                if (locToAddedListeners.length !== 0) {
                  for (let i = 0, len = locToAddedListeners.length; i < len; i++) {
                    this._forceAddEventListener(locToAddedListeners[i]);
                  }

                  this._toAddedListeners.length = 0;
                }

                if (this._toRemovedListeners.length !== 0) {
                  this._cleanToRemovedListeners();
                }
              }

              _cleanToRemovedListeners() {
                const toRemovedListeners = this._toRemovedListeners;

                for (let i = 0; i < toRemovedListeners.length; ++i) {
                  const selListener = toRemovedListeners[i];

                  const listeners = this._listenersMap[selListener._getListenerID()];

                  if (!listeners) {
                    continue;
                  }

                  const fixedPriorityListeners = listeners.getFixedPriorityListeners();
                  const sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();

                  if (sceneGraphPriorityListeners) {
                    const idx = sceneGraphPriorityListeners.indexOf(selListener);

                    if (idx !== -1) {
                      sceneGraphPriorityListeners.splice(idx, 1);
                    }
                  }

                  if (fixedPriorityListeners) {
                    const idx = fixedPriorityListeners.indexOf(selListener);

                    if (idx !== -1) {
                      fixedPriorityListeners.splice(idx, 1);
                    }
                  }
                }

                toRemovedListeners.length = 0;
              }

              _onTouchEventCallback(listener, argsObj) {
                if (!listener._isRegistered()) {
                  return false;
                }

                const event = argsObj.event;
                const selTouch = event.touch;
                event.currentTarget = listener._getSceneGraphPriority();
                let isClaimed = false;
                let removedIdx = -1;
                const eventType = event.type;

                if (eventType === SystemEventType.TOUCH_START) {
                  if (!macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch) {
                    const node = eventManager._currentTouchListener._node;

                    if (!node || node.activeInHierarchy) {
                      return false;
                    }
                  }

                  if (listener.onTouchBegan) {
                    isClaimed = listener.onTouchBegan(selTouch, event);

                    if (isClaimed && listener._isRegistered() && !listener._isPaused()) {
                      listener._claimedTouches.push(selTouch);

                      if (macro.ENABLE_MULTI_TOUCH || !eventManager._currentTouch) {
                        eventManager._currentTouch = selTouch;
                      }

                      eventManager._currentTouchListener = listener;
                    }
                  }
                } else if (listener._claimedTouches.length > 0) {
                  removedIdx = listener._claimedTouches.indexOf(selTouch);

                  if (removedIdx !== -1) {
                    isClaimed = true;

                    if (!macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch && eventManager._currentTouch !== selTouch) {
                      return false;
                    }

                    if (eventType === SystemEventType.TOUCH_MOVE && listener.onTouchMoved) {
                      listener.onTouchMoved(selTouch, event);
                    } else if (eventType === SystemEventType.TOUCH_END) {
                      if (listener.onTouchEnded) {
                        listener.onTouchEnded(selTouch, event);
                      }

                      if (listener._isRegistered()) {
                        listener._claimedTouches.splice(removedIdx, 1);
                      }

                      if (macro.ENABLE_MULTI_TOUCH || eventManager._currentTouch === selTouch) {
                        eventManager._currentTouch = null;
                      }

                      eventManager._currentTouchListener = null;
                    } else if (eventType === SystemEventType.TOUCH_CANCEL) {
                      if (listener.onTouchCancelled) {
                        listener.onTouchCancelled(selTouch, event);
                      }

                      if (listener._isRegistered()) {
                        listener._claimedTouches.splice(removedIdx, 1);
                      }

                      if (macro.ENABLE_MULTI_TOUCH || eventManager._currentTouch === selTouch) {
                        eventManager._currentTouch = null;
                      }

                      eventManager._currentTouchListener = null;
                    }
                  }
                }

                if (event.isStopped()) {
                  eventManager._updateTouchListeners(event);

                  return true;
                }

                if (isClaimed && listener._isRegistered() && listener.swallowTouches) {
                  if (argsObj.needsMutableSet) {
                    argsObj.touches.splice(selTouch, 1);
                  }

                  return true;
                }

                return false;
              }

              _dispatchTouchEvent(event) {
                this._sortEventListeners(ListenerID$1.TOUCH_ONE_BY_ONE);

                this._sortEventListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);

                const oneByOneListeners = this._getListeners(ListenerID$1.TOUCH_ONE_BY_ONE);

                const allAtOnceListeners = this._getListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);

                if (oneByOneListeners === null && allAtOnceListeners === null) {
                  return;
                }

                const originalTouches = event.getTouches();
                const mutableTouches = legacyCC.js.array.copy(originalTouches);
                const oneByOneArgsObj = {
                  event,
                  needsMutableSet: oneByOneListeners && allAtOnceListeners,
                  touches: mutableTouches,
                  selTouch: null
                };

                if (oneByOneListeners) {
                  for (let i = 0; i < originalTouches.length; ++i) {
                    const originalTouch = originalTouches[i];
                    event.touch = originalTouch;
                    event.propagationStopped = event.propagationImmediateStopped = false;

                    this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
                  }
                }

                if (allAtOnceListeners && mutableTouches.length > 0) {
                  this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
                    event,
                    touches: mutableTouches
                  });

                  if (event.isStopped()) {
                    return;
                  }
                }

                this._updateTouchListeners(event);
              }

              _onTouchesEventCallback(listener, callbackParams) {
                if (!listener._isRegistered()) {
                  return false;
                }

                const event = callbackParams.event;
                const touches = callbackParams.touches;
                const eventType = event.type;
                event.currentTarget = listener._getSceneGraphPriority();

                if (eventType === SystemEventType.TOUCH_START && listener.onTouchesBegan) {
                  listener.onTouchesBegan(touches, event);
                } else if (eventType === SystemEventType.TOUCH_MOVE && listener.onTouchesMoved) {
                  listener.onTouchesMoved(touches, event);
                } else if (eventType === SystemEventType.TOUCH_END && listener.onTouchesEnded) {
                  listener.onTouchesEnded(touches, event);
                } else if (eventType === SystemEventType.TOUCH_CANCEL && listener.onTouchesCancelled) {
                  listener.onTouchesCancelled(touches, event);
                }

                if (event.isStopped()) {
                  eventManager._updateTouchListeners(event);

                  return true;
                }

                return false;
              }

              _associateNodeAndEventListener(node, listener) {
                let listeners = this._nodeListenersMap[node.uuid];

                if (!listeners) {
                  listeners = [];
                  this._nodeListenersMap[node.uuid] = listeners;
                }

                listeners.push(listener);
              }

              _dissociateNodeAndEventListener(node, listener) {
                const listeners = this._nodeListenersMap[node.uuid];

                if (listeners) {
                  legacyCC.js.array.remove(listeners, listener);

                  if (listeners.length === 0) {
                    delete this._nodeListenersMap[node.uuid];
                  }
                }
              }

              _dispatchEventToListeners(listeners, onEvent, eventOrArgs) {
                let shouldStopPropagation = false;
                const fixedPriorityListeners = listeners.getFixedPriorityListeners();
                const sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                let i = 0;

                if (fixedPriorityListeners) {
                  if (fixedPriorityListeners.length !== 0) {
                    for (; i < listeners.gt0Index; ++i) {
                      const selListener = fixedPriorityListeners[i];

                      if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                        shouldStopPropagation = true;
                        break;
                      }
                    }
                  }
                }

                if (sceneGraphPriorityListeners && !shouldStopPropagation) {
                  for (let i = 0; i < sceneGraphPriorityListeners.length; ++i) {
                    const selListener = sceneGraphPriorityListeners[i];

                    if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                      shouldStopPropagation = true;
                      break;
                    }
                  }
                }

                if (fixedPriorityListeners && !shouldStopPropagation) {
                  for (; i < fixedPriorityListeners.length; ++i) {
                    const selListener = fixedPriorityListeners[i];

                    if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                      shouldStopPropagation = true;
                      break;
                    }
                  }
                }
              }

              _setDirty(listenerID, flag) {
                const locDirtyFlagMap = this._priorityDirtyFlagMap;

                if (locDirtyFlagMap[listenerID] == null) {
                  locDirtyFlagMap[listenerID] = flag;
                } else {
                  locDirtyFlagMap[listenerID] |= flag;
                }
              }

              _sortNumberAsc(a, b) {
                return a - b;
              }

              _clearCurTouch() {
                this._currentTouchListener = null;
                this._currentTouch = null;
              }

              _removeListenerInCallback(listeners, callback) {
                if (listeners == null) {
                  return false;
                }

                for (let i = listeners.length - 1; i >= 0; i--) {
                  const selListener = listeners[i];

                  if (selListener._onCustomEvent === callback || selListener.onEvent === callback) {
                    selListener._setRegistered(false);

                    if (selListener._getSceneGraphPriority() != null) {
                      this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);

                      selListener._setSceneGraphPriority(null);
                    }

                    if (this._inDispatch === 0) {
                      legacyCC.js.array.removeAt(listeners, i);
                    } else {
                      this._toRemovedListeners.push(selListener);
                    }

                    return true;
                  }
                }

                return false;
              }

              _removeListenerInVector(listeners, listener) {
                if (listeners == null) {
                  return false;
                }

                for (let i = listeners.length - 1; i >= 0; i--) {
                  const selListener = listeners[i];

                  if (selListener === listener) {
                    selListener._setRegistered(false);

                    if (selListener._getSceneGraphPriority() != null) {
                      this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);

                      selListener._setSceneGraphPriority(null);
                    }

                    if (this._inDispatch === 0) {
                      legacyCC.js.array.removeAt(listeners, i);
                    } else {
                      this._toRemovedListeners.push(selListener);
                    }

                    return true;
                  }
                }

                return false;
              }

            }

            const eventManager = new EventManager();

            const Destroying$1 = CCObject.Flags.Destroying;

            let NodeEventType;

            (function (NodeEventType) {
              NodeEventType["TOUCH_START"] = "touch-start";
              NodeEventType["TOUCH_MOVE"] = "touch-move";
              NodeEventType["TOUCH_END"] = "touch-end";
              NodeEventType["TOUCH_CANCEL"] = "touch-cancel";
              NodeEventType["MOUSE_DOWN"] = "mouse-down";
              NodeEventType["MOUSE_MOVE"] = "mouse-move";
              NodeEventType["MOUSE_UP"] = "mouse-up";
              NodeEventType["MOUSE_WHEEL"] = "mouse-wheel";
              NodeEventType["MOUSE_ENTER"] = "mouse-enter";
              NodeEventType["MOUSE_LEAVE"] = "mouse-leave";
              NodeEventType["KEY_DOWN"] = "keydown";
              NodeEventType["KEY_UP"] = "keyup";
              NodeEventType["DEVICEMOTION"] = "devicemotion";
              NodeEventType["TRANSFORM_CHANGED"] = "transform-changed";
              NodeEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
              NodeEventType["SIZE_CHANGED"] = "size-changed";
              NodeEventType["ANCHOR_CHANGED"] = "anchor-changed";
              NodeEventType["COLOR_CHANGED"] = "color-changed";
              NodeEventType["CHILD_ADDED"] = "child-added";
              NodeEventType["CHILD_REMOVED"] = "child-removed";
              NodeEventType["PARENT_CHANGED"] = "parent-changed";
              NodeEventType["NODE_DESTROYED"] = "node-destroyed";
              NodeEventType["LAYER_CHANGED"] = "layer-changed";
              NodeEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
            })(NodeEventType || (NodeEventType = exports('cT', {})));

            var _dec$i, _class$i, _class2$f, _descriptor$d, _descriptor2$9, _descriptor3$7, _descriptor4$6, _descriptor5$4, _class3$8, _temp$f;
            const Destroying$2 = CCObject.Flags.Destroying;
            const DontDestroy$1 = CCObject.Flags.DontDestroy;
            const Deactivating$1 = CCObject.Flags.Deactivating;
            const TRANSFORM_ON = 1 << 0;
            const idGenerator$2 = new IDGenerator('Node');

            function getConstructor(typeOrClassName) {
              if (!typeOrClassName) {
                errorID(3804);
                return null;
              }

              if (typeof typeOrClassName === 'string') {
                return getClassByName(typeOrClassName);
              }

              return typeOrClassName;
            }

            let BaseNode = exports('fM', (_dec$i = ccclass('cc.BaseNode'), _dec$i(_class$i = (_class2$f = (_temp$f = _class3$8 = class BaseNode extends CCObject {
              get components() {
                return this._components;
              }

              get _persistNode() {
                return (this._objFlags & DontDestroy$1) > 0;
              }

              set _persistNode(value) {
                if (value) {
                  this._objFlags |= DontDestroy$1;
                } else {
                  this._objFlags &= ~DontDestroy$1;
                }
              }

              get name() {
                return this._name;
              }

              set name(value) {

                this._name = value;
              }

              get uuid() {
                return this._id;
              }

              get children() {
                return this._children;
              }

              get active() {
                return this._active;
              }

              set active(isActive) {
                if (this._active !== isActive) {
                  this._active = isActive;
                  const parent = this._parent;

                  if (parent) {
                    const couldActiveInScene = parent._activeInHierarchy;

                    if (couldActiveInScene) {
                      legacyCC.director._nodeActivator.activateNode(this, isActive);
                    }
                  }
                }
              }

              get activeInHierarchy() {
                return this._activeInHierarchy;
              }

              get parent() {
                return this._parent;
              }

              set parent(value) {
                this.setParent(value);
              }

              get scene() {
                return this._scene;
              }

              get eventProcessor() {
                return this._eventProcessor;
              }

              static _setScene(node) {
                node._updateScene();
              }

              static _findComponent(node, constructor) {
                const cls = constructor;
                const comps = node._components;

                if (cls._sealed) {
                  for (let i = 0; i < comps.length; ++i) {
                    const comp = comps[i];

                    if (comp.constructor === constructor) {
                      return comp;
                    }
                  }
                } else {
                  for (let i = 0; i < comps.length; ++i) {
                    const comp = comps[i];

                    if (comp instanceof constructor) {
                      return comp;
                    }
                  }
                }

                return null;
              }

              static _findComponents(node, constructor, components) {
                const cls = constructor;
                const comps = node._components;

                if (cls._sealed) {
                  for (let i = 0; i < comps.length; ++i) {
                    const comp = comps[i];

                    if (comp.constructor === constructor) {
                      components.push(comp);
                    }
                  }
                } else {
                  for (let i = 0; i < comps.length; ++i) {
                    const comp = comps[i];

                    if (comp instanceof constructor) {
                      components.push(comp);
                    }
                  }
                }
              }

              static _findChildComponent(children, constructor) {
                for (let i = 0; i < children.length; ++i) {
                  const node = children[i];

                  let comp = BaseNode._findComponent(node, constructor);

                  if (comp) {
                    return comp;
                  }

                  if (node._children.length > 0) {
                    comp = BaseNode._findChildComponent(node._children, constructor);

                    if (comp) {
                      return comp;
                    }
                  }
                }

                return null;
              }

              static _findChildComponents(children, constructor, components) {
                for (let i = 0; i < children.length; ++i) {
                  const node = children[i];

                  BaseNode._findComponents(node, constructor, components);

                  if (node._children.length > 0) {
                    BaseNode._findChildComponents(node._children, constructor, components);
                  }
                }
              }

              _updateScene() {
                if (this._parent == null) {
                  error('Node %s(%s) has not attached to a scene.', this.name, this.uuid);
                } else {
                  this._scene = this._parent._scene;
                }
              }

              constructor(name) {
                super(name);

                _initializerDefineProperty(this, "_parent", _descriptor$d, this);

                _initializerDefineProperty(this, "_children", _descriptor2$9, this);

                _initializerDefineProperty(this, "_active", _descriptor3$7, this);

                _initializerDefineProperty(this, "_components", _descriptor4$6, this);

                _initializerDefineProperty(this, "_prefab", _descriptor5$4, this);

                this._scene = null;
                this._activeInHierarchy = false;
                this._id = idGenerator$2.getNewId();
                this._name = void 0;
                this._eventProcessor = new legacyCC.NodeEventProcessor(this);
                this._eventMask = 0;
                this._siblingIndex = 0;
                this._originalSceneId = '';
                this._registerIfAttached =  undefined ;
                this._name = name !== undefined ? name : 'New Node';
              }

              attr(attrs) {
                mixin(this, attrs);
              }

              getParent() {
                return this._parent;
              }

              setParent(value, keepWorldTransform = false) {
                if (this._parent === value) {
                  return;
                }

                const oldParent = this._parent;
                const newParent = value;

                if ( oldParent && oldParent._objFlags & Deactivating$1) {
                  errorID(3821);
                }

                this._parent = newParent;
                this._siblingIndex = 0;

                this._onSetParent(oldParent, keepWorldTransform);

                if (this.emit) {
                  this.emit(NodeEventType.PARENT_CHANGED, oldParent);
                }

                if (oldParent) {
                  if (!(oldParent._objFlags & Destroying$2)) {
                    const removeAt = oldParent._children.indexOf(this);

                    oldParent._children.splice(removeAt, 1);

                    oldParent._updateSiblingIndex();

                    if (oldParent.emit) {
                      oldParent.emit(NodeEventType.CHILD_REMOVED, this);
                    }
                  }
                }

                if (newParent) {
                  if ( newParent._objFlags & Deactivating$1) {
                    errorID(3821);
                  }

                  newParent._children.push(this);

                  this._siblingIndex = newParent._children.length - 1;

                  if (newParent.emit) {
                    newParent.emit(NodeEventType.CHILD_ADDED, this);
                  }
                }

                this._onHierarchyChanged(oldParent);
              }

              getChildByUuid(uuid) {
                if (!uuid) {
                  log('Invalid uuid');
                  return null;
                }

                const locChildren = this._children;

                for (let i = 0, len = locChildren.length; i < len; i++) {
                  if (locChildren[i]._id === uuid) {
                    return locChildren[i];
                  }
                }

                return null;
              }

              getChildByName(name) {
                if (!name) {
                  log('Invalid name');
                  return null;
                }

                const locChildren = this._children;

                for (let i = 0, len = locChildren.length; i < len; i++) {
                  if (locChildren[i]._name === name) {
                    return locChildren[i];
                  }
                }

                return null;
              }

              getChildByPath(path) {
                const segments = path.split('/');
                let lastNode = this;

                for (let i = 0; i < segments.length; ++i) {
                  const segment = segments[i];

                  if (segment.length === 0) {
                    continue;
                  }

                  const next = lastNode.children.find(childNode => childNode.name === segment);

                  if (!next) {
                    return null;
                  }

                  lastNode = next;
                }

                return lastNode;
              }

              addChild(child) {
                child.setParent(this);
              }

              insertChild(child, siblingIndex) {
                child.parent = this;
                child.setSiblingIndex(siblingIndex);
              }

              getSiblingIndex() {
                return this._siblingIndex;
              }

              setSiblingIndex(index) {
                if (!this._parent) {
                  return;
                }

                if (this._parent._objFlags & Deactivating$1) {
                  errorID(3821);
                  return;
                }

                const siblings = this._parent._children;
                index = index !== -1 ? index : siblings.length - 1;
                const oldIndex = siblings.indexOf(this);

                if (index !== oldIndex) {
                  siblings.splice(oldIndex, 1);

                  if (index < siblings.length) {
                    siblings.splice(index, 0, this);
                  } else {
                    siblings.push(this);
                  }

                  this._parent._updateSiblingIndex();

                  if (this._onSiblingIndexChanged) {
                    this._onSiblingIndexChanged(index);
                  }
                }
              }

              walk(preFunc, postFunc) {
                let index = 1;
                let children = null;
                let curr = null;
                let i = 0;
                let stack = BaseNode._stacks[BaseNode._stackId];

                if (!stack) {
                  stack = [];

                  BaseNode._stacks.push(stack);
                }

                BaseNode._stackId++;
                stack.length = 0;
                stack[0] = this;
                let parent = null;
                let afterChildren = false;

                while (index) {
                  index--;
                  curr = stack[index];

                  if (!curr) {
                    continue;
                  }

                  if (!afterChildren && preFunc) {
                    preFunc(curr);
                  } else if (afterChildren && postFunc) {
                    postFunc(curr);
                  }

                  stack[index] = null;

                  if (afterChildren) {
                    if (parent === this._parent) break;
                    afterChildren = false;
                  } else {
                    if (curr._children.length > 0) {
                      parent = curr;
                      children = curr._children;
                      i = 0;
                      stack[index] = children[i];
                      index++;
                    } else {
                      stack[index] = curr;
                      index++;
                      afterChildren = true;
                    }

                    continue;
                  }

                  if (children) {
                    i++;

                    if (children[i]) {
                      stack[index] = children[i];
                      index++;
                    } else if (parent) {
                      stack[index] = parent;
                      index++;
                      afterChildren = true;

                      if (parent._parent) {
                        children = parent._parent._children;
                        i = children.indexOf(parent);
                        parent = parent._parent;
                      } else {
                        parent = null;
                        children = null;
                      }

                      if (i < 0) {
                        break;
                      }
                    }
                  }
                }

                stack.length = 0;
                BaseNode._stackId--;
              }

              removeFromParent() {
                if (this._parent) {
                  this._parent.removeChild(this);
                }
              }

              removeChild(child) {
                if (this._children.indexOf(child) > -1) {
                  child.parent = null;
                }
              }

              removeAllChildren() {
                const children = this._children;

                for (let i = children.length - 1; i >= 0; i--) {
                  const node = children[i];

                  if (node) {
                    node.parent = null;
                  }
                }

                this._children.length = 0;
              }

              isChildOf(parent) {
                let child = this;

                do {
                  if (child === parent) {
                    return true;
                  }

                  child = child._parent;
                } while (child);

                return false;
              }

              getComponent(typeOrClassName) {
                const constructor = getConstructor(typeOrClassName);

                if (constructor) {
                  return BaseNode._findComponent(this, constructor);
                }

                return null;
              }

              getComponents(typeOrClassName) {
                const constructor = getConstructor(typeOrClassName);
                const components = [];

                if (constructor) {
                  BaseNode._findComponents(this, constructor, components);
                }

                return components;
              }

              getComponentInChildren(typeOrClassName) {
                const constructor = getConstructor(typeOrClassName);

                if (constructor) {
                  return BaseNode._findChildComponent(this._children, constructor);
                }

                return null;
              }

              getComponentsInChildren(typeOrClassName) {
                const constructor = getConstructor(typeOrClassName);
                const components = [];

                if (constructor) {
                  BaseNode._findComponents(this, constructor, components);

                  BaseNode._findChildComponents(this._children, constructor, components);
                }

                return components;
              }

              addComponent(typeOrClassName) {

                let constructor;

                if (typeof typeOrClassName === 'string') {
                  constructor = getClassByName(typeOrClassName);

                  if (!constructor) {
                    if (legacyCC._RF.peek()) {
                      errorID(3808, typeOrClassName);
                    }

                    throw TypeError(getError(3807, typeOrClassName));
                  }
                } else {
                  if (!typeOrClassName) {
                    throw TypeError(getError(3804));
                  }

                  constructor = typeOrClassName;
                }

                if (typeof constructor !== 'function') {
                  throw TypeError(getError(3809));
                }

                if (!isChildClassOf(constructor, legacyCC.Component)) {
                  throw TypeError(getError(3810));
                }

                const ReqComp = constructor._requireComponent;

                if (ReqComp && !this.getComponent(ReqComp)) {
                  this.addComponent(ReqComp);
                }

                const component = new constructor();
                component.node = this;

                this._components.push(component);

                if (this._activeInHierarchy) {
                  legacyCC.director._nodeActivator.activateComp(component);
                }

                return component;
              }

              removeComponent(component) {
                if (!component) {
                  errorID(3813);
                  return;
                }

                let componentInstance = null;

                if (component instanceof Component) {
                  componentInstance = component;
                } else {
                  componentInstance = this.getComponent(component);
                }

                if (componentInstance) {
                  componentInstance.destroy();
                }
              }

              on(type, callback, target, useCapture = false) {
                switch (type) {
                  case NodeEventType.TRANSFORM_CHANGED:
                    this._eventMask |= TRANSFORM_ON;
                    break;
                }

                this._eventProcessor.on(type, callback, target, useCapture);
              }

              off(type, callback, target, useCapture = false) {
                this._eventProcessor.off(type, callback, target, useCapture);

                const hasListeners = this._eventProcessor.hasEventListener(type);

                if (!hasListeners) {
                  switch (type) {
                    case NodeEventType.TRANSFORM_CHANGED:
                      this._eventMask &= ~TRANSFORM_ON;
                      break;
                  }
                }
              }

              once(type, callback, target, useCapture) {
                this._eventProcessor.once(type, callback, target, useCapture);
              }

              emit(type, arg0, arg1, arg2, arg3, arg4) {
                this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
              }

              dispatchEvent(event) {
                this._eventProcessor.dispatchEvent(event);
              }

              hasEventListener(type, callback, target) {
                return this._eventProcessor.hasEventListener(type, callback, target);
              }

              targetOff(target) {
                this._eventProcessor.targetOff(target);

                if (this._eventMask & TRANSFORM_ON && !this._eventProcessor.hasEventListener(NodeEventType.TRANSFORM_CHANGED)) {
                  this._eventMask &= ~TRANSFORM_ON;
                }
              }

              destroy() {
                if (super.destroy()) {
                  this.active = false;
                  return true;
                }

                return false;
              }

              destroyAllChildren() {
                const children = this._children;

                for (let i = 0; i < children.length; ++i) {
                  children[i].destroy();
                }
              }

              _removeComponent(component) {
                if (!component) {
                  errorID(3814);
                  return;
                }

                if (!(this._objFlags & Destroying$2)) {
                  const i = this._components.indexOf(component);

                  if (i !== -1) {
                    this._components.splice(i, 1);
                  } else if (component.node !== this) {
                    errorID(3815);
                  }
                }
              }

              _updateSiblingIndex() {
                for (let i = 0; i < this._children.length; ++i) {
                  this._children[i]._siblingIndex = i;
                }

                this.emit(NodeEventType.SIBLING_ORDER_CHANGED);
              }

              _onSetParent(oldParent, keepWorldTransform = false) {
                if (this._parent) {
                  if ((oldParent == null || oldParent._scene !== this._parent._scene) && this._parent._scene != null) {
                    this.walk(BaseNode._setScene);
                  }
                }
              }

              _onPostActivated(active) {}

              _onBatchCreated(dontSyncChildPrefab) {
                if (this._parent) {
                  this._siblingIndex = this._parent.children.indexOf(this);
                }
              }

              _onPreDestroy() {
                this._onPreDestroyBase();
              }

              _onHierarchyChanged(oldParent) {
                return this._onHierarchyChangedBase(oldParent);
              }

              _instantiate(cloned, isSyncedNode) {
                if (!cloned) {
                  cloned = legacyCC.instantiate._clone(this, this);
                }

                const newPrefabInfo = cloned._prefab;

                cloned._parent = null;

                cloned._onBatchCreated(isSyncedNode);

                return cloned;
              }

              _onHierarchyChangedBase(oldParent) {
                const newParent = this._parent;

                if (this._persistNode && !(newParent instanceof legacyCC.Scene)) {
                  legacyCC.game.removePersistRootNode(this);
                }

                const shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);

                if (this._activeInHierarchy !== shouldActiveNow) {
                  legacyCC.director._nodeActivator.activateNode(this, shouldActiveNow);
                }
              }

              _onPreDestroyBase() {
                this._objFlags |= Destroying$2;
                const parent = this._parent;
                const destroyByParent = !!parent && (parent._objFlags & Destroying$2) !== 0;

                if (!destroyByParent && EDITOR) {
                  this._registerIfAttached(false);
                }

                if (this._persistNode) {
                  legacyCC.game.removePersistRootNode(this);
                }

                if (!destroyByParent) {
                  if (parent) {
                    this.emit(NodeEventType.PARENT_CHANGED, this);

                    const childIndex = parent._children.indexOf(this);

                    parent._children.splice(childIndex, 1);

                    this._siblingIndex = 0;

                    parent._updateSiblingIndex();

                    if (parent.emit) {
                      parent.emit(NodeEventType.CHILD_REMOVED, this);
                    }
                  }
                }

                this.emit(NodeEventType.NODE_DESTROYED, this);

                this._eventProcessor.destroy();

                const children = this._children;

                for (let i = 0; i < children.length; ++i) {
                  children[i]._destroyImmediate();
                }

                const comps = this._components;

                for (let i = 0; i < comps.length; ++i) {
                  comps[i]._destroyImmediate();
                }

                return destroyByParent;
              }

            }, _class3$8.idGenerator = idGenerator$2, _class3$8._stacks = [[]], _class3$8._stackId = 0, _temp$f), (_applyDecoratedDescriptor(_class2$f.prototype, "_persistNode", [property], Object.getOwnPropertyDescriptor(_class2$f.prototype, "_persistNode"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "name", [editable], Object.getOwnPropertyDescriptor(_class2$f.prototype, "name"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "children", [editable], Object.getOwnPropertyDescriptor(_class2$f.prototype, "children"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "active", [editable], Object.getOwnPropertyDescriptor(_class2$f.prototype, "active"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "activeInHierarchy", [editable], Object.getOwnPropertyDescriptor(_class2$f.prototype, "activeInHierarchy"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "parent", [editable], Object.getOwnPropertyDescriptor(_class2$f.prototype, "parent"), _class2$f.prototype), _descriptor$d = _applyDecoratedDescriptor(_class2$f.prototype, "_parent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$9 = _applyDecoratedDescriptor(_class2$f.prototype, "_children", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor3$7 = _applyDecoratedDescriptor(_class2$f.prototype, "_active", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor4$6 = _applyDecoratedDescriptor(_class2$f.prototype, "_components", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor5$4 = _applyDecoratedDescriptor(_class2$f.prototype, "_prefab", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$f)) || _class$i));
            legacyCC._BaseNode = BaseNode;

            function createNodeWithPrefab(node) {
              const prefabInfo = node._prefab;

              if (!prefabInfo) {
                return;
              }

              const prefabInstance = prefabInfo.instance;

              if (!prefabInstance) {
                return;
              }

              if (!prefabInfo.asset) {
                {
                  errorID(3701, node.name);
                }

                prefabInfo.instance = undefined;
                return;
              }

              const _objFlags = node._objFlags;
              const _parent = node._parent;
              const _id = node._id;
              const _prefab = node._prefab;
              const editorExtras = node[editorExtrasTag];
              legacyCC.game._isCloning = true;

              {
                prefabInfo.asset._doInstantiate(node);
              }

              legacyCC.game._isCloning = false;
              node._objFlags = _objFlags;
              node._parent = _parent;
              node._id = _id;

              if (node._prefab) {
                node._prefab.instance = _prefab === null || _prefab === void 0 ? void 0 : _prefab.instance;
              }
            }
            function generateTargetMap(node, targetMap, isRoot) {
              var _node$_prefab;

              if (!targetMap) {
                return;
              }

              let curTargetMap = targetMap;
              const prefabInstance = (_node$_prefab = node._prefab) === null || _node$_prefab === void 0 ? void 0 : _node$_prefab.instance;

              if (!isRoot && prefabInstance) {
                targetMap[prefabInstance.fileId] = {};
                curTargetMap = targetMap[prefabInstance.fileId];
              }

              const prefabInfo = node._prefab;

              if (prefabInfo) {
                curTargetMap[prefabInfo.fileId] = node;
              }

              const components = node.components;

              for (let i = 0; i < components.length; i++) {
                const comp = components[i];

                if (comp.__prefab) {
                  curTargetMap[comp.__prefab.fileId] = comp;
                }
              }

              for (let i = 0; i < node.children.length; i++) {
                const childNode = node.children[i];
                generateTargetMap(childNode, curTargetMap, false);
              }
            }
            function getTarget(localID, targetMap) {
              if (!localID) {
                return null;
              }

              let target = null;
              let targetIter = targetMap;

              for (let i = 0; i < localID.length; i++) {
                if (!targetIter) {
                  return null;
                }

                targetIter = targetIter[localID[i]];
              }

              target = targetIter;
              return target;
            }
            function applyMountedChildren(node, mountedChildren, targetMap) {
              if (!mountedChildren) {
                return;
              }

              for (let i = 0; i < mountedChildren.length; i++) {
                const childInfo = mountedChildren[i];

                if (childInfo && childInfo.targetInfo) {
                  const target = getTarget(childInfo.targetInfo.localID, targetMap);

                  if (!target) {
                    continue;
                  }

                  let curTargetMap = targetMap;
                  const localID = childInfo.targetInfo.localID;

                  if (localID.length > 0) {
                    for (let i = 0; i < localID.length - 1; i++) {
                      curTargetMap = curTargetMap[localID[i]];
                    }
                  }

                  if (childInfo.nodes) {
                    for (let i = 0; i < childInfo.nodes.length; i++) {
                      const childNode = childInfo.nodes[i];

                      if (!childNode) {
                        continue;
                      }

                      target._children.push(childNode);

                      childNode._parent = target;

                      generateTargetMap(childNode, curTargetMap, false);
                      childNode._siblingIndex = target._children.length - 1;

                      childNode._onBatchCreated(false);
                    }
                  }
                }
              }
            }
            function applyMountedComponents(node, mountedComponents, targetMap) {
              if (!mountedComponents) {
                return;
              }

              for (let i = 0; i < mountedComponents.length; i++) {
                const componentsInfo = mountedComponents[i];

                if (componentsInfo && componentsInfo.targetInfo) {
                  const target = getTarget(componentsInfo.targetInfo.localID, targetMap);

                  if (!target) {
                    continue;
                  }

                  if (componentsInfo.components) {
                    for (let i = 0; i < componentsInfo.components.length; i++) {
                      const comp = componentsInfo.components[i];

                      if (!comp) {
                        continue;
                      }

                      comp.node = target;

                      target._components.push(comp);
                    }
                  }
                }
              }
            }
            function applyRemovedComponents(node, removedComponents, targetMap) {
              if (!removedComponents) {
                return;
              }

              for (let i = 0; i < removedComponents.length; i++) {
                const targetInfo = removedComponents[i];

                if (targetInfo) {
                  const target = getTarget(targetInfo.localID, targetMap);

                  if (!target || !target.node) {
                    continue;
                  }

                  const index = target.node.components.indexOf(target);

                  if (index >= 0) {
                    target.node._components.splice(index, 1);
                  }
                }
              }
            }
            function applyPropertyOverrides(node, propertyOverrides, targetMap) {
              if (propertyOverrides.length <= 0) {
                return;
              }

              let target = null;

              for (let i = 0; i < propertyOverrides.length; i++) {
                const propOverride = propertyOverrides[i];

                if (propOverride && propOverride.targetInfo) {
                  const targetInfo = propOverride.targetInfo;
                  target = getTarget(targetInfo.localID, targetMap);

                  if (!target) {
                    continue;
                  }

                  let targetPropOwner = target;
                  const propertyPath = propOverride.propertyPath.slice();

                  if (propertyPath.length > 0) {
                    const targetPropName = propertyPath.pop();

                    if (!targetPropName) {
                      continue;
                    }

                    for (let i = 0; i < propertyPath.length; i++) {
                      const propName = propertyPath[i];
                      targetPropOwner = targetPropOwner[propName];

                      if (!targetPropOwner) {
                        break;
                      }
                    }

                    if (!targetPropOwner) {
                      continue;
                    }

                    if (Array.isArray(targetPropOwner)) {
                      if (targetPropName === 'length') {
                        targetPropOwner[targetPropName] = propOverride.value;
                      } else {
                        const index = Number.parseInt(targetPropName);

                        if (Number.isInteger(index) && index < targetPropOwner.length) {
                          targetPropOwner[targetPropName] = propOverride.value;
                        }
                      }
                    } else {
                      targetPropOwner[targetPropName] = propOverride.value;
                    }
                  }
                }
              }
            }
            function applyTargetOverrides(node) {
              var _node$_prefab2;

              const targetOverrides = (_node$_prefab2 = node._prefab) === null || _node$_prefab2 === void 0 ? void 0 : _node$_prefab2.targetOverrides;

              if (targetOverrides) {
                for (let i = 0; i < targetOverrides.length; i++) {
                  var _targetOverride$targe, _targetOverride$targe2;

                  const targetOverride = targetOverrides[i];
                  let source = targetOverride.source;
                  const sourceInfo = targetOverride.sourceInfo;

                  if (sourceInfo) {
                    var _targetOverride$sourc, _targetOverride$sourc2;

                    const sourceInstance = (_targetOverride$sourc = targetOverride.source) === null || _targetOverride$sourc === void 0 ? void 0 : (_targetOverride$sourc2 = _targetOverride$sourc._prefab) === null || _targetOverride$sourc2 === void 0 ? void 0 : _targetOverride$sourc2.instance;

                    if (sourceInstance && sourceInstance.targetMap) {
                      source = getTarget(sourceInfo.localID, sourceInstance.targetMap);
                    }
                  }

                  if (!source) {
                    continue;
                  }

                  let target = null;
                  const targetInfo = targetOverride.targetInfo;

                  if (!targetInfo) {
                    continue;
                  }

                  const targetInstance = (_targetOverride$targe = targetOverride.target) === null || _targetOverride$targe === void 0 ? void 0 : (_targetOverride$targe2 = _targetOverride$targe._prefab) === null || _targetOverride$targe2 === void 0 ? void 0 : _targetOverride$targe2.instance;

                  if (!targetInstance || !targetInstance.targetMap) {
                    continue;
                  }

                  target = getTarget(targetInfo.localID, targetInstance.targetMap);

                  if (!target) {
                    continue;
                  }

                  const propertyPath = targetOverride.propertyPath.slice();
                  let targetPropOwner = source;

                  if (propertyPath.length > 0) {
                    const targetPropName = propertyPath.pop();

                    if (!targetPropName) {
                      return;
                    }

                    for (let i = 0; i < propertyPath.length; i++) {
                      const propName = propertyPath[i];
                      targetPropOwner = targetPropOwner[propName];

                      if (!targetPropOwner) {
                        break;
                      }
                    }

                    if (!targetPropOwner) {
                      continue;
                    }

                    targetPropOwner[targetPropName] = target;
                  }
                }
              }
            }

            var _dec$j, _dec2$7, _class$j, _class2$g, _descriptor$e, _descriptor2$a, _descriptor3$8, _descriptor4$7, _descriptor5$5, _class3$9, _temp$g;
            const v3_a = new Vec3();
            const q_a = new Quat();
            const q_b = new Quat();
            const qt_1$1 = new Quat();
            const m3_1$2 = new Mat3();
            const m3_scaling = new Mat3();
            const m4_1$1 = new Mat4();
            const dirtyNodes = [];
            const nativeDirtyNodes = [];

            class BookOfChange {
              constructor() {
                this._chunks = [];
                this._freelists = [];

                this._createChunk();
              }

              alloc() {
                const chunkCount = this._freelists.length;

                for (let i = 0; i < chunkCount; ++i) {
                  if (!this._freelists[i].length) continue;
                  return this._createView(i);
                }

                this._createChunk();

                return this._createView(chunkCount);
              }

              free(view, idx) {
                const chunkCount = this._freelists.length;

                for (let i = 0; i < chunkCount; ++i) {
                  if (this._chunks[i] !== view) continue;

                  this._freelists[i].push(idx);

                  return;
                }
              }

              clear() {
                const chunkCount = this._chunks.length;

                for (let i = 0; i < chunkCount; ++i) {
                  this._chunks[i].fill(0);
                }
              }

              _createChunk() {
                this._chunks.push(new Uint32Array(BookOfChange.CAPACITY_PER_CHUNK));

                const freelist = [];

                for (let i = 0; i < BookOfChange.CAPACITY_PER_CHUNK; ++i) freelist.push(i);

                this._freelists.push(freelist);
              }

              _createView(chunkIdx) {
                const chunk = this._chunks[chunkIdx];

                const offset = this._freelists[chunkIdx].pop();

                return [chunk, offset];
              }

            }

            BookOfChange.CAPACITY_PER_CHUNK = 256;
            const bookOfChange = new BookOfChange();
            const reserveContentsForAllSyncablePrefabTag = Symbol('ReserveContentsForAllSyncablePrefab');
            let Node$1 = exports('cA', (_dec$j = ccclass('cc.Node'), _dec2$7 = type(Vec3), _dec$j(_class$j = (_class2$g = (_temp$g = _class3$9 = class Node extends BaseNode {
              get _dirtyFlags() {
                return this._dirtyFlagsPri;
              }

              set _dirtyFlags(flags) {
                this._dirtyFlagsPri = flags;

                {
                  this._nativeDirtyFlag[0] = flags;
                }
              }

              _init() {
                const [chunk, offset] = bookOfChange.alloc();
                this._hasChangedFlagsChunk = chunk;
                this._hasChangedFlagsOffset = offset;

                {
                  this._nodeHandle = NodePool.alloc();
                  this._pos = new Vec3(NodePool.getTypedArray(this._nodeHandle, NodeView.WORLD_POSITION));
                  this._rot = new Quat(NodePool.getTypedArray(this._nodeHandle, NodeView.WORLD_ROTATION));
                  this._scale = new Vec3(NodePool.getTypedArray(this._nodeHandle, NodeView.WORLD_SCALE));
                  this._lpos = new Vec3(NodePool.getTypedArray(this._nodeHandle, NodeView.LOCAL_POSITION));
                  this._lrot = new Quat(NodePool.getTypedArray(this._nodeHandle, NodeView.LOCAL_ROTATION));
                  this._lscale = new Vec3(NodePool.getTypedArray(this._nodeHandle, NodeView.LOCAL_SCALE));
                  this._mat = new Mat4(NodePool.getTypedArray(this._nodeHandle, NodeView.WORLD_MATRIX));
                  this._nativeLayer = NodePool.getTypedArray(this._nodeHandle, NodeView.LAYER);
                  this._nativeDirtyFlag = NodePool.getTypedArray(this._nodeHandle, NodeView.DIRTY_FLAG);

                  this._scale.set(1, 1, 1);

                  this._lscale.set(1, 1, 1);

                  this._nativeLayer[0] = this._layer;
                  this._nativeObj = new NativeNode();
                  const flagBuffer = new Uint32Array(chunk.buffer, chunk.byteOffset + offset * 4, 1);

                  this._nativeObj.initWithData(NodePool.getBuffer(this._nodeHandle), flagBuffer, nativeDirtyNodes);
                }
              }

              constructor(name) {
                super(name);
                this._uiProps = new NodeUIProperties(this);
                this._static = false;

                _initializerDefineProperty(this, "_lpos", _descriptor$e, this);

                _initializerDefineProperty(this, "_lrot", _descriptor2$a, this);

                _initializerDefineProperty(this, "_lscale", _descriptor3$8, this);

                _initializerDefineProperty(this, "_layer", _descriptor4$7, this);

                _initializerDefineProperty(this, "_euler", _descriptor5$5, this);

                this._dirtyFlagsPri = TransformBit.NONE;
                this._eulerDirty = false;
                this._nodeHandle = NULL_HANDLE;

                this._init();
              }

              static isNode(obj) {
                return obj instanceof Node && (obj.constructor === Node || !(obj instanceof legacyCC.Scene));
              }

              _onPreDestroy() {
                const result = this._onPreDestroyBase();

                {
                  if (this._nodeHandle) {
                    NodePool.free(this._nodeHandle);
                    this._nodeHandle = NULL_HANDLE;
                  }

                  this._nativeObj = null;
                }

                bookOfChange.free(this._hasChangedFlagsChunk, this._hasChangedFlagsOffset);
                return result;
              }

              get native() {
                return this._nativeObj;
              }

              get position() {
                return this._lpos;
              }

              set position(val) {
                this.setPosition(val);
              }

              get worldPosition() {
                this.updateWorldTransform();
                return this._pos;
              }

              set worldPosition(val) {
                this.setWorldPosition(val);
              }

              get rotation() {
                return this._lrot;
              }

              set rotation(val) {
                this.setRotation(val);
              }

              set eulerAngles(val) {
                this.setRotationFromEuler(val.x, val.y, val.z);
              }

              get eulerAngles() {
                if (this._eulerDirty) {
                  Quat.toEuler(this._euler, this._lrot);
                  this._eulerDirty = false;
                }

                return this._euler;
              }

              get angle() {
                return this._euler.z;
              }

              set angle(val) {
                Vec3.set(this._euler, 0, 0, val);
                Quat.fromAngleZ(this._lrot, val);
                this._eulerDirty = false;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              get worldRotation() {
                this.updateWorldTransform();
                return this._rot;
              }

              set worldRotation(val) {
                this.setWorldRotation(val);
              }

              get scale() {
                return this._lscale;
              }

              set scale(val) {
                this.setScale(val);
              }

              get worldScale() {
                this.updateWorldTransform();
                return this._scale;
              }

              set worldScale(val) {
                this.setWorldScale(val);
              }

              set matrix(val) {
                Mat4.toRTS(val, this._lrot, this._lpos, this._lscale);
                this.invalidateChildren(TransformBit.TRS);
                this._eulerDirty = true;

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.TRS);
                }
              }

              get worldMatrix() {
                this.updateWorldTransform();
                return this._mat;
              }

              get forward() {
                return Vec3.transformQuat(new Vec3(), Vec3.FORWARD, this.worldRotation);
              }

              set forward(dir) {
                const len = dir.length();
                Vec3.multiplyScalar(v3_a, dir, -1 / len);
                Quat.fromViewUp(q_a, v3_a);
                this.setWorldRotation(q_a);
              }

              get up() {
                return Vec3.transformQuat(new Vec3(), Vec3.UP, this.worldRotation);
              }

              get right() {
                return Vec3.transformQuat(new Vec3(), Vec3.RIGHT, this.worldRotation);
              }

              set layer(l) {
                this._layer = l;

                {
                  this._nativeLayer[0] = this._layer;
                }

                this.emit(NodeEventType.LAYER_CHANGED, this._layer);
              }

              get layer() {
                return this._layer;
              }

              get hasChangedFlags() {
                return this._hasChangedFlagsChunk[this._hasChangedFlagsOffset];
              }

              set hasChangedFlags(val) {
                this._hasChangedFlagsChunk[this._hasChangedFlagsOffset] = val;
              }

              [serializeTag](serializationOutput, context) {
                {
                  serializationOutput.writeThis();
                  return;
                }
              }

              setParent(value, keepWorldTransform = false) {
                if (keepWorldTransform) {
                  this.updateWorldTransform();
                }

                super.setParent(value, keepWorldTransform);

                {
                  this._nativeObj.setParent(this.parent ? this.parent.native : null);
                }
              }

              _onSetParent(oldParent, keepWorldTransform) {
                super._onSetParent(oldParent, keepWorldTransform);

                if (keepWorldTransform) {
                  const parent = this._parent;

                  if (parent) {
                    parent.updateWorldTransform();
                    Mat4.multiply(m4_1$1, Mat4.invert(m4_1$1, parent._mat), this._mat);
                    Mat4.toRTS(m4_1$1, this._lrot, this._lpos, this._lscale);
                  } else {
                    Vec3.copy(this._lpos, this._pos);
                    Quat.copy(this._lrot, this._rot);
                    Vec3.copy(this._lscale, this._scale);
                  }

                  this._eulerDirty = true;
                }

                this.invalidateChildren(TransformBit.TRS);
              }

              _onHierarchyChanged(oldParent) {
                this.eventProcessor.reattach();

                super._onHierarchyChangedBase(oldParent);
              }

              _onBatchCreated(dontSyncChildPrefab) {
                var _this$_prefab4;

                {
                  var _this$parent;

                  this._nativeLayer[0] = this._layer;

                  this._nativeObj.setParent((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.native);
                }

                const prefabInstance = (_this$_prefab4 = this._prefab) === null || _this$_prefab4 === void 0 ? void 0 : _this$_prefab4.instance;

                if (!dontSyncChildPrefab && prefabInstance) {
                  createNodeWithPrefab(this);
                }

                this.hasChangedFlags = TransformBit.TRS;
                this._dirtyFlags |= TransformBit.TRS;
                this._uiProps.uiTransformDirty = true;
                const len = this._children.length;

                for (let i = 0; i < len; ++i) {
                  this._children[i]._siblingIndex = i;

                  this._children[i]._onBatchCreated(dontSyncChildPrefab);
                }

                if (!dontSyncChildPrefab && prefabInstance) {
                  const targetMap = {};
                  prefabInstance.targetMap = targetMap;
                  generateTargetMap(this, targetMap, true);
                  applyMountedChildren(this, prefabInstance.mountedChildren, targetMap);
                  applyRemovedComponents(this, prefabInstance.removedComponents, targetMap);
                  applyMountedComponents(this, prefabInstance.mountedComponents, targetMap);
                  applyPropertyOverrides(this, prefabInstance.propertyOverrides, targetMap);
                }

                applyTargetOverrides(this);
              }

              _onBeforeSerialize() {
                this.eulerAngles;
              }

              _onPostActivated(active) {
                if (active) {
                  eventManager.resumeTarget(this);
                  this.invalidateChildren(TransformBit.TRS);
                } else {
                  eventManager.pauseTarget(this);
                }
              }

              translate(trans, ns) {
                const space = ns || NodeSpace.LOCAL;

                if (space === NodeSpace.LOCAL) {
                  Vec3.transformQuat(v3_a, trans, this._lrot);
                  this._lpos.x += v3_a.x;
                  this._lpos.y += v3_a.y;
                  this._lpos.z += v3_a.z;
                } else if (space === NodeSpace.WORLD) {
                  if (this._parent) {
                    Quat.invert(q_a, this._parent.worldRotation);
                    Vec3.transformQuat(v3_a, trans, q_a);
                    const scale = this.worldScale;
                    this._lpos.x += v3_a.x / scale.x;
                    this._lpos.y += v3_a.y / scale.y;
                    this._lpos.z += v3_a.z / scale.z;
                  } else {
                    this._lpos.x += trans.x;
                    this._lpos.y += trans.y;
                    this._lpos.z += trans.z;
                  }
                }

                this.invalidateChildren(TransformBit.POSITION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
                }
              }

              rotate(rot, ns) {
                const space = ns || NodeSpace.LOCAL;
                Quat.normalize(q_a, rot);

                if (space === NodeSpace.LOCAL) {
                  Quat.multiply(this._lrot, this._lrot, q_a);
                } else if (space === NodeSpace.WORLD) {
                  const worldRot = this.worldRotation;
                  Quat.multiply(q_b, q_a, worldRot);
                  Quat.invert(q_a, worldRot);
                  Quat.multiply(q_b, q_a, q_b);
                  Quat.multiply(this._lrot, this._lrot, q_b);
                }

                this._eulerDirty = true;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              lookAt(pos, up) {
                this.getWorldPosition(v3_a);
                Vec3.subtract(v3_a, v3_a, pos);
                Vec3.normalize(v3_a, v3_a);
                Quat.fromViewUp(q_a, v3_a, up);
                this.setWorldRotation(q_a);
              }

              _setDirtyNode(idx, currNode) {
                dirtyNodes[idx] = currNode;

                {
                  nativeDirtyNodes[idx] = currNode.native;
                }
              }

              invalidateChildren(dirtyBit) {
                const childDirtyBit = dirtyBit | TransformBit.POSITION;

                this._setDirtyNode(0, this);

                let i = 0;

                while (i >= 0) {
                  const cur = dirtyNodes[i--];
                  const hasChangedFlags = cur.hasChangedFlags;

                  if (cur.isValid && (cur._dirtyFlags & hasChangedFlags & dirtyBit) !== dirtyBit) {
                    cur._dirtyFlags |= dirtyBit;
                    cur._uiProps.uiTransformDirty = true;
                    cur.hasChangedFlags = hasChangedFlags | dirtyBit;
                    const children = cur._children;
                    const len = children.length;

                    for (let j = 0; j < len; ++j) this._setDirtyNode(++i, children[j]);
                  }

                  dirtyBit = childDirtyBit;
                }
              }

              updateWorldTransform() {
                if (!this._dirtyFlags) {
                  return;
                }

                let cur = this;
                let i = 0;

                while (cur && cur._dirtyFlags) {
                  this._setDirtyNode(i++, cur);

                  cur = cur._parent;
                }

                let child;
                let dirtyBits = 0;

                while (i) {
                  child = dirtyNodes[--i];
                  dirtyBits |= child._dirtyFlags;

                  if (cur) {
                    if (dirtyBits & TransformBit.POSITION) {
                      Vec3.transformMat4(child._pos, child._lpos, cur._mat);
                      child._mat.m12 = child._pos.x;
                      child._mat.m13 = child._pos.y;
                      child._mat.m14 = child._pos.z;
                    }

                    if (dirtyBits & TransformBit.RS) {
                      Mat4.fromRTS(child._mat, child._lrot, child._lpos, child._lscale);
                      Mat4.multiply(child._mat, cur._mat, child._mat);

                      if (dirtyBits & TransformBit.ROTATION) {
                        Quat.multiply(child._rot, cur._rot, child._lrot);
                      }

                      Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, child._rot));
                      Mat3.multiplyMat4(m3_1$2, m3_1$2, child._mat);
                      child._scale.x = m3_1$2.m00;
                      child._scale.y = m3_1$2.m04;
                      child._scale.z = m3_1$2.m08;
                    }
                  } else {
                    if (dirtyBits & TransformBit.POSITION) {
                      Vec3.copy(child._pos, child._lpos);
                      child._mat.m12 = child._pos.x;
                      child._mat.m13 = child._pos.y;
                      child._mat.m14 = child._pos.z;
                    }

                    if (dirtyBits & TransformBit.RS) {
                      if (dirtyBits & TransformBit.ROTATION) {
                        Quat.copy(child._rot, child._lrot);
                      }

                      if (dirtyBits & TransformBit.SCALE) {
                        Vec3.copy(child._scale, child._lscale);
                        Mat4.fromRTS(child._mat, child._rot, child._pos, child._scale);
                      }
                    }
                  }

                  child._dirtyFlags = TransformBit.NONE;
                  cur = child;
                }
              }

              setPosition(val, y, z) {
                if (y === undefined && z === undefined) {
                  Vec3.copy(this._lpos, val);
                } else if (z === undefined) {
                  Vec3.set(this._lpos, val, y, this._lpos.z);
                } else {
                  Vec3.set(this._lpos, val, y, z);
                }

                this.invalidateChildren(TransformBit.POSITION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
                }
              }

              getPosition(out) {
                if (out) {
                  return Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z);
                }

                return Vec3.copy(new Vec3(), this._lpos);
              }

              setRotation(val, y, z, w) {
                if (y === undefined || z === undefined || w === undefined) {
                  Quat.copy(this._lrot, val);
                } else {
                  Quat.set(this._lrot, val, y, z, w);
                }

                this._eulerDirty = true;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              setRotationFromEuler(val, y, zOpt) {
                const z = zOpt === undefined ? this._euler.z : zOpt;

                if (y === undefined) {
                  Vec3.copy(this._euler, val);
                  Quat.fromEuler(this._lrot, val.x, val.y, val.z);
                } else {
                  Vec3.set(this._euler, val, y, z);
                  Quat.fromEuler(this._lrot, val, y, z);
                }

                this._eulerDirty = false;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              getRotation(out) {
                if (out) {
                  return Quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w);
                }

                return Quat.copy(new Quat(), this._lrot);
              }

              setScale(val, y, z) {
                if (y === undefined && z === undefined) {
                  Vec3.copy(this._lscale, val);
                } else if (z === undefined) {
                  Vec3.set(this._lscale, val, y, this._lscale.z);
                } else {
                  Vec3.set(this._lscale, val, y, z);
                }

                this.invalidateChildren(TransformBit.SCALE);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
                }
              }

              getScale(out) {
                if (out) {
                  return Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z);
                }

                return Vec3.copy(new Vec3(), this._lscale);
              }

              inverseTransformPoint(out, p) {
                Vec3.copy(out, p);
                let cur = this;
                let i = 0;

                while (cur._parent) {
                  this._setDirtyNode(i++, cur);

                  cur = cur._parent;
                }

                while (i >= 0) {
                  Vec3.transformInverseRTS(out, out, cur._lrot, cur._lpos, cur._lscale);
                  cur = dirtyNodes[--i];
                }

                return out;
              }

              setWorldPosition(val, y, z) {
                if (y === undefined || z === undefined) {
                  Vec3.copy(this._pos, val);
                } else {
                  Vec3.set(this._pos, val, y, z);
                }

                const parent = this._parent;
                const local = this._lpos;

                if (parent) {
                  parent.updateWorldTransform();
                  Vec3.transformMat4(local, this._pos, Mat4.invert(m4_1$1, parent._mat));
                } else {
                  Vec3.copy(local, this._pos);
                }

                this.invalidateChildren(TransformBit.POSITION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
                }
              }

              getWorldPosition(out) {
                this.updateWorldTransform();

                if (out) {
                  return Vec3.copy(out, this._pos);
                }

                return Vec3.copy(new Vec3(), this._pos);
              }

              setWorldRotation(val, y, z, w) {
                if (y === undefined || z === undefined || w === undefined) {
                  Quat.copy(this._rot, val);
                } else {
                  Quat.set(this._rot, val, y, z, w);
                }

                if (this._parent) {
                  this._parent.updateWorldTransform();

                  Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot);
                } else {
                  Quat.copy(this._lrot, this._rot);
                }

                this._eulerDirty = true;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              setWorldRotationFromEuler(x, y, z) {
                Quat.fromEuler(this._rot, x, y, z);

                if (this._parent) {
                  this._parent.updateWorldTransform();

                  Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot);
                } else {
                  Quat.copy(this._lrot, this._rot);
                }

                this._eulerDirty = true;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              getWorldRotation(out) {
                this.updateWorldTransform();

                if (out) {
                  return Quat.copy(out, this._rot);
                }

                return Quat.copy(new Quat(), this._rot);
              }

              setWorldScale(val, y, z) {
                if (y === undefined || z === undefined) {
                  Vec3.copy(this._scale, val);
                } else {
                  Vec3.set(this._scale, val, y, z);
                }

                const parent = this._parent;

                if (parent) {
                  parent.updateWorldTransform();
                  Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, parent._rot));
                  Mat3.multiplyMat4(m3_1$2, m3_1$2, parent._mat);
                  m3_scaling.m00 = this._scale.x;
                  m3_scaling.m04 = this._scale.y;
                  m3_scaling.m08 = this._scale.z;
                  Mat3.multiply(m3_1$2, m3_scaling, Mat3.invert(m3_1$2, m3_1$2));
                  this._lscale.x = Vec3.set(v3_a, m3_1$2.m00, m3_1$2.m01, m3_1$2.m02).length();
                  this._lscale.y = Vec3.set(v3_a, m3_1$2.m03, m3_1$2.m04, m3_1$2.m05).length();
                  this._lscale.z = Vec3.set(v3_a, m3_1$2.m06, m3_1$2.m07, m3_1$2.m08).length();
                } else {
                  Vec3.copy(this._lscale, this._scale);
                }

                this.invalidateChildren(TransformBit.SCALE);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
                }
              }

              getWorldScale(out) {
                this.updateWorldTransform();

                if (out) {
                  return Vec3.copy(out, this._scale);
                }

                return Vec3.copy(new Vec3(), this._scale);
              }

              getWorldMatrix(out) {
                this.updateWorldTransform();
                const target = out || new Mat4();
                return Mat4.copy(target, this._mat);
              }

              getWorldRS(out) {
                this.updateWorldTransform();
                const target = out || new Mat4();
                Mat4.copy(target, this._mat);
                target.m12 = 0;
                target.m13 = 0;
                target.m14 = 0;
                return target;
              }

              getWorldRT(out) {
                this.updateWorldTransform();
                const target = out || new Mat4();
                return Mat4.fromRT(target, this._rot, this._pos);
              }

              setRTS(rot, pos, scale) {
                let dirtyBit = 0;

                if (rot) {
                  dirtyBit |= TransformBit.ROTATION;

                  if (rot.w !== undefined) {
                    Quat.copy(this._lrot, rot);
                    this._eulerDirty = true;
                  } else {
                    Vec3.copy(this._euler, rot);
                    Quat.fromEuler(this._lrot, rot.x, rot.y, rot.z);
                    this._eulerDirty = false;
                  }
                }

                if (pos) {
                  Vec3.copy(this._lpos, pos);
                  dirtyBit |= TransformBit.POSITION;
                }

                if (scale) {
                  Vec3.copy(this._lscale, scale);
                  dirtyBit |= TransformBit.SCALE;
                }

                if (dirtyBit) {
                  this.invalidateChildren(dirtyBit);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(NodeEventType.TRANSFORM_CHANGED, dirtyBit);
                  }
                }
              }

              pauseSystemEvents(recursive) {
                eventManager.pauseTarget(this, recursive);
              }

              resumeSystemEvents(recursive) {
                eventManager.resumeTarget(this, recursive);
              }

              static resetHasChangedFlags() {
                bookOfChange.clear();
              }

              static clearNodeArray() {
                if (Node.ClearFrame < Node.ClearRound && !EDITOR) {
                  Node.ClearFrame++;
                } else {
                  Node.ClearFrame = 0;
                  dirtyNodes.length = 0;
                  nativeDirtyNodes.length = 0;
                }
              }

            }, _class3$9.EventType = NodeEventType, _class3$9.NodeSpace = NodeSpace, _class3$9.TransformDirtyBit = TransformBit, _class3$9.TransformBit = TransformBit, _class3$9.reserveContentsForAllSyncablePrefabTag = reserveContentsForAllSyncablePrefabTag, _class3$9.ClearFrame = 0, _class3$9.ClearRound = 1000, _temp$g), (_descriptor$e = _applyDecoratedDescriptor(_class2$g.prototype, "_lpos", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            }), _descriptor2$a = _applyDecoratedDescriptor(_class2$g.prototype, "_lrot", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Quat();
              }
            }), _descriptor3$8 = _applyDecoratedDescriptor(_class2$g.prototype, "_lscale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(1, 1, 1);
              }
            }), _descriptor4$7 = _applyDecoratedDescriptor(_class2$g.prototype, "_layer", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Layers.Enum.DEFAULT;
              }
            }), _descriptor5$5 = _applyDecoratedDescriptor(_class2$g.prototype, "_euler", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            }), _applyDecoratedDescriptor(_class2$g.prototype, "eulerAngles", [_dec2$7], Object.getOwnPropertyDescriptor(_class2$g.prototype, "eulerAngles"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "angle", [editable], Object.getOwnPropertyDescriptor(_class2$g.prototype, "angle"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "layer", [editable], Object.getOwnPropertyDescriptor(_class2$g.prototype, "layer"), _class2$g.prototype)), _class2$g)) || _class$j));
            legacyCC.Node = Node$1;

            var _dec$k, _class$k, _class2$h, _descriptor$f, _temp$h, _dec2$8, _dec3$2, _dec4$1, _dec5, _dec6, _class4$2, _class5$2, _descriptor2$b, _descriptor3$9, _descriptor4$8, _descriptor5$6, _descriptor6$2, _temp2$2, _dec7, _class7, _class8, _descriptor7$2, _temp3, _dec8, _dec9, _class10, _class11, _descriptor8$2, _descriptor9$1, _descriptor10$1, _temp4, _dec10, _dec11, _dec12, _class13, _class14, _descriptor11, _descriptor12, _temp5, _dec13, _dec14, _dec15, _class16, _class17, _descriptor13, _descriptor14, _temp6, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _class19, _class20, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _temp7, _dec22, _dec23, _dec24, _dec25, _class22, _class23, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _temp8;

            let TargetInfo = (_dec$k = ccclass('cc.TargetInfo'), _dec$k(_class$k = (_class2$h = (_temp$h = class TargetInfo {
              constructor() {
                _initializerDefineProperty(this, "localID", _descriptor$f, this);
              }

            }, _temp$h), (_descriptor$f = _applyDecoratedDescriptor(_class2$h.prototype, "localID", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$h)) || _class$k);
            let TargetOverrideInfo = (_dec2$8 = ccclass('cc.TargetOverrideInfo'), _dec3$2 = type(CCObject), _dec4$1 = type(TargetInfo), _dec5 = type(Node$1), _dec6 = type(TargetInfo), _dec2$8(_class4$2 = (_class5$2 = (_temp2$2 = class TargetOverrideInfo {
              constructor() {
                _initializerDefineProperty(this, "source", _descriptor2$b, this);

                _initializerDefineProperty(this, "sourceInfo", _descriptor3$9, this);

                _initializerDefineProperty(this, "propertyPath", _descriptor4$8, this);

                _initializerDefineProperty(this, "target", _descriptor5$6, this);

                _initializerDefineProperty(this, "targetInfo", _descriptor6$2, this);
              }

            }, _temp2$2), (_descriptor2$b = _applyDecoratedDescriptor(_class5$2.prototype, "source", [serializable, _dec3$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor3$9 = _applyDecoratedDescriptor(_class5$2.prototype, "sourceInfo", [serializable, _dec4$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor4$8 = _applyDecoratedDescriptor(_class5$2.prototype, "propertyPath", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor5$6 = _applyDecoratedDescriptor(_class5$2.prototype, "target", [serializable, _dec5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor6$2 = _applyDecoratedDescriptor(_class5$2.prototype, "targetInfo", [serializable, _dec6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class5$2)) || _class4$2);
            let CompPrefabInfo = (_dec7 = ccclass('cc.CompPrefabInfo'), _dec7(_class7 = (_class8 = (_temp3 = class CompPrefabInfo {
              constructor() {
                _initializerDefineProperty(this, "fileId", _descriptor7$2, this);
              }

            }, _temp3), (_descriptor7$2 = _applyDecoratedDescriptor(_class8.prototype, "fileId", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class8)) || _class7);
            let PropertyOverrideInfo = (_dec8 = ccclass('CCPropertyOverrideInfo'), _dec9 = type(TargetInfo), _dec8(_class10 = (_class11 = (_temp4 = class PropertyOverrideInfo {
              constructor() {
                _initializerDefineProperty(this, "targetInfo", _descriptor8$2, this);

                _initializerDefineProperty(this, "propertyPath", _descriptor9$1, this);

                _initializerDefineProperty(this, "value", _descriptor10$1, this);
              }

              isTarget(localID, propPath) {
              }

            }, _temp4), (_descriptor8$2 = _applyDecoratedDescriptor(_class11.prototype, "targetInfo", [serializable, _dec9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor9$1 = _applyDecoratedDescriptor(_class11.prototype, "propertyPath", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor10$1 = _applyDecoratedDescriptor(_class11.prototype, "value", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class11)) || _class10);
            let MountedChildrenInfo = (_dec10 = ccclass('cc.MountedChildrenInfo'), _dec11 = type(TargetInfo), _dec12 = type([Node$1]), _dec10(_class13 = (_class14 = (_temp5 = class MountedChildrenInfo {
              constructor() {
                _initializerDefineProperty(this, "targetInfo", _descriptor11, this);

                _initializerDefineProperty(this, "nodes", _descriptor12, this);
              }

              isTarget(localID) {
              }

            }, _temp5), (_descriptor11 = _applyDecoratedDescriptor(_class14.prototype, "targetInfo", [serializable, _dec11], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor12 = _applyDecoratedDescriptor(_class14.prototype, "nodes", [serializable, _dec12], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class14)) || _class13);
            let MountedComponentsInfo = (_dec13 = ccclass('cc.MountedComponentsInfo'), _dec14 = type(TargetInfo), _dec15 = type([Component]), _dec13(_class16 = (_class17 = (_temp6 = class MountedComponentsInfo {
              constructor() {
                _initializerDefineProperty(this, "targetInfo", _descriptor13, this);

                _initializerDefineProperty(this, "components", _descriptor14, this);
              }

              isTarget(localID) {
              }

            }, _temp6), (_descriptor13 = _applyDecoratedDescriptor(_class17.prototype, "targetInfo", [serializable, _dec14], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor14 = _applyDecoratedDescriptor(_class17.prototype, "components", [serializable, _dec15], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class17)) || _class16);
            let PrefabInstance = (_dec16 = ccclass('cc.PrefabInstance'), _dec17 = type(Node$1), _dec18 = type([MountedChildrenInfo]), _dec19 = type([MountedComponentsInfo]), _dec20 = type([PropertyOverrideInfo]), _dec21 = type([TargetInfo]), _dec16(_class19 = (_class20 = (_temp7 = class PrefabInstance {
              constructor() {
                _initializerDefineProperty(this, "fileId", _descriptor15, this);

                _initializerDefineProperty(this, "prefabRootNode", _descriptor16, this);

                _initializerDefineProperty(this, "mountedChildren", _descriptor17, this);

                _initializerDefineProperty(this, "mountedComponents", _descriptor18, this);

                _initializerDefineProperty(this, "propertyOverrides", _descriptor19, this);

                _initializerDefineProperty(this, "removedComponents", _descriptor20, this);

                this.targetMap = {};
              }

              findPropertyOverride(localID, propPath) {
              }

              removePropertyOverride(localID, propPath) {
              }

            }, _temp7), (_descriptor15 = _applyDecoratedDescriptor(_class20.prototype, "fileId", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor16 = _applyDecoratedDescriptor(_class20.prototype, "prefabRootNode", [serializable, _dec17], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor17 = _applyDecoratedDescriptor(_class20.prototype, "mountedChildren", [serializable, _dec18], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor18 = _applyDecoratedDescriptor(_class20.prototype, "mountedComponents", [serializable, _dec19], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor19 = _applyDecoratedDescriptor(_class20.prototype, "propertyOverrides", [serializable, _dec20], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor20 = _applyDecoratedDescriptor(_class20.prototype, "removedComponents", [serializable, _dec21], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class20)) || _class19);
            let PrefabInfo = (_dec22 = ccclass('cc.PrefabInfo'), _dec23 = type(Node$1), _dec24 = type(PrefabInstance), _dec25 = type([TargetOverrideInfo]), _dec22(_class22 = (_class23 = (_temp8 = class PrefabInfo {
              constructor() {
                _initializerDefineProperty(this, "root", _descriptor21, this);

                _initializerDefineProperty(this, "asset", _descriptor22, this);

                _initializerDefineProperty(this, "fileId", _descriptor23, this);

                _initializerDefineProperty(this, "instance", _descriptor24, this);

                _initializerDefineProperty(this, "targetOverrides", _descriptor25, this);
              }

            }, _temp8), (_descriptor21 = _applyDecoratedDescriptor(_class23.prototype, "root", [serializable, _dec23], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor22 = _applyDecoratedDescriptor(_class23.prototype, "asset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor23 = _applyDecoratedDescriptor(_class23.prototype, "fileId", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor24 = _applyDecoratedDescriptor(_class23.prototype, "instance", [serializable, _dec24], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor25 = _applyDecoratedDescriptor(_class23.prototype, "targetOverrides", [serializable, _dec25], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class23)) || _class22);
            legacyCC._PrefabInfo = PrefabInfo;

            var utils = /*#__PURE__*/Object.freeze({
                __proto__: null,
                TargetInfo: TargetInfo,
                TargetOverrideInfo: TargetOverrideInfo,
                CompPrefabInfo: CompPrefabInfo,
                PropertyOverrideInfo: PropertyOverrideInfo,
                MountedChildrenInfo: MountedChildrenInfo,
                MountedComponentsInfo: MountedComponentsInfo,
                PrefabInstance: PrefabInstance,
                PrefabInfo: PrefabInfo,
                createNodeWithPrefab: createNodeWithPrefab,
                generateTargetMap: generateTargetMap,
                getTarget: getTarget,
                applyMountedChildren: applyMountedChildren,
                applyMountedComponents: applyMountedComponents,
                applyRemovedComponents: applyRemovedComponents,
                applyPropertyOverrides: applyPropertyOverrides,
                applyTargetOverrides: applyTargetOverrides
            });

            var _dec$l, _class$l, _class2$i, _descriptor$g, _descriptor2$c, _class3$a, _temp$i;
            const OptimizationPolicy = Enum({
              AUTO: 0,
              SINGLE_INSTANCE: 1,
              MULTI_INSTANCE: 2
            });
            let Prefab = exports('f6', (_dec$l = ccclass('cc.Prefab'), _dec$l(_class$l = (_class2$i = (_temp$i = _class3$a = class Prefab extends Asset {
              constructor() {
                super();

                _initializerDefineProperty(this, "data", _descriptor$g, this);

                _initializerDefineProperty(this, "optimizationPolicy", _descriptor2$c, this);

                this._createFunction = void 0;
                this._instantiatedTimes = void 0;
                this._createFunction = null;
                this._instantiatedTimes = 0;
              }

              createNode(cb) {
                const node = legacyCC.instantiate(this);
                node.name = this.name;
                cb(null, node);
              }

              compileCreateFunction() {
                this._createFunction = compile(this.data);
              }

              _doInstantiate(rootToRedirect) {
                if (!this.data._prefab) {
                  warnID(3700);
                }

                if (!this._createFunction) {
                  this.compileCreateFunction();
                }

                return this._createFunction(rootToRedirect);
              }

              _instantiate() {
                let node;
                let useJit = false;

                {
                  if (this.optimizationPolicy === OptimizationPolicy.SINGLE_INSTANCE) {
                    useJit = false;
                  } else if (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE) {
                    useJit = true;
                  } else {
                    useJit = this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold;
                  }
                }

                if (useJit) {
                  node = this._doInstantiate();

                  this.data._instantiate(node);
                } else {
                  node = this.data._instantiate();
                }

                ++this._instantiatedTimes;
                return node;
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                this.data = new Node$1();
                this.data.name = '(Missing Node)';
                const prefabInfo = new legacyCC._PrefabInfo();
                prefabInfo.asset = this;
                prefabInfo.root = this.data;
                this.data._prefab = prefabInfo;
              }

              validate() {
                return !!this.data;
              }

            }, _class3$a.OptimizationPolicy = OptimizationPolicy, _class3$a.OptimizationPolicyThreshold = 3, _temp$i), (_descriptor$g = _applyDecoratedDescriptor(_class2$i.prototype, "data", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$c = _applyDecoratedDescriptor(_class2$i.prototype, "optimizationPolicy", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return OptimizationPolicy.AUTO;
              }
            })), _class2$i)) || _class$l));
            js.value(Prefab, '_utils', utils);
            legacyCC.Prefab = Prefab;

            {
              obsolete(legacyCC, 'cc._Prefab', 'Prefab');
            }

            var _dec$m, _dec2$9, _dec3$3, _class$m, _class2$j, _descriptor$h, _temp$j;
            let PrefabLink = exports('eV', (_dec$m = ccclass('cc.PrefabLink'), _dec2$9 = type(Prefab), _dec3$3 = visible(), _dec$m(_class$m = (_class2$j = (_temp$j = class PrefabLink extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "prefab", _descriptor$h, this);
              }

            }, _temp$j), (_descriptor$h = _applyDecoratedDescriptor(_class2$j.prototype, "prefab", [_dec2$9, serializable, _dec3$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$j)) || _class$m));

            const _vec3 = new Vec3();

            function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
              if (!out) {
                out = new Vec3();
              }

              mainCamera.convertToUINode(wpos, uiNode, out);
              const pos = uiNode.position;
              out.add(pos);
              return out;
            }
            function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
              if (!out) {
                out = new Vec3();
              }

              mainCamera.worldToScreen(wpos, out);
              out.x /= legacyCC.view.getScaleX();
              out.y /= legacyCC.view.getScaleY();
              return out;
            }
            const convertUtils = exports('eZ', {
              WorldNode3DToLocalNodeUI,
              WorldNode3DToWorldNodeUI
            });
            legacyCC.pipelineUtils = convertUtils;
            replaceProperty(legacyCC.pipelineUtils, 'cc.pipelineUtils', [{
              name: 'WorldNode3DToLocalNodeUI',
              newName: 'convertToUINode',
              targetName: 'cc.Camera.prototype',

              customFunction(...args) {
                const camera = args[0];
                const out = args[3] || _vec3;
                camera.convertToUINode(args[1], args[2], out);
                out.add(args[2].position);
                return args[3] || out.clone();
              }

            }]);

            var _dec$n, _dec2$a, _dec3$4, _dec4$2, _dec5$1, _class$n, _class2$k, _descriptor$i, _descriptor2$d, _temp$k;

            const _colorAttachment = new ColorAttachment();

            _colorAttachment.endAccesses = [AccessType.FRAGMENT_SHADER_READ_TEXTURE];

            const _depthStencilAttachment = new DepthStencilAttachment();

            const passInfo = new RenderPassInfo([_colorAttachment], _depthStencilAttachment);
            const _windowInfo = {
              width: 1,
              height: 1,
              renderPassInfo: passInfo
            };
            let RenderTexture = exports('d3', (_dec$n = ccclass('cc.RenderTexture'), _dec2$a = rangeMin(), _dec3$4 = rangeMax(), _dec4$2 = rangeMin(), _dec5$1 = rangeMax(), _dec$n(_class$n = (_class2$k = (_temp$k = class RenderTexture extends TextureBase {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_width", _descriptor$i, this);

                _initializerDefineProperty(this, "_height", _descriptor2$d, this);

                this._window = null;
              }

              get width() {
                return this._width;
              }

              get height() {
                return this._height;
              }

              get window() {
                return this._window;
              }

              initialize(info) {
                this._name = info.name || '';
                this._width = info.width;
                this._height = info.height;

                this._initWindow(info);
              }

              reset(info) {
                this.initialize(info);
              }

              destroy() {
                if (this._window) {
                  const root = legacyCC.director.root;
                  root === null || root === void 0 ? void 0 : root.destroyWindow(this._window);
                  this._window = null;
                }

                return super.destroy();
              }

              resize(width, height) {
                this._width = width;
                this._height = height;

                if (this._window) {
                  this._window.resize(width, height);
                }

                this.emit('resize', this._window);
              }

              get _serialize() {
                return null;
              }

              get _deserialize() {
                return null;
              }

              getGFXTexture() {
                return this._window && this._window.framebuffer.colorTextures[0];
              }

              getGFXSampler() {
                const root = legacyCC.director.root;
                return samplerLib.getSampler(root.device, defaultSamplerHash);
              }

              getSamplerHash() {
                return defaultSamplerHash;
              }

              onLoaded() {
                this._initWindow();
              }

              _initWindow(info) {
                const root = legacyCC.director.root;
                _windowInfo.title = this._name;
                _windowInfo.width = this._width;
                _windowInfo.height = this._height;
                _windowInfo.renderPassInfo = info && info.passInfo ? info.passInfo : passInfo;

                if (this._window) {
                  this._window.destroy();

                  this._window.initialize(root.device, _windowInfo);
                } else {
                  this._window = root.createWindow(_windowInfo);
                }
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                this._width = this._height = 1;

                this._initWindow();
              }

              validate() {
                return this.width >= 1 && this.width <= 2048 && this.height >= 1 && this.height <= 2048;
              }

            }, _temp$k), (_descriptor$i = _applyDecoratedDescriptor(_class2$k.prototype, "_width", [serializable, _dec2$a, _dec3$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor2$d = _applyDecoratedDescriptor(_class2$k.prototype, "_height", [serializable, _dec4$2, _dec5$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            })), _class2$k)) || _class$n));
            legacyCC.RenderTexture = RenderTexture;

            removeProperty(TextureBase.prototype, 'TextureBase.prototype', [{
              name: 'hasPremultipliedAlpha'
            }, {
              name: 'setPremultiplyAlpha'
            }, {
              name: 'setFlipY'
            }]);
            replaceProperty(RenderTexture.prototype, 'RenderTexture.prototype', [{
              name: 'getGFXWindow',

              customFunction() {
                return this._window;
              }

            }]);

            var _dec$o, _class$o, _class2$l, _temp$l;
            let BufferAsset = exports('f5', (_dec$o = ccclass('cc.BufferAsset'), _dec$o(_class$o = (_class2$l = (_temp$l = class BufferAsset extends Asset {
              constructor(...args) {
                super(...args);
                this._buffer = null;
              }

              get _nativeAsset() {
                return this._buffer;
              }

              set _nativeAsset(bin) {
                if (bin instanceof ArrayBuffer) {
                  this._buffer = bin;
                } else {
                  this._buffer = bin.buffer;
                }
              }

              buffer() {
                return this._buffer;
              }

              validate() {
                return !!this.buffer;
              }

            }, _temp$l), (_applyDecoratedDescriptor(_class2$l.prototype, "_nativeAsset", [override], Object.getOwnPropertyDescriptor(_class2$l.prototype, "_nativeAsset"), _class2$l.prototype)), _class2$l)) || _class$o));
            legacyCC.BufferAsset = BufferAsset;

            const _typeMap = {
              [FormatType.UNORM]: 'Uint',
              [FormatType.SNORM]: 'Int',
              [FormatType.UINT]: 'Uint',
              [FormatType.INT]: 'Int',
              [FormatType.UFLOAT]: 'Float',
              [FormatType.FLOAT]: 'Float',
              default: 'Uint'
            };

            function _getDataViewType(info) {
              const type = _typeMap[info.type] || _typeMap.default;
              const bytes = info.size / info.count * 8;
              return `${type}${bytes}`;
            }

            function writeBuffer(target, data, format = Format.R32F, offset = 0, stride = 0) {
              const info = FormatInfos[format];

              if (!stride) {
                stride = info.size;
              }

              const writer = `set${_getDataViewType(info)}`;
              const componentBytesLength = info.size / info.count;
              const nSeg = Math.floor(data.length / info.count);
              const isLittleEndian = sys.isLittleEndian;

              for (let iSeg = 0; iSeg < nSeg; ++iSeg) {
                const x = offset + stride * iSeg;

                for (let iComponent = 0; iComponent < info.count; ++iComponent) {
                  const y = x + componentBytesLength * iComponent;
                  target[writer](y, data[info.count * iSeg + iComponent], isLittleEndian);
                }
              }
            }
            function readBuffer(target, format = Format.R32F, offset = 0, length = target.byteLength - offset, stride = 0, out = []) {
              const info = FormatInfos[format];

              if (!stride) {
                stride = info.size;
              }

              const reader = `get${_getDataViewType(info)}`;
              const componentBytesLength = info.size / info.count;
              const nSeg = Math.floor(length / stride);
              const isLittleEndian = sys.isLittleEndian;

              for (let iSeg = 0; iSeg < nSeg; ++iSeg) {
                const x = offset + stride * iSeg;

                for (let iComponent = 0; iComponent < info.count; ++iComponent) {
                  const y = x + componentBytesLength * iComponent;
                  out[info.count * iSeg + iComponent] = target[reader](y, isLittleEndian);
                }
              }

              return out;
            }
            function mapBuffer(target, callback, format = Format.R32F, offset = 0, length = target.byteLength - offset, stride = 0, out) {
              if (!out) {
                out = new DataView(target.buffer.slice(target.byteOffset, target.byteOffset + target.byteLength));
              }

              const info = FormatInfos[format];

              if (!stride) {
                stride = info.size;
              }

              const writer = `set${_getDataViewType(info)}`;
              const reader = `get${_getDataViewType(info)}`;
              const componentBytesLength = info.size / info.count;
              const nSeg = Math.floor(length / stride);
              const isLittleEndian = sys.isLittleEndian;

              for (let iSeg = 0; iSeg < nSeg; ++iSeg) {
                const x = offset + stride * iSeg;

                for (let iComponent = 0; iComponent < info.count; ++iComponent) {
                  const y = x + componentBytesLength * iComponent;
                  const cur = target[reader](y, isLittleEndian);
                  out[writer](y, callback(cur, iComponent, target), isLittleEndian);
                }
              }

              return out;
            }

            const _cachedArray = new Array(16);

            let _currentHovered = null;
            let pos = new Vec2();
            const _touchEvents = [NodeEventType.TOUCH_START, NodeEventType.TOUCH_MOVE, NodeEventType.TOUCH_END, NodeEventType.TOUCH_CANCEL];
            const _mouseEvents = [NodeEventType.MOUSE_DOWN, NodeEventType.MOUSE_ENTER, NodeEventType.MOUSE_MOVE, NodeEventType.MOUSE_LEAVE, NodeEventType.MOUSE_UP, NodeEventType.MOUSE_WHEEL];

            function _touchStartHandler(touch, event) {
              const node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return false;
              }

              touch.getUILocation(pos);

              if (node._uiProps.uiTransformComp.isHit(pos, this)) {
                event.type = NodeEventType.TOUCH_START;
                event.touch = touch;
                event.bubbles = true;
                node.dispatchEvent(event);
                return true;
              }

              return false;
            }

            function _touchMoveHandler(touch, event) {
              const node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return false;
              }

              event.type = NodeEventType.TOUCH_MOVE;
              event.touch = touch;
              event.bubbles = true;
              node.dispatchEvent(event);
              return true;
            }

            function _touchEndHandler(touch, event) {
              const node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              touch.getUILocation(pos);

              if (node._uiProps.uiTransformComp.isHit(pos, this)) {
                event.type = NodeEventType.TOUCH_END;
              } else {
                event.type = NodeEventType.TOUCH_CANCEL;
              }

              event.touch = touch;
              event.bubbles = true;
              node.dispatchEvent(event);
            }

            function _touchCancelHandler(touch, event) {
              const node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              event.type = NodeEventType.TOUCH_CANCEL;
              event.touch = touch;
              event.bubbles = true;
              node.dispatchEvent(event);
            }

            function _mouseDownHandler(event) {
              const node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              pos = event.getUILocation();

              if (node._uiProps.uiTransformComp.isHit(pos, this)) {
                event.type = NodeEventType.MOUSE_DOWN;
                event.bubbles = true;
                node.dispatchEvent(event);
              }
            }

            function _mouseMoveHandler(event) {
              const node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              pos = event.getUILocation();

              const hit = node._uiProps.uiTransformComp.isHit(pos, this);

              if (hit) {
                if (!this._previousIn) {
                  if (_currentHovered && _currentHovered.eventProcessor.mouseListener) {
                    event.type = NodeEventType.MOUSE_LEAVE;

                    _currentHovered.dispatchEvent(event);

                    if (_currentHovered.eventProcessor.mouseListener) {
                      _currentHovered.eventProcessor.mouseListener._previousIn = false;
                    }
                  }

                  _currentHovered = node;
                  event.type = NodeEventType.MOUSE_ENTER;
                  node.dispatchEvent(event);
                  this._previousIn = true;
                }

                event.type = NodeEventType.MOUSE_MOVE;
                event.bubbles = true;
                node.dispatchEvent(event);
              } else if (this._previousIn) {
                event.type = NodeEventType.MOUSE_LEAVE;
                node.dispatchEvent(event);
                this._previousIn = false;
                _currentHovered = null;
              } else {
                return;
              }

              event.propagationStopped = true;
            }

            function _mouseUpHandler(event) {
              const node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              pos = event.getUILocation();

              if (node._uiProps.uiTransformComp.isHit(pos, this)) {
                event.type = NodeEventType.MOUSE_UP;
                event.bubbles = true;
                node.dispatchEvent(event);
                event.propagationStopped = true;
              }
            }

            function _mouseWheelHandler(event) {
              const node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              pos = event.getUILocation();

              if (node._uiProps.uiTransformComp.isHit(pos, this)) {
                event.type = NodeEventType.MOUSE_WHEEL;
                event.bubbles = true;
                node.dispatchEvent(event);
                event.propagationStopped = true;
              }
            }

            function _doDispatchEvent(owner, event) {
              let target;
              let i = 0;
              event.target = owner;
              _cachedArray.length = 0;
              owner.eventProcessor.getCapturingTargets(event.type, _cachedArray);
              event.eventPhase = 1;

              for (i = _cachedArray.length - 1; i >= 0; --i) {
                target = _cachedArray[i];

                if (target.eventProcessor.capturingTargets) {
                  event.currentTarget = target;
                  target.eventProcessor.capturingTargets.emit(event.type, event, _cachedArray);

                  if (event.propagationStopped) {
                    _cachedArray.length = 0;
                    return;
                  }
                }
              }

              _cachedArray.length = 0;
              event.eventPhase = 2;
              event.currentTarget = owner;

              if (owner.eventProcessor.capturingTargets) {
                owner.eventProcessor.capturingTargets.emit(event.type, event);
              }

              if (!event.propagationImmediateStopped && owner.eventProcessor.bubblingTargets) {
                owner.eventProcessor.bubblingTargets.emit(event.type, event);
              }

              if (!event.propagationStopped && event.bubbles) {
                owner.eventProcessor.getBubblingTargets(event.type, _cachedArray);
                event.eventPhase = 3;

                for (i = 0; i < _cachedArray.length; ++i) {
                  target = _cachedArray[i];

                  if (target.eventProcessor.bubblingTargets) {
                    event.currentTarget = target;
                    target.eventProcessor.bubblingTargets.emit(event.type, event);

                    if (event.propagationStopped) {
                      _cachedArray.length = 0;
                      return;
                    }
                  }
                }
              }

              _cachedArray.length = 0;
            }

            function _searchComponentsInParent(node, ctor) {
              if (ctor) {
                let index = 0;
                let list = [];

                for (let curr = node; curr && Node$1.isNode(curr); curr = curr.parent, ++index) {
                  const comp = curr.getComponent(ctor);

                  if (comp) {
                    const next = {
                      index,
                      comp
                    };

                    if (list) {
                      list.push(next);
                    } else {
                      list = [next];
                    }
                  }
                }

                return list.length > 0 ? list : null;
              }

              return null;
            }

            function _checkListeners(node, events) {
              if (!node._persistNode) {
                if (node.eventProcessor.bubblingTargets) {
                  for (let i = 0; i < events.length; ++i) {
                    if (node.eventProcessor.bubblingTargets.hasEventListener(events[i])) {
                      return true;
                    }
                  }
                }

                if (node.eventProcessor.capturingTargets) {
                  for (let i = 0; i < events.length; ++i) {
                    if (node.eventProcessor.capturingTargets.hasEventListener(events[i])) {
                      return true;
                    }
                  }
                }

                return false;
              }

              return true;
            }

            class NodeEventProcessor {
              get node() {
                return this._node;
              }

              constructor(node) {
                this.bubblingTargets = null;
                this.capturingTargets = null;
                this.touchListener = null;
                this.mouseListener = null;
                this._node = void 0;
                this._node = node;
              }

              reattach() {
                let currMask;
                this.node.walk(node => {
                  if (!currMask) {
                    currMask = _searchComponentsInParent(node, NodeEventProcessor._comp);
                  }

                  if (node.eventProcessor.touchListener) {
                    node.eventProcessor.touchListener.mask = currMask;
                  }

                  if (node.eventProcessor.mouseListener) {
                    node.eventProcessor.mouseListener.mask = currMask;
                  }
                });
              }

              destroy() {
                if (_currentHovered === this._node) {
                  _currentHovered = null;
                }

                if (this.touchListener || this.mouseListener) {
                  eventManager.removeListeners(this._node);

                  if (this.touchListener) {
                    this.touchListener.owner = null;
                    this.touchListener.mask = null;
                    this.touchListener = null;
                  }

                  if (this.mouseListener) {
                    this.mouseListener.owner = null;
                    this.mouseListener.mask = null;
                    this.mouseListener = null;
                  }
                }

                if (this.capturingTargets) this.capturingTargets.clear();
                if (this.bubblingTargets) this.bubblingTargets.clear();
              }

              on(type, callback, target, useCapture) {
                const forDispatch = this._checknSetupSysEvent(type);

                if (forDispatch) {
                  return this._onDispatch(type, callback, target, useCapture);
                } else {
                  if (!this.bubblingTargets) {
                    this.bubblingTargets = new CallbacksInvoker();
                  }

                  return this.bubblingTargets.on(type, callback, target);
                }
              }

              once(type, callback, target, useCapture) {
                const forDispatch = this._checknSetupSysEvent(type);

                let listeners;

                if (forDispatch && useCapture) {
                  listeners = this.capturingTargets = this.capturingTargets || new CallbacksInvoker();
                } else {
                  listeners = this.bubblingTargets = this.bubblingTargets || new CallbacksInvoker();
                }

                listeners.on(type, callback, target, true);
                listeners.on(type, () => {
                  this.off(type, callback, target);
                }, undefined, true);
              }

              off(type, callback, target, useCapture) {
                const touchEvent = _touchEvents.indexOf(type) !== -1;
                const mouseEvent = !touchEvent && _mouseEvents.indexOf(type) !== -1;

                if (touchEvent || mouseEvent) {
                  this._offDispatch(type, callback, target, useCapture);

                  if (touchEvent) {
                    if (this.touchListener && !_checkListeners(this._node, _touchEvents)) {
                      eventManager.removeListener(this.touchListener);
                      this.touchListener = null;
                    }
                  } else if (mouseEvent) {
                    if (this.mouseListener && !_checkListeners(this._node, _mouseEvents)) {
                      eventManager.removeListener(this.mouseListener);
                      this.mouseListener = null;
                    }
                  }
                } else if (this.bubblingTargets) {
                  this.bubblingTargets.off(type, callback, target);
                }
              }

              emit(type, arg0, arg1, arg2, arg3, arg4) {
                if (this.bubblingTargets) {
                  this.bubblingTargets.emit(type, arg0, arg1, arg2, arg3, arg4);
                }
              }

              dispatchEvent(event) {
                _doDispatchEvent(this._node, event);

                _cachedArray.length = 0;
              }

              hasEventListener(type, callback, target) {
                let has = false;

                if (this.bubblingTargets) {
                  has = this.bubblingTargets.hasEventListener(type, callback, target);
                }

                if (!has && this.capturingTargets) {
                  has = this.capturingTargets.hasEventListener(type, callback, target);
                }

                return has;
              }

              targetOff(target) {
                if (this.capturingTargets) {
                  this.capturingTargets.removeAll(target);
                }

                if (this.bubblingTargets) {
                  this.bubblingTargets.removeAll(target);
                }

                if (this.touchListener && !_checkListeners(this.node, _touchEvents)) {
                  eventManager.removeListener(this.touchListener);
                  this.touchListener = null;
                }

                if (this.mouseListener && !_checkListeners(this.node, _mouseEvents)) {
                  eventManager.removeListener(this.mouseListener);
                  this.mouseListener = null;
                }
              }

              getCapturingTargets(type, targets) {
                let parent = this._node.parent;

                while (parent) {
                  if (parent.eventProcessor.capturingTargets && parent.eventProcessor.capturingTargets.hasEventListener(type)) {
                    targets.push(parent);
                  }

                  parent = parent.parent;
                }
              }

              getBubblingTargets(type, targets) {
                let parent = this._node.parent;

                while (parent) {
                  if (parent.eventProcessor.bubblingTargets && parent.eventProcessor.bubblingTargets.hasEventListener(type)) {
                    targets.push(parent);
                  }

                  parent = parent.parent;
                }
              }

              _checknSetupSysEvent(type) {
                let newAdded = false;
                let forDispatch = false;

                if (_touchEvents.indexOf(type) !== -1) {
                  if (!this.touchListener) {
                    this.touchListener = legacyCC.EventListener.create({
                      event: legacyCC.EventListener.TOUCH_ONE_BY_ONE,
                      swallowTouches: true,
                      owner: this._node,
                      mask: _searchComponentsInParent(this._node, NodeEventProcessor._comp),
                      onTouchBegan: _touchStartHandler,
                      onTouchMoved: _touchMoveHandler,
                      onTouchEnded: _touchEndHandler,
                      onTouchCancelled: _touchCancelHandler
                    });
                    eventManager.addListener(this.touchListener, this._node);
                    newAdded = true;
                  }

                  forDispatch = true;
                } else if (_mouseEvents.indexOf(type) !== -1) {
                  if (!this.mouseListener) {
                    this.mouseListener = legacyCC.EventListener.create({
                      event: legacyCC.EventListener.MOUSE,
                      _previousIn: false,
                      owner: this._node,
                      mask: _searchComponentsInParent(this._node, NodeEventProcessor._comp),
                      onMouseDown: _mouseDownHandler,
                      onMouseMove: _mouseMoveHandler,
                      onMouseUp: _mouseUpHandler,
                      onMouseScroll: _mouseWheelHandler
                    });
                    eventManager.addListener(this.mouseListener, this._node);
                    newAdded = true;
                  }

                  forDispatch = true;
                }

                if (newAdded && !this._node.activeInHierarchy) {
                  legacyCC.director.getScheduler().schedule(() => {
                    if (!this._node.activeInHierarchy) {
                      eventManager.pauseTarget(this._node);
                    }
                  }, this._node, 0, 0, 0, false);
                }

                return forDispatch;
              }

              _onDispatch(type, callback, target, useCapture) {
                if (typeof target === 'boolean') {
                  useCapture = target;
                  target = undefined;
                } else {
                  useCapture = !!useCapture;
                }

                if (!callback) {
                  errorID(6800);
                  return undefined;
                }

                let listeners = null;

                if (useCapture) {
                  listeners = this.capturingTargets = this.capturingTargets || new CallbacksInvoker();
                } else {
                  listeners = this.bubblingTargets = this.bubblingTargets || new CallbacksInvoker();
                }

                if (!listeners.hasEventListener(type, callback, target)) {
                  listeners.on(type, callback, target);
                }

                return callback;
              }

              _offDispatch(type, callback, target, useCapture) {
                if (typeof target === 'boolean') {
                  useCapture = target;
                  target = undefined;
                } else {
                  useCapture = !!useCapture;
                }

                if (!callback) {
                  if (this.capturingTargets) {
                    this.capturingTargets.removeAll(type);
                  }

                  if (this.bubblingTargets) {
                    this.bubblingTargets.removeAll(type);
                  }
                } else {
                  const listeners = useCapture ? this.capturingTargets : this.bubblingTargets;

                  if (listeners) {
                    listeners.off(type, callback, target);
                  }
                }
              }

            } exports('c$', NodeEventProcessor);
            NodeEventProcessor._comp = null;
            legacyCC.NodeEventProcessor = NodeEventProcessor;

            var _dec$p, _dec2$b, _class$p, _class2$m, _descriptor$j, _descriptor2$e, _descriptor3$a, _temp$m, _dec3$5, _dec4$3, _dec5$2, _class4$3, _class5$3, _descriptor4$9, _descriptor5$7, _descriptor6$3, _descriptor7$3, _temp2$3, _dec6$1, _dec7$1, _dec8$1, _dec9$1, _dec10$1, _dec11$1, _dec12$1, _dec13$1, _dec14$1, _dec15$1, _dec16$1, _dec17$1, _dec18$1, _dec19$1, _dec20$1, _dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _class7$1, _class8$1, _descriptor8$3, _descriptor9$2, _descriptor10$2, _descriptor11$1, _descriptor12$1, _descriptor13$1, _descriptor14$1, _descriptor15$1, _descriptor16$1, _class9, _temp3$1, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _dec46, _dec47, _dec48, _dec49, _dec50, _dec51, _dec52, _dec53, _dec54, _dec55, _dec56, _dec57, _dec58, _dec59, _dec60, _class10$1, _class11$1, _descriptor17$1, _descriptor18$1, _descriptor19$1, _descriptor20$1, _descriptor21$1, _descriptor22$1, _descriptor23$1, _descriptor24$1, _descriptor25$1, _descriptor26, _descriptor27, _descriptor28, _descriptor29, _descriptor30, _descriptor31, _temp4$1, _dec61, _dec62, _class13$1, _class14$1, _descriptor32, _descriptor33, _descriptor34, _descriptor35, _temp5$1;

            const _up = new Vec3(0, 1, 0);

            const _v3$1 = new Vec3();

            const _qt$1 = new Quat();

            let AmbientInfo = (_dec$p = ccclass('cc.AmbientInfo'), _dec2$b = type(CCFloat), _dec$p(_class$p = (_class2$m = (_temp$m = class AmbientInfo {
              constructor() {
                _initializerDefineProperty(this, "_skyColor", _descriptor$j, this);

                _initializerDefineProperty(this, "_skyIllum", _descriptor2$e, this);

                _initializerDefineProperty(this, "_groundAlbedo", _descriptor3$a, this);

                this._resource = null;
              }

              set skyColor(val) {
                this._skyColor.set(val);

                if (this._resource) {
                  this._resource.skyColor = this._skyColor;
                }
              }

              get skyColor() {
                return this._skyColor;
              }

              set skyIllum(val) {
                this._skyIllum = val;

                if (this._resource) {
                  this._resource.skyIllum = this.skyIllum;
                }
              }

              get skyIllum() {
                return this._skyIllum;
              }

              set groundAlbedo(val) {
                this._groundAlbedo.set(val);

                if (this._resource) {
                  this._resource.groundAlbedo = this._groundAlbedo;
                }
              }

              get groundAlbedo() {
                return this._groundAlbedo;
              }

              activate(resource) {
                this._resource = resource;

                this._resource.initialize(this);
              }

            }, _temp$m), (_descriptor$j = _applyDecoratedDescriptor(_class2$m.prototype, "_skyColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color(51, 128, 204, 1.0);
              }
            }), _descriptor2$e = _applyDecoratedDescriptor(_class2$m.prototype, "_skyIllum", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Ambient.SKY_ILLUM;
              }
            }), _descriptor3$a = _applyDecoratedDescriptor(_class2$m.prototype, "_groundAlbedo", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color(51, 51, 51, 255);
              }
            }), _applyDecoratedDescriptor(_class2$m.prototype, "skyColor", [editable], Object.getOwnPropertyDescriptor(_class2$m.prototype, "skyColor"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "skyIllum", [editable, _dec2$b], Object.getOwnPropertyDescriptor(_class2$m.prototype, "skyIllum"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "groundAlbedo", [editable], Object.getOwnPropertyDescriptor(_class2$m.prototype, "groundAlbedo"), _class2$m.prototype)), _class2$m)) || _class$p);
            legacyCC.AmbientInfo = AmbientInfo;
            let SkyboxInfo = (_dec3$5 = ccclass('cc.SkyboxInfo'), _dec4$3 = type(TextureCube), _dec5$2 = type(TextureCube), _dec3$5(_class4$3 = (_class5$3 = (_temp2$3 = class SkyboxInfo {
              constructor() {
                _initializerDefineProperty(this, "_envmap", _descriptor4$9, this);

                _initializerDefineProperty(this, "_isRGBE", _descriptor5$7, this);

                _initializerDefineProperty(this, "_enabled", _descriptor6$3, this);

                _initializerDefineProperty(this, "_useIBL", _descriptor7$3, this);

                this._resource = null;
              }

              set enabled(val) {
                if (this._enabled === val) return;
                this._enabled = val;

                if (this._resource) {
                  this._resource.enabled = this._enabled;
                }
              }

              get enabled() {
                return this._enabled;
              }

              set useIBL(val) {
                this._useIBL = val;

                if (this._resource) {
                  this._resource.useIBL = this._useIBL;
                }
              }

              get useIBL() {
                return this._useIBL;
              }

              set envmap(val) {
                this._envmap = val;

                if (this._resource) {
                  this._resource.envmap = this._envmap;
                }
              }

              get envmap() {
                return this._envmap;
              }

              set isRGBE(val) {
                this._isRGBE = val;

                if (this._resource) {
                  this._resource.isRGBE = this._isRGBE;
                }
              }

              get isRGBE() {
                return this._isRGBE;
              }

              activate(resource) {
                this._resource = resource;

                this._resource.initialize(this);

                this._resource.activate();
              }

            }, _temp2$3), (_descriptor4$9 = _applyDecoratedDescriptor(_class5$3.prototype, "_envmap", [_dec4$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor5$7 = _applyDecoratedDescriptor(_class5$3.prototype, "_isRGBE", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor6$3 = _applyDecoratedDescriptor(_class5$3.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor7$3 = _applyDecoratedDescriptor(_class5$3.prototype, "_useIBL", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class5$3.prototype, "enabled", [editable], Object.getOwnPropertyDescriptor(_class5$3.prototype, "enabled"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "useIBL", [editable], Object.getOwnPropertyDescriptor(_class5$3.prototype, "useIBL"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "envmap", [editable, _dec5$2], Object.getOwnPropertyDescriptor(_class5$3.prototype, "envmap"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "isRGBE", [editable], Object.getOwnPropertyDescriptor(_class5$3.prototype, "isRGBE"), _class5$3.prototype)), _class5$3)) || _class4$3);
            legacyCC.SkyboxInfo = SkyboxInfo;
            let FogInfo = (_dec6$1 = ccclass('cc.FogInfo'), _dec7$1 = type(FogType), _dec8$1 = visible(), _dec9$1 = type(CCFloat), _dec10$1 = range(), _dec11$1 = rangeStep(), _dec12$1 = displayOrder(), _dec13$1 = visible(), _dec14$1 = type(CCFloat), _dec15$1 = rangeStep(), _dec16$1 = displayOrder(), _dec17$1 = visible(), _dec18$1 = type(CCFloat), _dec19$1 = rangeStep(), _dec20$1 = displayOrder(), _dec21$1 = visible(), _dec22$1 = type(CCFloat), _dec23$1 = rangeMin(), _dec24$1 = rangeStep(), _dec25$1 = displayOrder(), _dec26 = visible(), _dec27 = type(CCFloat), _dec28 = rangeStep(), _dec29 = displayOrder(), _dec30 = visible(), _dec31 = type(CCFloat), _dec32 = rangeStep(), _dec33 = displayOrder(), _dec6$1(_class7$1 = (_class8$1 = (_temp3$1 = _class9 = class FogInfo {
              constructor() {
                _initializerDefineProperty(this, "_type", _descriptor8$3, this);

                _initializerDefineProperty(this, "_fogColor", _descriptor9$2, this);

                _initializerDefineProperty(this, "_enabled", _descriptor10$2, this);

                _initializerDefineProperty(this, "_fogDensity", _descriptor11$1, this);

                _initializerDefineProperty(this, "_fogStart", _descriptor12$1, this);

                _initializerDefineProperty(this, "_fogEnd", _descriptor13$1, this);

                _initializerDefineProperty(this, "_fogAtten", _descriptor14$1, this);

                _initializerDefineProperty(this, "_fogTop", _descriptor15$1, this);

                _initializerDefineProperty(this, "_fogRange", _descriptor16$1, this);

                this._resource = null;
              }

              set enabled(val) {
                if (this._enabled === val) return;
                this._enabled = val;

                if (this._resource) {
                  this._resource.enabled = val;

                  if (val) {
                    this._resource.type = this._type;
                  }
                }
              }

              get enabled() {
                return this._enabled;
              }

              set fogColor(val) {
                this._fogColor.set(val);

                if (this._resource) {
                  this._resource.fogColor = this._fogColor;
                }
              }

              get fogColor() {
                return this._fogColor;
              }

              get type() {
                return this._type;
              }

              set type(val) {
                this._type = val;

                if (this._resource) {
                  this._resource.type = val;
                }
              }

              get fogDensity() {
                return this._fogDensity;
              }

              set fogDensity(val) {
                this._fogDensity = val;

                if (this._resource) {
                  this._resource.fogDensity = val;
                }
              }

              get fogStart() {
                return this._fogStart;
              }

              set fogStart(val) {
                this._fogStart = val;

                if (this._resource) {
                  this._resource.fogStart = val;
                }
              }

              get fogEnd() {
                return this._fogEnd;
              }

              set fogEnd(val) {
                this._fogEnd = val;

                if (this._resource) {
                  this._resource.fogEnd = val;
                }
              }

              get fogAtten() {
                return this._fogAtten;
              }

              set fogAtten(val) {
                this._fogAtten = val;

                if (this._resource) {
                  this._resource.fogAtten = val;
                }
              }

              get fogTop() {
                return this._fogTop;
              }

              set fogTop(val) {
                this._fogTop = val;

                if (this._resource) {
                  this._resource.fogTop = val;
                }
              }

              get fogRange() {
                return this._fogRange;
              }

              set fogRange(val) {
                this._fogRange = val;

                if (this._resource) {
                  this._resource.fogRange = val;
                }
              }

              activate(resource) {
                this._resource = resource;

                this._resource.initialize(this);

                this._resource.activate();
              }

            }, _class9.FogType = FogType, _temp3$1), (_descriptor8$3 = _applyDecoratedDescriptor(_class8$1.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return FogType.LINEAR;
              }
            }), _descriptor9$2 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color('#C8C8C8');
              }
            }), _descriptor10$2 = _applyDecoratedDescriptor(_class8$1.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor11$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogDensity", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.3;
              }
            }), _descriptor12$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogStart", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.5;
              }
            }), _descriptor13$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogEnd", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 300;
              }
            }), _descriptor14$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogAtten", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 5;
              }
            }), _descriptor15$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogTop", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.5;
              }
            }), _descriptor16$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogRange", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.2;
              }
            }), _applyDecoratedDescriptor(_class8$1.prototype, "enabled", [editable], Object.getOwnPropertyDescriptor(_class8$1.prototype, "enabled"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogColor", [editable], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogColor"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "type", [editable, _dec7$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "type"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogDensity", [_dec8$1, _dec9$1, _dec10$1, _dec11$1, slide, _dec12$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogDensity"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogStart", [_dec13$1, _dec14$1, _dec15$1, _dec16$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogStart"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogEnd", [_dec17$1, _dec18$1, _dec19$1, _dec20$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogEnd"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogAtten", [_dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogAtten"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogTop", [_dec26, _dec27, _dec28, _dec29], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogTop"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogRange", [_dec30, _dec31, _dec32, _dec33], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogRange"), _class8$1.prototype)), _class8$1)) || _class7$1);
            let ShadowsInfo = (_dec34 = ccclass('cc.ShadowsInfo'), _dec35 = type(ShadowType), _dec36 = visible(), _dec37 = visible(), _dec38 = type(CCFloat), _dec39 = visible(), _dec40 = range(), _dec41 = type(CCFloat), _dec42 = visible(), _dec43 = type(PCFType), _dec44 = visible(), _dec45 = type(CCInteger), _dec46 = visible(), _dec47 = type(CCFloat), _dec48 = visible(), _dec49 = type(CCFloat), _dec50 = visible(), _dec51 = type(ShadowSize), _dec52 = visible(), _dec53 = type(CCBoolean), _dec54 = visible(), _dec55 = type(CCFloat), _dec56 = visible(), _dec57 = type(CCFloat), _dec58 = visible(), _dec59 = type(CCFloat), _dec60 = visible(), _dec34(_class10$1 = (_class11$1 = (_temp4$1 = class ShadowsInfo {
              constructor() {
                _initializerDefineProperty(this, "_type", _descriptor17$1, this);

                _initializerDefineProperty(this, "_enabled", _descriptor18$1, this);

                _initializerDefineProperty(this, "_normal", _descriptor19$1, this);

                _initializerDefineProperty(this, "_distance", _descriptor20$1, this);

                _initializerDefineProperty(this, "_shadowColor", _descriptor21$1, this);

                _initializerDefineProperty(this, "_autoAdapt", _descriptor22$1, this);

                _initializerDefineProperty(this, "_pcf", _descriptor23$1, this);

                _initializerDefineProperty(this, "_bias", _descriptor24$1, this);

                _initializerDefineProperty(this, "_normalBias", _descriptor25$1, this);

                _initializerDefineProperty(this, "_near", _descriptor26, this);

                _initializerDefineProperty(this, "_far", _descriptor27, this);

                _initializerDefineProperty(this, "_orthoSize", _descriptor28, this);

                _initializerDefineProperty(this, "_maxReceived", _descriptor29, this);

                _initializerDefineProperty(this, "_size", _descriptor30, this);

                _initializerDefineProperty(this, "_saturation", _descriptor31, this);

                this._resource = null;
              }

              set enabled(val) {
                if (this._enabled === val) return;
                this._enabled = val;

                if (this._resource) {
                  this._resource.enabled = val;

                  if (val) {
                    this._resource.type = this._type;
                  }
                }
              }

              get enabled() {
                return this._enabled;
              }

              set type(val) {
                this._type = val;

                if (this._resource) {
                  this._resource.type = val;
                }
              }

              get type() {
                return this._type;
              }

              set shadowColor(val) {
                this._shadowColor.set(val);

                if (this._resource) {
                  this._resource.shadowColor = val;
                }
              }

              get shadowColor() {
                return this._shadowColor;
              }

              set normal(val) {
                Vec3.copy(this._normal, val);

                if (this._resource) {
                  this._resource.normal = val;
                }
              }

              get normal() {
                return this._normal;
              }

              set distance(val) {
                this._distance = val;

                if (this._resource) {
                  this._resource.distance = val;
                }
              }

              get distance() {
                return this._distance;
              }

              set saturation(val) {
                if (val > 1.0) {
                  this._saturation = val / val;

                  if (this._resource) {
                    this._resource.saturation = val / val;
                  }
                } else {
                  this._saturation = val;

                  if (this._resource) {
                    this._resource.saturation = val;
                  }
                }
              }

              get saturation() {
                return this._saturation;
              }

              set pcf(val) {
                this._pcf = val;

                if (this._resource) {
                  this._resource.pcf = val;
                }
              }

              get pcf() {
                return this._pcf;
              }

              set maxReceived(val) {
                this._maxReceived = val;

                if (this._resource) {
                  this._resource.maxReceived = val;
                }
              }

              get maxReceived() {
                return this._maxReceived;
              }

              set bias(val) {
                this._bias = val;

                if (this._resource) {
                  this._resource.bias = val;
                }
              }

              get bias() {
                return this._bias;
              }

              set normalBias(val) {
                this._normalBias = val;

                if (this._resource) {
                  this._resource.normalBias = val;
                }
              }

              get normalBias() {
                return this._normalBias;
              }

              set shadowMapSize(value) {
                this._size.set(value, value);

                if (this._resource) {
                  this._resource.size.set(value, value);

                  this._resource.shadowMapDirty = true;
                }
              }

              get shadowMapSize() {
                return this._size.x;
              }

              get size() {
                return this._size;
              }

              set autoAdapt(val) {
                this._autoAdapt = val;

                if (this._resource) {
                  this._resource.autoAdapt = val;
                }
              }

              get autoAdapt() {
                return this._autoAdapt;
              }

              set near(val) {
                this._near = val;

                if (this._resource) {
                  this._resource.near = val;
                }
              }

              get near() {
                return this._near;
              }

              set far(val) {
                this._far = val;

                if (this._resource) {
                  this._resource.far = val;
                }
              }

              get far() {
                return this._far;
              }

              set orthoSize(val) {
                this._orthoSize = val;

                if (this._resource) {
                  this._resource.orthoSize = val;
                }
              }

              get orthoSize() {
                return this._orthoSize;
              }

              setPlaneFromNode(node) {
                node.getWorldRotation(_qt$1);
                this.normal = Vec3.transformQuat(_v3$1, _up, _qt$1);
                node.getWorldPosition(_v3$1);
                this.distance = Vec3.dot(this._normal, _v3$1);
              }

              activate(resource) {
                this._resource = resource;

                this._resource.initialize(this);

                this._resource.activate();
              }

            }, _temp4$1), (_descriptor17$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ShadowType.Planar;
              }
            }), _descriptor18$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor19$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_normal", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(0, 1, 0);
              }
            }), _descriptor20$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_distance", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor21$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_shadowColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color(0, 0, 0, 76);
              }
            }), _descriptor22$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_autoAdapt", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor23$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_pcf", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return PCFType.HARD;
              }
            }), _descriptor24$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_bias", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.00001;
              }
            }), _descriptor25$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_normalBias", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.0;
              }
            }), _descriptor26 = _applyDecoratedDescriptor(_class11$1.prototype, "_near", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor27 = _applyDecoratedDescriptor(_class11$1.prototype, "_far", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 30;
              }
            }), _descriptor28 = _applyDecoratedDescriptor(_class11$1.prototype, "_orthoSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 5;
              }
            }), _descriptor29 = _applyDecoratedDescriptor(_class11$1.prototype, "_maxReceived", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 4;
              }
            }), _descriptor30 = _applyDecoratedDescriptor(_class11$1.prototype, "_size", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2(512, 512);
              }
            }), _descriptor31 = _applyDecoratedDescriptor(_class11$1.prototype, "_saturation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.75;
              }
            }), _applyDecoratedDescriptor(_class11$1.prototype, "enabled", [editable], Object.getOwnPropertyDescriptor(_class11$1.prototype, "enabled"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "type", [editable, _dec35], Object.getOwnPropertyDescriptor(_class11$1.prototype, "type"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "shadowColor", [_dec36], Object.getOwnPropertyDescriptor(_class11$1.prototype, "shadowColor"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "normal", [_dec37], Object.getOwnPropertyDescriptor(_class11$1.prototype, "normal"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "distance", [_dec38, _dec39], Object.getOwnPropertyDescriptor(_class11$1.prototype, "distance"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "saturation", [editable, _dec40, slide, _dec41, _dec42], Object.getOwnPropertyDescriptor(_class11$1.prototype, "saturation"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "pcf", [_dec43, _dec44], Object.getOwnPropertyDescriptor(_class11$1.prototype, "pcf"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "maxReceived", [_dec45, _dec46], Object.getOwnPropertyDescriptor(_class11$1.prototype, "maxReceived"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "bias", [_dec47, _dec48], Object.getOwnPropertyDescriptor(_class11$1.prototype, "bias"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "normalBias", [_dec49, _dec50], Object.getOwnPropertyDescriptor(_class11$1.prototype, "normalBias"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "shadowMapSize", [_dec51, _dec52], Object.getOwnPropertyDescriptor(_class11$1.prototype, "shadowMapSize"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "autoAdapt", [_dec53, _dec54], Object.getOwnPropertyDescriptor(_class11$1.prototype, "autoAdapt"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "near", [_dec55, _dec56], Object.getOwnPropertyDescriptor(_class11$1.prototype, "near"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "far", [_dec57, _dec58], Object.getOwnPropertyDescriptor(_class11$1.prototype, "far"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "orthoSize", [_dec59, _dec60], Object.getOwnPropertyDescriptor(_class11$1.prototype, "orthoSize"), _class11$1.prototype)), _class11$1)) || _class10$1);
            legacyCC.ShadowsInfo = ShadowsInfo;
            let SceneGlobals = (_dec61 = ccclass('cc.SceneGlobals'), _dec62 = type(SkyboxInfo), _dec61(_class13$1 = (_class14$1 = (_temp5$1 = class SceneGlobals {
              constructor() {
                _initializerDefineProperty(this, "ambient", _descriptor32, this);

                _initializerDefineProperty(this, "shadows", _descriptor33, this);

                _initializerDefineProperty(this, "_skybox", _descriptor34, this);

                _initializerDefineProperty(this, "fog", _descriptor35, this);
              }

              get skybox() {
                return this._skybox;
              }

              set skybox(value) {
                this._skybox = value;
              }

              activate() {
                const sceneData = legacyCC.director.root.pipeline.pipelineSceneData;
                this.ambient.activate(sceneData.ambient);
                this.skybox.activate(sceneData.skybox);
                this.shadows.activate(sceneData.shadows);
                this.fog.activate(sceneData.fog);
              }

            }, _temp5$1), (_descriptor32 = _applyDecoratedDescriptor(_class14$1.prototype, "ambient", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new AmbientInfo();
              }
            }), _descriptor33 = _applyDecoratedDescriptor(_class14$1.prototype, "shadows", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new ShadowsInfo();
              }
            }), _descriptor34 = _applyDecoratedDescriptor(_class14$1.prototype, "_skybox", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new SkyboxInfo();
              }
            }), _descriptor35 = _applyDecoratedDescriptor(_class14$1.prototype, "fog", [editable, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new FogInfo();
              }
            }), _applyDecoratedDescriptor(_class14$1.prototype, "skybox", [editable, _dec62], Object.getOwnPropertyDescriptor(_class14$1.prototype, "skybox"), _class14$1.prototype)), _class14$1)) || _class13$1);
            legacyCC.SceneGlobals = SceneGlobals;

            var _dec$q, _class$q;
            replaceProperty(BaseNode.prototype, 'BaseNode', [{
              name: 'childrenCount',
              newName: 'children.length',

              customGetter() {
                return this.children.length;
              }

            }]);
            replaceProperty(Node$1.prototype, 'Node', [{
              name: 'width',
              targetName: 'node.getComponent(UITransform)',

              customGetter() {
                return this._uiProps.uiTransformComp.width;
              },

              customSetter(value) {
                this._uiProps.uiTransformComp.width = value;
              }

            }, {
              name: 'height',
              targetName: 'node.getComponent(UITransform)',

              customGetter() {
                return this._uiProps.uiTransformComp.height;
              },

              customSetter(value) {
                this._uiProps.uiTransformComp.height = value;
              }

            }, {
              name: 'anchorX',
              targetName: 'node.getComponent(UITransform)',

              customGetter() {
                return this._uiProps.uiTransformComp.anchorX;
              },

              customSetter(value) {
                this._uiProps.uiTransformComp.anchorX = value;
              }

            }, {
              name: 'anchorY',
              targetName: 'node.getComponent(UITransform)',

              customGetter() {
                return this._uiProps.uiTransformComp.anchorY;
              },

              customSetter(value) {
                this._uiProps.uiTransformComp.anchorY = value;
              }

            }, {
              name: 'getAnchorPoint',
              targetName: 'node.getComponent(UITransform)',

              customFunction(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._uiProps.uiTransformComp.anchorPoint);
                return out;
              }

            }, {
              name: 'setAnchorPoint',
              targetName: 'node.getComponent(UITransform)',

              customFunction(point, y) {
                this._uiProps.uiTransformComp.setAnchorPoint(point, y);
              }

            }, {
              name: 'getContentSize',
              targetName: 'node.getComponent(UITransform)',

              customFunction(out) {
                if (!out) {
                  out = new Size();
                }

                out.set(this._uiProps.uiTransformComp.contentSize);
                return out;
              }

            }, {
              name: 'setContentSize',
              targetName: 'node.getComponent(UITransform)',

              customFunction(size, height) {
                if (typeof size === 'number') {
                  this._uiProps.uiTransformComp.setContentSize(size, height);
                } else {
                  this._uiProps.uiTransformComp.setContentSize(size);
                }
              }

            }]);
            removeProperty(SceneGlobals.prototype, 'SceneGlobals.prototype', [{
              name: 'aspect'
            }, {
              name: 'selfShadow'
            }, {
              name: 'linear'
            }, {
              name: 'packing'
            }]);
            removeProperty(Node$1.prototype, 'Node.prototype', [{
              name: 'addLayer'
            }, {
              name: 'removeLayer'
            }]);
            removeProperty(Layers, 'Layers', [{
              name: 'All'
            }, {
              name: 'RaycastMask'
            }, {
              name: 'check'
            }]);
            replaceProperty(Layers, 'Layers', [{
              name: 'Default',
              newName: 'DEFAULT',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Always',
              newName: 'ALWAYS',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'IgnoreRaycast',
              newName: 'IGNORE_RAYCAST',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Gizmos',
              newName: 'GIZMOS',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Editor',
              newName: 'EDITOR',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'UI',
              newName: 'UI_3D',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'UI2D',
              newName: 'UI_2D',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'SceneGizmo',
              newName: 'SCENE_GIZMO',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'makeInclusiveMask',
              newName: 'makeMaskInclude',
              target: Layers,
              targetName: 'Layers'
            }, {
              name: 'makeExclusiveMask',
              newName: 'makeMaskExclude',
              target: Layers,
              targetName: 'Layers'
            }]);
            removeProperty(Layers.Enum, 'Layers.Enum', [{
              name: 'ALWAYS'
            }]);
            removeProperty(Layers.BitMask, 'Layers.BitMask', [{
              name: 'ALWAYS'
            }]);
            const HideInHierarchy$1 = CCObject.Flags.HideInHierarchy;
            const DontSave$1 = CCObject.Flags.DontSave;
            let PrivateNode = exports('fO', (_dec$q = ccclass('cc.PrivateNode'), _dec$q(_class$q = class PrivateNode extends Node$1 {
              constructor(name) {
                super(name);
                warnID(12003, this.name);
                this.hideFlags |= DontSave$1 | HideInHierarchy$1;
              }

            }) || _class$q));

            legacyCC.PrivateNode = PrivateNode;

            var _dec$r, _class$r, _class2$n, _descriptor$k, _descriptor2$f, _temp$n;
            let Scene = exports('dx', (_dec$r = ccclass('cc.Scene'), _dec$r(_class$r = (_class2$n = (_temp$n = class Scene extends BaseNode {
              get renderScene() {
                return this._renderScene;
              }

              get globals() {
                return this._globals;
              }

              _updateScene() {
                this._scene = this;
              }

              get native() {
                return this._nativeObj;
              }

              _init() {
                {
                  this._nativeObj = new NativeScene();
                }
              }

              constructor(name) {
                super(name);

                _initializerDefineProperty(this, "autoReleaseAssets", _descriptor$k, this);

                _initializerDefineProperty(this, "_globals", _descriptor2$f, this);

                this._renderScene = null;
                this.dependAssets = null;
                this._inited = void 0;
                this._prefabSyncedInLiveReload = false;
                this._pos = Vec3.ZERO;
                this._rot = Quat.IDENTITY;
                this._scale = Vec3.ONE;
                this._mat = Mat4.IDENTITY;
                this._dirtyFlags = 0;
                this._activeInHierarchy = false;

                if (legacyCC.director && legacyCC.director.root) {
                  this._renderScene = legacyCC.director.root.createScene({});
                }

                this._inited = legacyCC.game ? !legacyCC.game._isCloning : true;

                this._init();
              }

              destroy() {
                const success = CCObject.prototype.destroy.call(this);

                if (success) {
                  const children = this._children;

                  for (let i = 0; i < children.length; ++i) {
                    children[i].active = false;
                  }
                }

                if (this._renderScene) legacyCC.director.root.destroyScene(this._renderScene);
                this._active = false;
                this._activeInHierarchy = false;
                return success;
              }

              addComponent() {
                throw new Error(getError(3822));
              }

              _onHierarchyChanged() {}

              _onBatchCreated(dontSyncChildPrefab) {
                super._onBatchCreated(dontSyncChildPrefab);

                const len = this._children.length;

                for (let i = 0; i < len; ++i) {
                  this.children[i]._siblingIndex = i;

                  this._children[i]._onBatchCreated(dontSyncChildPrefab);
                }

                applyTargetOverrides(this);
              }

              getPosition(out) {
                return Vec3.copy(out || new Vec3(), Vec3.ZERO);
              }

              getRotation(out) {
                return Quat.copy(out || new Quat(), Quat.IDENTITY);
              }

              getScale(out) {
                return Vec3.copy(out || new Vec3(), Vec3.ONE);
              }

              getWorldPosition(out) {
                return Vec3.copy(out || new Vec3(), Vec3.ZERO);
              }

              getWorldRotation(out) {
                return Quat.copy(out || new Quat(), Quat.IDENTITY);
              }

              getWorldScale(out) {
                return Vec3.copy(out || new Vec3(), Vec3.ONE);
              }

              getWorldMatrix(out) {
                return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
              }

              getWorldRS(out) {
                return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
              }

              getWorldRT(out) {
                return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
              }

              get position() {
                return Vec3.ZERO;
              }

              get worldPosition() {
                return Vec3.ZERO;
              }

              get rotation() {
                return Quat.IDENTITY;
              }

              get worldRotation() {
                return Quat.IDENTITY;
              }

              get scale() {
                return Vec3.ONE;
              }

              get worldScale() {
                return Vec3.ONE;
              }

              get eulerAngles() {
                return Vec3.ZERO;
              }

              get worldMatrix() {
                return Mat4.IDENTITY;
              }

              updateWorldTransform() {}

              _instantiate() {}

              _load() {
                if (!this._inited) {

                  this._onBatchCreated(EDITOR );

                  this._inited = true;
                }

                this.walk(BaseNode._setScene);
              }

              _activate(active) {
                active = active !== false;

                legacyCC.director._nodeActivator.activateNode(this, active);

                this._globals.activate();
              }

            }, _temp$n), (_applyDecoratedDescriptor(_class2$n.prototype, "globals", [editable], Object.getOwnPropertyDescriptor(_class2$n.prototype, "globals"), _class2$n.prototype), _descriptor$k = _applyDecoratedDescriptor(_class2$n.prototype, "autoReleaseAssets", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$f = _applyDecoratedDescriptor(_class2$n.prototype, "_globals", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new SceneGlobals();
              }
            })), _class2$n)) || _class$r));
            legacyCC.Scene = Scene;

            function find(path, referenceNode) {
              if (!referenceNode) {
                const scene = legacyCC.director.getScene();

                if (!scene) {

                  return null;
                }

                referenceNode = scene;
              }

              return referenceNode.getChildByPath(path);
            }
            legacyCC.find = find;

            const fastRemoveAt$2 = array.fastRemoveAt;
            const IsStartCalled$1 = CCObject.Flags.IsStartCalled;
            const IsOnEnableCalled$1 = CCObject.Flags.IsOnEnableCalled;
            const IsEditorOnEnableCalled$1 = CCObject.Flags.IsEditorOnEnableCalled;

            function sortedIndex(array, comp) {
              const order = comp.constructor._executionOrder;
              const id = comp._id;
              let l = 0;

              for (let h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                const test = array[m];
                const testOrder = test.constructor._executionOrder;

                if (testOrder > order) {
                  h = m - 1;
                } else if (testOrder < order) {
                  l = m + 1;
                } else {
                  const testId = test._id;

                  if (testId > id) {
                    h = m - 1;
                  } else if (testId < id) {
                    l = m + 1;
                  } else {
                    return m;
                  }
                }
              }

              return ~l;
            }

            function stableRemoveInactive(iterator, flagToClear) {
              const array = iterator.array;
              let next = iterator.i + 1;

              while (next < array.length) {
                const comp = array[next];

                if (comp.node._activeInHierarchy) {
                  ++next;
                } else {
                  iterator.removeAt(next);

                  if (flagToClear) {
                    comp._objFlags &= ~flagToClear;
                  }
                }
              }
            }

            class LifeCycleInvoker {
              constructor(invokeFunc) {
                this._zero = void 0;
                this._neg = void 0;
                this._pos = void 0;
                this._invoke = void 0;
                const Iterator = MutableForwardIterator;
                this._zero = new Iterator([]);
                this._neg = new Iterator([]);
                this._pos = new Iterator([]);

                this._invoke = invokeFunc;
              }

            }
            LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;

            function compareOrder(a, b) {
              return a.constructor._executionOrder - b.constructor._executionOrder;
            }

            class OneOffInvoker extends LifeCycleInvoker {
              add(comp) {
                const order = comp.constructor._executionOrder;
                (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
              }

              remove(comp) {
                const order = comp.constructor._executionOrder;
                (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
              }

              cancelInactive(flagToClear) {
                stableRemoveInactive(this._zero, flagToClear);
                stableRemoveInactive(this._neg, flagToClear);
                stableRemoveInactive(this._pos, flagToClear);
              }

              invoke() {
                const compsNeg = this._neg;

                if (compsNeg.array.length > 0) {
                  compsNeg.array.sort(compareOrder);

                  this._invoke(compsNeg);

                  compsNeg.array.length = 0;
                }

                this._invoke(this._zero);

                this._zero.array.length = 0;
                const compsPos = this._pos;

                if (compsPos.array.length > 0) {
                  compsPos.array.sort(compareOrder);

                  this._invoke(compsPos);

                  compsPos.array.length = 0;
                }
              }

            }

            class ReusableInvoker extends LifeCycleInvoker {
              add(comp) {
                const order = comp.constructor._executionOrder;

                if (order === 0) {
                  this._zero.array.push(comp);
                } else {
                  const array = order < 0 ? this._neg.array : this._pos.array;
                  const i = sortedIndex(array, comp);

                  if (i < 0) {
                    array.splice(~i, 0, comp);
                  }
                }
              }

              remove(comp) {
                const order = comp.constructor._executionOrder;

                if (order === 0) {
                  this._zero.fastRemove(comp);
                } else {
                  const iterator = order < 0 ? this._neg : this._pos;
                  const i = sortedIndex(iterator.array, comp);

                  if (i >= 0) {
                    iterator.removeAt(i);
                  }
                }
              }

              invoke(dt) {
                if (this._neg.array.length > 0) {
                  this._invoke(this._neg, dt);
                }

                this._invoke(this._zero, dt);

                if (this._pos.array.length > 0) {
                  this._invoke(this._pos, dt);
                }
              }

            }

            function createInvokeImplJit(code, useDt, ensureFlag) {
              const body = `${'var a=it.array;' + 'for(it.i=0;it.i<a.length;++it.i){' + 'var c=a[it.i];'}${code}}`;
              const fastPath = useDt ? Function('it', 'dt', body) : Function('it', body);
              const singleInvoke = Function('c', 'dt', code);
              return createInvokeImpl(singleInvoke, fastPath, ensureFlag);
            }
            function createInvokeImpl(singleInvoke, fastPath, ensureFlag) {
              return (iterator, dt) => {
                try {
                  fastPath(iterator, dt);
                } catch (e) {
                  legacyCC._throw(e);

                  const array = iterator.array;

                  if (ensureFlag) {
                    array[iterator.i]._objFlags |= ensureFlag;
                  }

                  ++iterator.i;

                  for (; iterator.i < array.length; ++iterator.i) {
                    try {
                      singleInvoke(array[iterator.i], dt);
                    } catch (e) {
                      legacyCC._throw(e);

                      if (ensureFlag) {
                        array[iterator.i]._objFlags |= ensureFlag;
                      }
                    }
                  }
                }
              };
            }
            const invokeStart =  createInvokeImplJit(`c.start();c._objFlags|=${IsStartCalled$1}`, false, IsStartCalled$1) ;
            const invokeUpdate =  createInvokeImplJit('c.update(dt)', true) ;
            const invokeLateUpdate =  createInvokeImplJit('c.lateUpdate(dt)', true) ;
            const invokeOnEnable =  iterator => {
              const compScheduler = legacyCC.director._compScheduler;
              const array = iterator.array;

              for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                const comp = array[iterator.i];

                if (comp._enabled) {
                  comp.onEnable();
                  const deactivatedDuringOnEnable = !comp.node._activeInHierarchy;

                  if (!deactivatedDuringOnEnable) {
                    compScheduler._onEnabled(comp);
                  }
                }
              }
            };
            class ComponentScheduler {
              constructor() {
                this._deferredComps = [];
                this.unscheduleAll();
              }

              unscheduleAll() {
                this.startInvoker = new OneOffInvoker(invokeStart);
                this.updateInvoker = new ReusableInvoker(invokeUpdate);
                this.lateUpdateInvoker = new ReusableInvoker(invokeLateUpdate);
                this._updating = false;
              }

              _onEnabled(comp) {
                legacyCC.director.getScheduler().resumeTarget(comp);
                comp._objFlags |= IsOnEnableCalled$1;

                if (this._updating) {
                  this._deferredComps.push(comp);
                } else {
                  this._scheduleImmediate(comp);
                }
              }

              _onDisabled(comp) {
                legacyCC.director.getScheduler().pauseTarget(comp);
                comp._objFlags &= ~IsOnEnableCalled$1;

                const index = this._deferredComps.indexOf(comp);

                if (index >= 0) {
                  fastRemoveAt$2(this._deferredComps, index);
                  return;
                }

                if (comp.start && !(comp._objFlags & IsStartCalled$1)) {
                  this.startInvoker.remove(comp);
                }

                if (comp.update) {
                  this.updateInvoker.remove(comp);
                }

                if (comp.lateUpdate) {
                  this.lateUpdateInvoker.remove(comp);
                }
              }

              enableComp(comp, invoker) {
                if (!(comp._objFlags & IsOnEnableCalled$1)) {
                  if (comp.onEnable) {
                    if (invoker) {
                      invoker.add(comp);
                      return;
                    } else {
                      comp.onEnable();
                      const deactivatedDuringOnEnable = !comp.node._activeInHierarchy;

                      if (deactivatedDuringOnEnable) {
                        return;
                      }
                    }
                  }

                  this._onEnabled(comp);
                }
              }

              disableComp(comp) {
                if (comp._objFlags & IsOnEnableCalled$1) {
                  if (comp.onDisable) {
                    comp.onDisable();
                  }

                  this._onDisabled(comp);
                }
              }

              startPhase() {
                this._updating = true;
                this.startInvoker.invoke();

                this._startForNewComps();
              }

              updatePhase(dt) {
                this.updateInvoker.invoke(dt);
              }

              lateUpdatePhase(dt) {
                this.lateUpdateInvoker.invoke(dt);
                this._updating = false;

                this._startForNewComps();
              }

              _startForNewComps() {
                if (this._deferredComps.length > 0) {
                  this._deferredSchedule();

                  this.startInvoker.invoke();
                }
              }

              _scheduleImmediate(comp) {
                if (typeof comp.start === 'function' && !(comp._objFlags & IsStartCalled$1)) {
                  this.startInvoker.add(comp);
                }

                if (typeof comp.update === 'function') {
                  this.updateInvoker.add(comp);
                }

                if (typeof comp.lateUpdate === 'function') {
                  this.lateUpdateInvoker.add(comp);
                }
              }

              _deferredSchedule() {
                const comps = this._deferredComps;

                for (let i = 0, len = comps.length; i < len; i++) {
                  this._scheduleImmediate(comps[i]);
                }

                comps.length = 0;
              }

            }

            const MAX_POOL_SIZE = 4;
            const IsPreloadStarted$1 = CCObject.Flags.IsPreloadStarted;
            const IsOnLoadStarted$1 = CCObject.Flags.IsOnLoadStarted;
            const IsOnLoadCalled$2 = CCObject.Flags.IsOnLoadCalled;
            const Deactivating$2 = CCObject.Flags.Deactivating;

            class UnsortedInvoker extends LifeCycleInvoker {
              add(comp) {
                this._zero.array.push(comp);
              }

              remove(comp) {
                this._zero.fastRemove(comp);
              }

              cancelInactive(flagToClear) {
                LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
              }

              invoke() {
                this._invoke(this._zero);

                this._zero.array.length = 0;
              }

            }

            const invokePreload =  createInvokeImplJit('c.__preload();') ;
            const invokeOnLoad =  createInvokeImplJit(`c.onLoad();c._objFlags|=${IsOnLoadCalled$2}`, false, IsOnLoadCalled$2) ;
            const activateTasksPool = new Pool$1(MAX_POOL_SIZE);

            activateTasksPool.get = function getActivateTask() {
              const task = this._get() || {
                preload: new UnsortedInvoker(invokePreload),
                onLoad: new OneOffInvoker(invokeOnLoad),
                onEnable: new OneOffInvoker(invokeOnEnable)
              };
              task.preload._zero.i = -1;
              let invoker = task.onLoad;
              invoker._zero.i = -1;
              invoker._neg.i = -1;
              invoker._pos.i = -1;
              invoker = task.onEnable;
              invoker._zero.i = -1;
              invoker._neg.i = -1;
              invoker._pos.i = -1;
              return task;
            };

            function _componentCorrupted(node, comp, index) {

              if (comp) {
                node._removeComponent(comp);
              } else {
                array.removeAt(node._components, index);
              }
            }

            class NodeActivator {
              constructor() {
                this.resetComp = void 0;
                this.reset();
              }

              reset() {
                this._activatingStack = [];
              }

              activateNode(node, active) {
                if (active) {
                  const task = activateTasksPool.get();

                  this._activatingStack.push(task);

                  this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);

                  task.preload.invoke();
                  task.onLoad.invoke();
                  task.onEnable.invoke();

                  this._activatingStack.pop();

                  activateTasksPool.put(task);
                } else {
                  this._deactivateNodeRecursively(node);

                  const stack = this._activatingStack;

                  for (const lastTask of stack) {
                    lastTask.preload.cancelInactive(IsPreloadStarted$1);
                    lastTask.onLoad.cancelInactive(IsOnLoadStarted$1);
                    lastTask.onEnable.cancelInactive();
                  }
                }

                node.emit('active-in-hierarchy-changed', node);
              }

              activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (!isValid(comp, true)) {
                  return;
                }

                if (!(comp._objFlags & IsPreloadStarted$1)) {
                  comp._objFlags |= IsPreloadStarted$1;

                  if (comp.__preload) {
                    if (preloadInvoker) {
                      preloadInvoker.add(comp);
                    } else {
                      comp.__preload();
                    }
                  }
                }

                if (!(comp._objFlags & IsOnLoadStarted$1)) {
                  comp._objFlags |= IsOnLoadStarted$1;

                  if (comp.onLoad) {
                    if (onLoadInvoker) {
                      onLoadInvoker.add(comp);
                    } else {
                      comp.onLoad();
                      comp._objFlags |= IsOnLoadCalled$2;
                    }
                  } else {
                    comp._objFlags |= IsOnLoadCalled$2;
                  }
                }

                if (comp._enabled) {
                  const deactivatedOnLoading = !comp.node._activeInHierarchy;

                  if (deactivatedOnLoading) {
                    return;
                  }

                  legacyCC.director._compScheduler.enableComp(comp, onEnableInvoker);
                }
              }

              destroyComp(comp) {
                legacyCC.director._compScheduler.disableComp(comp);

                if (comp.onDestroy && comp._objFlags & IsOnLoadCalled$2) {
                  comp.onDestroy();
                }
              }

              _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (node._objFlags & Deactivating$2) {
                  errorID(3816, node.name);
                  return;
                }

                node._activeInHierarchy = true;
                let originCount = node._components.length;

                for (let i = 0; i < originCount; ++i) {
                  const component = node._components[i];

                  if (component instanceof legacyCC.Component) {
                    this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker);
                  } else {
                    _componentCorrupted(node, component, i);

                    --i;
                    --originCount;
                  }
                }

                node._childArrivalOrder = node._children.length;

                for (let i = 0, len = node._children.length; i < len; ++i) {
                  const child = node._children[i];

                  if (child._active) {
                    this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
                  }
                }

                node._onPostActivated(true);
              }

              _deactivateNodeRecursively(node) {

                node._objFlags |= Deactivating$2;
                node._activeInHierarchy = false;
                const originCount = node._components.length;

                for (let c = 0; c < originCount; ++c) {
                  const component = node._components[c];

                  if (component._enabled) {
                    legacyCC.director._compScheduler.disableComp(component);

                    if (node._activeInHierarchy) {
                      node._objFlags &= ~Deactivating$2;
                      return;
                    }
                  }
                }

                for (let i = 0, len = node._children.length; i < len; ++i) {
                  const child = node._children[i];

                  if (child._activeInHierarchy) {
                    this._deactivateNodeRecursively(child);

                    if (node._activeInHierarchy) {
                      node._objFlags &= ~Deactivating$2;
                      return;
                    }
                  }
                }

                node._onPostActivated(false);

                node._objFlags &= ~Deactivating$2;
              }

            } exports('fN', NodeActivator);

            var _dec$s, _class$s, _class2$o, _descriptor$l, _temp$o;
            let SceneAsset = exports('f7', (_dec$s = ccclass('cc.SceneAsset'), _dec$s(_class$s = (_class2$o = (_temp$o = class SceneAsset extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "scene", _descriptor$l, this);
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                this.scene = new Scene('New Scene');
              }

              validate() {
                return !!this.scene;
              }

            }, _temp$o), (_descriptor$l = _applyDecoratedDescriptor(_class2$o.prototype, "scene", [editable, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$o)) || _class$s));
            legacyCC.SceneAsset = SceneAsset;

            var _dec$t, _class$t, _class2$p, _descriptor$m, _temp$p;
            let TextAsset = exports('ep', (_dec$t = ccclass('cc.TextAsset'), _dec$t(_class$t = (_class2$p = (_temp$p = class TextAsset extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "text", _descriptor$m, this);
              }

              toString() {
                return this.text;
              }

            }, _temp$p), (_descriptor$m = _applyDecoratedDescriptor(_class2$p.prototype, "text", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class2$p)) || _class$t));
            legacyCC.TextAsset = TextAsset;

            var _dec$u, _class$u, _class2$q, _descriptor$n, _temp$q;
            let JsonAsset = exports('f8', (_dec$u = ccclass('cc.JsonAsset'), _dec$u(_class$u = (_class2$q = (_temp$q = class JsonAsset extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "json", _descriptor$n, this);
              }

            }, _temp$q), (_descriptor$n = _applyDecoratedDescriptor(_class2$q.prototype, "json", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$q)) || _class$u));
            legacyCC.JsonAsset = JsonAsset;

            class DeferredPipelineSceneData extends PipelineSceneData {
              get deferredLightingMaterial() {
                return this._deferredLightingMaterial;
              }

              set deferredLightingMaterial(mat) {
                if (this._deferredLightingMaterial === mat || !mat) return;
                this._deferredLightingMaterial = mat;
                this.updateDeferredPassInfo();
              }

              get deferredPostMaterial() {
                return this._deferredPostMaterial;
              }

              set deferredPostMaterial(mat) {
                if (this._deferredPostMaterial === mat || !mat) return;
                this._deferredPostMaterial = mat;
                this.updateDeferredPassInfo();
              }

              onGlobalPipelineStateChanged() {
                this.updateDeferredPassInfo();
              }

              initPipelinePassInfo() {
                const deferredMat = new Material();
                deferredMat._uuid = 'builtin-deferred-material';
                deferredMat.initialize({
                  effectName: 'deferred-lighting'
                });

                for (let i = 0; i < deferredMat.passes.length; ++i) {
                  deferredMat.passes[i].tryCompile();
                }

                this._deferredLightingMaterial = deferredMat;
                const postMat = new Material();
                postMat._uuid = 'builtin-post-process-material';
                postMat.initialize({
                  effectName: 'post-process'
                });

                for (let i = 0; i < postMat.passes.length; ++i) {
                  postMat.passes[i].tryCompile();
                }

                this._deferredPostMaterial = postMat;
                this.updateDeferredPassInfo();
              }

              activate(device, pipeline) {
                super.activate(device, pipeline);
                this.initPipelinePassInfo();
                return true;
              }

              updateDeferredPassInfo() {
                this.updateDeferredLightPass();
                this.updateDeferredPostPass();
              }

              updateDeferredLightPass() {
                if (!this._deferredLightingMaterial) return;
                const passLit = this._deferredLightingMaterial.passes[0];
                passLit.beginChangeStatesSilently();
                passLit.tryCompile();
                passLit.endChangeStatesSilently();

                {
                  this._nativeObj.deferredLightPassShader = passLit.getShaderVariant();
                  this._nativeObj.deferredLightPass = passLit.native;
                }
              }

              updateDeferredPostPass() {
                if (!this.deferredPostMaterial) return;
                const passPost = this.deferredPostMaterial.passes[0];
                passPost.beginChangeStatesSilently();
                passPost.tryCompile();
                passPost.endChangeStatesSilently();

                {
                  this._nativeObj.deferredPostPassShader = passPost.getShaderVariant();
                  this._nativeObj.deferredPostPass = passPost.native;
                }
              }

            }

            nr.getPhaseID = getPhaseID;
            const RenderPipeline = exports('fp', nr.RenderPipeline);
            const RenderFlow = exports('fq', nr.RenderFlow);
            const RenderStage = exports('fr', nr.RenderStage);
            const InstancedBuffer$1 = exports('fs', nr.InstancedBuffer);
            const PipelineStateManager = exports('ft', nr.PipelineStateManager);
            let instancedBufferProto = nr.InstancedBuffer;
            let oldGetFunc = instancedBufferProto.get;
            let getOrCreatePipelineState = nr.PipelineStateManager.getOrCreatePipelineState;

            nr.PipelineStateManager.getOrCreatePipelineState = function (device, pass, shader, renderPass, ia) {
              return getOrCreatePipelineState.call(device, pass.native, shader, renderPass, ia);
            };

            function createDefaultPipeline() {
              const pipeline = new ForwardPipeline();
              pipeline.init();
              return pipeline;
            }
            class ForwardPipeline extends nr.ForwardPipeline {
              constructor() {
                super();
                this.pipelineSceneData = new PipelineSceneData();
                this._tag = 0;
                this._flows = [];
                this.renderTextures = [];
                this.materials = [];
              }

              init() {
                this.setPipelineSharedSceneData(this.pipelineSceneData.native);

                for (let i = 0; i < this._flows.length; i++) {
                  this._flows[i].init();
                }

                const info = new nr.RenderPipelineInfo(this._tag, this._flows);
                this.initialize(info);
              }

              activate() {
                return super.activate() && this.pipelineSceneData.activate(legacyCC.director.root.device, this);
              }

              render(cameras) {
                let nativeObjs = [];

                for (let i = 0, len = cameras.length; i < len; ++i) {
                  nativeObjs.push(cameras[i].native);
                }

                super.render(nativeObjs);
              }

              destroy() {
                this.pipelineSceneData.destroy();
                super.destroy();
              }

            } exports('fv', ForwardPipeline);
            mixin(ForwardPipeline.prototype, Asset.prototype);
            const ForwardOnLoaded = ForwardPipeline.prototype.onLoaded;

            ForwardPipeline.prototype.onLoaded = function () {
              if (ForwardOnLoaded) ForwardOnLoaded.call(this);
              this.init();
            };

            class ForwardFlow extends nr.ForwardFlow {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this._stages = [];
              }

              init() {
                for (let i = 0; i < this._stages.length; i++) {
                  this._stages[i].init();
                }

                const info = new nr.RenderFlowInfo(this._name, this._priority, this._tag, this._stages);
                this.initialize(info);
              }

            } exports('fw', ForwardFlow);
            class ShadowFlow extends nr.ShadowFlow {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this._stages = [];
              }

              init() {
                for (let i = 0; i < this._stages.length; i++) {
                  this._stages[i].init();
                }

                const info = new nr.RenderFlowInfo(this._name, this._priority, this._tag, this._stages);
                this.initialize(info);
              }

            } exports('fx', ShadowFlow);
            class ForwardStage extends nr.ForwardStage {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this.renderQueues = [];
              }

              init() {
                const queues = [];

                for (let i = 0; i < this.renderQueues.length; i++) {
                  queues.push(this.renderQueues[i].init());
                }

                const info = new nr.RenderStageInfo(this._name, this._priority, this._tag, queues);
                this.initialize(info);
              }

            } exports('fy', ForwardStage);
            class ShadowStage extends nr.ShadowStage {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
              }

              init() {
                const info = new nr.RenderStageInfo(this._name, this._priority, this._tag, []);
                this.initialize(info);
              }

            } exports('fz', ShadowStage);
            class RenderQueueDesc {
              constructor() {
                this.isTransparent = false;
                this.sortMode = 0;
                this.stages = [];
                this.isTransparent = false;
                this.sortMode = 0;
                this.stages = [];
              }

              init() {
                return new nr.RenderQueueDesc(this.isTransparent, this.sortMode, this.stages);
              }

            } exports('fA', RenderQueueDesc);
            class DeferredPipeline extends nr.DeferredPipeline {
              constructor() {
                super();
                this.pipelineSceneData = new DeferredPipelineSceneData();
                this._tag = 0;
                this._flows = [];
                this.renderTextures = [];
                this.materials = [];
              }

              init() {
                this.setPipelineSharedSceneData(this.pipelineSceneData.native);

                for (let i = 0; i < this._flows.length; i++) {
                  this._flows[i].init(this);
                }

                let info = new nr.RenderPipelineInfo(this._tag, this._flows);
                this.initialize(info);
              }

              activate() {
                return super.activate() && this.pipelineSceneData.activate(legacyCC.director.root.device, this);
              }

              render(cameras) {
                let nativeObjs = [];

                for (let i = 0, len = cameras.length; i < len; ++i) {
                  nativeObjs.push(cameras[i].native);
                }

                super.render(nativeObjs);
              }

              destroy() {
                this.fog.destroy();
                this.ambient.destroy();
                this.skybox.destroy();
                this.shadows.destroy();
                this.pipelineSceneData.destroy();
                super.destroy();
              }

            } exports('fB', DeferredPipeline);
            mixin(DeferredPipeline.prototype, Asset.prototype);
            const DeferredOnLoaded = DeferredPipeline.prototype.onLoaded;

            DeferredPipeline.prototype.onLoaded = function () {
              if (DeferredOnLoaded) DeferredOnLoaded.call(this);
              this.init();
            };

            class GbufferFlow extends nr.GbufferFlow {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this._stages = [];
              }

              init(pipeline) {
                for (let i = 0; i < this._stages.length; i++) {
                  this._stages[i].init(pipeline);
                }

                let info = new nr.RenderFlowInfo(this._name, this._priority, this._tag, this._stages);
                this.initialize(info);
              }

            } exports('fC', GbufferFlow);
            class GbufferStage extends nr.GbufferStage {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this.renderQueues = [];
              }

              init(pipeline) {
                const queues = [];

                for (let i = 0; i < this.renderQueues.length; i++) {
                  queues.push(this.renderQueues[i].init());
                }

                let info = new nr.RenderStageInfo(this._name, this._priority, this._tag, queues);
                this.initialize(info);
              }

            } exports('fD', GbufferStage);

            class LightingFlow extends nr.LightingFlow {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this._stages = [];
              }

              init(pipeline) {
                for (let i = 0; i < this._stages.length; i++) {
                  this._stages[i].init(pipeline);
                }

                let info = new nr.RenderFlowInfo(this._name, this._priority, this._tag, this._stages);
                this.initialize(info);
              }

            }

            class LightingStage extends nr.LightingStage {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this.renderQueues = [];
                this._deferredMaterial = null;
              }

              init(pipeline) {
                const queues = [];

                for (let i = 0; i < this.renderQueues.length; i++) {
                  queues.push(this.renderQueues[i].init());
                }

                pipeline.pipelineSceneData.deferredLightingMaterial = this._deferredMaterial;
                let info = new nr.RenderStageInfo(this._name, this._priority, this._tag, queues);
                this.initialize(info);
              }

            } exports('fE', LightingStage);
            class PostprocessStage extends nr.PostprocessStage {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this.renderQueues = [];
                this._postProcessMaterial = null;
              }

              init(pipeline) {
                const queues = [];

                for (let i = 0; i < this.renderQueues.length; i++) {
                  queues.push(this.renderQueues[i].init());
                }

                pipeline.pipelineSceneData.deferredPostMaterial = this._postProcessMaterial;
                let info = new nr.RenderStageInfo(this._name, this._priority, this._tag, queues);
                this.initialize(info);
              }

            } exports('fF', PostprocessStage);
            setClassName('DeferredPipeline', DeferredPipeline);
            setClassName('GbufferFlow', GbufferFlow);
            setClassName('GbufferStage', GbufferStage);
            setClassName('LightingFlow', LightingFlow);
            setClassName('LightingStage', LightingStage);
            setClassName('PostprocessStage', PostprocessStage);
            setClassName('ForwardPipeline', ForwardPipeline);
            setClassName('ForwardFlow', ForwardFlow);
            setClassName('ShadowFlow', ShadowFlow);
            setClassName('ForwardStage', ForwardStage);
            setClassName('ShadowStage', ShadowStage);
            setClassName('RenderQueueDesc', RenderQueueDesc);

            replaceProperty(SystemEventType, 'Node.EventType', [{
              name: 'POSITION_PART',
              newName: 'TRANSFORM_CHANGED'
            }, {
              name: 'ROTATION_PART',
              newName: 'TRANSFORM_CHANGED'
            }, {
              name: 'SCALE_PART',
              newName: 'TRANSFORM_CHANGED'
            }]);

            class AccelerometerInputSource {
              constructor() {
                this.support = void 0;
                this._intervalInSeconds = 0.2;
                this._intervalId = void 0;
                this._isEnabled = false;
                this._eventTarget = new EventTarget();
                this._didAccelerateFunc = void 0;
                const support = systemInfo.isMobile;
                this.support = support;
                this._didAccelerateFunc = this._didAccelerate.bind(this);
              }

              _didAccelerate() {
                const deviceMotionValue = jsb.device.getDeviceMotionValue();
                let x = deviceMotionValue[3] * 0.1;
                let y = deviceMotionValue[4] * 0.1;
                const z = deviceMotionValue[5] * 0.1;
                const orientation = screenAdapter.orientation;
                const tmpX = x;

                if (orientation === Orientation.LANDSCAPE_RIGHT) {
                  x = -y;
                  y = tmpX;
                } else if (orientation === Orientation.LANDSCAPE_LEFT) {
                  x = y;
                  y = -tmpX;
                } else if (orientation === Orientation.PORTRAIT_UPSIDE_DOWN) {
                  x = -x;
                  y = -y;
                }

                if (systemInfo.os === OS.ANDROID || systemInfo.os === OS.OHOS) {
                  x = -x;
                  y = -y;
                }

                const accelerometer = {
                  type: SystemEventType.DEVICEMOTION,
                  x,
                  y,
                  z,
                  timestamp: performance.now()
                };

                this._eventTarget.emit(SystemEventType.DEVICEMOTION, accelerometer);
              }

              start() {
                if (this._intervalId) {
                  clearInterval(this._intervalId);
                }

                this._intervalId = setInterval(this._didAccelerateFunc, this._intervalInSeconds * 1000);
                jsb.device.setAccelerometerInterval(this._intervalInSeconds);
                jsb.device.setAccelerometerEnabled(true);
                this._isEnabled = true;
              }

              stop() {
                if (this._intervalId) {
                  clearInterval(this._intervalId);
                  this._intervalId = undefined;
                }

                jsb.device.setAccelerometerEnabled(false);
                this._isEnabled = false;
              }

              setInterval(intervalInMileseconds) {
                this._intervalInSeconds = intervalInMileseconds / 1000;
                jsb.device.setAccelerometerInterval(this._intervalInSeconds);

                if (this._isEnabled) {
                  jsb.device.setAccelerometerEnabled(false);
                  jsb.device.setAccelerometerEnabled(true);
                }
              }

              onChange(cb) {
                this._eventTarget.on(SystemEventType.DEVICEMOTION, cb);
              }

            }

            class InputBox {
              constructor() {
                this.support = void 0;
                this.support = true;
              }

              show() {
                throw new Error('Method not implemented.');
              }

              hide() {
                throw new Error('Method not implemented.');
              }

              onChange() {
                throw new Error('Method not implemented.');
              }

              onComplete() {
                throw new Error('Method not implemented.');
              }

              offChange() {
                throw new Error('Method not implemented.');
              }

              offComplete() {
                throw new Error('Method not implemented.');
              }

            }

            let KeyCode;

            (function (KeyCode) {
              KeyCode[KeyCode["NONE"] = 0] = "NONE";
              KeyCode[KeyCode["BACKSPACE"] = 8] = "BACKSPACE";
              KeyCode[KeyCode["TAB"] = 9] = "TAB";
              KeyCode[KeyCode["ENTER"] = 13] = "ENTER";
              KeyCode[KeyCode["SHIFT_LEFT"] = 16] = "SHIFT_LEFT";
              KeyCode[KeyCode["CTRL_LEFT"] = 17] = "CTRL_LEFT";
              KeyCode[KeyCode["ALT_LEFT"] = 18] = "ALT_LEFT";
              KeyCode[KeyCode["PAUSE"] = 19] = "PAUSE";
              KeyCode[KeyCode["CAPS_LOCK"] = 20] = "CAPS_LOCK";
              KeyCode[KeyCode["ESCAPE"] = 27] = "ESCAPE";
              KeyCode[KeyCode["SPACE"] = 32] = "SPACE";
              KeyCode[KeyCode["PAGE_UP"] = 33] = "PAGE_UP";
              KeyCode[KeyCode["PAGE_DOWN"] = 34] = "PAGE_DOWN";
              KeyCode[KeyCode["END"] = 35] = "END";
              KeyCode[KeyCode["HOME"] = 36] = "HOME";
              KeyCode[KeyCode["ARROW_LEFT"] = 37] = "ARROW_LEFT";
              KeyCode[KeyCode["ARROW_UP"] = 38] = "ARROW_UP";
              KeyCode[KeyCode["ARROW_RIGHT"] = 39] = "ARROW_RIGHT";
              KeyCode[KeyCode["ARROW_DOWN"] = 40] = "ARROW_DOWN";
              KeyCode[KeyCode["INSERT"] = 45] = "INSERT";
              KeyCode[KeyCode["DELETE"] = 46] = "DELETE";
              KeyCode[KeyCode["DIGIT_0"] = 48] = "DIGIT_0";
              KeyCode[KeyCode["DIGIT_1"] = 49] = "DIGIT_1";
              KeyCode[KeyCode["DIGIT_2"] = 50] = "DIGIT_2";
              KeyCode[KeyCode["DIGIT_3"] = 51] = "DIGIT_3";
              KeyCode[KeyCode["DIGIT_4"] = 52] = "DIGIT_4";
              KeyCode[KeyCode["DIGIT_5"] = 53] = "DIGIT_5";
              KeyCode[KeyCode["DIGIT_6"] = 54] = "DIGIT_6";
              KeyCode[KeyCode["DIGIT_7"] = 55] = "DIGIT_7";
              KeyCode[KeyCode["DIGIT_8"] = 56] = "DIGIT_8";
              KeyCode[KeyCode["DIGIT_9"] = 57] = "DIGIT_9";
              KeyCode[KeyCode["KEY_A"] = 65] = "KEY_A";
              KeyCode[KeyCode["KEY_B"] = 66] = "KEY_B";
              KeyCode[KeyCode["KEY_C"] = 67] = "KEY_C";
              KeyCode[KeyCode["KEY_D"] = 68] = "KEY_D";
              KeyCode[KeyCode["KEY_E"] = 69] = "KEY_E";
              KeyCode[KeyCode["KEY_F"] = 70] = "KEY_F";
              KeyCode[KeyCode["KEY_G"] = 71] = "KEY_G";
              KeyCode[KeyCode["KEY_H"] = 72] = "KEY_H";
              KeyCode[KeyCode["KEY_I"] = 73] = "KEY_I";
              KeyCode[KeyCode["KEY_J"] = 74] = "KEY_J";
              KeyCode[KeyCode["KEY_K"] = 75] = "KEY_K";
              KeyCode[KeyCode["KEY_L"] = 76] = "KEY_L";
              KeyCode[KeyCode["KEY_M"] = 77] = "KEY_M";
              KeyCode[KeyCode["KEY_N"] = 78] = "KEY_N";
              KeyCode[KeyCode["KEY_O"] = 79] = "KEY_O";
              KeyCode[KeyCode["KEY_P"] = 80] = "KEY_P";
              KeyCode[KeyCode["KEY_Q"] = 81] = "KEY_Q";
              KeyCode[KeyCode["KEY_R"] = 82] = "KEY_R";
              KeyCode[KeyCode["KEY_S"] = 83] = "KEY_S";
              KeyCode[KeyCode["KEY_T"] = 84] = "KEY_T";
              KeyCode[KeyCode["KEY_U"] = 85] = "KEY_U";
              KeyCode[KeyCode["KEY_V"] = 86] = "KEY_V";
              KeyCode[KeyCode["KEY_W"] = 87] = "KEY_W";
              KeyCode[KeyCode["KEY_X"] = 88] = "KEY_X";
              KeyCode[KeyCode["KEY_Y"] = 89] = "KEY_Y";
              KeyCode[KeyCode["KEY_Z"] = 90] = "KEY_Z";
              KeyCode[KeyCode["NUM_0"] = 96] = "NUM_0";
              KeyCode[KeyCode["NUM_1"] = 97] = "NUM_1";
              KeyCode[KeyCode["NUM_2"] = 98] = "NUM_2";
              KeyCode[KeyCode["NUM_3"] = 99] = "NUM_3";
              KeyCode[KeyCode["NUM_4"] = 100] = "NUM_4";
              KeyCode[KeyCode["NUM_5"] = 101] = "NUM_5";
              KeyCode[KeyCode["NUM_6"] = 102] = "NUM_6";
              KeyCode[KeyCode["NUM_7"] = 103] = "NUM_7";
              KeyCode[KeyCode["NUM_8"] = 104] = "NUM_8";
              KeyCode[KeyCode["NUM_9"] = 105] = "NUM_9";
              KeyCode[KeyCode["NUM_MULTIPLY"] = 106] = "NUM_MULTIPLY";
              KeyCode[KeyCode["NUM_PLUS"] = 107] = "NUM_PLUS";
              KeyCode[KeyCode["NUM_SUBTRACT"] = 109] = "NUM_SUBTRACT";
              KeyCode[KeyCode["NUM_DECIMAL"] = 110] = "NUM_DECIMAL";
              KeyCode[KeyCode["NUM_DIVIDE"] = 111] = "NUM_DIVIDE";
              KeyCode[KeyCode["F1"] = 112] = "F1";
              KeyCode[KeyCode["F2"] = 113] = "F2";
              KeyCode[KeyCode["F3"] = 114] = "F3";
              KeyCode[KeyCode["F4"] = 115] = "F4";
              KeyCode[KeyCode["F5"] = 116] = "F5";
              KeyCode[KeyCode["F6"] = 117] = "F6";
              KeyCode[KeyCode["F7"] = 118] = "F7";
              KeyCode[KeyCode["F8"] = 119] = "F8";
              KeyCode[KeyCode["F9"] = 120] = "F9";
              KeyCode[KeyCode["F10"] = 121] = "F10";
              KeyCode[KeyCode["F11"] = 122] = "F11";
              KeyCode[KeyCode["F12"] = 123] = "F12";
              KeyCode[KeyCode["NUM_LOCK"] = 144] = "NUM_LOCK";
              KeyCode[KeyCode["SCROLL_LOCK"] = 145] = "SCROLL_LOCK";
              KeyCode[KeyCode["SEMICOLON"] = 186] = "SEMICOLON";
              KeyCode[KeyCode["EQUAL"] = 187] = "EQUAL";
              KeyCode[KeyCode["COMMA"] = 188] = "COMMA";
              KeyCode[KeyCode["DASH"] = 189] = "DASH";
              KeyCode[KeyCode["PERIOD"] = 190] = "PERIOD";
              KeyCode[KeyCode["SLASH"] = 191] = "SLASH";
              KeyCode[KeyCode["BACK_QUOTE"] = 192] = "BACK_QUOTE";
              KeyCode[KeyCode["BRACKET_LEFT"] = 219] = "BRACKET_LEFT";
              KeyCode[KeyCode["BACKSLASH"] = 220] = "BACKSLASH";
              KeyCode[KeyCode["BRACKET_RIGHT"] = 221] = "BRACKET_RIGHT";
              KeyCode[KeyCode["QUOTE"] = 222] = "QUOTE";
              KeyCode[KeyCode["SHIFT_RIGHT"] = 2000] = "SHIFT_RIGHT";
              KeyCode[KeyCode["CTRL_RIGHT"] = 2001] = "CTRL_RIGHT";
              KeyCode[KeyCode["ALT_RIGHT"] = 2002] = "ALT_RIGHT";
              KeyCode[KeyCode["NUM_ENTER"] = 2003] = "NUM_ENTER";
            })(KeyCode || (KeyCode = exports('dp', {})));

            const nativeKeyCode2KeyCode = {
              12: KeyCode.NUM_LOCK,
              10048: KeyCode.NUM_0,
              10049: KeyCode.NUM_1,
              10050: KeyCode.NUM_2,
              10051: KeyCode.NUM_3,
              10052: KeyCode.NUM_4,
              10053: KeyCode.NUM_5,
              10054: KeyCode.NUM_6,
              10055: KeyCode.NUM_7,
              10056: KeyCode.NUM_8,
              10057: KeyCode.NUM_9,
              20013: KeyCode.NUM_ENTER,
              20016: KeyCode.SHIFT_RIGHT,
              20017: KeyCode.CTRL_RIGHT,
              20018: KeyCode.ALT_RIGHT
            };

            function getKeyCode(keyCode) {
              return nativeKeyCode2KeyCode[keyCode] || keyCode;
            }

            class KeyboardInputSource {
              constructor() {
                this.support = void 0;
                this._eventTarget = new EventTarget();
                this._keyStateMap = {};
                this.support = !systemInfo.isMobile;

                this._registerEvent();
              }

              _registerEvent() {
                jsb.onKeyDown = event => {
                  const keyCode = getKeyCode(event.keyCode);

                  const keyPressingInputEvent = this._getInputEvent(event, SystemEventType.KEY_DOWN);

                  this._eventTarget.emit(SystemEventType.KEY_DOWN, keyPressingInputEvent);

                  this._keyStateMap[keyCode] = true;
                };

                jsb.onKeyUp = event => {
                  const keyCode = getKeyCode(event.keyCode);
                  const inputEvent = {
                    type: SystemEventType.KEY_UP,
                    code: keyCode,
                    timestamp: performance.now()
                  };
                  this._keyStateMap[keyCode] = false;

                  this._eventTarget.emit(SystemEventType.KEY_UP, inputEvent);
                };
              }

              _getInputEvent(event, eventType) {
                const keyCode = getKeyCode(event.keyCode);
                const inputEvent = {
                  type: eventType,
                  code: keyCode,
                  timestamp: performance.now()
                };
                return inputEvent;
              }

              onDown(cb) {
                this._eventTarget.on('keypress', cb);
              }

              onPressing(cb) {
                this._eventTarget.on(SystemEventType.KEY_DOWN, cb);
              }

              onUp(cb) {
                this._eventTarget.on(SystemEventType.KEY_UP, cb);
              }

            }

            class MouseInputSource {
              constructor() {
                this.support = void 0;
                this._eventTarget = new EventTarget();
                this._preMousePos = new Vec2();
                this.support = !systemInfo.isMobile;

                this._registerEvent();
              }

              _getLocation(event) {
                return new Vec2(event.x, event.y);
              }

              _registerEvent() {
                jsb.onMouseDown = this._createCallback(SystemEventType.MOUSE_DOWN);
                jsb.onMouseMove = this._createCallback(SystemEventType.MOUSE_MOVE);
                jsb.onMouseUp = this._createCallback(SystemEventType.MOUSE_UP);

                jsb.onMouseWheel = event => {
                  const location = this._getLocation(event);

                  const windowSize = screenAdapter.windowSize;
                  const matchStandardFactor = 120;
                  const inputEvent = {
                    type: SystemEventType.MOUSE_WHEEL,
                    x: location.x,
                    y: windowSize.height - location.y,
                    button: event.button,
                    deltaX: event.wheelDeltaX * matchStandardFactor,
                    deltaY: event.wheelDeltaY * matchStandardFactor,
                    timestamp: performance.now()
                  };

                  this._eventTarget.emit(SystemEventType.MOUSE_WHEEL, inputEvent);
                };
              }

              _createCallback(eventType) {
                return event => {
                  const location = this._getLocation(event);

                  const windowSize = screenAdapter.windowSize;
                  const locationX = location.x;
                  const locationY = windowSize.height - location.y;
                  const inputEvent = {
                    type: eventType,
                    x: locationX,
                    y: locationY,
                    movementX: locationX - this._preMousePos.x,
                    movementY: this._preMousePos.y - locationY,
                    button: event.button,
                    timestamp: performance.now()
                  };

                  this._preMousePos.set(inputEvent.x, inputEvent.y);

                  this._eventTarget.emit(eventType, inputEvent);
                };
              }

              onDown(cb) {
                this._eventTarget.on(SystemEventType.MOUSE_DOWN, cb);
              }

              onMove(cb) {
                this._eventTarget.on(SystemEventType.MOUSE_MOVE, cb);
              }

              onUp(cb) {
                this._eventTarget.on(SystemEventType.MOUSE_UP, cb);
              }

              onWheel(cb) {
                this._eventTarget.on(SystemEventType.MOUSE_WHEEL, cb);
              }

            }

            class TouchInputSource {
              constructor() {
                this.support = void 0;
                this._eventTarget = new EventTarget();
                this.support = true;

                this._registerEvent();
              }

              _registerEvent() {
                jsb.onTouchStart = this._createCallback(SystemEventType.TOUCH_START);
                jsb.onTouchMove = this._createCallback(SystemEventType.TOUCH_MOVE);
                jsb.onTouchEnd = this._createCallback(SystemEventType.TOUCH_END);
                jsb.onTouchCancel = this._createCallback(SystemEventType.TOUCH_CANCEL);
              }

              _createCallback(eventType) {
                return touchList => {
                  const touchDataList = [];
                  const length = touchList.length;
                  const windowSize = screenAdapter.windowSize;

                  for (let i = 0; i < length; ++i) {
                    const touch = touchList[i];

                    const location = this._getLocation(touch);

                    const x = location.x;
                    const y = windowSize.height - location.y;
                    const touchData = {
                      identifier: touch.identifier,
                      x,
                      y,
                      force: touch.force
                    };
                    touchDataList.push(touchData);
                  }

                  const inputEvent = {
                    type: eventType,
                    changedTouches: touchDataList,
                    timestamp: performance.now()
                  };

                  this._eventTarget.emit(eventType, inputEvent);
                };
              }

              _getLocation(event) {
                return new Vec2(event.clientX, event.clientY);
              }

              onStart(cb) {
                this._eventTarget.on(SystemEventType.TOUCH_START, cb);
              }

              onMove(cb) {
                this._eventTarget.on(SystemEventType.TOUCH_MOVE, cb);
              }

              onEnd(cb) {
                this._eventTarget.on(SystemEventType.TOUCH_END, cb);
              }

              onCancel(cb) {
                this._eventTarget.on(SystemEventType.TOUCH_CANCEL, cb);
              }

            }

            class Input {
              constructor() {
                this._touch = new TouchInputSource();
                this._mouse = new MouseInputSource();
                this._keyboard = new KeyboardInputSource();
                this._accelerometer = new AccelerometerInputSource();
                this._inputBox = new InputBox();
                this._touchEvents = [];
                this._mouseEvents = [];
                this._keyboardEvents = [];
                this._accelerometerEvents = [];

                this._registerEvent();
              }

              _registerEvent() {
                if (this._touch.support) {
                  const touchEvents = this._touchEvents;

                  this._touch.onStart(event => {
                    touchEvents.push(event);
                  });

                  this._touch.onMove(event => {
                    touchEvents.push(event);
                  });

                  this._touch.onEnd(event => {
                    touchEvents.push(event);
                  });

                  this._touch.onCancel(event => {
                    touchEvents.push(event);
                  });
                }

                if (this._mouse.support) {
                  const mouseEvents = this._mouseEvents;

                  this._mouse.onDown(event => {
                    mouseEvents.push(event);
                  });

                  this._mouse.onMove(event => {
                    mouseEvents.push(event);
                  });

                  this._mouse.onUp(event => {
                    mouseEvents.push(event);
                  });

                  this._mouse.onWheel(event => {
                    mouseEvents.push(event);
                  });
                }

                if (this._keyboard.support) {
                  const keyboardEvents = this._keyboardEvents;

                  this._keyboard.onPressing(event => {
                    keyboardEvents.push(event);
                  });

                  this._keyboard.onUp(event => {
                    keyboardEvents.push(event);
                  });
                }

                if (this._accelerometer.support) {
                  const accelerometerEvents = this._accelerometerEvents;

                  this._accelerometer.onChange(event => {
                    accelerometerEvents.push(event);
                  });
                }
              }

              startAccelerometer() {
                this._accelerometer.start();
              }

              stopAccelerometer() {
                this._accelerometer.stop();
              }

              setAccelerometerInterval(interval) {
                this._accelerometer.setInterval(interval);
              }

              pollTouchEvents() {
                const events = js.array.copy(this._touchEvents);
                this._touchEvents.length = 0;
                return events;
              }

              pollMouseEvents() {
                const events = js.array.copy(this._mouseEvents);
                this._mouseEvents.length = 0;
                return events;
              }

              pollKeyboardEvents() {
                const events = js.array.copy(this._keyboardEvents);
                this._keyboardEvents.length = 0;
                return events;
              }

              pollAccelerometerEvents() {
                const events = js.array.copy(this._accelerometerEvents);
                this._accelerometerEvents.length = 0;
                return events;
              }

            }
            const input = new Input();

            const _vec2 = new Vec2();

            class EventMouse extends Event {
              get eventType() {
                return this._eventType;
              }

              constructor(eventType, bubbles, prevLoc) {
                super(eventType, bubbles);
                this.movementX = 0;
                this.movementY = 0;
                this._eventType = void 0;
                this._button = EventMouse.BUTTON_MISSING;
                this._x = 0;
                this._y = 0;
                this._prevX = 0;
                this._prevY = 0;
                this._scrollX = 0;
                this._scrollY = 0;
                this._eventType = eventType;

                if (prevLoc) {
                  this._prevX = prevLoc.x;
                  this._prevY = prevLoc.y;
                }
              }

              setScrollData(scrollX, scrollY) {
                this._scrollX = scrollX;
                this._scrollY = scrollY;
              }

              getScrollX() {
                return this._scrollX;
              }

              getScrollY() {
                return this._scrollY;
              }

              setLocation(x, y) {
                this._x = x;
                this._y = y;
              }

              getLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._x, this._y);
                return out;
              }

              getLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._x, legacyCC.view._designResolutionSize.height - this._y);
                return out;
              }

              getUILocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._x, this._y);

                legacyCC.view._convertPointWithScale(out);

                return out;
              }

              getPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._prevX, this._prevY);
                return out;
              }

              getUIPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._prevX, this._prevY);

                legacyCC.view._convertPointWithScale(out);

                return out;
              }

              getDelta(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._x - this._prevX, this._y - this._prevY);
                return out;
              }

              getDeltaX() {
                return this._x - this._prevX;
              }

              getDeltaY() {
                return this._y - this._prevY;
              }

              getUIDelta(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, (this._x - this._prevX) / legacyCC.view.getScaleX(), (this._y - this._prevY) / legacyCC.view.getScaleY());
                return out;
              }

              getUIDeltaX() {
                return (this._x - this._prevX) / legacyCC.view.getScaleX();
              }

              getUIDeltaY() {
                return (this._y - this._prevY) / legacyCC.view.getScaleY();
              }

              setButton(button) {
                this._button = button;
              }

              getButton() {
                return this._button;
              }

              getLocationX() {
                return this._x;
              }

              getLocationY() {
                return this._y;
              }

              getUILocationX() {
                const viewport = legacyCC.view.getViewportRect();
                return (this._x - viewport.x) / legacyCC.view.getScaleX();
              }

              getUILocationY() {
                const viewport = legacyCC.view.getViewportRect();
                return (this._y - viewport.y) / legacyCC.view.getScaleY();
              }

            } exports('fl', EventMouse);
            EventMouse.BUTTON_MISSING = -1;
            EventMouse.BUTTON_LEFT = 0;
            EventMouse.BUTTON_RIGHT = 2;
            EventMouse.BUTTON_MIDDLE = 1;
            EventMouse.BUTTON_4 = 3;
            EventMouse.BUTTON_5 = 4;
            EventMouse.BUTTON_6 = 5;
            EventMouse.BUTTON_7 = 6;
            EventMouse.BUTTON_8 = 7;
            class EventTouch extends Event {
              constructor(changedTouches, bubbles, eventType, touches = []) {
                super(eventType, bubbles);
                this.touch = null;
                this.simulate = false;
                this._eventCode = void 0;
                this._touches = void 0;
                this._allTouches = void 0;
                this._eventCode = eventType;
                this._touches = changedTouches || [];
                this._allTouches = touches;
              }

              getEventCode() {
                return this._eventCode;
              }

              getTouches() {
                return this._touches;
              }

              getAllTouches() {
                return this._allTouches;
              }

              setLocation(x, y) {
                if (this.touch) {
                  this.touch.setTouchInfo(this.touch.getID(), x, y);
                }
              }

              getLocation(out) {
                return this.touch ? this.touch.getLocation(out) : new Vec2();
              }

              getUILocation(out) {
                return this.touch ? this.touch.getUILocation(out) : new Vec2();
              }

              getLocationInView(out) {
                return this.touch ? this.touch.getLocationInView(out) : new Vec2();
              }

              getPreviousLocation(out) {
                return this.touch ? this.touch.getPreviousLocation(out) : new Vec2();
              }

              getStartLocation(out) {
                return this.touch ? this.touch.getStartLocation(out) : new Vec2();
              }

              getUIStartLocation(out) {
                return this.touch ? this.touch.getUIStartLocation(out) : new Vec2();
              }

              getID() {
                return this.touch ? this.touch.getID() : null;
              }

              getDelta(out) {
                return this.touch ? this.touch.getDelta(out) : new Vec2();
              }

              getUIDelta(out) {
                return this.touch ? this.touch.getUIDelta(out) : new Vec2();
              }

              getDeltaX() {
                return this.touch ? this.touch.getDelta(_vec2).x : 0;
              }

              getDeltaY() {
                return this.touch ? this.touch.getDelta(_vec2).y : 0;
              }

              getLocationX() {
                return this.touch ? this.touch.getLocationX() : 0;
              }

              getLocationY() {
                return this.touch ? this.touch.getLocationY() : 0;
              }

            } exports('du', EventTouch);
            EventTouch.MAX_TOUCHES = 5;
            class EventAcceleration extends Event {
              constructor(acc, bubbles) {
                super(SystemEventType.DEVICEMOTION, bubbles);
                this.acc = void 0;
                this.acc = acc;
              }

            } exports('fm', EventAcceleration);
            class EventKeyboard extends Event {
              get isPressed() {
                return this._isPressed;
              }

              constructor(keyCode, eventType, bubbles) {
                if (typeof eventType === 'boolean') {
                  const isPressed = eventType;
                  eventType = isPressed ? SystemEventType.KEY_DOWN : SystemEventType.KEY_UP;
                }

                super(eventType, bubbles);
                this.keyCode = void 0;
                this.rawEvent = void 0;
                this._isPressed = void 0;
                this._isPressed = eventType !== SystemEventType.KEY_UP;

                if (typeof keyCode === 'number') {
                  this.keyCode = keyCode;
                } else {
                  this.keyCode = keyCode.keyCode;
                  this.rawEvent = keyCode;
                }
              }

            } exports('fn', EventKeyboard);
            Event.EventMouse = EventMouse;
            Event.EventTouch = EventTouch;
            Event.EventAcceleration = EventAcceleration;
            Event.EventKeyboard = EventKeyboard;

            const _vec2$1 = new Vec2();

            class Touch {
              get lastModified() {
                return this._lastModified;
              }

              constructor(x, y, id = 0) {
                this._point = new Vec2();
                this._prevPoint = new Vec2();
                this._lastModified = 0;
                this._id = 0;
                this._startPoint = new Vec2();
                this._startPointCaptured = false;
                this.setTouchInfo(id, x, y);
              }

              getLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._point.x, this._point.y);
                return out;
              }

              getLocationX() {
                return this._point.x;
              }

              getLocationY() {
                return this._point.y;
              }

              getUILocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._point.x, this._point.y);

                legacyCC.view._convertPointWithScale(out);

                return out;
              }

              getUILocationX() {
                const viewport = legacyCC.view.getViewportRect();
                return (this._point.x - viewport.x) / legacyCC.view.getScaleX();
              }

              getUILocationY() {
                const viewport = legacyCC.view.getViewportRect();
                return (this._point.y - viewport.y) / legacyCC.view.getScaleY();
              }

              getPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._prevPoint.x, this._prevPoint.y);
                return out;
              }

              getUIPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._prevPoint.x, this._prevPoint.y);

                legacyCC.view._convertPointWithScale(out);

                return out;
              }

              getStartLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._startPoint.x, this._startPoint.y);
                return out;
              }

              getUIStartLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._startPoint.x, this._startPoint.y);

                legacyCC.view._convertPointWithScale(out);

                return out;
              }

              getDelta(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._point);
                out.subtract(this._prevPoint);
                return out;
              }

              getUIDelta(out) {
                if (!out) {
                  out = new Vec2();
                }

                _vec2$1.set(this._point);

                _vec2$1.subtract(this._prevPoint);

                out.set(legacyCC.view.getScaleX(), legacyCC.view.getScaleY());
                Vec2.divide(out, _vec2$1, out);
                return out;
              }

              getLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._point.x, legacyCC.view._designResolutionSize.height - this._point.y);
                return out;
              }

              getPreviousLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._prevPoint.x, legacyCC.view._designResolutionSize.height - this._prevPoint.y);
                return out;
              }

              getStartLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._startPoint.x, legacyCC.view._designResolutionSize.height - this._startPoint.y);
                return out;
              }

              getID() {
                return this._id;
              }

              setTouchInfo(id = 0, x, y) {
                this._prevPoint = this._point;
                this._point = new Vec2(x || 0, y || 0);
                this._id = id;

                if (!this._startPointCaptured) {
                  this._startPoint = new Vec2(this._point);
                  this._startPointCaptured = true;
                }
              }

              setPoint(x, y) {
                if (typeof x === 'object') {
                  this._point.x = x.x;
                  this._point.y = x.y;
                } else {
                  this._point.x = x || 0;
                  this._point.y = y || 0;
                }

                this._lastModified = legacyCC.game.frameStartTime;
              }

              setPrevPoint(x, y) {
                if (typeof x === 'object') {
                  this._prevPoint = new Vec2(x.x, x.y);
                } else {
                  this._prevPoint = new Vec2(x || 0, y || 0);
                }

                this._lastModified = legacyCC.game.frameStartTime;
              }

            } exports('fo', Touch);
            legacyCC.Touch = Touch;

            class Acceleration {
              constructor(x = 0, y = 0, z = 0, timestamp = 0) {
                this.x = void 0;
                this.y = void 0;
                this.z = void 0;
                this.timestamp = void 0;
                this.x = x;
                this.y = y;
                this.z = z;
                this.timestamp = timestamp;
              }

            }

            const TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT;

            const _vec2$2 = new Vec2();

            const _preLocation = new Vec2();

            class InputManager {
              constructor() {
                this._preTouchPoint = new Vec2();
                this._prevMousePoint = new Vec2();
                this._preTouchPool = [];
                this._preTouchPoolPointer = 0;
                this._touches = [];
                this._touchesIntegerDict = {};
                this._indexBitsUsed = 0;
                this._maxTouches = 8;
                this._glView = null;
              }

              clearEvents() {
                input.pollMouseEvents();
                input.pollTouchEvents();
                input.pollKeyboardEvents();
                input.pollAccelerometerEvents();
              }

              frameDispatchEvents() {
                const mouseEvents = input.pollMouseEvents();

                for (let i = 0, length = mouseEvents.length; i < length; ++i) {
                  const mouseEvent = mouseEvents[i];

                  this._dispatchMouseEvent(mouseEvent);
                }

                const touchEvents = input.pollTouchEvents();

                for (let i = 0, length = touchEvents.length; i < length; ++i) {
                  const touchEvent = touchEvents[i];

                  this._dispatchTouchEvent(touchEvent);
                }

                const keyboardEvents = input.pollKeyboardEvents();

                for (let i = 0, length = keyboardEvents.length; i < length; ++i) {
                  const keyboardEvent = keyboardEvents[i];

                  this._dispatchKeyboardEvent(keyboardEvent);
                }

                const accelerometerEvents = input.pollAccelerometerEvents();

                for (let i = 0, length = accelerometerEvents.length; i < length; ++i) {
                  const accelerometerEvent = accelerometerEvents[i];

                  this._dispatchAccelerometerEvent(accelerometerEvent);
                }
              }

              _dispatchMouseEvent(inputEvent) {
                let mouseEvent;
                let touch;

                switch (inputEvent.type) {
                  case SystemEventType.MOUSE_DOWN:
                    mouseEvent = this._getMouseEvent(inputEvent);
                    touch = this._getTouch(inputEvent);

                    this._handleTouchesStart([touch]);

                    eventManager.dispatchEvent(mouseEvent);
                    break;

                  case SystemEventType.MOUSE_MOVE:
                    mouseEvent = this._getMouseEvent(inputEvent);
                    touch = this._getTouch(inputEvent);

                    this._handleTouchesMove([touch]);

                    eventManager.dispatchEvent(mouseEvent);
                    break;

                  case SystemEventType.MOUSE_UP:
                    mouseEvent = this._getMouseEvent(inputEvent);
                    touch = this._getTouch(inputEvent);

                    this._handleTouchesEnd([touch]);

                    eventManager.dispatchEvent(mouseEvent);
                    break;

                  case SystemEventType.MOUSE_WHEEL:
                    mouseEvent = this._getMouseEvent(inputEvent);
                    mouseEvent.setScrollData(inputEvent.deltaX, inputEvent.deltaY);
                    eventManager.dispatchEvent(mouseEvent);
                    break;
                }
              }

              _dispatchTouchEvent(inputEvent) {
                const touchList = this._getTouchList(inputEvent);

                switch (inputEvent.type) {
                  case SystemEventType.TOUCH_START:
                    this._handleTouchesStart(touchList);

                    break;

                  case SystemEventType.TOUCH_MOVE:
                    this._handleTouchesMove(touchList);

                    break;

                  case SystemEventType.TOUCH_END:
                    this._handleTouchesEnd(touchList);

                    break;

                  case SystemEventType.TOUCH_CANCEL:
                    this._handleTouchesCancel(touchList);

                    break;
                }
              }

              _handleTouchesStart(touches) {
                const handleTouches = [];
                const locTouchIntDict = this._touchesIntegerDict;

                for (let i = 0; i < touches.length; ++i) {
                  const touch = touches[i];
                  const touchID = touch.getID();

                  if (touchID === null) {
                    continue;
                  }

                  const index = locTouchIntDict[touchID];

                  if (index === undefined) {
                    const unusedIndex = this._getUnUsedIndex();

                    if (unusedIndex === -1) {
                      logID(2300, unusedIndex);
                      continue;
                    }

                    touch.getLocation(_vec2$2);
                    const curTouch = new Touch(_vec2$2.x, _vec2$2.y, touchID);
                    this._touches[unusedIndex] = curTouch;
                    touch.getPreviousLocation(_vec2$2);
                    curTouch.setPrevPoint(_vec2$2);
                    locTouchIntDict[touchID] = unusedIndex;
                    handleTouches.push(curTouch);
                  }
                }

                if (handleTouches.length > 0) {
                  const touchEvent = new EventTouch(handleTouches, false, SystemEventType.TOUCH_START, macro.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : handleTouches);
                  eventManager.dispatchEvent(touchEvent);
                }
              }

              _handleTouchesMove(touches) {
                const handleTouches = [];
                const locTouches = this._touches;

                for (let i = 0; i < touches.length; ++i) {
                  const touch = touches[i];
                  const touchID = touch.getID();

                  if (touchID === null) {
                    continue;
                  }

                  const index = this._touchesIntegerDict[touchID];

                  if (index === undefined) {
                    continue;
                  }

                  if (locTouches[index]) {
                    touch.getLocation(_vec2$2);
                    locTouches[index].setPoint(_vec2$2);
                    touch.getPreviousLocation(_vec2$2);
                    locTouches[index].setPrevPoint(_vec2$2);
                    handleTouches.push(locTouches[index]);
                  }
                }

                if (handleTouches.length > 0) {
                  const touchEvent = new EventTouch(handleTouches, false, SystemEventType.TOUCH_MOVE, macro.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : handleTouches);
                  eventManager.dispatchEvent(touchEvent);
                }
              }

              _handleTouchesEnd(touches) {
                const handleTouches = this.getSetOfTouchesEndOrCancel(touches);

                if (handleTouches.length > 0) {
                  const touchEvent = new EventTouch(handleTouches, false, SystemEventType.TOUCH_END, macro.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : handleTouches);
                  eventManager.dispatchEvent(touchEvent);
                }

                this._preTouchPool.length = 0;
              }

              _handleTouchesCancel(touches) {
                const handleTouches = this.getSetOfTouchesEndOrCancel(touches);

                if (handleTouches.length > 0) {
                  const touchEvent = new EventTouch(handleTouches, false, SystemEventType.TOUCH_CANCEL, macro.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : handleTouches);
                  eventManager.dispatchEvent(touchEvent);
                }

                this._preTouchPool.length = 0;
              }

              getSetOfTouchesEndOrCancel(touches) {
                const handleTouches = [];
                const locTouches = this._touches;
                const locTouchesIntDict = this._touchesIntegerDict;

                for (let i = 0; i < touches.length; ++i) {
                  const touch = touches[i];
                  const touchID = touch.getID();

                  if (touchID === null) {
                    continue;
                  }

                  const index = locTouchesIntDict[touchID];

                  if (index === undefined) {
                    continue;
                  }

                  if (locTouches[index]) {
                    touch.getLocation(_vec2$2);
                    locTouches[index].setPoint(_vec2$2);
                    touch.getPreviousLocation(_vec2$2);
                    locTouches[index].setPrevPoint(_vec2$2);
                    handleTouches.push(locTouches[index]);

                    this._removeUsedIndexBit(index);

                    delete locTouchesIntDict[touchID];
                  }
                }

                return handleTouches;
              }

              _getPreTouch(touch) {
                let preTouch = null;
                const locPreTouchPool = this._preTouchPool;
                const id = touch.getID();

                for (let i = locPreTouchPool.length - 1; i >= 0; i--) {
                  if (locPreTouchPool[i].getID() === id) {
                    preTouch = locPreTouchPool[i];
                    break;
                  }
                }

                if (!preTouch) {
                  preTouch = touch;
                }

                return preTouch;
              }

              _setPreTouch(touch) {
                let find = false;
                const locPreTouchPool = this._preTouchPool;
                const id = touch.getID();

                for (let i = locPreTouchPool.length - 1; i >= 0; i--) {
                  if (locPreTouchPool[i].getID() === id) {
                    locPreTouchPool[i] = touch;
                    find = true;
                    break;
                  }
                }

                if (!find) {
                  if (locPreTouchPool.length <= 50) {
                    locPreTouchPool.push(touch);
                  } else {
                    locPreTouchPool[this._preTouchPoolPointer] = touch;
                    this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50;
                  }
                }
              }

              _getViewPixelRatio() {
                if (!this._glView) {
                  this._glView = legacyCC.view;
                }

                return this._glView ? this._glView._devicePixelRatio : 1;
              }

              _getTouch(inputEvent) {
                const locPreTouch = this._preTouchPoint;

                const pixelRatio = this._getViewPixelRatio();

                const x = inputEvent.x * pixelRatio;
                const y = inputEvent.y * pixelRatio;
                const touch = new Touch(x, y, 0);
                touch.setPrevPoint(locPreTouch.x, locPreTouch.y);
                locPreTouch.x = x;
                locPreTouch.y = y;
                return touch;
              }

              _getMouseEvent(inputEvent) {
                const locPreMouse = this._prevMousePoint;
                const mouseEvent = new EventMouse(inputEvent.type, false, locPreMouse);

                const pixelRatio = this._getViewPixelRatio();

                locPreMouse.x = inputEvent.x * pixelRatio;
                locPreMouse.y = inputEvent.y * pixelRatio;

                if (legacyCC.GAME_VIEW) {
                  locPreMouse.x /= legacyCC.gameView.canvas.width / legacyCC.game.canvas.width;
                  locPreMouse.y /= legacyCC.gameView.canvas.height / legacyCC.game.canvas.height;
                }

                mouseEvent.setLocation(locPreMouse.x, locPreMouse.y);
                mouseEvent.setButton(inputEvent.button);

                if (inputEvent.movementX) {
                  mouseEvent.movementX = inputEvent.movementX;
                }

                if (inputEvent.movementY) {
                  mouseEvent.movementY = inputEvent.movementY;
                }

                return mouseEvent;
              }

              _getTouchList(inputEvent) {
                const touchList = [];
                const locPreTouch = this._preTouchPoint;
                const length = inputEvent.changedTouches.length;

                const pixelRatio = this._getViewPixelRatio();

                for (let i = 0; i < length; i++) {
                  const touchData = inputEvent.changedTouches[i];
                  const x = touchData.x * pixelRatio;
                  const y = touchData.y * pixelRatio;
                  const touch = new Touch(x, y, touchData.identifier);

                  this._getPreTouch(touch).getLocation(_preLocation);

                  touch.setPrevPoint(_preLocation.x, _preLocation.y);

                  this._setPreTouch(touch);

                  locPreTouch.x = x;
                  locPreTouch.y = y;
                  touchList.push(touch);

                  if (!macro.ENABLE_MULTI_TOUCH) {
                    break;
                  }
                }

                return touchList;
              }

              _getUnUsedIndex() {
                let temp = this._indexBitsUsed;
                const now = legacyCC.game.frameStartTime;

                for (let i = 0; i < this._maxTouches; i++) {
                  if (!(temp & 0x00000001)) {
                    this._indexBitsUsed |= 1 << i;
                    return i;
                  } else {
                    const touch = this._touches[i];

                    if (now - touch.lastModified > TOUCH_TIMEOUT) {
                      this._removeUsedIndexBit(i);

                      const touchID = touch.getID();

                      if (touchID !== null) {
                        delete this._touchesIntegerDict[touchID];
                      }

                      return i;
                    }
                  }

                  temp >>= 1;
                }

                return -1;
              }

              _removeUsedIndexBit(index) {
                if (index < 0 || index >= this._maxTouches) {
                  return;
                }

                let temp = 1 << index;
                temp = ~temp;
                this._indexBitsUsed &= temp;
              }

              _getUsefulTouches() {
                const touches = [];
                const touchDict = this._touchesIntegerDict;

                for (const id in touchDict) {
                  const index = parseInt(id);
                  const usedID = touchDict[index];

                  if (usedID === undefined || usedID === null) {
                    continue;
                  }

                  const touch = this._touches[usedID];
                  touches.push(touch);
                }

                return touches;
              }

              _dispatchKeyboardEvent(inputEvent) {
                switch (inputEvent.type) {
                  case SystemEventType.KEY_DOWN:
                    eventManager.dispatchEvent(new EventKeyboard(inputEvent.code, SystemEventType.KEY_DOWN));
                    break;

                  case SystemEventType.KEY_UP:
                    eventManager.dispatchEvent(new EventKeyboard(inputEvent.code, SystemEventType.KEY_UP));
                    break;
                }
              }

              _dispatchAccelerometerEvent(inputEvent) {
                if (inputEvent.type === SystemEventType.DEVICEMOTION) {
                  const {
                    x,
                    y,
                    z,
                    timestamp
                  } = inputEvent;
                  eventManager.dispatchEvent(new EventAcceleration(new Acceleration(x, y, z, timestamp)));
                }
              }

              setAccelerometerEnabled(isEnable) {
                if (isEnable) {
                  input.startAccelerometer();
                } else {
                  input.stopAccelerometer();
                }
              }

              setAccelerometerInterval(intervalInMileSeconds) {
                input.setAccelerometerInterval(intervalInMileSeconds);
              }

            }

            const inputManager = new InputManager();
            legacyCC.internal.inputManager = inputManager;

            let keyboardListener = null;
            let accelerationListener = null;
            let touchListener = null;
            let mouseListener = null;
            class SystemEvent extends EventTarget {
              constructor() {
                super();
              }

              setAccelerometerEnabled(isEnabled) {

                if (isEnabled && window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
                  DeviceMotionEvent.requestPermission().then(response => {
                    logID(3520, response);
                    inputManager.setAccelerometerEnabled(response === 'granted');
                  }).catch(error => {
                    warnID(3521, error.message);
                    inputManager.setAccelerometerEnabled(false);
                  });
                } else {
                  inputManager.setAccelerometerEnabled(isEnabled);
                }
              }

              setAccelerometerInterval(interval) {

                inputManager.setAccelerometerInterval(interval);
              }

              on(type, callback, target, once) {

                super.on(type, callback, target, once);

                if (type === SystemEventType.KEY_DOWN || type === SystemEventType.KEY_UP) {
                  if (!keyboardListener) {
                    keyboardListener = EventListener.create({
                      event: EventListener.KEYBOARD,

                      onKeyDown(keyCode, event) {
                        systemEvent.emit(event.type, event);
                      },

                      onKeyPressed(keyCode, event) {
                        systemEvent.emit(event.type, event);
                      },

                      onKeyReleased(keyCode, event) {
                        systemEvent.emit(event.type, event);
                      }

                    });
                    eventManager.addListener(keyboardListener, 256);
                  }
                }

                if (type === SystemEventType.DEVICEMOTION) {
                  if (!accelerationListener) {
                    accelerationListener = EventListener.create({
                      event: EventListener.ACCELERATION,

                      callback(acc, event) {
                        legacyCC.systemEvent.emit(event.type, event);
                      }

                    });
                    eventManager.addListener(accelerationListener, 256);
                  }
                }

                if (type === SystemEventType.TOUCH_START || type === SystemEventType.TOUCH_MOVE || type === SystemEventType.TOUCH_END || type === SystemEventType.TOUCH_CANCEL) {
                  if (!touchListener) {
                    touchListener = EventListener.create({
                      event: EventListener.TOUCH_ONE_BY_ONE,

                      onTouchBegan(touch, event) {
                        legacyCC.systemEvent.emit(event.type, touch, event);
                        return true;
                      },

                      onTouchMoved(touch, event) {
                        legacyCC.systemEvent.emit(event.type, touch, event);
                      },

                      onTouchEnded(touch, event) {
                        legacyCC.systemEvent.emit(event.type, touch, event);
                      },

                      onTouchCancelled(touch, event) {
                        legacyCC.systemEvent.emit(event.type, touch, event);
                      }

                    });
                    eventManager.addListener(touchListener, 256);
                  }
                }

                if (type === SystemEventType.MOUSE_DOWN || type === SystemEventType.MOUSE_MOVE || type === SystemEventType.MOUSE_UP || type === SystemEventType.MOUSE_WHEEL) {
                  if (!mouseListener) {
                    mouseListener = EventListener.create({
                      event: EventListener.MOUSE,

                      onMouseDown(event) {
                        legacyCC.systemEvent.emit(event.type, event);
                      },

                      onMouseMove(event) {
                        legacyCC.systemEvent.emit(event.type, event);
                      },

                      onMouseUp(event) {
                        legacyCC.systemEvent.emit(event.type, event);
                      },

                      onMouseScroll(event) {
                        legacyCC.systemEvent.emit(event.type, event);
                      }

                    });
                    eventManager.addListener(mouseListener, 256);
                  }
                }

                return callback;
              }

              off(type, callback, target) {

                super.off(type, callback, target);

                if (keyboardListener && (type === SystemEventType.KEY_DOWN || type === SystemEventType.KEY_UP)) {
                  const hasKeyPressingEventListener = this.hasEventListener(SystemEventType.KEY_DOWN);
                  const hasKeyUpEventListener = this.hasEventListener(SystemEventType.KEY_UP);

                  if (!hasKeyPressingEventListener && !hasKeyUpEventListener) {
                    eventManager.removeListener(keyboardListener);
                    keyboardListener = null;
                  }
                }

                if (accelerationListener && type === SystemEventType.DEVICEMOTION) {
                  eventManager.removeListener(accelerationListener);
                  accelerationListener = null;
                }

                if (touchListener && (type === SystemEventType.TOUCH_START || type === SystemEventType.TOUCH_MOVE || type === SystemEventType.TOUCH_END || type === SystemEventType.TOUCH_CANCEL)) {
                  const hasTouchStart = this.hasEventListener(SystemEventType.TOUCH_START);
                  const hasTouchMove = this.hasEventListener(SystemEventType.TOUCH_MOVE);
                  const hasTouchEnd = this.hasEventListener(SystemEventType.TOUCH_END);
                  const hasTouchCancel = this.hasEventListener(SystemEventType.TOUCH_CANCEL);

                  if (!hasTouchStart && !hasTouchMove && !hasTouchEnd && !hasTouchCancel) {
                    eventManager.removeListener(touchListener);
                    touchListener = null;
                  }
                }

                if (mouseListener && (type === SystemEventType.MOUSE_DOWN || type === SystemEventType.MOUSE_MOVE || type === SystemEventType.MOUSE_UP || type === SystemEventType.MOUSE_WHEEL)) {
                  const hasMouseDown = this.hasEventListener(SystemEventType.MOUSE_DOWN);
                  const hasMouseMove = this.hasEventListener(SystemEventType.MOUSE_MOVE);
                  const hasMouseUp = this.hasEventListener(SystemEventType.MOUSE_UP);
                  const hasMouseWheel = this.hasEventListener(SystemEventType.MOUSE_WHEEL);

                  if (!hasMouseDown && !hasMouseMove && !hasMouseUp && !hasMouseWheel) {
                    eventManager.removeListener(mouseListener);
                    mouseListener = null;
                  }
                }
              }

            } exports('fj', SystemEvent);
            SystemEvent.EventType = SystemEventType;
            legacyCC.SystemEvent = SystemEvent;
            const systemEvent = exports('fk', new SystemEvent());
            legacyCC.systemEvent = systemEvent;

            class Game extends EventTarget {
              constructor(...args) {
                super(...args);
                this.frame = null;
                this.container = null;
                this.canvas = null;
                this.renderType = -1;
                this.eventTargetOn = super.on;
                this.eventTargetOnce = super.once;
                this.config = {};
                this.onStart = null;
                this.frameTime = 1000 / 60;
                this.collisionMatrix = [];
                this.groupList = [];
                this._persistRootNodes = {};
                this._gfxDevice = null;
                this._configLoaded = false;
                this._isCloning = false;
                this._inited = false;
                this._engineInited = false;
                this._rendererInitialized = false;
                this._paused = true;
                this._frameRate = 60;
                this._intervalId = 0;
                this._initTime = 0;
                this._startTime = 0;
                this._deltaTime = 0.0;
              }

              get inited() {
                return this._inited;
              }

              get frameRate() {
                return this._frameRate;
              }

              set frameRate(frameRate) {
                if (typeof frameRate !== 'number') {
                  frameRate = parseInt(frameRate, 10);

                  if (Number.isNaN(frameRate)) {
                    frameRate = 60;
                  }
                }

                this._frameRate = frameRate;
                this.frameTime = 1000 / frameRate;

                this._setAnimFrame();
              }

              get deltaTime() {
                return this._deltaTime;
              }

              get totalTime() {
                return performance.now() - this._initTime;
              }

              get frameStartTime() {
                return this._startTime;
              }

              setFrameRate(frameRate) {
                this.frameRate = frameRate;
              }

              getFrameRate() {
                return this.frameRate;
              }

              step() {
                legacyCC.director.tick(this.frameTime / 1000);
              }

              pause() {
                if (this._paused) {
                  return;
                }

                this._paused = true;

                if (this._intervalId) {
                  window.cAF(this._intervalId);
                  this._intervalId = 0;
                }
              }

              resume() {
                if (!this._paused) {
                  return;
                }

                inputManager.clearEvents();

                if (this._intervalId) {
                  window.cAF(this._intervalId);
                  this._intervalId = 0;
                }

                this._paused = false;

                this._updateCallback();

                this._intervalId = window.rAF(this._frameCB);
              }

              isPaused() {
                return this._paused;
              }

              restart() {
                const endFramePromise = new Promise(resolve => legacyCC.director.once(legacyCC.Director.EVENT_END_FRAME, () => resolve()));
                return endFramePromise.then(() => {
                  for (const id in this._persistRootNodes) {
                    this.removePersistRootNode(this._persistRootNodes[id]);
                  }

                  legacyCC.director.getScene().destroy();

                  legacyCC.Object._deferredDestroy();

                  legacyCC.director.reset();
                  this.pause();
                  return this._setRenderPipelineNShowSplash().then(() => {
                    this.resume();

                    this._safeEmit(Game.EVENT_RESTART);
                  });
                });
              }

              end() {
                systemInfo.close();
              }

              on(type, callback, target, once) {
                if (this._engineInited && type === Game.EVENT_ENGINE_INITED || this._inited && type === Game.EVENT_GAME_INITED || this._rendererInitialized && type === Game.EVENT_RENDERER_INITED) {
                  callback.call(target);
                }

                return this.eventTargetOn(type, callback, target, once);
              }

              once(type, callback, target) {
                if (this._engineInited && type === Game.EVENT_ENGINE_INITED) {
                  return callback.call(target);
                }

                return this.eventTargetOnce(type, callback, target);
              }

              init(config) {
                this._initConfig(config);

                if (this.config.assetOptions) {
                  legacyCC.assetManager.init(this.config.assetOptions);
                }

                if (this.config.layers) {
                  const userLayers = this.config.layers;

                  for (let i = 0; i < userLayers.length; i++) {
                    const layer = userLayers[i];
                    const bitNum = log2(layer.value);
                    Layers.addLayer(layer.name, bitNum);
                  }
                }

                return this._initEngine().then(() => {
                  {
                    this._initEvents();
                  }

                  if (legacyCC.director.root && legacyCC.director.root.dataPoolManager) {
                    legacyCC.director.root.dataPoolManager.jointTexturePool.registerCustomTextureLayouts(config.customJointTextureLayouts);
                  }

                  return this._engineInited;
                });
              }

              run(configOrCallback, onStart) {
                let initPromise;

                if (typeof configOrCallback !== 'function' && configOrCallback) {
                  initPromise = this.init(configOrCallback);
                  this.onStart = onStart !== null && onStart !== void 0 ? onStart : null;
                } else {
                  this.onStart = configOrCallback !== null && configOrCallback !== void 0 ? configOrCallback : null;
                }

                garbageCollectionManager.init();
                return Promise.resolve(initPromise).then(() => this._setRenderPipelineNShowSplash());
              }

              addPersistRootNode(node) {
                if (!legacyCC.Node.isNode(node) || !node.uuid) {
                  warnID(3800);
                  return;
                }

                const id = node.uuid;

                if (!this._persistRootNodes[id]) {
                  const scene = legacyCC.director._scene;

                  if (legacyCC.isValid(scene)) {
                    if (!node.parent) {
                      node.parent = scene;
                    } else if (!(node.parent instanceof legacyCC.Scene)) {
                      warnID(3801);
                      return;
                    } else if (node.parent !== scene) {
                      warnID(3802);
                      return;
                    } else {
                      node._originalSceneId = scene.uuid;
                    }
                  }

                  this._persistRootNodes[id] = node;
                  node._persistNode = true;

                  legacyCC.assetManager._releaseManager._addPersistNodeRef(node);
                }
              }

              removePersistRootNode(node) {
                const id = node.uuid || '';

                if (node === this._persistRootNodes[id]) {
                  delete this._persistRootNodes[id];
                  node._persistNode = false;
                  node._originalSceneId = '';

                  legacyCC.assetManager._releaseManager._removePersistNodeRef(node);
                }
              }

              isPersistRootNode(node) {
                return !!node._persistNode;
              }

              _initEngine() {
                this._initDevice();

                return Promise.resolve(legacyCC.director._init()).then(() => {
                  log(`Cocos Creator v${engineVersion}`);
                  this.emit(Game.EVENT_ENGINE_INITED);
                  this._engineInited = true;

                  if (legacyCC.internal.dynamicAtlasManager) {
                    legacyCC.internal.dynamicAtlasManager.enabled = !macro.CLEANUP_IMAGE_CACHE;
                  }
                });
              }

              _setAnimFrame() {
                const frameRate = this._frameRate;

                {
                  jsb.setPreferredFramesPerSecond(frameRate);
                  window.rAF = window.requestAnimationFrame;
                  window.cAF = window.cancelAnimationFrame;
                }
              }

              _stTime(callback) {
                const currTime = performance.now();
                const elapseTime = Math.max(0, currTime - this._startTime);
                const timeToCall = Math.max(0, this.frameTime - elapseTime);
                const id = window.setTimeout(callback, timeToCall);
                return id;
              }

              _ctTime(id) {
                window.clearTimeout(id);
              }

              _calculateDT(now) {
                if (!now) now = performance.now();
                this._deltaTime = now > this._startTime ? (now - this._startTime) / 1000 : 0;

                if (this._deltaTime > Game.DEBUG_DT_THRESHOLD) {
                  this._deltaTime = this.frameTime / 1000;
                }

                this._startTime = now;
                return this._deltaTime;
              }

              _updateCallback() {
                const director = legacyCC.director;
                let callback;

                {
                  callback = time => {
                    director.tick(this._calculateDT(time));
                    this._intervalId = window.rAF(this._frameCB);
                  };
                }

                this._frameCB = callback;
              }

              _runMainLoop() {
                if (!this._inited || EDITOR ) {
                  return;
                }

                const config = this.config;
                const director = legacyCC.director;
                setDisplayStats(!!config.showFPS);
                director.startAnimation();
                this.resume();
              }

              _initConfig(config) {
                if (typeof config.debugMode !== 'number') {
                  config.debugMode = DebugMode.NONE;
                }

                config.exposeClassName = !!config.exposeClassName;

                if (typeof config.frameRate !== 'number') {
                  config.frameRate = 60;
                }

                const renderMode = config.renderMode;

                if (typeof renderMode !== 'number' || renderMode > 2 || renderMode < 0) {
                  config.renderMode = 0;
                }

                config.showFPS = !!config.showFPS;

                _resetDebugSetting(config.debugMode);

                this.config = config;
                this._configLoaded = true;
                this.frameRate = config.frameRate;
              }

              _determineRenderType() {
                const config = this.config;
                const userRenderMode = parseInt(config.renderMode, 10);
                this.renderType = Game.RENDER_TYPE_CANVAS;
                let supportRender = false;

                if (userRenderMode === 0) {
                  if (sys.capabilities.opengl) {
                    this.renderType = Game.RENDER_TYPE_WEBGL;
                    supportRender = true;
                  } else if (sys.capabilities.canvas) {
                    this.renderType = Game.RENDER_TYPE_CANVAS;
                    supportRender = true;
                  }
                } else if (userRenderMode === 1 && sys.capabilities.canvas) {
                  this.renderType = Game.RENDER_TYPE_CANVAS;
                  supportRender = true;
                } else if (userRenderMode === 2 && sys.capabilities.opengl) {
                  this.renderType = Game.RENDER_TYPE_WEBGL;
                  supportRender = true;
                }

                if (!supportRender) {
                  throw new Error(getError(3820, userRenderMode));
                }
              }

              _initDevice() {
                if (this._rendererInitialized) {
                  return;
                }

                const adapter = this.config.adapter;

                if (adapter) {
                  this.canvas = adapter.canvas;
                  this.frame = adapter.frame;
                  this.container = adapter.container;
                }

                this._determineRenderType();

                if (this.renderType === Game.RENDER_TYPE_WEBGL) {
                  const ctors = [];
                  const opts = new DeviceInfo(this.canvas,  macro.ENABLE_WEBGL_ANTIALIAS, false, window.devicePixelRatio, sys.windowPixelResolution.width, sys.windowPixelResolution.height, bindingMappingInfo);

                  if ( window.gfx) {
                    this._gfxDevice = gfx.DeviceManager.create(opts);
                  } else {
                    let useWebGL2 = !!window.WebGL2RenderingContext;
                    const userAgent = window.navigator.userAgent.toLowerCase();

                    if (userAgent.indexOf('safari') !== -1 && userAgent.indexOf('chrome') === -1 || sys.browserType === BrowserType.UC) {
                        useWebGL2 = false;
                      }

                    if (useWebGL2 && legacyCC.WebGL2Device) {
                      ctors.push(legacyCC.WebGL2Device);
                    }

                    if (legacyCC.WebGLDevice) {
                      ctors.push(legacyCC.WebGLDevice);
                    }

                    for (let i = 0; i < ctors.length; i++) {
                      this._gfxDevice = new ctors[i]();

                      if (this._gfxDevice.initialize(opts)) {
                        break;
                      }
                    }
                  }
                }

                if (!this._gfxDevice) {
                  error('can not support canvas rendering in 3D');
                  this.renderType = Game.RENDER_TYPE_CANVAS;
                  return;
                }

                this.canvas.oncontextmenu = () => false;
              }

              _initEvents() {
                systemInfo.on('show', this._onShow, this);
                systemInfo.on('hide', this._onHide, this);
              }

              _onHide() {
                this.emit(Game.EVENT_HIDE);
                this.pause();
              }

              _onShow() {
                this.emit(Game.EVENT_SHOW);
                this.resume();
              }

              _setRenderPipelineNShowSplash() {

                return Promise.resolve(this._setupRenderPipeline()).then(() => Promise.resolve(this._showSplashScreen()).then(() => {
                  this._inited = true;
                  this._initTime = performance.now();

                  this._runMainLoop();

                  this._safeEmit(Game.EVENT_GAME_INITED);

                  if (this.onStart) {
                    this.onStart();
                  }
                }));
              }

              _setupRenderPipeline() {
                const {
                  renderPipeline
                } = this.config;

                if (!renderPipeline) {
                  return this._setRenderPipeline();
                }

                return new Promise((resolve, reject) => {
                  legacyCC.assetManager.loadAny(renderPipeline, (err, asset) => err || !(asset instanceof RenderPipeline) ? reject(err) : resolve(asset));
                }).then(asset => {
                  this._setRenderPipeline(asset);
                }).catch(reason => {
                  warn(reason);
                  warn(`Failed load render pipeline: ${renderPipeline}, engine failed to initialize, will fallback to default pipeline`);

                  this._setRenderPipeline();
                });
              }

              _showSplashScreen() {
                if ( legacyCC.internal.SplashScreen) {
                  const splashScreen = legacyCC.internal.SplashScreen.instance;
                  splashScreen.main(legacyCC.director.root);
                  return new Promise(resolve => {
                    splashScreen.setOnFinish(() => resolve());
                    splashScreen.loadFinish = true;
                  });
                }

                return null;
              }

              _setRenderPipeline(rppl) {
                if (!legacyCC.director.root.setRenderPipeline(rppl)) {
                  this._setRenderPipeline();
                }

                this._rendererInitialized = true;

                this._safeEmit(Game.EVENT_RENDERER_INITED);
              }

              _safeEmit(event) {
                {
                  this.emit(event);
                }
              }

            } exports('er', Game);
            Game.EVENT_HIDE = 'game_on_hide';
            Game.EVENT_SHOW = 'game_on_show';
            Game.EVENT_LOW_MEMORY = 'game_on_low_memory';
            Game.EVENT_GAME_INITED = 'game_inited';
            Game.EVENT_ENGINE_INITED = 'engine_inited';
            Game.EVENT_RENDERER_INITED = 'renderer_inited';
            Game.EVENT_RESTART = 'game_on_restart';
            Game.RENDER_TYPE_CANVAS = 0;
            Game.RENDER_TYPE_WEBGL = 1;
            Game.RENDER_TYPE_OPENGL = 2;
            Game.DEBUG_DT_THRESHOLD = 1;
            legacyCC.Game = Game;
            const game = exports('d5', legacyCC.game = new Game());

            const visibleRect = exports('cV', {
              topLeft: legacyCC.v2(0, 0),
              topRight: legacyCC.v2(0, 0),
              top: legacyCC.v2(0, 0),
              bottomLeft: legacyCC.v2(0, 0),
              bottomRight: legacyCC.v2(0, 0),
              bottom: legacyCC.v2(0, 0),
              center: legacyCC.v2(0, 0),
              left: legacyCC.v2(0, 0),
              right: legacyCC.v2(0, 0),
              width: 0,
              height: 0,

              init(visibleRect_) {
                const w = this.width = visibleRect_.width;
                const h = this.height = visibleRect_.height;
                const l = visibleRect_.x;
                const b = visibleRect_.y;
                const t = b + h;
                const r = l + w;
                this.topLeft.x = l;
                this.topLeft.y = t;
                this.topRight.x = r;
                this.topRight.y = t;
                this.top.x = l + w / 2;
                this.top.y = t;
                this.bottomLeft.x = l;
                this.bottomLeft.y = b;
                this.bottomRight.x = r;
                this.bottomRight.y = b;
                this.bottom.x = l + w / 2;
                this.bottom.y = b;
                this.center.x = l + w / 2;
                this.center.y = b + h / 2;
                this.left.x = l;
                this.left.y = b + h / 2;
                this.right.x = r;
                this.right.y = b + h / 2;
              }

            });
            legacyCC.visibleRect = visibleRect;

            class Screen {
              get supportsFullScreen() {
                return screenAdapter.supportFullScreen;
              }

              fullScreen() {
                return screenAdapter.isFullScreen;
              }

              requestFullScreen(element, onFullScreenChange, onFullScreenError) {
                if (arguments.length > 0) {
                  warnID(1400, 'screen.requestFullScreen(element, onFullScreenChange?, onFullScreenError?)', 'screen.requestFullScreen(): Promise');
                }

                return screenAdapter.requestFullScreen().then(() => {
                  onFullScreenChange === null || onFullScreenChange === void 0 ? void 0 : onFullScreenChange();
                }).catch(err => {
                  console.error(err);
                  onFullScreenError === null || onFullScreenError === void 0 ? void 0 : onFullScreenError();
                });
              }

              exitFullScreen() {
                return screenAdapter.exitFullScreen();
              }

              autoFullScreen(element, onFullScreenChange) {
                var _this$requestFullScre;

                (_this$requestFullScre = this.requestFullScreen(element, onFullScreenChange)) === null || _this$requestFullScre === void 0 ? void 0 : _this$requestFullScre.catch(e => {});
              }

              disableAutoFullScreen(element) {}

            }

            const screen = exports('eh', new Screen());
            legacyCC.screen = screen;

            const localWinSize = new Size();
            class View extends EventTarget {
              constructor() {
                super();
                this._resizeWithBrowserSize = void 0;
                this._designResolutionSize = void 0;
                this._frameSize = void 0;
                this._scaleX = void 0;
                this._scaleY = void 0;
                this._viewportRect = void 0;
                this._visibleRect = void 0;
                this._autoFullScreen = void 0;
                this._devicePixelRatio = void 0;
                this._maxPixelRatio = void 0;
                this._retinaEnabled = void 0;
                this._resizeCallback = void 0;
                this._resizing = void 0;
                this._orientationChanging = void 0;
                this._isRotated = void 0;
                this._orientation = void 0;
                this._resolutionPolicy = void 0;
                this._rpExactFit = void 0;
                this._rpShowAll = void 0;
                this._rpNoBorder = void 0;
                this._rpFixedHeight = void 0;
                this._rpFixedWidth = void 0;
                const _strategyer = ContainerStrategy;
                const _strategy = ContentStrategy;
                this._frameSize = new Size(0, 0);
                this._designResolutionSize = new Size(0, 0);
                this._scaleX = 1;
                this._scaleY = 1;
                this._viewportRect = new Rect(0, 0, 0, 0);
                this._visibleRect = new Rect(0, 0, 0, 0);
                this._autoFullScreen = false;
                this._devicePixelRatio = 1;

                {
                  this._maxPixelRatio = 4;
                }

                this._retinaEnabled = false;
                this._resizeCallback = null;
                this._resizing = false;
                this._resizeWithBrowserSize = false;
                this._orientationChanging = true;
                this._isRotated = false;
                this._orientation = legacyCC.macro.ORIENTATION_AUTO;
                this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
                this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL);
                this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
                this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
                this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
                this._resolutionPolicy = this._rpShowAll;
                legacyCC.game.once(legacyCC.Game.EVENT_ENGINE_INITED, this.init, this);
              }

              init() {
                this._initFrameSize();

                const w = legacyCC.game.canvas.width;
                const h = legacyCC.game.canvas.height;
                this._designResolutionSize.width = w;
                this._designResolutionSize.height = h;
                this._viewportRect.width = w;
                this._viewportRect.height = h;
                this._visibleRect.width = w;
                this._visibleRect.height = h;
                localWinSize.width = this._visibleRect.width;
                localWinSize.height = this._visibleRect.height;

                if (visibleRect) {
                  visibleRect.init(this._visibleRect);
                }
              }

              resizeWithBrowserSize(enabled) {
                if (enabled) {
                  if (!this._resizeWithBrowserSize) {
                    this._resizeWithBrowserSize = true;
                    screenAdapter.on('window-resize', this._resizeEvent, this);
                    screenAdapter.on('orientation-change', this._orientationChange, this);
                  }
                } else if (this._resizeWithBrowserSize) {
                  this._resizeWithBrowserSize = false;
                  screenAdapter.off('window-resize', this._resizeEvent, this);
                  screenAdapter.off('orientation-change', this._orientationChange, this);
                }
              }

              setResizeCallback(callback) {
                if (typeof callback === 'function' || callback == null) {
                  this._resizeCallback = callback;
                }
              }

              setOrientation(orientation) {
                orientation &= legacyCC.macro.ORIENTATION_AUTO;

                if (orientation && this._orientation !== orientation) {
                  this._orientation = orientation;
                }
              }

              adjustViewportMeta(enabled) {}

              enableRetina(enabled) {
                this._retinaEnabled = !!enabled;
              }

              isRetinaEnabled() {
                return this._retinaEnabled;
              }

              enableAutoFullScreen(enabled) {
                if (enabled === this._autoFullScreen) {
                  return;
                }

                this._autoFullScreen = enabled;

                if (enabled) {
                  screen.requestFullScreen().catch(e => {});
                }
              }

              isAutoFullScreenEnabled() {
                return this._autoFullScreen;
              }

              setCanvasSize(width, height) {
                const canvas = legacyCC.game.canvas;
                const container = legacyCC.game.container;
                this._devicePixelRatio = window.devicePixelRatio;
                canvas.width = sys.windowPixelResolution.width;
                canvas.height = sys.windowPixelResolution.height;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                container.style.width = `${width}px`;
                container.style.height = `${height}px`;

                this._resizeEvent();
              }

              getCanvasSize() {
                return new Size(legacyCC.game.canvas.width, legacyCC.game.canvas.height);
              }

              getFrameSize() {
                return new Size(this._frameSize.width, this._frameSize.height);
              }

              setFrameSize(width, height) {
                this._frameSize.width = width;
                this._frameSize.height = height;
                legacyCC.game.frame.style.width = `${width}px`;
                legacyCC.game.frame.style.height = `${height}px`;

                this._resizeEvent();
              }

              getVisibleSize() {
                return new Size(this._visibleRect.width, this._visibleRect.height);
              }

              getVisibleSizeInPixel() {
                return new Size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
              }

              getVisibleOrigin() {
                return new Vec2(this._visibleRect.x, this._visibleRect.y);
              }

              getVisibleOriginInPixel() {
                return new Vec2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
              }

              getResolutionPolicy() {
                return this._resolutionPolicy;
              }

              setResolutionPolicy(resolutionPolicy) {
                if (resolutionPolicy instanceof ResolutionPolicy) {
                  this._resolutionPolicy = resolutionPolicy;
                } else {
                  const _locPolicy = ResolutionPolicy;

                  if (resolutionPolicy === _locPolicy.EXACT_FIT) {
                    this._resolutionPolicy = this._rpExactFit;
                  }

                  if (resolutionPolicy === _locPolicy.SHOW_ALL) {
                    this._resolutionPolicy = this._rpShowAll;
                  }

                  if (resolutionPolicy === _locPolicy.NO_BORDER) {
                    this._resolutionPolicy = this._rpNoBorder;
                  }

                  if (resolutionPolicy === _locPolicy.FIXED_HEIGHT) {
                    this._resolutionPolicy = this._rpFixedHeight;
                  }

                  if (resolutionPolicy === _locPolicy.FIXED_WIDTH) {
                    this._resolutionPolicy = this._rpFixedWidth;
                  }
                }
              }

              setDesignResolutionSize(width, height, resolutionPolicy) {
                if (!(width > 0 && height > 0)) {
                  errorID(2200);
                  return;
                }

                this.setResolutionPolicy(resolutionPolicy);
                const policy = this._resolutionPolicy;

                if (policy) {
                  policy.preApply(this);
                }

                this._orientationChanging = true;

                if (!this._resizing) {
                  this._initFrameSize();
                }

                if (!policy) {
                  logID(2201);
                  return;
                }

                this._designResolutionSize.width = width;
                this._designResolutionSize.height = height;
                const result = policy.apply(this, this._designResolutionSize);

                if (result.scale && result.scale.length === 2) {
                  this._scaleX = result.scale[0];
                  this._scaleY = result.scale[1];
                }

                if (result.viewport) {
                  const vp = this._viewportRect;
                  const vb = this._visibleRect;
                  const rv = result.viewport;
                  vp.x = rv.x;
                  vp.y = rv.y;
                  vp.width = rv.width;
                  vp.height = rv.height;
                  vb.x = 0;
                  vb.y = 0;
                  vb.width = rv.width / this._scaleX;
                  vb.height = rv.height / this._scaleY;
                }

                policy.postApply(this);
                localWinSize.width = this._visibleRect.width;
                localWinSize.height = this._visibleRect.height;

                if (visibleRect) {
                  visibleRect.init(this._visibleRect);
                }

                this.emit('design-resolution-changed');
              }

              getDesignResolutionSize() {
                return new Size(this._designResolutionSize.width, this._designResolutionSize.height);
              }

              setRealPixelResolution(width, height, resolutionPolicy) {

                this.setDesignResolutionSize(width, height, resolutionPolicy);
              }

              getViewportRect() {
                return this._viewportRect;
              }

              getScaleX() {
                return this._scaleX;
              }

              getScaleY() {
                return this._scaleY;
              }

              getDevicePixelRatio() {
                return this._devicePixelRatio;
              }

              convertToLocationInView(tx, ty, relatedPos, out) {
                const result = out || new Vec2();
                const x = this._devicePixelRatio * (tx - relatedPos.left);
                const y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty);

                if (this._isRotated) {
                  result.x = legacyCC.game.canvas.width - y;
                  result.y = x;
                } else {
                  result.x = x;
                  result.y = y;
                }

                if (legacyCC.GAME_VIEW) {
                  result.x /= legacyCC.gameView.canvas.width / legacyCC.game.canvas.width;
                  result.y /= legacyCC.gameView.canvas.height / legacyCC.game.canvas.height;
                }

                return result;
              }

              _convertPointWithScale(point) {
                const viewport = this._viewportRect;
                point.x = (point.x - viewport.x) / this._scaleX;
                point.y = (point.y - viewport.y) / this._scaleY;
              }

              _resizeEvent() {
                var _this$_resizeCallback;

                const prevFrameW = this._frameSize.width;
                const prevFrameH = this._frameSize.height;
                const prevRotated = this._isRotated;

                if (legacyCC.sys.isMobile) {
                  const containerStyle = legacyCC.game.container.style;
                  const margin = containerStyle.margin;
                  containerStyle.margin = '0';
                  containerStyle.display = 'none';

                  this._initFrameSize();

                  containerStyle.margin = margin;
                  containerStyle.display = 'block';
                } else {
                  this._initFrameSize();
                }

                const width = this._designResolutionSize.width;
                const height = this._designResolutionSize.height;
                this._resizing = true;

                if (width > 0) {
                  this.setDesignResolutionSize(width, height, this._resolutionPolicy);
                }

                this._resizing = false;
                this.emit('canvas-resize');
                (_this$_resizeCallback = this._resizeCallback) === null || _this$_resizeCallback === void 0 ? void 0 : _this$_resizeCallback.call(this);
              }

              _orientationChange() {
                this._orientationChanging = true;

                this._resizeEvent();
              }

              _initFrameSize() {
                const locFrameSize = this._frameSize;
                const windowSize = screenAdapter.windowSize;
                const w = windowSize.width;
                const h = windowSize.height;
                const isLandscape = w >= h;

                if ( !legacyCC.sys.isMobile || isLandscape && this._orientation & legacyCC.macro.ORIENTATION_LANDSCAPE || !isLandscape && this._orientation & legacyCC.macro.ORIENTATION_PORTRAIT) {
                  locFrameSize.width = w;
                  locFrameSize.height = h;
                  legacyCC.game.container.style['-webkit-transform'] = 'rotate(0deg)';
                  legacyCC.game.container.style.transform = 'rotate(0deg)';
                  this._isRotated = false;
                } else {
                  locFrameSize.width = h;
                  locFrameSize.height = w;
                  legacyCC.game.container.style['-webkit-transform'] = 'rotate(90deg)';
                  legacyCC.game.container.style.transform = 'rotate(90deg)';
                  legacyCC.game.container.style['-webkit-transform-origin'] = '0px 0px 0px';
                  legacyCC.game.container.style.transformOrigin = '0px 0px 0px';
                  this._isRotated = true;
                  legacyCC.game.canvas.style['-webkit-transform'] = 'translateZ(0px)';
                  legacyCC.game.canvas.style.transform = 'translateZ(0px)';
                }

                if (this._orientationChanging) {
                  setTimeout(() => {
                    legacyCC.view._orientationChanging = false;
                  }, 1000);
                }
              }

            } exports('dB', View);
            View.instance = void 0;

            class ContainerStrategy {
              constructor() {
                this.name = 'ContainerStrategy';
              }

              preApply(_view) {}

              apply(_view, designedResolution) {}

              postApply(_view) {}

              _setupContainer(_view, w, h) {
                const locCanvas = legacyCC.game.canvas;
                const locContainer = legacyCC.game.container;

                if (sys.os === OS.ANDROID || sys.os === OS.OHOS) {
                  document.body.style.width = `${_view._isRotated ? h : w}px`;
                  document.body.style.height = `${_view._isRotated ? w : h}px`;
                }

                locContainer.style.width = locCanvas.style.width = `${w}px`;
                locContainer.style.height = locCanvas.style.height = `${h}px`;
                _view._devicePixelRatio = 1;

                if (_view.isRetinaEnabled()) {
                  _view._devicePixelRatio = Math.min(_view._maxPixelRatio, window.devicePixelRatio || 1);
                }

                {
                  locCanvas.width = sys.windowPixelResolution.width;
                  locCanvas.height = sys.windowPixelResolution.height;
                }
              }

              _fixContainer() {
                document.body.insertBefore(legacyCC.game.container, document.body.firstChild);
                const bs = document.body.style;
                bs.width = `${window.innerWidth}px`;
                bs.height = `${window.innerHeight}px`;
                bs.overflow = 'hidden';
                const contStyle = legacyCC.game.container.style;
                contStyle.position = 'fixed';
                contStyle.left = contStyle.top = '0px';
                document.body.scrollTop = 0;
              }

            }

            ContainerStrategy.EQUAL_TO_FRAME = void 0;
            ContainerStrategy.PROPORTION_TO_FRAME = void 0;

            class ContentStrategy {
              constructor() {
                this.name = 'ContentStrategy';
                this._result = void 0;
                this._result = {
                  scale: [1, 1],
                  viewport: null
                };
              }

              preApply(_view) {}

              apply(_view, designedResolution) {
                return {
                  scale: [1, 1]
                };
              }

              postApply(_view) {}

              _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
                if (Math.abs(containerW - contentW) < 2) {
                  contentW = containerW;
                }

                if (Math.abs(containerH - contentH) < 2) {
                  contentH = containerH;
                }

                const viewport = new Rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
                this._result.scale = [scaleX, scaleY];
                this._result.viewport = viewport;
                return this._result;
              }

            }

            ContentStrategy.EXACT_FIT = void 0;
            ContentStrategy.SHOW_ALL = void 0;
            ContentStrategy.NO_BORDER = void 0;
            ContentStrategy.FIXED_HEIGHT = void 0;
            ContentStrategy.FIXED_WIDTH = void 0;

            (() => {
              class EqualToFrame extends ContainerStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'EqualToFrame';
                }

                apply(_view) {
                  const frameH = _view._frameSize.height;
                  const containerStyle = legacyCC.game.container.style;

                  this._setupContainer(_view, _view._frameSize.width, _view._frameSize.height);

                  if (_view._isRotated) {
                    containerStyle.margin = `0 0 0 ${frameH}px`;
                  } else {
                    containerStyle.margin = '0px';
                  }

                  containerStyle.padding = '0px';
                }

              }

              class ProportionalToFrame extends ContainerStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'ProportionalToFrame';
                }

                apply(_view, designedResolution) {
                  const frameW = _view._frameSize.width;
                  const frameH = _view._frameSize.height;
                  const containerStyle = legacyCC.game.container.style;
                  const designW = designedResolution.width;
                  const designH = designedResolution.height;
                  const scaleX = frameW / designW;
                  const scaleY = frameH / designH;
                  let containerW;
                  let containerH;

                  if (scaleX < scaleY) {
                    containerW = frameW;
                    containerH = designH * scaleX;
                  } else {
                    containerW = designW * scaleY;
                    containerH = frameH;
                  }

                  const offx = Math.round((frameW - containerW) / 2);
                  const offy = Math.round((frameH - containerH) / 2);
                  containerW = frameW - 2 * offx;
                  containerH = frameH - 2 * offy;

                  this._setupContainer(_view, containerW, containerH);

                  {
                    if (_view._isRotated) {
                      containerStyle.margin = `0 0 0 ${frameH}px`;
                    } else {
                      containerStyle.margin = '0px';
                    }

                    containerStyle.paddingLeft = `${offx}px`;
                    containerStyle.paddingRight = `${offx}px`;
                    containerStyle.paddingTop = `${offy}px`;
                    containerStyle.paddingBottom = `${offy}px`;
                  }
                }

              }

              const _global = typeof window === 'undefined' ? global : window;

              const globalAdapter = _global.__globalAdapter;

              if (globalAdapter) {
                if (globalAdapter.adaptContainerStrategy) {
                  globalAdapter.adaptContainerStrategy(ContainerStrategy.prototype);
                }

                if (globalAdapter.adaptView) {
                  globalAdapter.adaptView(View.prototype);
                }
              }

              ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
              ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();

              class ExactFit extends ContentStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'ExactFit';
                }

                apply(_view, designedResolution) {
                  const containerW = legacyCC.game.canvas.width;
                  const containerH = legacyCC.game.canvas.height;
                  const scaleX = containerW / designedResolution.width;
                  const scaleY = containerH / designedResolution.height;
                  return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
                }

              }

              class ShowAll extends ContentStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'ShowAll';
                }

                apply(_view, designedResolution) {
                  const containerW = legacyCC.game.canvas.width;
                  const containerH = legacyCC.game.canvas.height;
                  const designW = designedResolution.width;
                  const designH = designedResolution.height;
                  const scaleX = containerW / designW;
                  const scaleY = containerH / designH;
                  let scale = 0;
                  let contentW;
                  let contentH;

                  if (scaleX < scaleY) {
                    scale = scaleX;
                    contentW = containerW;
                    contentH = designH * scale;
                  } else {
                    scale = scaleY;
                    contentW = designW * scale;
                    contentH = containerH;
                  }

                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }

              }

              class NoBorder extends ContentStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'NoBorder';
                }

                apply(_view, designedResolution) {
                  const containerW = legacyCC.game.canvas.width;
                  const containerH = legacyCC.game.canvas.height;
                  const designW = designedResolution.width;
                  const designH = designedResolution.height;
                  const scaleX = containerW / designW;
                  const scaleY = containerH / designH;
                  let scale;
                  let contentW;
                  let contentH;

                  if (scaleX < scaleY) {
                    scale = scaleY;
                    contentW = designW * scale;
                    contentH = containerH;
                  } else {
                    scale = scaleX;
                    contentW = containerW;
                    contentH = designH * scale;
                  }

                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }

              }

              class FixedHeight extends ContentStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'FixedHeight';
                }

                apply(_view, designedResolution) {
                  const containerW = legacyCC.game.canvas.width;
                  const containerH = legacyCC.game.canvas.height;
                  const designH = designedResolution.height;
                  const scale = containerH / designH;
                  const contentW = containerW;
                  const contentH = containerH;
                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }

              }

              class FixedWidth extends ContentStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'FixedWidth';
                }

                apply(_view, designedResolution) {
                  const containerW = legacyCC.game.canvas.width;
                  const containerH = legacyCC.game.canvas.height;
                  const designW = designedResolution.width;
                  const scale = containerW / designW;
                  const contentW = containerW;
                  const contentH = containerH;
                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }

              }

              ContentStrategy.EXACT_FIT = new ExactFit();
              ContentStrategy.SHOW_ALL = new ShowAll();
              ContentStrategy.NO_BORDER = new NoBorder();
              ContentStrategy.FIXED_HEIGHT = new FixedHeight();
              ContentStrategy.FIXED_WIDTH = new FixedWidth();
            })();

            class ResolutionPolicy {
              constructor(containerStg, contentStg) {
                this.name = 'ResolutionPolicy';
                this._containerStrategy = void 0;
                this._contentStrategy = void 0;
                this._containerStrategy = null;
                this._contentStrategy = null;
                this.setContainerStrategy(containerStg);
                this.setContentStrategy(contentStg);
              }

              get canvasSize() {
                return new Vec2(legacyCC.game.canvas.width, legacyCC.game.canvas.height);
              }

              preApply(_view) {
                this._containerStrategy.preApply(_view);

                this._contentStrategy.preApply(_view);
              }

              apply(_view, designedResolution) {
                this._containerStrategy.apply(_view, designedResolution);

                return this._contentStrategy.apply(_view, designedResolution);
              }

              postApply(_view) {
                this._containerStrategy.postApply(_view);

                this._contentStrategy.postApply(_view);
              }

              setContainerStrategy(containerStg) {
                if (containerStg instanceof ContainerStrategy) {
                  this._containerStrategy = containerStg;
                }
              }

              setContentStrategy(contentStg) {
                if (contentStg instanceof ContentStrategy) {
                  this._contentStrategy = contentStg;
                }
              }

            } exports('fi', ResolutionPolicy);
            ResolutionPolicy.EXACT_FIT = 0;
            ResolutionPolicy.NO_BORDER = 1;
            ResolutionPolicy.SHOW_ALL = 2;
            ResolutionPolicy.FIXED_HEIGHT = 3;
            ResolutionPolicy.FIXED_WIDTH = 4;
            ResolutionPolicy.UNKNOWN = 5;
            ResolutionPolicy.ContainerStrategy = ContainerStrategy;
            ResolutionPolicy.ContentStrategy = ContentStrategy;
            legacyCC.ResolutionPolicy = ResolutionPolicy;
            const view = exports('d6', View.instance = legacyCC.view = new View());
            legacyCC.winSize = localWinSize;

            removeProperty(View.prototype, 'View.prototype', [{
              name: 'isAntiAliasEnabled',
              suggest: 'The API of Texture2d have been largely modified, no alternative'
            }, {
              name: 'enableAntiAlias',
              suggest: 'The API of Texture2d have been largely modified, no alternative'
            }]);
            markAsWarning(View.prototype, 'View.prototype', [{
              name: 'adjustViewportMeta'
            }, {
              name: 'enableAutoFullScreen',
              suggest: 'use screen.requestFullScreen() instead.'
            }, {
              name: 'isAutoFullScreenEnabled'
            }]);
            markAsWarning(legacyCC, 'cc', [{
              name: 'winSize',
              suggest: 'please use view.getVisibleSize() instead.'
            }]);
            replaceProperty(Event, 'Event', [{
              name: 'ACCELERATION',
              newName: 'DEVICEMOTION',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            markAsWarning(Event, 'Event', [{
              name: 'TOUCH',
              suggest: 'please use SystemEvent.EventType.TOUCH_START, SystemEvent.EventType.TOUCH_MOVE, SystemEvent.EventType.TOUCH_END and SystemEvent.EventType.TOUCH_CANCEL instead'
            }, {
              name: 'MOUSE',
              suggest: 'please use SystemEvent.EventType.MOUSE_DOWN, SystemEvent.EventType.MOUSE_MOVE, SystemEvent.EventType.MOUSE_UP, SystemEvent.EventType.MOUSE_WHEEL, Node.EventType.MOUSE_ENTER and Node.EventType.MOUSE_LEAVE instead'
            }, {
              name: 'KEYBOARD',
              suggest: 'please use SystemEvent.EventType.KEY_DOWN and SystemEvent.EventType.KEY_UP instead'
            }]);
            replaceProperty(EventMouse, 'EventMouse', ['DOWN', 'UP', 'MOVE'].map(item => ({
              name: item,
              newName: `MOUSE_${item}`,
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            })));
            replaceProperty(EventMouse, 'EventMouse', [{
              name: 'SCROLL',
              newName: 'MOUSE_WHEEL',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            markAsWarning(EventMouse.prototype, 'EventMouse.prototype', [{
              name: 'eventType',
              suggest: 'please use EventMouse.prototype.type instead'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'BEGAN',
              newName: 'TOUCH_START',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'MOVED',
              newName: 'TOUCH_MOVE',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'ENDED',
              newName: 'TOUCH_END',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'CANCELLED',
              newName: 'TOUCH_CANCEL',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            markAsWarning(EventTouch.prototype, 'EventTouch.prototype', [{
              name: 'getEventCode',
              suggest: 'please use EventTouch.prototype.type instead'
            }]);
            markAsWarning(EventKeyboard.prototype, 'EventKeyboard.prototype', [{
              name: 'isPressed',
              suggest: 'use EventKeyboard.prototype.type !== SystemEvent.EventType.KEY_UP instead'
            }]);
            replaceProperty(sys, 'sys', ['UNKNOWN', 'ENGLISH', 'CHINESE', 'FRENCH', 'ITALIAN', 'GERMAN', 'SPANISH', 'DUTCH', 'RUSSIAN', 'KOREAN', 'JAPANESE', 'HUNGARIAN', 'PORTUGUESE', 'ARABIC', 'NORWEGIAN', 'POLISH', 'TURKISH', 'UKRAINIAN', 'ROMANIAN', 'BULGARIAN'].map(item => ({
              name: `LANGUAGE_${item}`,
              newName: item,
              target: sys.Language,
              targetName: 'sys.Language'
            })));
            replaceProperty(sys, 'sys', ['UNKNOWN', 'IOS', 'ANDROID', 'WINDOWS', 'LINUX', 'OSX'].map(item => ({
              name: `OS_${item}`,
              newName: item,
              target: sys.OS,
              targetName: 'sys.OS'
            })));
            replaceProperty(sys, 'sys', ['UNKNOWN', 'WECHAT', 'ANDROID', 'IE', 'EDGE', 'QQ', 'MOBILE_QQ', 'UC', 'UCBS', 'BAIDU_APP', 'BAIDU', 'MAXTHON', 'OPERA', 'OUPENG', 'MIUI', 'FIREFOX', 'SAFARI', 'CHROME', 'LIEBAO', 'QZONE', 'SOUGOU', 'HUAWEI'].map(item => ({
              name: `BROWSER_TYPE_${item}`,
              newName: item,
              target: sys.BrowserType,
              targetName: 'sys.BrowserType'
            })));
            replaceProperty(sys, 'sys', [{
              name: 'BROWSER_TYPE_360',
              newName: 'BROWSER_360',
              target: sys.BrowserType,
              targetName: 'sys.BrowserType'
            }]);
            replaceProperty(sys, 'sys', ['UNKNOWN', 'EDITOR_PAGE', 'EDITOR_CORE', 'MOBILE_BROWSER', 'DESKTOP_BROWSER', 'WIN32', 'MACOS', 'IOS', 'ANDROID', 'OHOS', 'WECHAT_GAME', 'BAIDU_MINI_GAME', 'XIAOMI_QUICK_GAME', 'ALIPAY_MINI_GAME', 'BYTEDANCE_MINI_GAME', 'OPPO_MINI_GAME', 'VIVO_MINI_GAME', 'HUAWEI_QUICK_GAME', 'COCOSPLAY', 'LINKSURE_MINI_GAME', 'QTT_MINI_GAME'].map(item => ({
              name: item,
              target: sys.Platform,
              targetName: 'sys.Platform'
            })));
            replaceProperty(sys, 'sys', [{
              name: 'IPHONE',
              newName: 'IOS',
              target: sys.Platform,
              targetName: 'sys.Platform'
            }, {
              name: 'IPAD',
              newName: 'IOS',
              target: sys.Platform,
              targetName: 'sys.Platform'
            }]);
            removeProperty(sys, 'sys', ['LINUX', 'BLACKBERRY', 'NACL', 'EMSCRIPTEN', 'TIZEN', 'WINRT', 'WP8', 'QQ_PLAY', 'FB_PLAYABLE_ADS'].map(item => ({
              name: item
            })));
            replaceProperty(SystemEventType, 'SystemEventType', ['MOUSE_ENTER', 'MOUSE_LEAVE', 'TRANSFORM_CHANGED', 'SCENE_CHANGED_FOR_PERSISTS', 'SIZE_CHANGED', 'ANCHOR_CHANGED', 'COLOR_CHANGED', 'CHILD_ADDED', 'CHILD_REMOVED', 'PARENT_CHANGED', 'NODE_DESTROYED', 'LAYER_CHANGED', 'SIBLING_ORDER_CHANGED'].map(name => ({
              name,
              target: Node$1.EventType,
              targetName: 'Node.EventType'
            })));
            replaceProperty(Node$1.EventType, 'Node.EventType', [{
              name: 'DEVICEMOTION',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }, {
              name: 'KEY_DOWN',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }, {
              name: 'KEY_UP',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            markAsWarning(macro.KEY, 'macro.KEY', ['back', 'menu', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '*', '+', '-', '/', ';', '=', ',', '.', '[', ']', 'dpadLeft', 'dpadRight', 'dpadUp', 'dpadDown', 'dpadCenter'].map(item => ({
              name: item
            })));
            markAsWarning(macro.KEY, 'macro.KEY', [{
              name: 'shift',
              suggest: 'please use KeyCode.SHIFT_LEFT instead'
            }]);
            markAsWarning(macro.KEY, 'macro.KEY', [{
              name: 'ctrl',
              suggest: 'please use KeyCode.CTRL_LEFT instead'
            }]);
            markAsWarning(macro.KEY, 'macro.KEY', [{
              name: 'alt',
              suggest: 'please use KeyCode.ALT_LEFT instead'
            }]);
            markAsWarning(macro, 'macro', [{
              name: 'KEY',
              suggest: 'please use KeyCode instead'
            }]);
            markAsWarning(screen, 'screen', [{
              name: 'autoFullScreen',
              suggest: 'please use screen.requestFullScreen() instead.'
            }, {
              name: 'disableAutoFullScreen'
            }]);

            const v2_0 = new Vec2();
            class SplashScreen {
              set splashFinish(v) {
                this._splashFinish = v;

                this._tryToStart();
              }

              set loadFinish(v) {
                this._loadFinish = v;

                this._tryToStart();
              }

              main(root) {
                if (root == null) {
                  error('RENDER ROOT IS NULL.');
                  return;
                }

                if (window._CCSettings && window._CCSettings.splashScreen) {
                  const setting = this.settings = window._CCSettings.splashScreen;
                  setting.totalTime = this.settings.totalTime != null ? this.settings.totalTime : 3000;
                  setting.base64src = this.settings.base64src || '';
                  setting.effect = this.settings.effect || 'FADE-INOUT';
                  setting.clearColor = this.settings.clearColor || new Color$1(0.88, 0.88, 0.88, 1);
                  setting.displayRatio = this.settings.displayRatio != null ? this.settings.displayRatio : 0.4;
                  setting.displayWatermark = this.settings.displayWatermark != null ? this.settings.displayWatermark : true;
                } else {
                  this.settings = {
                    totalTime: 3000,
                    base64src: '',
                    effect: 'FADE-INOUT',
                    clearColor: new Color$1(0.88, 0.88, 0.88, 1),
                    displayRatio: 0.4,
                    displayWatermark: true
                  };
                }

                if (this.settings.base64src === '' || this.settings.totalTime <= 0) {
                  if (this.callBack) {
                    this.callBack();
                  }

                  this.callBack = null;
                  this.settings = null;
                  this._directCall = true;
                } else {
                  legacyCC.view.enableRetina(true);
                  legacyCC.view.resizeWithBrowserSize(true);
                  const designRes = window._CCSettings.designResolution;

                  if (designRes) {
                    legacyCC.view.setDesignResolutionSize(designRes.width, designRes.height, designRes.policy);
                  } else {
                    legacyCC.view.setDesignResolutionSize(960, 640, 4);
                  }

                  this.root = root;
                  this.device = root.device;
                  legacyCC.game.once(legacyCC.Game.EVENT_GAME_INITED, () => {
                    legacyCC.director._lateUpdate = performance.now();
                  }, legacyCC.director);
                  this.callBack = null;
                  this.cancelAnimate = false;
                  this.startTime = -1;
                  this.preInit();
                  this.logoImage = new Image();
                  this.logoImage.onload = this.init.bind(this);
                  this.logoImage.src = this.settings.base64src;
                }
              }

              setOnFinish(cb) {
                if (this._directCall) {
                  if (cb) {
                    SplashScreen._ins = undefined;
                    cb();
                    return;
                  }
                }

                this.callBack = cb;
              }

              _tryToStart() {
                if (this._splashFinish && this._loadFinish) {
                  if (this.callBack) {
                    this.callBack();
                    this.hide();
                    legacyCC.game.resume();
                  }
                }
              }

              preInit() {
                const clearColor = this.settings.clearColor;
                this.clearColors = [new Color$1(clearColor.x, clearColor.y, clearColor.z, clearColor.w)];
                const device = this.device;
                this.renderArea = new Rect$1(0, 0, device.width, device.height);
                this.framebuffer = this.root.mainWindow.framebuffer;
                this.cmdBuff = device.commandBuffer;
                const verts = new Float32Array([0.5, 0.5, 1, 0, -0.5, 0.5, 0, 0, 0.5, -0.5, 1, 1, -0.5, -0.5, 0, 1]);
                const vbStride = Float32Array.BYTES_PER_ELEMENT * 4;
                const vbSize = vbStride * 4;
                this.vertexBuffers = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, vbSize, vbStride));
                this.vertexBuffers.update(verts);
                const indices = new Uint16Array([0, 1, 2, 1, 3, 2]);
                const ibStride = Uint16Array.BYTES_PER_ELEMENT;
                const ibSize = ibStride * 6;
                this.indicesBuffers = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, ibSize, ibStride));
                this.indicesBuffers.update(indices);
                const attributes = [new Attribute('a_position', Format.RG32F), new Attribute('a_texCoord', Format.RG32F)];
                const IAInfo = new InputAssemblerInfo(attributes, [this.vertexBuffers], this.indicesBuffers);
                this.quadAssmebler = device.createInputAssembler(IAInfo);
                this.projection = new Mat4();
                Mat4.ortho(this.projection, -1, 1, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, device.surfaceTransform);
              }

              init() {
                this.initLogo();
                if (this.settings.displayWatermark) this.initWarterMark();

                const animate = time => {
                  if (this.cancelAnimate) return;
                  const settings = this.settings;
                  const device = this.device;
                  Mat4.ortho(this.projection, -1, 1, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, device.surfaceTransform);
                  const dw = device.width;
                  const dh = device.height;
                  const refW = dw < dh ? dw : dh;
                  if (this.startTime < 0) this.startTime = time;
                  const elapsedTime = time - this.startTime;
                  const percent = clamp01(elapsedTime / settings.totalTime);
                  let u_p = cubicOut(percent);
                  if (settings.effect === 'NONE') u_p = 1.0;
                  const logoTW = this.logoTexture.width;
                  const logoTH = this.logoTexture.height;
                  const logoW = refW * settings.displayRatio;
                  let scaleX = logoW * logoTW / logoTH;
                  let scaleY = logoW;

                  if (device.surfaceTransform === SurfaceTransform.ROTATE_90 || device.surfaceTransform === SurfaceTransform.ROTATE_270) {
                    scaleX = logoW * dw / dh;
                    scaleY = logoW * logoTH / logoTW * dh / dw;
                  }

                  this.logoMat.setProperty('resolution', v2_0.set(dw, dh), 0);
                  this.logoMat.setProperty('scale', v2_0.set(scaleX, scaleY), 0);
                  this.logoMat.setProperty('translate', v2_0.set(dw * 0.5, dh * 0.5), 0);
                  this.logoMat.setProperty('precent', u_p);
                  this.logoMat.setProperty('u_projection', this.projection);
                  this.logoMat.passes[0].update();

                  if (settings.displayWatermark && this.watermarkMat) {
                    const wartermarkW = refW * 0.5;
                    const wartermarkTW = this.watermarkTexture.width;
                    const wartermarkTH = this.watermarkTexture.height;
                    let scaleX = wartermarkW;
                    let scaleY = wartermarkW * wartermarkTH / wartermarkTW;

                    if (device.surfaceTransform === SurfaceTransform.ROTATE_90 || device.surfaceTransform === SurfaceTransform.ROTATE_270) {
                      scaleX = wartermarkW * 0.5;
                      scaleY = wartermarkW * dw / dh * 0.5;
                    }

                    this.watermarkMat.setProperty('resolution', v2_0.set(dw, dh), 0);
                    this.watermarkMat.setProperty('scale', v2_0.set(scaleX, scaleY), 0);
                    this.watermarkMat.setProperty('translate', v2_0.set(dw * 0.5, dh * 0.1), 0);
                    this.watermarkMat.setProperty('precent', u_p);
                    this.watermarkMat.setProperty('u_projection', this.projection);
                    this.watermarkMat.passes[0].update();
                  }

                  this.frame();
                  if (elapsedTime > settings.totalTime) this.splashFinish = true;
                  requestAnimationFrame(animate);
                };

                legacyCC.game.pause();
                this.handle = requestAnimationFrame(animate);
              }

              hide() {
                cancelAnimationFrame(this.handle);
                this.cancelAnimate = true;
                setTimeout(this.destroy.bind(this));
              }

              initLogo() {
                const device = this.device;
                this.logoMat = new Material();
                this.logoMat.initialize({
                  effectName: 'splash-screen'
                });
                const samplerInfo = new SamplerInfo();
                samplerInfo.addressU = Address.CLAMP;
                samplerInfo.addressV = Address.CLAMP;
                samplerInfo.addressW = Address.CLAMP;
                this.sampler = device.createSampler(samplerInfo);
                this.logoTexture = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, this.logoImage.width, this.logoImage.height));
                const pass = this.logoMat.passes[0];
                const binding = pass.getBinding('mainTexture');
                pass.bindTexture(binding, this.logoTexture);
                this.shader = pass.getShaderVariant();
                const descriptorSet = pass.descriptorSet;
                descriptorSet.bindSampler(binding, this.sampler);
                descriptorSet.update();
                const region = new BufferTextureCopy();
                region.texExtent.width = this.logoImage.width;
                region.texExtent.height = this.logoImage.height;
                region.texExtent.depth = 1;
                device.copyTexImagesToTexture([this.logoImage], this.logoTexture, [region]);
              }

              initWarterMark() {
                const wartemarkImg = document.createElement('canvas');
                wartemarkImg.width = 330;
                wartemarkImg.height = 30;
                wartemarkImg.style.width = `${wartemarkImg.width}`;
                wartemarkImg.style.height = `${wartemarkImg.height}`;
                const ctx = wartemarkImg.getContext('2d');
                ctx.font = `${18}px Arial`;
                ctx.textBaseline = 'top';
                ctx.textAlign = 'left';
                ctx.fillStyle = '`#424242`';
                const text = 'Powered by Cocos Creator';
                const textMetrics = ctx.measureText(text);
                ctx.fillText(text, (330 - textMetrics.width) / 2, 6);
                const region = new BufferTextureCopy();
                region.texExtent.width = wartemarkImg.width;
                region.texExtent.height = wartemarkImg.height;
                region.texExtent.depth = 1;
                this.watermarkTexture = this.device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, wartemarkImg.width, wartemarkImg.height));
                this.device.copyTexImagesToTexture([wartemarkImg], this.watermarkTexture, [region]);
                this.watermarkMat = new Material();
                this.watermarkMat.initialize({
                  effectName: 'splash-screen'
                });
                const pass = this.watermarkMat.passes[0];
                const binding = pass.getBinding('mainTexture');
                pass.bindTexture(binding, this.watermarkTexture);
                pass.descriptorSet.update();
              }

              frame() {
                const device = this.device;
                device.acquire();
                const cmdBuff = this.cmdBuff;
                const framebuffer = this.framebuffer;
                const renderArea = this.renderArea;
                renderArea.width = device.width;
                renderArea.height = device.height;
                cmdBuff.begin();
                cmdBuff.beginRenderPass(framebuffer.renderPass, framebuffer, renderArea, this.clearColors, 1.0, 0);
                const logoPass = this.logoMat.passes[0];
                const logoPso = PipelineStateManager.getOrCreatePipelineState(device, logoPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
                cmdBuff.bindPipelineState(logoPso);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, logoPass.descriptorSet);
                cmdBuff.bindInputAssembler(this.quadAssmebler);
                cmdBuff.draw(this.quadAssmebler);

                if (this.settings.displayWatermark && this.watermarkMat) {
                  const wartermarkPass = this.watermarkMat.passes[0];
                  const watermarkPso = PipelineStateManager.getOrCreatePipelineState(device, wartermarkPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
                  cmdBuff.bindPipelineState(watermarkPso);
                  cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, wartermarkPass.descriptorSet);
                  cmdBuff.bindInputAssembler(this.quadAssmebler);
                  cmdBuff.draw(this.quadAssmebler);
                }

                cmdBuff.endRenderPass();
                cmdBuff.end();
                device.flushCommands([cmdBuff]);
                device.queue.submit([cmdBuff]);
                device.present();
              }

              destroy() {
                this.callBack = null;
                this.root = null;
                this.device = null;
                this.clearColors = null;
                if (this.logoImage.destroy) this.logoImage.destroy();
                this.logoImage = null;
                this.framebuffer = null;
                this.renderArea = null;
                this.cmdBuff = null;
                this.shader = null;
                this.logoMat.destroy();
                this.logoMat = null;
                this.logoTexture.destroy();
                this.logoTexture = null;
                this.quadAssmebler.destroy();
                this.quadAssmebler = null;
                this.vertexBuffers.destroy();
                this.vertexBuffers = null;
                this.indicesBuffers.destroy();
                this.indicesBuffers = null;
                this.sampler.destroy();
                this.sampler = null;

                if (this.watermarkTexture) {
                  this.watermarkMat.destroy();
                  this.watermarkMat = null;
                  this.watermarkTexture.destroy();
                  this.watermarkTexture = null;
                }

                this.settings = null;
                SplashScreen._ins = undefined;
              }

              static get instance() {
                if (!SplashScreen._ins) {
                  SplashScreen._ins = new SplashScreen();
                }

                return SplashScreen._ins;
              }

              constructor() {
                this.handle = 0;
                this.callBack = null;
                this.cancelAnimate = false;
                this.startTime = -1;
                this._splashFinish = false;
                this._loadFinish = false;
                this._directCall = false;
              }

            }
            SplashScreen._ins = void 0;
            legacyCC.internal.SplashScreen = SplashScreen;

            class System {
              constructor() {
                this._id = '';
                this._priority = 0;
                this._executeInEditMode = false;
              }

              set priority(value) {
                this._priority = value;
              }

              get priority() {
                return this._priority;
              }

              set id(id) {
                this._id = id;
              }

              get id() {
                return this._id;
              }

              static sortByPriority(a, b) {
                if (a._priority < b._priority) {
                  return 1;
                } else if (a._priority > b.priority) {
                  return -1;
                } else {
                  return 0;
                }
              }

              init() {}

              update(dt) {}

              postUpdate(dt) {}

            } exports('dU', System);
            System.Priority = Enum({
              LOW: 0,
              MEDIUM: 100,
              HIGH: 200,
              SCHEDULER: 1 << 31 >>> 0
            });

            const MAX_POOL_SIZE$1 = 20;
            const idGenerator$3 = new IDGenerator('Scheduler');

            class ListEntry {
              constructor(target, priority, paused, markedForDeletion) {
                this.target = void 0;
                this.priority = void 0;
                this.paused = void 0;
                this.markedForDeletion = void 0;
                this.target = target;
                this.priority = priority;
                this.paused = paused;
                this.markedForDeletion = markedForDeletion;
              }

            }

            ListEntry.get = (target, priority, paused, markedForDeletion) => {
              let result = ListEntry._listEntries.pop();

              if (result) {
                result.target = target;
                result.priority = priority;
                result.paused = paused;
                result.markedForDeletion = markedForDeletion;
              } else {
                result = new ListEntry(target, priority, paused, markedForDeletion);
              }

              return result;
            };

            ListEntry.put = entry => {
              if (ListEntry._listEntries.length < MAX_POOL_SIZE$1) {
                entry.target = null;

                ListEntry._listEntries.push(entry);
              }
            };

            ListEntry._listEntries = [];

            class HashUpdateEntry {
              constructor(list, entry, target, callback) {
                this.list = void 0;
                this.entry = void 0;
                this.target = void 0;
                this.callback = void 0;
                this.list = list;
                this.entry = entry;
                this.target = target;
                this.callback = callback;
              }

            }

            HashUpdateEntry.get = (list, entry, target, callback) => {
              let result = HashUpdateEntry._hashUpdateEntries.pop();

              if (result) {
                result.list = list;
                result.entry = entry;
                result.target = target;
                result.callback = callback;
              } else {
                result = new HashUpdateEntry(list, entry, target, callback);
              }

              return result;
            };

            HashUpdateEntry.put = entry => {
              if (HashUpdateEntry._hashUpdateEntries.length < MAX_POOL_SIZE$1) {
                entry.list = entry.entry = entry.target = entry.callback = null;

                HashUpdateEntry._hashUpdateEntries.push(entry);
              }
            };

            HashUpdateEntry._hashUpdateEntries = [];

            class HashTimerEntry {
              constructor(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
                this.timers = void 0;
                this.target = void 0;
                this.timerIndex = void 0;
                this.currentTimer = void 0;
                this.currentTimerSalvaged = void 0;
                this.paused = void 0;
                this.timers = timers;
                this.target = target;
                this.timerIndex = timerIndex;
                this.currentTimer = currentTimer;
                this.currentTimerSalvaged = currentTimerSalvaged;
                this.paused = paused;
              }

            }

            HashTimerEntry.get = (timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) => {
              let result = HashTimerEntry._hashTimerEntries.pop();

              if (result) {
                result.timers = timers;
                result.target = target;
                result.timerIndex = timerIndex;
                result.currentTimer = currentTimer;
                result.currentTimerSalvaged = currentTimerSalvaged;
                result.paused = paused;
              } else {
                result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
              }

              return result;
            };

            HashTimerEntry.put = entry => {
              if (HashTimerEntry._hashTimerEntries.length < MAX_POOL_SIZE$1) {
                entry.timers = entry.target = entry.currentTimer = null;

                HashTimerEntry._hashTimerEntries.push(entry);
              }
            };

            HashTimerEntry._hashTimerEntries = [];

            class CallbackTimer {
              constructor() {
                this._lock = void 0;
                this._scheduler = void 0;
                this._elapsed = void 0;
                this._runForever = void 0;
                this._useDelay = void 0;
                this._timesExecuted = void 0;
                this._repeat = void 0;
                this._delay = void 0;
                this._interval = void 0;
                this._target = void 0;
                this._callback = void 0;
                this._lock = false;
                this._scheduler = null;
                this._elapsed = -1;
                this._runForever = false;
                this._useDelay = false;
                this._timesExecuted = 0;
                this._repeat = 0;
                this._delay = 0;
                this._interval = 0;
                this._target = null;
                this._callback = null;
              }

              initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
                this._lock = false;
                this._scheduler = scheduler;
                this._target = target;
                this._callback = callback;
                this._elapsed = -1;
                this._interval = seconds;
                this._delay = delay;
                this._useDelay = this._delay > 0;
                this._repeat = repeat;
                this._runForever = this._repeat === legacyCC.macro.REPEAT_FOREVER;
                return true;
              }

              getInterval() {
                return this._interval;
              }

              setInterval(interval) {
                this._interval = interval;
              }

              update(dt) {
                if (this._elapsed === -1) {
                  this._elapsed = 0;
                  this._timesExecuted = 0;
                } else {
                  this._elapsed += dt;

                  if (this._runForever && !this._useDelay) {
                    if (this._elapsed >= this._interval) {
                      this.trigger();
                      this._elapsed = 0;
                    }
                  } else {
                    if (this._useDelay) {
                      if (this._elapsed >= this._delay) {
                        this.trigger();
                        this._elapsed -= this._delay;
                        this._timesExecuted += 1;
                        this._useDelay = false;
                      }
                    } else if (this._elapsed >= this._interval) {
                      this.trigger();
                      this._elapsed = 0;
                      this._timesExecuted += 1;
                    }

                    if (this._callback && !this._runForever && this._timesExecuted > this._repeat) {
                      this.cancel();
                    }
                  }
                }
              }

              getCallback() {
                return this._callback;
              }

              trigger() {
                if (this._target && this._callback) {
                  this._lock = true;

                  this._callback.call(this._target, this._elapsed);

                  this._lock = false;
                }
              }

              cancel() {
                this._scheduler.unschedule(this._callback, this._target);
              }

            }

            CallbackTimer._timers = [];

            CallbackTimer.get = () => CallbackTimer._timers.pop() || new CallbackTimer();

            CallbackTimer.put = timer => {
              if (CallbackTimer._timers.length < MAX_POOL_SIZE$1 && !timer._lock) {
                timer._scheduler = timer._target = timer._callback = null;

                CallbackTimer._timers.push(timer);
              }
            };

            class Scheduler extends System {
              static enableForTarget(target) {
                let found = false;

                if (target.uuid) {
                  found = true;
                } else if (target.id) {
                  found = true;
                }

                if (!found) {
                  if (target.__instanceId) {
                    warnID(1513);
                  } else {
                    target.id = idGenerator$3.getNewId();
                  }
                }
              }

              constructor() {
                super();
                this._timeScale = void 0;
                this._updatesNegList = void 0;
                this._updates0List = void 0;
                this._updatesPosList = void 0;
                this._hashForUpdates = void 0;
                this._hashForTimers = void 0;
                this._currentTarget = void 0;
                this._currentTargetSalvaged = void 0;
                this._updateHashLocked = void 0;
                this._arrayForTimers = void 0;
                this._timeScale = 1.0;
                this._updatesNegList = [];
                this._updates0List = [];
                this._updatesPosList = [];
                this._hashForUpdates = createMap(true);
                this._hashForTimers = createMap(true);
                this._currentTarget = null;
                this._currentTargetSalvaged = false;
                this._updateHashLocked = false;
                this._arrayForTimers = [];
              }

              setTimeScale(timeScale) {
                this._timeScale = timeScale;
              }

              getTimeScale() {
                return this._timeScale;
              }

              update(dt) {
                this._updateHashLocked = true;

                if (this._timeScale !== 1) {
                  dt *= this._timeScale;
                }

                let i;
                let list;
                let len;
                let entry;

                for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
                  entry = list[i];

                  if (!entry.paused && !entry.markedForDeletion) {
                    entry.target.update(dt);
                  }
                }

                for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
                  entry = list[i];

                  if (!entry.paused && !entry.markedForDeletion) {
                    entry.target.update(dt);
                  }
                }

                for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
                  entry = list[i];

                  if (!entry.paused && !entry.markedForDeletion) {
                    entry.target.update(dt);
                  }
                }

                let elt;
                const arr = this._arrayForTimers;

                for (i = 0; i < arr.length; i++) {
                  elt = arr[i];
                  this._currentTarget = elt;
                  this._currentTargetSalvaged = false;

                  if (!elt.paused) {
                    for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
                      elt.currentTimer = elt.timers[elt.timerIndex];
                      elt.currentTimerSalvaged = false;
                      elt.currentTimer.update(dt);
                      elt.currentTimer = null;
                    }
                  }

                  if (this._currentTargetSalvaged && this._currentTarget.timers.length === 0) {
                    this._removeHashElement(this._currentTarget);

                    --i;
                  }
                }

                for (i = 0, list = this._updatesNegList; i < list.length;) {
                  entry = list[i];

                  if (entry.markedForDeletion) {
                    this._removeUpdateFromHash(entry);
                  } else {
                    i++;
                  }
                }

                for (i = 0, list = this._updates0List; i < list.length;) {
                  entry = list[i];

                  if (entry.markedForDeletion) {
                    this._removeUpdateFromHash(entry);
                  } else {
                    i++;
                  }
                }

                for (i = 0, list = this._updatesPosList; i < list.length;) {
                  entry = list[i];

                  if (entry.markedForDeletion) {
                    this._removeUpdateFromHash(entry);
                  } else {
                    i++;
                  }
                }

                this._updateHashLocked = false;
                this._currentTarget = null;
              }

              schedule(callback, target, interval, repeat, delay, paused) {
                if (typeof callback !== 'function') {
                  const tmp = callback;
                  callback = target;
                  target = tmp;
                }

                if (arguments.length === 3 || arguments.length === 4 || arguments.length === 5) {
                  paused = !!repeat;
                  repeat = legacyCC.macro.REPEAT_FOREVER;
                  delay = 0;
                }

                assertID(target, 1502);
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                let element = this._hashForTimers[targetId];

                if (!element) {
                  element = HashTimerEntry.get(null, target, 0, null, null, paused);

                  this._arrayForTimers.push(element);

                  this._hashForTimers[targetId] = element;
                } else if (element.paused !== paused) {
                  warnID(1511);
                }

                let timer;
                let i;

                if (element.timers == null) {
                  element.timers = [];
                } else {
                  for (i = 0; i < element.timers.length; ++i) {
                    timer = element.timers[i];

                    if (timer && callback === timer._callback) {
                      logID(1507, timer.getInterval(), interval);
                      timer._interval = interval;
                      return;
                    }
                  }
                }

                timer = CallbackTimer.get();
                timer.initWithCallback(this, callback, target, interval, repeat, delay);
                element.timers.push(timer);

                if (this._currentTarget === element && this._currentTargetSalvaged) {
                  this._currentTargetSalvaged = false;
                }
              }

              scheduleUpdate(target, priority, paused) {
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const hashElement = this._hashForUpdates[targetId];

                if (hashElement && hashElement.entry) {
                  if (hashElement.entry.priority !== priority) {
                    if (this._updateHashLocked) {
                      logID(1506);
                      hashElement.entry.markedForDeletion = false;
                      hashElement.entry.paused = paused;
                      return;
                    } else {
                      this.unscheduleUpdate(target);
                    }
                  } else {
                    hashElement.entry.markedForDeletion = false;
                    hashElement.entry.paused = paused;
                    return;
                  }
                }

                const listElement = ListEntry.get(target, priority, paused, false);
                let ppList;

                if (priority === 0) {
                  ppList = this._updates0List;

                  this._appendIn(ppList, listElement);
                } else {
                  ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;

                  this._priorityIn(ppList, listElement, priority);
                }

                this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
              }

              unschedule(callback, target) {
                if (!target || !callback) {
                  return;
                }

                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const element = this._hashForTimers[targetId];

                if (element) {
                  const timers = element.timers;

                  for (let i = 0, li = timers.length; i < li; i++) {
                    const timer = timers[i];

                    if (callback === timer._callback) {
                      if (timer === element.currentTimer && !element.currentTimerSalvaged) {
                        element.currentTimerSalvaged = true;
                      }

                      timers.splice(i, 1);
                      CallbackTimer.put(timer);

                      if (element.timerIndex >= i) {
                        element.timerIndex--;
                      }

                      if (timers.length === 0) {
                        if (this._currentTarget === element) {
                          this._currentTargetSalvaged = true;
                        } else {
                          this._removeHashElement(element);
                        }
                      }

                      return;
                    }
                  }
                }
              }

              unscheduleUpdate(target) {
                if (!target) {
                  return;
                }

                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const element = this._hashForUpdates[targetId];

                if (element) {
                  if (this._updateHashLocked) {
                    element.entry.markedForDeletion = true;
                  } else {
                    this._removeUpdateFromHash(element.entry);
                  }
                }
              }

              unscheduleAllForTarget(target) {
                if (!target) {
                  return;
                }

                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const element = this._hashForTimers[targetId];

                if (element) {
                  const timers = element.timers;

                  if (timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged) {
                    element.currentTimerSalvaged = true;
                  }

                  for (let i = 0, l = timers.length; i < l; i++) {
                    CallbackTimer.put(timers[i]);
                  }

                  timers.length = 0;

                  if (this._currentTarget === element) {
                    this._currentTargetSalvaged = true;
                  } else {
                    this._removeHashElement(element);
                  }
                }

                this.unscheduleUpdate(target);
              }

              unscheduleAll() {
                this.unscheduleAllWithMinPriority(System.Priority.SCHEDULER);
              }

              unscheduleAllWithMinPriority(minPriority) {
                let i;
                let element;
                const arr = this._arrayForTimers;

                for (i = arr.length - 1; i >= 0; i--) {
                  element = arr[i];
                  this.unscheduleAllForTarget(element.target);
                }

                let entry;
                let temp_length = 0;

                if (minPriority < 0) {
                  for (i = 0; i < this._updatesNegList.length;) {
                    temp_length = this._updatesNegList.length;
                    entry = this._updatesNegList[i];

                    if (entry && entry.priority >= minPriority) {
                      this.unscheduleUpdate(entry.target);
                    }

                    if (temp_length === this._updatesNegList.length) {
                      i++;
                    }
                  }
                }

                if (minPriority <= 0) {
                  for (i = 0; i < this._updates0List.length;) {
                    temp_length = this._updates0List.length;
                    entry = this._updates0List[i];

                    if (entry) {
                      this.unscheduleUpdate(entry.target);
                    }

                    if (temp_length === this._updates0List.length) {
                      i++;
                    }
                  }
                }

                for (i = 0; i < this._updatesPosList.length;) {
                  temp_length = this._updatesPosList.length;
                  entry = this._updatesPosList[i];

                  if (entry && entry.priority >= minPriority) {
                    this.unscheduleUpdate(entry.target);
                  }

                  if (temp_length === this._updatesPosList.length) {
                    i++;
                  }
                }
              }

              isScheduled(callback, target) {
                assertID(callback, 1508);
                assertID(target, 1509);
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return false;
                }

                const element = this._hashForTimers[targetId];

                if (!element) {
                  return false;
                }

                if (element.timers == null) {
                  return false;
                } else {
                  const timers = element.timers;

                  for (let i = 0; i < timers.length; ++i) {
                    const timer = timers[i];

                    if (callback === timer._callback) {
                      return true;
                    }
                  }

                  return false;
                }
              }

              pauseAllTargets() {
                return this.pauseAllTargetsWithMinPriority(System.Priority.SCHEDULER);
              }

              pauseAllTargetsWithMinPriority(minPriority) {
                const idsWithSelectors = [];
                let element;
                const locArrayForTimers = this._arrayForTimers;
                let i;
                let li;

                for (i = 0, li = locArrayForTimers.length; i < li; i++) {
                  element = locArrayForTimers[i];

                  if (element) {
                    element.paused = true;
                    idsWithSelectors.push(element.target);
                  }
                }

                let entry;

                if (minPriority < 0) {
                  for (i = 0; i < this._updatesNegList.length; i++) {
                    entry = this._updatesNegList[i];

                    if (entry) {
                      if (entry.priority >= minPriority) {
                        entry.paused = true;
                        idsWithSelectors.push(entry.target);
                      }
                    }
                  }
                }

                if (minPriority <= 0) {
                  for (i = 0; i < this._updates0List.length; i++) {
                    entry = this._updates0List[i];

                    if (entry) {
                      entry.paused = true;
                      idsWithSelectors.push(entry.target);
                    }
                  }
                }

                for (i = 0; i < this._updatesPosList.length; i++) {
                  entry = this._updatesPosList[i];

                  if (entry) {
                    if (entry.priority >= minPriority) {
                      entry.paused = true;
                      idsWithSelectors.push(entry.target);
                    }
                  }
                }

                return idsWithSelectors;
              }

              resumeTargets(targetsToResume) {
                if (!targetsToResume) {
                  return;
                }

                for (let i = 0; i < targetsToResume.length; i++) {
                  this.resumeTarget(targetsToResume[i]);
                }
              }

              pauseTarget(target) {
                assertID(target, 1503);
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const element = this._hashForTimers[targetId];

                if (element) {
                  element.paused = true;
                }

                const elementUpdate = this._hashForUpdates[targetId];

                if (elementUpdate) {
                  elementUpdate.entry.paused = true;
                }
              }

              resumeTarget(target) {
                assertID(target, 1504);
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const element = this._hashForTimers[targetId];

                if (element) {
                  element.paused = false;
                }

                const elementUpdate = this._hashForUpdates[targetId];

                if (elementUpdate) {
                  elementUpdate.entry.paused = false;
                }
              }

              isTargetPaused(target) {
                assertID(target, 1505);
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return false;
                }

                const element = this._hashForTimers[targetId];

                if (element) {
                  return element.paused;
                }

                const elementUpdate = this._hashForUpdates[targetId];

                if (elementUpdate) {
                  return elementUpdate.entry.paused;
                }

                return false;
              }

              _removeHashElement(element) {
                const targetId = element.target.uuid || element.target.id;
                delete this._hashForTimers[targetId];
                const arr = this._arrayForTimers;

                for (let i = 0, l = arr.length; i < l; i++) {
                  if (arr[i] === element) {
                    arr.splice(i, 1);
                    break;
                  }
                }

                HashTimerEntry.put(element);
              }

              _removeUpdateFromHash(entry) {
                const targetId = entry.target.uuid || entry.target.id;
                const element = this._hashForUpdates[targetId];

                if (element) {
                  const list = element.list;
                  const listEntry = element.entry;

                  for (let i = 0, l = list.length; i < l; i++) {
                    if (list[i] === listEntry) {
                      list.splice(i, 1);
                      break;
                    }
                  }

                  delete this._hashForUpdates[targetId];
                  ListEntry.put(listEntry);
                  HashUpdateEntry.put(element);
                }
              }

              _priorityIn(ppList, listElement, priority) {
                for (let i = 0; i < ppList.length; i++) {
                  if (priority < ppList[i].priority) {
                    ppList.splice(i, 0, listElement);
                    return;
                  }
                }

                ppList.push(listElement);
              }

              _appendIn(ppList, listElement) {
                ppList.push(listElement);
              }

            } exports('es', Scheduler);
            Scheduler.ID = 'scheduler';
            legacyCC.Scheduler = Scheduler;

            class RenderWindow {
              get width() {
                return this._width;
              }

              get height() {
                return this._height;
              }

              get framebuffer() {
                return this._framebuffer;
              }

              get shouldSyncSizeWithSwapchain() {
                return this._shouldSyncSizeWithSwapchain;
              }

              get hasOnScreenAttachments() {
                return this._hasOnScreenAttachments;
              }

              get hasOffScreenAttachments() {
                return this._hasOffScreenAttachments;
              }

              get cameras() {
                return this._cameras;
              }

              static registerCreateFunc(root) {
                root._createWindowFun = _root => new RenderWindow(_root);
              }

              get native() {
                return this._nativeObj;
              }

              constructor(root) {
                this._title = '';
                this._width = 1;
                this._height = 1;
                this._renderPass = null;
                this._colorTextures = [];
                this._depthStencilTexture = null;
                this._swapchainBufferIndices = 0;
                this._shouldSyncSizeWithSwapchain = false;
                this._cameras = [];
                this._hasOnScreenAttachments = false;
                this._hasOffScreenAttachments = false;
                this._framebuffer = null;
              }

              _setHasOffScreenAttachments(val) {
                this._hasOffScreenAttachments = val;

                {
                  this._nativeObj.hasOffScreenAttachments = val;
                }
              }

              _setHasOnScreenAttachments(val) {
                this._hasOnScreenAttachments = val;

                {
                  this._nativeObj.hasOnScreenAttachments = val;
                }
              }

              _createFrameBuffer(device, renderPass) {
                this._framebuffer = device.createFramebuffer(new FramebufferInfo(renderPass, this._colorTextures, this._depthStencilTexture));

                {
                  this._nativeObj.frameBuffer = this._framebuffer;
                }
              }

              _init() {
                {
                  this._nativeObj = new NativeRenderWindow();
                }
              }

              initialize(device, info) {
                this._init();

                if (info.title !== undefined) {
                  this._title = info.title;
                }

                if (info.swapchainBufferIndices !== undefined) {
                  this._swapchainBufferIndices = info.swapchainBufferIndices;
                }

                if (info.shouldSyncSizeWithSwapchain !== undefined) {
                  this._shouldSyncSizeWithSwapchain = info.shouldSyncSizeWithSwapchain;
                }

                this._width = info.width;
                this._height = info.height;
                const {
                  colorAttachments,
                  depthStencilAttachment
                } = info.renderPassInfo;

                for (let i = 0; i < colorAttachments.length; i++) {
                  if (colorAttachments[i].format === Format.UNKNOWN) {
                    colorAttachments[i].format = device.colorFormat;
                  }
                }

                if (depthStencilAttachment && depthStencilAttachment.format === Format.UNKNOWN) {
                  depthStencilAttachment.format = device.depthStencilFormat;
                }

                this._renderPass = device.createRenderPass(info.renderPassInfo);

                for (let i = 0; i < colorAttachments.length; i++) {
                  let colorTex = null;

                  if (!(this._swapchainBufferIndices & 1 << i)) {
                    colorTex = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, colorAttachments[i].format, this._width, this._height));

                    this._setHasOffScreenAttachments(true);
                  } else {
                    this._setHasOnScreenAttachments(true);
                  }

                  this._colorTextures.push(colorTex);
                }

                if (depthStencilAttachment) {
                  if (this._swapchainBufferIndices >= 0) {
                    this._depthStencilTexture = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.DEPTH_STENCIL_ATTACHMENT | TextureUsageBit.SAMPLED, depthStencilAttachment.format, this._width, this._height));

                    this._setHasOffScreenAttachments(true);
                  }
                } else {
                  this._setHasOnScreenAttachments(true);
                }

                this._createFrameBuffer(device, this._renderPass);

                return true;
              }

              _destroy() {
                this.framebuffer.destroy();

                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this.clearCameras();

                if (this._depthStencilTexture) {
                  this._depthStencilTexture.destroy();

                  this._depthStencilTexture = null;
                }

                for (let i = 0; i < this._colorTextures.length; i++) {
                  const colorTexture = this._colorTextures[i];

                  if (colorTexture) {
                    colorTexture.destroy();
                  }
                }

                this._colorTextures.length = 0;

                this._destroy();
              }

              resize(width, height) {
                this._width = width;
                this._height = height;
                let needRebuild = false;

                if (this._depthStencilTexture) {
                  this._depthStencilTexture.resize(width, height);

                  needRebuild = true;
                }

                for (let i = 0; i < this._colorTextures.length; i++) {
                  const colorTex = this._colorTextures[i];

                  if (colorTex) {
                    colorTex.resize(width, height);
                    needRebuild = true;
                  }
                }

                const framebuffer = this.framebuffer;

                if (needRebuild && framebuffer) {
                  framebuffer.destroy();
                  framebuffer.initialize(new FramebufferInfo(this._renderPass, this._colorTextures, this._depthStencilTexture));
                }

                for (const camera of this._cameras) {
                  if (camera.isWindowSize) {
                    camera.resize(width, height);
                  }
                }
              }

              extractRenderCameras(cameras) {
                for (let j = 0; j < this._cameras.length; j++) {
                  const camera = this._cameras[j];

                  if (camera.enabled) {
                    camera.update();
                    cameras.push(camera);
                  }
                }
              }

              attachCamera(camera) {
                for (let i = 0; i < this._cameras.length; i++) {
                  if (this._cameras[i] === camera) {
                    return;
                  }
                }

                this._cameras.push(camera);

                this.sortCameras();
              }

              detachCamera(camera) {
                for (let i = 0; i < this._cameras.length; ++i) {
                  if (this._cameras[i] === camera) {
                    this._cameras.splice(i, 1);

                    return;
                  }
                }
              }

              clearCameras() {
                this._cameras.length = 0;
              }

              sortCameras() {
                this._cameras.sort((a, b) => a.priority - b.priority);
              }

            }

            class Root {
              _init() {
                {
                  this._naitveObj = new NativeRoot();
                }
              }

              _destroy() {
                {
                  this._naitveObj = null;
                }
              }

              _setCumulativeTime(deltaTime) {
                this._cumulativeTime += deltaTime;

                {
                  this._naitveObj.cumulativeTime = this._cumulativeTime;
                }
              }

              _setFrameTime(deltaTime) {
                this._frameTime = deltaTime;

                {
                  this._naitveObj.frameTime = deltaTime;
                }
              }

              get device() {
                return this._device;
              }

              get mainWindow() {
                return this._mainWindow;
              }

              set curWindow(window) {
                this._curWindow = window;
              }

              get curWindow() {
                return this._curWindow;
              }

              set tempWindow(window) {
                this._tempWindow = window;
              }

              get tempWindow() {
                return this._tempWindow;
              }

              get windows() {
                return this._windows;
              }

              get pipeline() {
                return this._pipeline;
              }

              get batcher2D() {
                return this._batcher;
              }

              get scenes() {
                return this._scenes;
              }

              get cumulativeTime() {
                return this._cumulativeTime;
              }

              get frameTime() {
                return this._frameTime;
              }

              get frameCount() {
                return this._frameCount;
              }

              get fps() {
                return this._fps;
              }

              set fixedFPS(fps) {
                if (fps > 0) {
                  this._fixedFPS = fps;
                  this._fixedFPSFrameTime = 1000.0 / fps;
                } else {
                  this._fixedFPSFrameTime = 0;
                }
              }

              get fixedFPS() {
                return this._fixedFPS;
              }

              get dataPoolManager() {
                return this._dataPoolMgr;
              }

              get useDeferredPipeline() {
                return this._useDeferredPipeline;
              }

              constructor(device) {
                this._createSceneFun = null;
                this._createWindowFun = null;
                this._device = void 0;
                this._windows = [];
                this._mainWindow = null;
                this._curWindow = null;
                this._tempWindow = null;
                this._pipeline = null;
                this._batcher = null;
                this._dataPoolMgr = void 0;
                this._scenes = [];
                this._modelPools = new Map();
                this._cameraPool = null;
                this._lightPools = new Map();
                this._fpsTime = 0;
                this._frameCount = 0;
                this._fps = 0;
                this._fixedFPS = 0;
                this._useDeferredPipeline = false;
                this._fixedFPSFrameTime = 0;
                this._cumulativeTime = 0;
                this._frameTime = 0;
                this._device = device;
                this._dataPoolMgr = legacyCC.internal.DataPoolManager && new legacyCC.internal.DataPoolManager(device);
                RenderScene.registerCreateFunc(this);
                RenderWindow.registerCreateFunc(this);
                this._cameraPool = new Pool(() => new Camera(this._device), 4);
              }

              initialize(info) {
                this._init();

                const colorAttachment = new ColorAttachment();
                const depthStencilAttachment = new DepthStencilAttachment();
                depthStencilAttachment.depthStoreOp = StoreOp.DISCARD;
                depthStencilAttachment.stencilStoreOp = StoreOp.DISCARD;
                const renderPassInfo = new RenderPassInfo([colorAttachment], depthStencilAttachment);
                this._mainWindow = this.createWindow({
                  title: 'rootMainWindow',
                  width: this._device.width,
                  height: this._device.height,
                  renderPassInfo,
                  swapchainBufferIndices: -1
                });
                this._curWindow = this._mainWindow;
                return Promise.resolve(builtinResMgr.initBuiltinRes(this._device)).then(() => {
                  legacyCC.view.on('design-resolution-changed', () => {
                    const width = legacyCC.game.canvas.width;
                    const height = legacyCC.game.canvas.height;
                    this.resize(width, height);
                  }, this);
                });
              }

              destroy() {
                this.destroyScenes();

                if (this._pipeline) {
                  this._pipeline.destroy();

                  this._pipeline = null;
                }

                if (this._batcher) {
                  this._batcher.destroy();

                  this._batcher = null;
                }

                this._curWindow = null;
                this._mainWindow = null;
                this.dataPoolManager.clear();

                this._destroy();
              }

              resize(width, height) {
                this._device.resize(width, height);

                this._mainWindow.resize(width, height);

                for (const window of this._windows) {
                  if (window.shouldSyncSizeWithSwapchain) {
                    window.resize(width, height);
                  }
                }

                if (this._pipeline) {
                  this._pipeline.resize(width, height);
                }
              }

              setRenderPipeline(rppl) {
                if (rppl instanceof DeferredPipeline) {
                  this._useDeferredPipeline = true;
                }

                if (!rppl) {
                  rppl = createDefaultPipeline();
                }

                this._pipeline = rppl;

                if (!this._pipeline.activate()) {
                  return false;
                }

                const scene = legacyCC.director.getScene();

                if (scene) {
                  scene.globals.activate();
                }

                this.onGlobalPipelineStateChanged();

                if (!this._batcher && legacyCC.internal.Batcher2D) {
                  this._batcher = new legacyCC.internal.Batcher2D(this);

                  if (!this._batcher.initialize()) {
                    this.destroy();
                    return false;
                  }
                }

                return true;
              }

              onGlobalPipelineStateChanged() {
                for (let i = 0; i < this._scenes.length; i++) {
                  this._scenes[i].onGlobalPipelineStateChanged();
                }

                this._pipeline.pipelineSceneData.onGlobalPipelineStateChanged();
              }

              activeWindow(window) {
                this._curWindow = window;
              }

              resetCumulativeTime() {
                this._setCumulativeTime(0);
              }

              frameMove(deltaTime) {
                this._setFrameTime(deltaTime);

                ++this._frameCount;

                this._setCumulativeTime(deltaTime);

                this._fpsTime += deltaTime;

                if (this._fpsTime > 1.0) {
                  this._fps = this._frameCount;
                  this._frameCount = 0;
                  this._fpsTime = 0.0;
                }

                for (let i = 0; i < this._scenes.length; ++i) {
                  this._scenes[i].removeBatches();
                }

                if (this._batcher) this._batcher.update();
                const windows = this._windows;
                const cameraList = [];

                for (let i = 0; i < windows.length; i++) {
                  const window = windows[i];
                  window.extractRenderCameras(cameraList);
                }

                if (this._pipeline && cameraList.length > 0) {
                  this._device.acquire();

                  const scenes = this._scenes;
                  const stamp = legacyCC.director.getTotalFrames();
                  if (this._batcher) this._batcher.uploadBuffers();

                  for (let i = 0; i < scenes.length; i++) {
                    scenes[i].update(stamp);
                  }

                  legacyCC.director.emit(legacyCC.Director.EVENT_BEFORE_COMMIT);
                  cameraList.sort((a, b) => a.priority - b.priority);

                  this._pipeline.render(cameraList);

                  this._device.present();
                }

                if (this._batcher) this._batcher.reset();
              }

              createWindow(info) {
                const window = this._createWindowFun(this);

                window.initialize(this.device, info);

                this._windows.push(window);

                return window;
              }

              destroyWindow(window) {
                for (let i = 0; i < this._windows.length; ++i) {
                  if (this._windows[i] === window) {
                    window.destroy();

                    this._windows.splice(i, 1);

                    return;
                  }
                }
              }

              destroyWindows() {
                for (const window of this._windows) {
                  window.destroy();
                }

                this._windows = [];
              }

              createScene(info) {
                const scene = this._createSceneFun(this);

                scene.initialize(info);

                this._scenes.push(scene);

                return scene;
              }

              destroyScene(scene) {
                for (let i = 0; i < this._scenes.length; ++i) {
                  if (this._scenes[i] === scene) {
                    scene.destroy();

                    this._scenes.splice(i, 1);

                    return;
                  }
                }
              }

              destroyScenes() {
                for (const scene of this._scenes) {
                  scene.destroy();
                }

                this._scenes = [];
              }

              createModel(ModelCtor) {
                let p = this._modelPools.get(ModelCtor);

                if (!p) {
                  this._modelPools.set(ModelCtor, new Pool(() => new ModelCtor(), 10));

                  p = this._modelPools.get(ModelCtor);
                }

                const model = p.alloc();
                model.initialize();
                return model;
              }

              destroyModel(m) {
                const p = this._modelPools.get(m.constructor);

                if (p) {
                  p.free(m);
                  m.destroy();

                  if (m.scene) {
                    m.scene.removeModel(m);
                  }
                } else {
                  warnID(1300, m.constructor.name);
                }
              }

              createCamera() {
                return this._cameraPool.alloc();
              }

              createLight(LightCtor) {
                let l = this._lightPools.get(LightCtor);

                if (!l) {
                  this._lightPools.set(LightCtor, new Pool(() => new LightCtor(), 4));

                  l = this._lightPools.get(LightCtor);
                }

                const light = l.alloc();
                light.initialize();
                return light;
              }

              destroyLight(l) {
                const p = this._lightPools.get(l.constructor);

                l.destroy();

                if (p) {
                  p.free(l);

                  if (l.scene) {
                    switch (l.type) {
                      case LightType.SPHERE:
                        l.scene.removeSphereLight(l);
                        break;

                      case LightType.SPOT:
                        l.scene.removeSpotLight(l);
                        break;
                    }
                  }
                }
              }

            }
            legacyCC.Root = Root;

            class Director extends EventTarget {
              constructor() {
                super();
                this._compScheduler = void 0;
                this._nodeActivator = void 0;
                this._invalid = void 0;
                this._paused = void 0;
                this._root = void 0;
                this._loadingScene = void 0;
                this._scene = void 0;
                this._totalFrames = void 0;
                this._scheduler = void 0;
                this._systems = void 0;
                this._invalid = false;
                this._paused = false;
                this._root = null;
                this._loadingScene = '';
                this._scene = null;
                this._totalFrames = 0;
                this._scheduler = new Scheduler();
                this._compScheduler = new ComponentScheduler();
                this._nodeActivator = new NodeActivator();
                this._systems = [];
                game.once(Game.EVENT_RENDERER_INITED, this._initOnRendererInitialized, this);
              }

              calculateDeltaTime(now) {}

              convertToGL(uiPoint) {
                const container = game.container;
                const view = legacyCC.view;
                const box = container.getBoundingClientRect();
                const left = box.left + window.pageXOffset - container.clientLeft;
                const top = box.top + window.pageYOffset - container.clientTop;
                const x = view._devicePixelRatio * (uiPoint.x - left);
                const y = view._devicePixelRatio * (top + box.height - uiPoint.y);
                return view._isRotated ? v2(view._viewportRect.width - y, x) : v2(x, y);
              }

              convertToUI(glPoint) {
                const container = game.container;
                const view = legacyCC.view;
                const box = container.getBoundingClientRect();
                const left = box.left + window.pageXOffset - container.clientLeft;
                const top = box.top + window.pageYOffset - container.clientTop;
                const uiPoint = v2(0, 0);

                if (view._isRotated) {
                  uiPoint.x = left + glPoint.y / view._devicePixelRatio;
                  uiPoint.y = top + box.height - (view._viewportRect.width - glPoint.x) / view._devicePixelRatio;
                } else {
                  uiPoint.x = left + glPoint.x * view._devicePixelRatio;
                  uiPoint.y = top + box.height - glPoint.y * view._devicePixelRatio;
                }

                return uiPoint;
              }

              end() {
                this.once(Director.EVENT_END_FRAME, () => {
                  this.purgeDirector();
                });
              }

              pause() {
                if (this._paused) {
                  return;
                }

                this._paused = true;
              }

              purgeDirector() {
                this._scheduler.unscheduleAll();

                this._compScheduler.unscheduleAll();

                this._nodeActivator.reset();

                if (eventManager) {
                  eventManager.setEnabled(false);
                }

                {
                  if (legacyCC.isValid(this._scene)) {
                    this._scene.destroy();
                  }

                  this._scene = null;
                }

                this.stopAnimation();
                legacyCC.assetManager.releaseAll();
              }

              reset() {
                this.purgeDirector();
                this.emit(Director.EVENT_RESET);

                if (eventManager) {
                  eventManager.setEnabled(true);
                }

                this.startAnimation();
              }

              runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
                if (scene instanceof SceneAsset) scene = scene.scene;
                assertID(scene instanceof Scene, 1216);

                {
                  console.time('InitScene');
                }

                scene._load();

                {
                  console.timeEnd('InitScene');
                }

                {
                  console.time('AttachPersist');
                }

                const persistNodeList = Object.keys(game._persistRootNodes).map(x => game._persistRootNodes[x]);

                for (let i = 0; i < persistNodeList.length; i++) {
                  const node = persistNodeList[i];
                  node.emit(legacyCC.Node.SCENE_CHANGED_FOR_PERSISTS, scene.renderScene);
                  const existNode = scene.uuid === node._originalSceneId && scene.getChildByUuid(node.uuid);

                  if (existNode) {
                    const index = existNode.getSiblingIndex();

                    existNode._destroyImmediate();

                    scene.insertChild(node, index);
                  } else {
                    node.parent = scene;
                  }
                }

                {
                  console.timeEnd('AttachPersist');
                }

                const oldScene = this._scene;

                {
                  console.time('Destroy');
                }

                if (legacyCC.isValid(oldScene)) {
                  oldScene.destroy();
                }

                {
                  {
                    console.time('AutoRelease');
                  }

                  legacyCC.assetManager._releaseManager._autoRelease(oldScene, scene, game._persistRootNodes);

                  {
                    console.timeEnd('AutoRelease');
                  }
                }

                this._scene = null;

                CCObject._deferredDestroy();

                {
                  console.timeEnd('Destroy');
                }

                if (onBeforeLoadScene) {
                  onBeforeLoadScene();
                }

                this.emit(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
                this._scene = scene;

                {
                  console.time('Activate');
                }

                scene._activate();

                {
                  console.timeEnd('Activate');
                }

                if (this._root) {
                  this._root.resetCumulativeTime();
                }

                this.startAnimation();

                if (onLaunched) {
                  onLaunched(null, scene);
                }

                this.emit(legacyCC.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
              }

              runScene(scene, onBeforeLoadScene, onLaunched) {
                if (scene instanceof SceneAsset) scene = scene.scene;
                assertID(scene, 1205);
                assertID(scene instanceof Scene, 1216);

                scene._load();

                this.once(legacyCC.Director.EVENT_END_FRAME, () => {
                  this.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
                });
              }

              loadScene(sceneName, onLaunched, onUnloaded) {
                if (this._loadingScene) {
                  warnID(1208, sceneName, this._loadingScene);
                  return false;
                }

                const bundle = legacyCC.assetManager.bundles.find(bundle => !!bundle.getSceneInfo(sceneName));

                if (bundle) {
                  this.emit(legacyCC.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
                  this._loadingScene = sceneName;
                  console.time(`LoadScene ${sceneName}`);
                  bundle.loadScene(sceneName, (err, scene) => {
                    console.timeEnd(`LoadScene ${sceneName}`);
                    this._loadingScene = '';

                    if (err) {
                      error(err);

                      if (onLaunched) {
                        onLaunched(err);
                      }
                    } else {
                      this.runSceneImmediate(scene, onUnloaded, onLaunched);
                    }
                  });
                  return true;
                } else {
                  errorID(1209, sceneName);
                  return false;
                }
              }

              preloadScene(sceneName, onProgress, onLoaded) {
                const bundle = legacyCC.assetManager.bundles.find(bundle => !!bundle.getSceneInfo(sceneName));

                if (bundle) {
                  bundle.preloadScene(sceneName, null, onProgress, onLoaded);
                } else {
                  const err = `Can not preload the scene "${sceneName}" because it is not in the build settings.`;

                  if (onLoaded) {
                    onLoaded(new Error(err));
                  }

                  error(`preloadScene: ${err}`);
                }
              }

              resume() {
                if (!this._paused) {
                  return;
                }

                this._paused = false;
              }

              get root() {
                return this._root;
              }

              getScene() {
                return this._scene;
              }

              getDeltaTime() {
                return game.deltaTime;
              }

              getTotalTime() {
                return game.totalTime;
              }

              getCurrentTime() {
                return game.frameStartTime;
              }

              getTotalFrames() {
                return this._totalFrames;
              }

              isPaused() {
                return this._paused;
              }

              getScheduler() {
                return this._scheduler;
              }

              setScheduler(scheduler) {
                if (this._scheduler !== scheduler) {
                  this.unregisterSystem(this._scheduler);
                  this._scheduler = scheduler;
                  this.registerSystem(Scheduler.ID, scheduler, 200);
                }
              }

              registerSystem(name, sys, priority) {
                sys.id = name;
                sys.priority = priority;
                sys.init();

                this._systems.push(sys);

                this._systems.sort(System.sortByPriority);
              }

              unregisterSystem(sys) {
                array.fastRemove(this._systems, sys);

                this._systems.sort(System.sortByPriority);
              }

              getSystem(name) {
                return this._systems.find(sys => sys.id === name);
              }

              getAnimationManager() {
                return this.getSystem(legacyCC.AnimationManager.ID);
              }

              startAnimation() {
                this._invalid = false;
              }

              stopAnimation() {
                this._invalid = true;
              }

              mainLoop(now) {
                let dt;

                {
                  dt = game._calculateDT(now);
                }

                this.tick(dt);
              }

              tick(dt) {
                if (!this._invalid) {
                  this.emit(Director.EVENT_BEGIN_FRAME);

                  {
                    inputManager.frameDispatchEvents();
                  }

                  if (!this._paused) {
                    this.emit(Director.EVENT_BEFORE_UPDATE);

                    this._compScheduler.startPhase();

                    this._compScheduler.updatePhase(dt);

                    for (let i = 0; i < this._systems.length; ++i) {
                      this._systems[i].update(dt);
                    }

                    this._compScheduler.lateUpdatePhase(dt);

                    this.emit(Director.EVENT_AFTER_UPDATE);

                    CCObject._deferredDestroy();

                    for (let i = 0; i < this._systems.length; ++i) {
                      this._systems[i].postUpdate(dt);
                    }
                  }

                  this.emit(Director.EVENT_BEFORE_DRAW);
                  this._root.frameMove(dt);
                  this.emit(Director.EVENT_AFTER_DRAW);
                  eventManager.frameUpdateListeners();
                  Node$1.resetHasChangedFlags();
                  Node$1.clearNodeArray();
                  this.emit(Director.EVENT_END_FRAME);
                  this._totalFrames++;
                }
              }

              _initOnRendererInitialized() {
                this._totalFrames = 0;
                this._paused = false;

                if (eventManager) {
                  eventManager.setEnabled(true);
                }

                this.registerSystem(Scheduler.ID, this._scheduler, 200);
                this.emit(Director.EVENT_INIT);
              }

              _init() {
                this._root = new Root(game._gfxDevice);
                const rootInfo = {};
                return this._root.initialize(rootInfo).catch(error => {
                  errorID(1217);
                  return Promise.reject(error);
                });
              }

            } exports('cR', Director);
            Director.EVENT_INIT = 'director_init';
            Director.EVENT_RESET = 'director_reset';
            Director.EVENT_BEFORE_SCENE_LOADING = 'director_before_scene_loading';
            Director.EVENT_BEFORE_SCENE_LAUNCH = 'director_before_scene_launch';
            Director.EVENT_AFTER_SCENE_LAUNCH = 'director_after_scene_launch';
            Director.EVENT_BEFORE_UPDATE = 'director_before_update';
            Director.EVENT_AFTER_UPDATE = 'director_after_update';
            Director.EVENT_BEFORE_DRAW = 'director_before_draw';
            Director.EVENT_AFTER_DRAW = 'director_after_draw';
            Director.EVENT_BEFORE_COMMIT = 'director_before_commit';
            Director.EVENT_BEFORE_PHYSICS = 'director_before_physics';
            Director.EVENT_AFTER_PHYSICS = 'director_after_physics';
            Director.EVENT_BEGIN_FRAME = 'director_begin_frame';
            Director.EVENT_END_FRAME = 'director_end_frame';
            Director.instance = void 0;
            legacyCC.Director = Director;
            const director = exports('cQ', Director.instance = legacyCC.director = new Director());

            const vmath = {};
            replaceProperty(vmath, 'vmath', [{
              name: 'vec2',
              newName: 'Vec2',
              target: math,
              targetName: 'math'
            }, {
              name: 'vec3',
              newName: 'Vec3',
              target: math,
              targetName: 'math'
            }, {
              name: 'vec4',
              newName: 'Vec4',
              target: math,
              targetName: 'math'
            }, {
              name: 'quat',
              newName: 'Quat',
              target: math,
              targetName: 'math'
            }, {
              name: 'mat3',
              newName: 'Mat3',
              target: math,
              targetName: 'math'
            }, {
              name: 'mat4',
              newName: 'Mat4',
              target: math,
              targetName: 'math'
            }, {
              name: 'color4',
              newName: 'Color',
              target: math,
              targetName: 'math'
            }, {
              name: 'rect',
              newName: 'Rect',
              target: math,
              targetName: 'math'
            }, {
              name: 'approx',
              newName: 'approx',
              target: math,
              targetName: 'math'
            }, {
              name: 'EPSILON',
              newName: 'EPSILON',
              target: math,
              targetName: 'math'
            }, {
              name: 'equals',
              newName: 'equals',
              target: math,
              targetName: 'math'
            }, {
              name: 'clamp',
              newName: 'clamp',
              target: math,
              targetName: 'math'
            }, {
              name: 'clamp01',
              newName: 'clamp01',
              target: math,
              targetName: 'math'
            }, {
              name: 'lerp',
              newName: 'lerp',
              target: math,
              targetName: 'math'
            }, {
              name: 'toRadian',
              newName: 'toRadian',
              target: math,
              targetName: 'math'
            }, {
              name: 'toDegree',
              newName: 'toDegree',
              target: math,
              targetName: 'math'
            }, {
              name: 'random',
              newName: 'random',
              target: math,
              targetName: 'math'
            }, {
              name: 'randomRange',
              newName: 'randomRange',
              target: math,
              targetName: 'math'
            }, {
              name: 'randomRangeInt',
              newName: 'randomRangeInt',
              target: math,
              targetName: 'math'
            }, {
              name: 'pseudoRandom',
              newName: 'pseudoRandom',
              target: math,
              targetName: 'math'
            }, {
              name: 'pseudoRandomRangeInt',
              newName: 'pseudoRandomRangeInt',
              target: math,
              targetName: 'math'
            }, {
              name: 'nextPow2',
              newName: 'nextPow2',
              target: math,
              targetName: 'math'
            }, {
              name: 'repeat',
              newName: 'repeat',
              target: math,
              targetName: 'math'
            }, {
              name: 'pingPong',
              newName: 'pingPong',
              target: math,
              targetName: 'math'
            }, {
              name: 'inverseLerp',
              newName: 'inverseLerp',
              target: math,
              targetName: 'math'
            }]);
            legacyCC.vmath = vmath;
            replaceProperty(Scheduler.prototype, 'Scheduler.prototype', [{
              name: 'enableForTarget',
              newName: 'enableForTarget',
              target: Scheduler,
              targetName: 'Scheduler'
            }]);
            replaceProperty(Scheduler, 'Scheduler', [{
              name: 'PRIORITY_SYSTEM',
              newName: 'System.Priority.SCHEDULER',

              customGetter() {
                return System.Priority.SCHEDULER;
              }

            }]);
            removeProperty(Scheduler, 'Scheduler', [{
              name: 'PRIORITY_NON_SYSTEM',
              suggest: 'Use enum` System.Priority` instead'
            }]);
            replaceProperty(EventTouch.prototype, 'EventTouch.prototype', [{
              name: 'getUILocationInView',
              newName: 'getLocationInView',
              target: EventTouch,
              targetName: 'EventTouch'
            }]);
            replaceProperty(SubModel.prototype, 'SubModel.prototype', [{
              name: 'subMeshData',
              newName: 'subMesh'
            }]);
            removeProperty(SubModel.prototype, 'SubModel.prototype', [{
              name: 'getSubModel',
              suggest: 'Use `subModels[i]` instead'
            }, {
              name: 'subModelNum',
              suggest: 'Use `subModels.length` instead'
            }]);
            replaceProperty(Root.prototype, 'Root.prototype', [{
              name: 'ui',
              newName: 'batcher2D'
            }]);
            markAsWarning(game, 'game', [{
              name: 'collisionMatrix'
            }, {
              name: 'groupList'
            }]);
            markAsWarning(Director.prototype, 'director', [{
              name: 'calculateDeltaTime'
            }, {
              name: 'getDeltaTime',
              suggest: 'Use game.deltaTime instead'
            }, {
              name: 'getTotalTime',
              suggest: 'Use game.totalTime instead'
            }, {
              name: 'getCurrentTime',
              suggest: 'Use game.frameStartTime instead'
            }]);
            removeProperty(Director.prototype, 'director', [{
              name: 'setAnimationInterval',
              suggest: 'please use game.frameRate instead'
            }, {
              name: 'getAnimationInterval',
              suggest: 'please use game.frameRate instead'
            }, {
              name: 'getRunningScene',
              suggest: 'please use getScene instead'
            }, {
              name: 'setDepthTest',
              suggest: 'please use camera API instead'
            }, {
              name: 'setClearColor',
              suggest: 'please use camera API instead'
            }, {
              name: 'getWinSize',
              suggest: 'please use view.getVisibleSize instead'
            }, {
              name: 'getWinSizeInPixels'
            }, {
              name: 'purgeCachedData',
              suggest: 'please use assetManager.releaseAll instead'
            }]);

            const isMatchByWord = (path, test) => {
              if (path.length > test.length) {
                const nextAscii = path.charCodeAt(test.length);
                return nextAscii === 47;
              }

              return true;
            };

            const processOptions = options => {

              let uuids = options.uuids;
              const paths = options.paths;
              const types = options.types;
              const bundles = options.deps;
              const realEntries = options.paths = Object.create(null);

              if (options.debug === false) {
                for (let i = 0, l = uuids.length; i < l; i++) {
                  uuids[i] = decodeUuid(uuids[i]);
                }

                for (const id in paths) {
                  const entry = paths[id];
                  const type = entry[1];
                  entry[1] = types[type];
                }
              } else {
                const out = Object.create(null);

                for (let i = 0, l = uuids.length; i < l; i++) {
                  const uuid = uuids[i];
                  uuids[i] = out[uuid] = decodeUuid(uuid);
                }

                uuids = out;
              }

              for (const id in paths) {
                const entry = paths[id];
                realEntries[uuids[id]] = entry;
              }

              const scenes = options.scenes;

              for (const name in scenes) {
                const uuid = scenes[name];
                scenes[name] = uuids[uuid];
              }

              const packs = options.packs;

              for (const packId in packs) {
                const packedIds = packs[packId];

                for (let j = 0; j < packedIds.length; ++j) {
                  packedIds[j] = uuids[packedIds[j]];
                }
              }

              const versions = options.versions;

              if (versions) {
                for (const folder in versions) {
                  const entries = versions[folder];

                  for (let i = 0; i < entries.length; i += 2) {
                    const uuid = entries[i];
                    entries[i] = uuids[uuid] || uuid;
                  }
                }
              }

              const redirect = options.redirect;

              if (redirect) {
                for (let i = 0; i < redirect.length; i += 2) {
                  redirect[i] = uuids[redirect[i]];
                  redirect[i + 1] = bundles[redirect[i + 1]];
                }
              }

              const extensionMap = options.extensionMap;

              if (extensionMap) {
                for (const ext in options.extensionMap) {
                  if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
                    continue;
                  }

                  options.extensionMap[ext].forEach((uuid, index) => {
                    options.extensionMap[ext][index] = uuids[uuid] || uuid;
                  });
                }
              }
            };

            class Config {
              constructor() {
                this.name = '';
                this.base = '';
                this.importBase = '';
                this.nativeBase = '';
                this.deps = null;
                this.assetInfos = new Cache();
                this.scenes = new Cache();
                this.paths = new Cache();
              }

              init(options) {
                processOptions(options);
                this.importBase = options.importBase || '';
                this.nativeBase = options.nativeBase || '';
                this.base = options.base || '';
                this.name = options.name || '';
                this.deps = options.deps || [];

                this._initUuid(options.uuids);

                this._initPath(options.paths);

                this._initScene(options.scenes);

                this._initPackage(options.packs);

                this._initVersion(options.versions);

                this._initRedirect(options.redirect);

                for (const ext in options.extensionMap) {
                  if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
                    continue;
                  }

                  options.extensionMap[ext].forEach(uuid => {
                    const assetInfo = this.assetInfos.get(uuid);

                    if (assetInfo) {
                      assetInfo.extension = ext;
                    }
                  });
                }
              }

              getInfoWithPath(path, type) {
                if (!path) {
                  return null;
                }

                path = normalize(path);
                const items = this.paths.get(path);

                if (items) {
                  if (type) {
                    for (let i = 0, l = items.length; i < l; i++) {
                      const assetInfo = items[i];

                      if (js.isChildClassOf(assetInfo.ctor, type)) {
                        return assetInfo;
                      }
                    }
                  } else {
                    return items[0];
                  }
                }

                return null;
              }

              getDirWithPath(path, type, out) {
                path = normalize(path);

                if (path[path.length - 1] === '/') {
                  path = path.slice(0, -1);
                }

                const infos = out || [];
                this.paths.forEach((items, p) => {
                  if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
                    for (let i = 0, l = items.length; i < l; i++) {
                      const entry = items[i];

                      if (!type || js.isChildClassOf(entry.ctor, type)) {
                        infos.push(entry);
                      }
                    }
                  }
                });
                return infos;
              }

              getAssetInfo(uuid) {
                return this.assetInfos.get(uuid) || null;
              }

              getSceneInfo(name) {
                if (!name.endsWith('.scene')) {
                  name += '.scene';
                }

                if (name[0] !== '/' && !name.startsWith('db://')) {
                  name = `/${name}`;
                }

                const info = this.scenes.find((val, key) => key.endsWith(name));
                return info;
              }

              destroy() {
                this.paths.destroy();
                this.scenes.destroy();
                this.assetInfos.destroy();
              }

              _initUuid(uuidList) {
                if (!uuidList) {
                  return;
                }

                this.assetInfos.clear();

                for (let i = 0, l = uuidList.length; i < l; i++) {
                  const uuid = uuidList[i];
                  this.assetInfos.add(uuid, {
                    uuid
                  });
                }
              }

              _initPath(pathList) {
                if (!pathList) {
                  return;
                }

                const paths = this.paths;
                paths.clear();

                for (const uuid in pathList) {
                  const info = pathList[uuid];
                  const path = info[0];
                  const type = info[1];
                  const isSubAsset = info.length === 3;
                  const assetInfo = this.assetInfos.get(uuid);
                  assetInfo.path = path;
                  assetInfo.ctor = js._getClassById(type);

                  if (paths.has(path)) {
                    if (isSubAsset) {
                      paths.get(path).push(assetInfo);
                    } else {
                      paths.get(path).unshift(assetInfo);
                    }
                  } else {
                    paths.add(path, [assetInfo]);
                  }
                }
              }

              _initScene(sceneList) {
                if (!sceneList) {
                  return;
                }

                const scenes = this.scenes;
                scenes.clear();
                const assetInfos = this.assetInfos;

                for (const sceneName in sceneList) {
                  const uuid = sceneList[sceneName];
                  const assetInfo = assetInfos.get(uuid);
                  assetInfo.url = sceneName;
                  scenes.add(sceneName, assetInfo);
                }
              }

              _initPackage(packageList) {
                if (!packageList) {
                  return;
                }

                const assetInfos = this.assetInfos;

                for (const packUuid in packageList) {
                  const uuids = packageList[packUuid];
                  const pack = {
                    uuid: packUuid,
                    packedUuids: uuids,
                    ext: '.json'
                  };
                  assetInfos.add(packUuid, pack);

                  for (let i = 0, l = uuids.length; i < l; i++) {
                    const uuid = uuids[i];
                    const assetInfo = assetInfos.get(uuid);
                    const assetPacks = assetInfo.packs;

                    if (assetPacks) {
                      if (l === 1) {
                        assetPacks.unshift(pack);
                      } else {
                        assetPacks.push(pack);
                      }
                    } else {
                      assetInfo.packs = [pack];
                    }
                  }
                }
              }

              _initVersion(versions) {
                if (!versions) {
                  return;
                }

                const assetInfos = this.assetInfos;
                let entries = versions.import;

                if (entries) {
                  for (let i = 0, l = entries.length; i < l; i += 2) {
                    const uuid = entries[i];
                    const assetInfo = assetInfos.get(uuid);
                    assetInfo.ver = entries[i + 1];
                  }
                }

                entries = versions.native;

                if (entries) {
                  for (let i = 0, l = entries.length; i < l; i += 2) {
                    const uuid = entries[i];
                    const assetInfo = assetInfos.get(uuid);
                    assetInfo.nativeVer = entries[i + 1];
                  }
                }
              }

              _initRedirect(redirect) {
                if (!redirect) {
                  return;
                }

                const assetInfos = this.assetInfos;

                for (let i = 0, l = redirect.length; i < l; i += 2) {
                  const uuid = redirect[i];
                  const assetInfo = assetInfos.get(uuid);
                  assetInfo.redirect = redirect[i + 1];
                }
              }

            }

            function visitAsset(asset, deps) {
              if (!asset._uuid) {
                return;
              }

              deps.push(asset._uuid);
            }

            function visitComponent(comp, deps) {
              const props = Object.getOwnPropertyNames(comp);

              for (let i = 0; i < props.length; i++) {
                const propName = props[i];

                if (propName === 'node' || propName === '__eventTargets') {
                  continue;
                }

                const value = comp[propName];

                if (typeof value === 'object' && value) {
                  if (Array.isArray(value)) {
                    for (let j = 0; j < value.length; j++) {
                      const val = value[j];

                      if (val instanceof Asset) {
                        visitAsset(val, deps);
                      }
                    }
                  } else if (!value.constructor || value.constructor === Object) {
                    const keys = Object.getOwnPropertyNames(value);

                    for (let j = 0; j < keys.length; j++) {
                      const val = value[keys[j]];

                      if (val instanceof Asset) {
                        visitAsset(val, deps);
                      }
                    }
                  } else if (value instanceof Asset) {
                    visitAsset(value, deps);
                  }
                }
              }
            }

            function visitNode(node, deps) {
              for (let i = 0; i < node._components.length; i++) {
                visitComponent(node._components[i], deps);
              }

              for (let i = 0; i < node._children.length; i++) {
                visitNode(node._children[i], deps);
              }
            }

            function descendOpRef(asset, refs, exclude, op) {
              exclude.push(asset._uuid);
              const depends = dependUtil.getDeps(asset._uuid);

              for (let i = 0, l = depends.length; i < l; i++) {
                const dependAsset = assets.get(depends[i]);

                if (!dependAsset) {
                  continue;
                }

                const uuid = dependAsset._uuid;

                if (!(uuid in refs)) {
                  refs[uuid] = dependAsset.refCount + op;
                } else {
                  refs[uuid] += op;
                }

                if (exclude.includes(uuid)) {
                  continue;
                }

                descendOpRef(dependAsset, refs, exclude, op);
              }
            }

            const _temp$r = [];

            function checkCircularReference(asset) {
              const refs = Object.create(null);
              refs[asset._uuid] = asset.refCount;
              descendOpRef(asset, refs, _temp$r, -1);
              _temp$r.length = 0;

              if (refs[asset._uuid] !== 0) {
                return refs[asset._uuid];
              }

              for (const uuid in refs) {
                if (refs[uuid] !== 0) {
                  descendOpRef(assets.get(uuid), refs, _temp$r, 1);
                }
              }

              _temp$r.length = 0;
              return refs[asset._uuid];
            }

            class ReleaseManager {
              constructor() {
                this._persistNodeDeps = new Cache();
                this._toDelete = new Cache();
                this._eventListener = false;
              }

              init() {
                this._persistNodeDeps.clear();

                this._toDelete.clear();
              }

              _addPersistNodeRef(node) {
                const deps = [];
                visitNode(node, deps);

                for (let i = 0, l = deps.length; i < l; i++) {
                  const dependAsset = assets.get(deps[i]);

                  if (dependAsset) {
                    dependAsset.addRef();
                  }
                }

                this._persistNodeDeps.add(node.uuid, deps);
              }

              _removePersistNodeRef(node) {
                if (!this._persistNodeDeps.has(node.uuid)) {
                  return;
                }

                const deps = this._persistNodeDeps.get(node.uuid);

                for (let i = 0, l = deps.length; i < l; i++) {
                  const dependAsset = assets.get(deps[i]);

                  if (dependAsset) {
                    dependAsset.decRef();
                  }
                }

                this._persistNodeDeps.remove(node.uuid);
              }

              _autoRelease(oldScene, newScene, persistNodes) {
                if (oldScene) {
                  const childs = dependUtil.getDeps(oldScene.uuid);

                  for (let i = 0, l = childs.length; i < l; i++) {
                    const asset = assets.get(childs[i]);

                    if (asset) {
                      asset.decRef( oldScene.autoReleaseAssets);
                    }
                  }

                  const dependencies = dependUtil._depends.get(oldScene.uuid);

                  if (dependencies && dependencies.persistDeps) {
                    const persistDeps = dependencies.persistDeps;

                    for (let i = 0, l = persistDeps.length; i < l; i++) {
                      const asset = assets.get(persistDeps[i]);

                      if (asset) {
                        asset.decRef( oldScene.autoReleaseAssets);
                      }
                    }
                  }

                  if (oldScene.uuid !== newScene.uuid) {
                    dependUtil.remove(oldScene.uuid);
                  }
                }

                const sceneDeps = dependUtil._depends.get(newScene.uuid);

                if (sceneDeps) {
                  sceneDeps.persistDeps = [];
                }

                for (const key in persistNodes) {
                  const node = persistNodes[key];

                  const deps = this._persistNodeDeps.get(node.uuid);

                  for (const dep of deps) {
                    const dependAsset = assets.get(dep);

                    if (dependAsset) {
                      dependAsset.addRef();
                    }
                  }

                  if (!sceneDeps) {
                    continue;
                  }

                  sceneDeps.persistDeps.push(...deps);
                }
              }

              tryRelease(asset, force = false) {
                if (!(asset instanceof Asset)) {
                  return;
                }

                if (force) {
                  this._free(asset, force);

                  return;
                }

                this._toDelete.add(asset._uuid, asset);

                if (!this._eventListener) {
                  this._eventListener = true;
                  callInNextTick(this._freeAssets.bind(this));
                }
              }

              _freeAssets() {
                this._eventListener = false;

                this._toDelete.forEach(asset => {
                  this._free(asset);
                });

                this._toDelete.clear();
              }

              _free(asset, force = false) {
                const uuid = asset._uuid;

                this._toDelete.remove(uuid);

                if (!isValid(asset, true)) {
                  return;
                }

                if (!force) {
                  if (asset.refCount > 0) {
                    if (checkCircularReference(asset) > 0) {
                      return;
                    }
                  }
                }

                assets.remove(uuid);
                const depends = dependUtil.getDeps(uuid);

                for (let i = 0, l = depends.length; i < l; i++) {
                  const dependAsset = assets.get(depends[i]);

                  if (dependAsset) {
                    dependAsset.decRef(false);

                    {
                      this._free(dependAsset, false);
                    }
                  }
                }

                {
                  asset.destroy();
                }

                dependUtil.remove(uuid);
              }

            }

            var releaseManager = new ReleaseManager();

            let defaultProgressCallback = null;
            function setDefaultProgressCallback(onProgress) {
              defaultProgressCallback = onProgress;
            }
            function clear$1(task, clearRef) {
              for (let i = 0, l = task.input.length; i < l; i++) {
                const item = task.input[i];

                if (clearRef) {
                  if (!item.isNative && item.content instanceof Asset) {
                    item.content.decRef(false);
                  }
                }

                item.recycle();
              }

              task.input = null;
            }
            function urlAppendTimestamp(url, append) {
              if (append) {
                if (/\?/.test(url)) {
                  return `${url}&_t=${Date.now()}`;
                }

                return `${url}?_t=${Date.now()}`;
              }

              return url;
            }
            function retry(process, times, wait, onComplete, index = 0) {
              process(index, (err, result) => {
                index++;

                if (!err || index > times) {
                  if (onComplete) {
                    onComplete(err, result);
                  }
                } else {
                  setTimeout(() => {
                    retry(process, times, wait, onComplete, index);
                  }, wait);
                }
              });
            }
            function getDepends(uuid, data, exclude, depends, config) {
              try {
                const info = dependUtil.parse(uuid, data);

                for (let i = 0, l = info.deps.length; i < l; i++) {
                  const dep = info.deps[i];

                  if (!(dep in exclude)) {
                    exclude[dep] = true;
                    depends.push({
                      uuid: dep,
                      bundle: config && config.name
                    });
                  }
                }

                if (info.nativeDep) {
                  if (config) {
                    info.nativeDep.bundle = config.name;
                  }

                  depends.push({ ...info.nativeDep
                  });
                }
              } catch (e) {
                error(e.message, e.stack);
              }
            }
            function cache(id, asset, cacheAsset) {
              if (!asset) {
                return;
              }

              cacheAsset = cacheAsset !== undefined ? cacheAsset : legacyCC.assetManager.cacheAsset;

              if (!isScene(asset) && cacheAsset && !asset.isDefault) {
                assets.add(id, asset);
              }
            }
            function setProperties(uuid, asset, assetsMap) {
              let missingAsset = false;
              const depends = dependMap.get(asset);

              if (depends) {

                for (let i = 0, l = depends.length; i < l; i++) {
                  const depend = depends[i];
                  const dependAsset = assetsMap[`${depend.uuid}@import`];

                  if (!dependAsset) {
                    {
                      error(`The asset ${depend.uuid} is missing!`);
                    }

                    if (depend.type && depend.type !== Asset) {
                      const placeHolder = new depend.type();
                      placeHolder.initDefault(depend.uuid);
                      depend.owner[depend.prop] = placeHolder;
                    }

                    missingAsset = true;
                  } else {
                    depend.owner[depend.prop] = dependAsset.addRef();
                  }
                }

                dependMap.delete(asset);
              }

              if (nativeDependMap.has(asset)) {
                if (assetsMap[`${uuid}@native`]) {
                  asset._nativeAsset = assetsMap[`${uuid}@native`];
                } else {
                  missingAsset = true;
                  console.error(`the native asset of ${uuid} is missing!`);
                }

                nativeDependMap.delete(asset);
              }

              return missingAsset;
            }
            function gatherAsset(task) {
              const source = task.source;

              if (!task.options.__outputAsArray__ && source.length === 1) {
                task.output = source[0].content;
              } else {
                const output = task.output = [];

                for (let i = 0, l = source.length; i < l; i++) {
                  output.push(source[i].content);
                }
              }
            }
            function forEach(array, process, onComplete) {
              let count = 0;
              const errs = [];
              const length = array.length;

              if (length === 0 && onComplete) {
                onComplete(errs);
              }

              const cb = err => {
                if (err) {
                  errs.push(err);
                }

                count++;

                if (count === length) {
                  if (onComplete) {
                    onComplete(errs);
                  }
                }
              };

              for (let i = 0; i < length; i++) {
                process(array[i], cb);
              }
            }
            function parseParameters(options, onProgress, onComplete) {
              let optionsOut = options;
              let onProgressOut = onProgress;
              let onCompleteOut = onComplete;

              if (onComplete === undefined) {
                const isCallback = typeof options === 'function';

                if (onProgress) {
                  onCompleteOut = onProgress;

                  if (!isCallback) {
                    onProgressOut = null;
                  }
                } else if (onProgress === undefined && isCallback) {
                  onCompleteOut = options;
                  optionsOut = null;
                  onProgressOut = null;
                }

                if (onProgress !== undefined && isCallback) {
                  onProgressOut = options;
                  optionsOut = null;
                }
              }

              return {
                options: optionsOut || Object.create(null),
                onProgress: onProgressOut,
                onComplete: onCompleteOut
              };
            }
            function parseLoadResArgs(type, onProgress, onComplete) {
              let typeOut = type;
              let onProgressOut = onProgress;
              let onCompleteOut = onComplete;

              if (onComplete === undefined) {
                const isValidType = js.isChildClassOf(type, Asset);

                if (onProgress) {
                  onCompleteOut = onProgress;

                  if (isValidType) {
                    onProgressOut = null;
                  }
                } else if (onProgress === undefined && !isValidType) {
                  onCompleteOut = type;
                  onProgressOut = null;
                  typeOut = null;
                }

                if (onProgress !== undefined && !isValidType) {
                  onProgressOut = type;
                  typeOut = null;
                }
              }

              return {
                type: typeOut,
                onProgress: onProgressOut || defaultProgressCallback,
                onComplete: onCompleteOut
              };
            }
            function checkCircleReference(owner, uuid, map, checked = {}) {
              const item = map[uuid];

              if (!item || checked[uuid]) {
                return false;
              }

              checked[uuid] = true;
              let result = false;
              const deps = dependUtil.getDeps(uuid);

              if (deps) {
                for (let i = 0, l = deps.length; i < l; i++) {
                  const dep = deps[i];

                  if (dep === owner || checkCircleReference(owner, dep, map, checked)) {
                    result = true;
                    break;
                  }
                }
              }

              return result;
            }
            function asyncify(cb) {
              return (p1, p2) => {
                if (!cb) {
                  return;
                }

                const refs = [];

                if (Array.isArray(p2)) {
                  p2.forEach(x => x instanceof Asset && refs.push(x.addRef()));
                } else if (p2 instanceof Asset) {
                  refs.push(p2.addRef());
                }

                callInNextTick(() => {
                  refs.forEach(x => x.decRef(false));
                  cb(p1, p2);
                });
              };
            }

            class Bundle {
              constructor() {
                this._config = new Config();
              }

              get config() {
                return this._config;
              }

              get name() {
                return this._config.name;
              }

              get deps() {
                return this._config.deps;
              }

              get base() {
                return this._config.base;
              }

              getInfoWithPath(path, type) {
                return this._config.getInfoWithPath(path, type);
              }

              getDirWithPath(path, type, out) {
                return this._config.getDirWithPath(path, type, out);
              }

              getAssetInfo(uuid) {
                return this._config.getAssetInfo(uuid);
              }

              getSceneInfo(name) {
                return this._config.getSceneInfo(name);
              }

              init(options) {
                this._config.init(options);

                bundles.add(options.name, this);
              }

              load(paths, type, onProgress, onComplete) {
                const {
                  type: _type,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseLoadResArgs(type, onProgress, onComplete);
                const options = {
                  __requestType__: RequestType.PATH,
                  type: _type,
                  bundle: this.name,
                  __outputAsArray__: Array.isArray(paths)
                };
                legacyCC.assetManager.loadAny(paths, options, onProg, onComp);
              }

              preload(paths, type, onProgress, onComplete) {
                const {
                  type: _type,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseLoadResArgs(type, onProgress, onComplete);
                legacyCC.assetManager.preloadAny(paths, {
                  __requestType__: RequestType.PATH,
                  type: _type,
                  bundle: this.name
                }, onProg, onComp);
              }

              loadDir(dir, type, onProgress, onComplete) {
                const {
                  type: _type,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseLoadResArgs(type, onProgress, onComplete);
                legacyCC.assetManager.loadAny(dir, {
                  __requestType__: RequestType.DIR,
                  type: _type,
                  bundle: this.name,
                  __outputAsArray__: true
                }, onProg, onComp);
              }

              preloadDir(dir, type, onProgress, onComplete) {
                const {
                  type: _type,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseLoadResArgs(type, onProgress, onComplete);
                legacyCC.assetManager.preloadAny(dir, {
                  __requestType__: RequestType.DIR,
                  type: _type,
                  bundle: this.name
                }, onProg, onComp);
              }

              loadScene(sceneName, options, onProgress, onComplete) {
                const {
                  options: opts,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseParameters(options, onProgress, onComplete);
                opts.preset = opts.preset || 'scene';
                opts.bundle = this.name;
                legacyCC.assetManager.loadAny({
                  scene: sceneName
                }, opts, onProg, (err, sceneAsset) => {
                  if (err) {
                    error(err.message, err.stack);
                  } else if (sceneAsset instanceof SceneAsset && sceneAsset.scene) {
                    const scene = sceneAsset.scene;
                    scene._id = sceneAsset._uuid;
                    scene.name = sceneAsset.name;
                  } else {
                    err = new Error(`The asset ${sceneAsset._uuid} is not a scene`);
                  }

                  if (onComp) {
                    onComp(err, sceneAsset);
                  }
                });
              }

              preloadScene(sceneName, options, onProgress, onComplete) {
                const {
                  options: opts,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseParameters(options, onProgress, onComplete);
                opts.bundle = this.name;
                legacyCC.assetManager.preloadAny({
                  scene: sceneName
                }, opts, onProg, err => {
                  if (err) {
                    errorID(1210, sceneName, err.message);
                  }

                  if (onComp) {
                    onComp(err);
                  }
                });
              }

              get(path, type) {
                const info = this.getInfoWithPath(path, type);

                if (info) {
                  return assets.get(info.uuid) || null;
                }

                return null;
              }

              release(path, type) {
                const asset = this.get(path, type);

                if (asset) {
                  releaseManager.tryRelease(asset, true);
                }
              }

              releaseUnusedAssets() {
                assets.forEach(asset => {
                  const info = this.getAssetInfo(asset._uuid);

                  if (info && !info.redirect) {
                    releaseManager.tryRelease(asset);
                  }
                });
              }

              releaseAll() {
                assets.forEach(asset => {
                  const info = this.getAssetInfo(asset._uuid);

                  if (info && !info.redirect) {
                    releaseManager.tryRelease(asset, true);
                  }
                });
              }

              _destroy() {
                this._config.destroy();
              }

            }
            const resources = exports('fH', new Bundle());
            legacyCC.resources = resources;

            function downloadDomImage(url, options, onComplete) {
              const img = new Image();

              if (window.location.protocol !== 'file:') {
                img.crossOrigin = 'anonymous';
              }

              function loadCallback() {
                img.removeEventListener('load', loadCallback);
                img.removeEventListener('error', errorCallback);

                if (onComplete) {
                  onComplete(null, img);
                }
              }

              function errorCallback() {
                img.removeEventListener('load', loadCallback);
                img.removeEventListener('error', errorCallback);

                if (onComplete) {
                  onComplete(new Error(getError(4930, url)));
                }
              }

              img.addEventListener('load', loadCallback);
              img.addEventListener('error', errorCallback);
              img.src = url;
              return img;
            }

            function downloadFile(url, options, onProgress, onComplete) {
              const xhr = new XMLHttpRequest();
              const errInfo = `download failed: ${url}, status: `;
              xhr.open('GET', url, true);

              if (options.xhrResponseType !== undefined) {
                xhr.responseType = options.xhrResponseType;
              }

              if (options.xhrWithCredentials !== undefined) {
                xhr.withCredentials = options.xhrWithCredentials;
              }

              if (options.xhrMimeType !== undefined && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.xhrMimeType);
              }

              if (options.xhrTimeout !== undefined) {
                xhr.timeout = options.xhrTimeout;
              }

              if (options.xhrHeader) {
                for (const header in options.xhrHeader) {
                  xhr.setRequestHeader(header, options.xhrHeader[header]);
                }
              }

              xhr.onload = () => {
                if (xhr.status === 200 || xhr.status === 0) {
                  if (onComplete) {
                    onComplete(null, xhr.response);
                  }
                } else if (onComplete) {
                  onComplete(new Error(`${errInfo}${xhr.status}(no response)`));
                }
              };

              if (onProgress) {
                xhr.onprogress = e => {
                  if (e.lengthComputable) {
                    onProgress(e.loaded, e.total);
                  }
                };
              }

              xhr.onerror = () => {
                if (onComplete) {
                  onComplete(new Error(`${errInfo}${xhr.status}(error)`));
                }
              };

              xhr.ontimeout = () => {
                if (onComplete) {
                  onComplete(new Error(`${errInfo}${xhr.status}(time out)`));
                }
              };

              xhr.onabort = () => {
                if (onComplete) {
                  onComplete(new Error(`${errInfo}${xhr.status}(abort)`));
                }
              };

              xhr.send(null);
              return xhr;
            }

            const downloaded = {};
            function downloadScript(url, options, onComplete) {
              if (downloaded[url]) {
                if (onComplete) {
                  onComplete(null);
                }

                return null;
              }

              const script = document.createElement('script');

              if (window.location.protocol !== 'file:') {
                script.crossOrigin = 'anonymous';
              }

              script.async = options.scriptAsyncLoading || false;
              script.src = url;

              function loadHandler() {
                script.parentNode.removeChild(script);
                script.removeEventListener('load', loadHandler, false);
                script.removeEventListener('error', errorHandler, false);
                downloaded[url] = true;

                if (onComplete) {
                  onComplete(null);
                }
              }

              function errorHandler() {
                script.parentNode.removeChild(script);
                script.removeEventListener('load', loadHandler, false);
                script.removeEventListener('error', errorHandler, false);

                if (onComplete) {
                  onComplete(new Error(getError(4928, url)));
                }
              }

              script.addEventListener('load', loadHandler, false);
              script.addEventListener('error', errorHandler, false);
              document.body.appendChild(script);
              return script;
            }

            const REGEX = /^(?:\w+:\/\/|\.+\/).+/;

            const downloadImage = (url, options, onComplete) => {
              const func = sys.capabilities.imageBitmap && legacyCC.assetManager.allowImageBitmap ? downloadBlob : downloadDomImage;
              func(url, options, onComplete);
            };

            const downloadBlob = (url, options, onComplete) => {
              options.xhrResponseType = 'blob';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };

            const downloadJson = (url, options, onComplete) => {
              options.xhrResponseType = 'json';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };

            const downloadArrayBuffer = (url, options, onComplete) => {
              options.xhrResponseType = 'arraybuffer';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };

            const downloadCCON = (url, options, onComplete) => {
              downloadJson(url, options, (err, json) => {
                if (err) {
                  onComplete(err);
                  return;
                }

                const cconPreface = parseCCONJson(json);
                const chunkPromises = Promise.all(cconPreface.chunks.map(chunk => new Promise((resolve, reject) => {
                  downloadArrayBuffer(`${mainFileName(url)}${chunk}`, {}, (errChunk, chunkBuffer) => {
                    if (err) {
                      reject(err);
                    } else {
                      resolve(new Uint8Array(chunkBuffer));
                    }
                  });
                })));
                chunkPromises.then(chunks => {
                  const ccon = new CCON(cconPreface.document, chunks);
                  onComplete(null, ccon);
                }).catch(err => {
                  onComplete(err);
                });
              });
            };

            const downloadCCONB = (url, options, onComplete) => {
              downloadArrayBuffer(url, options, (err, arrayBuffer) => {
                if (err) {
                  onComplete(err);
                  return;
                }

                try {
                  const ccon = decodeCCONBinary(new Uint8Array(arrayBuffer));
                  onComplete(null, ccon);
                } catch (err) {
                  onComplete(err);
                }
              });
            };

            const downloadText = (url, options, onComplete) => {
              options.xhrResponseType = 'text';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };

            const downloadBundle = (nameOrUrl, options, onComplete) => {
              const bundleName = basename(nameOrUrl);
              let url = nameOrUrl;

              if (!REGEX.test(url)) {
                if (downloader.remoteBundles.indexOf(bundleName) !== -1) {
                  url = `${downloader.remoteServerAddress}remote/${bundleName}`;
                } else {
                  url = `assets/${bundleName}`;
                }
              }

              const version = options.version || downloader.bundleVers[bundleName];
              let count = 0;
              const config = `${url}/config.${version ? `${version}.` : ''}json`;
              let out = null;
              let error = null;
              downloadJson(config, options, (err, response) => {
                error = err;
                out = response;

                if (out) {
                  out.base = `${url}/`;
                }

                if (++count === 2) {
                  onComplete(error, out);
                }
              });
              const jspath = `${url}/index.${version ? `${version}.` : ''}js`;
              downloadScript(jspath, options, err => {
                error = err;

                if (++count === 2) {
                  onComplete(err, out);
                }
              });
            };

            class Downloader {
              constructor() {
                this.maxConcurrency = 6;
                this.maxRequestsPerFrame = 6;
                this.maxRetryCount =  3 ;
                this.appendTimeStamp = !!EDITOR;
                this.limited = !EDITOR;
                this.retryInterval = 2000;
                this.bundleVers = null;
                this.remoteBundles = [];
                this.downloadDomImage = downloadDomImage;
                this.downloadDomAudio = null;
                this.downloadFile = downloadFile;
                this.downloadScript = downloadScript;
                this._downloaders = {
                  '.png': downloadImage,
                  '.jpg': downloadImage,
                  '.bmp': downloadImage,
                  '.jpeg': downloadImage,
                  '.gif': downloadImage,
                  '.ico': downloadImage,
                  '.tiff': downloadImage,
                  '.webp': downloadImage,
                  '.image': downloadImage,
                  '.pvr': downloadArrayBuffer,
                  '.pkm': downloadArrayBuffer,
                  '.astc': downloadArrayBuffer,
                  '.txt': downloadText,
                  '.xml': downloadText,
                  '.vsh': downloadText,
                  '.fsh': downloadText,
                  '.atlas': downloadText,
                  '.tmx': downloadText,
                  '.tsx': downloadText,
                  '.json': downloadJson,
                  '.ExportJson': downloadJson,
                  '.plist': downloadText,
                  '.ccon': downloadCCON,
                  '.cconb': downloadCCONB,
                  '.fnt': downloadText,
                  '.binary': downloadArrayBuffer,
                  '.bin': downloadArrayBuffer,
                  '.dbbin': downloadArrayBuffer,
                  '.skel': downloadArrayBuffer,
                  '.js': downloadScript,
                  bundle: downloadBundle,
                  default: downloadText
                };
                this._downloading = new Cache();
                this._queue = [];
                this._queueDirty = false;
                this._totalNum = 0;
                this._totalNumThisPeriod = 0;
                this._lastDate = -1;
                this._checkNextPeriod = false;
                this._remoteServerAddress = '';
                this._maxInterval = 1 / 30;
              }

              get remoteServerAddress() {
                return this._remoteServerAddress;
              }

              init(remoteServerAddress = '', bundleVers = {}, remoteBundles = []) {
                this._downloading.clear();

                this._queue.length = 0;
                this._remoteServerAddress = remoteServerAddress;
                this.bundleVers = bundleVers;
                this.remoteBundles = remoteBundles;
              }

              register(type, handler) {
                if (typeof type === 'object') {
                  mixin(this._downloaders, type);
                } else {
                  this._downloaders[type] = handler;
                }
              }

              download(id, url, type, options, onComplete) {
                const file = files.get(id);

                if (file) {
                  onComplete(null, file);
                  return;
                }

                const downloadCallbacks = this._downloading.get(id);

                if (downloadCallbacks) {
                  downloadCallbacks.push(onComplete);

                  const request = this._queue.find(x => x.id === id);

                  if (!request) {
                    return;
                  }

                  const priority = options.priority || 0;

                  if (request.priority < priority) {
                    request.priority = priority;
                    this._queueDirty = true;
                  }

                  return;
                }

                const maxRetryCount = typeof options.maxRetryCount !== 'undefined' ? options.maxRetryCount : this.maxRetryCount;
                const maxConcurrency = typeof options.maxConcurrency !== 'undefined' ? options.maxConcurrency : this.maxConcurrency;
                const maxRequestsPerFrame = typeof options.maxRequestsPerFrame !== 'undefined' ? options.maxRequestsPerFrame : this.maxRequestsPerFrame;
                const handler = this._downloaders[type] || this._downloaders.default;

                const process = (index, callback) => {
                  if (index === 0) {
                    this._downloading.add(id, [onComplete]);
                  }

                  if (!this.limited) {
                    handler(urlAppendTimestamp(url, this.appendTimeStamp), options, callback);
                    return;
                  }

                  this._updateTime();

                  const done = (err, data) => {
                    this._totalNum--;

                    this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);

                    callback(err, data);
                  };

                  if (this._totalNum < maxConcurrency && this._totalNumThisPeriod < maxRequestsPerFrame) {
                    handler(urlAppendTimestamp(url, this.appendTimeStamp), options, done);
                    this._totalNum++;
                    this._totalNumThisPeriod++;
                  } else {
                    this._queue.push({
                      id,
                      priority: options.priority || 0,
                      url,
                      options,
                      done,
                      handler
                    });

                    this._queueDirty = true;

                    if (this._totalNum < maxConcurrency) {
                      this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
                    }
                  }
                };

                const finale = (err, result) => {
                  if (!err) {
                    files.add(id, result);
                  }

                  const callbacks = this._downloading.remove(id);

                  for (let i = 0, l = callbacks.length; i < l; i++) {
                    callbacks[i](err, result);
                  }
                };

                retry(process, maxRetryCount, this.retryInterval, finale);
              }

              loadSubpackage(name, completeCallback) {
                legacyCC.assetManager.loadBundle(name, null, completeCallback);
              }

              _updateTime() {
                const now = performance.now();
                const deltaTime = legacyCC.game.deltaTime;
                const interval = deltaTime > this._maxInterval ? this._maxInterval : deltaTime;

                if (now - this._lastDate > interval * 1000) {
                  this._totalNumThisPeriod = 0;
                  this._lastDate = now;
                }
              }

              _handleQueue(maxConcurrency, maxRequestsPerFrame) {
                this._checkNextPeriod = false;

                this._updateTime();

                while (this._queue.length > 0 && this._totalNum < maxConcurrency && this._totalNumThisPeriod < maxRequestsPerFrame) {
                  if (this._queueDirty) {
                    this._queue.sort((a, b) => a.priority - b.priority);

                    this._queueDirty = false;
                  }

                  const request = this._queue.pop();

                  if (!request) {
                    break;
                  }

                  this._totalNum++;
                  this._totalNumThisPeriod++;
                  request.handler(urlAppendTimestamp(request.url, this.appendTimeStamp), request.options, request.done);
                }

                this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
              }

              _handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame) {
                if (!this._checkNextPeriod && this._queue.length > 0) {
                  callInNextTick(this._handleQueue.bind(this), maxConcurrency, maxRequestsPerFrame);
                  this._checkNextPeriod = true;
                }
              }

            }
            const downloader = exports('dh', new Downloader());

            function createImageAsset(id, data, options, onComplete) {
              let out = null;
              let err = null;

              try {
                out = new ImageAsset();
                out._nativeUrl = id;
                out._nativeAsset = data;
              } catch (e) {
                err = e;
              }

              onComplete(err, out);
            }

            function createJsonAsset(id, data, options, onComplete) {
              const out = new JsonAsset();
              out.json = data;
              onComplete(null, out);
            }

            function createTextAsset(id, data, options, onComplete) {
              const out = new TextAsset();
              out.text = data;
              onComplete(null, out);
            }

            function createBufferAsset(id, data, options, onComplete) {
              const out = new BufferAsset();
              out._nativeUrl = id;
              out._nativeAsset = data;
              onComplete(null, out);
            }

            function createAsset(id, data, options, onComplete) {
              const out = new Asset();
              out._nativeUrl = id;
              out._nativeAsset = data;
              onComplete(null, out);
            }

            function createBundle(id, data, options, onComplete) {
              let bundle = bundles.get(data.name);

              if (!bundle) {
                bundle = data.name === BuiltinBundleName.RESOURCES ? resources : new Bundle();
                data.base = data.base || `${id}/`;
                bundle.init(data);
              }

              module.import(`virtual:///prerequisite-imports/${bundle.name}`).then(() => {
                onComplete(null, bundle);
              }).catch(onComplete);
            }

            class Factory {
              constructor() {
                this._creating = new Cache();
                this._producers = {
                  '.png': createImageAsset,
                  '.jpg': createImageAsset,
                  '.bmp': createImageAsset,
                  '.jpeg': createImageAsset,
                  '.gif': createImageAsset,
                  '.ico': createImageAsset,
                  '.tiff': createImageAsset,
                  '.webp': createImageAsset,
                  '.image': createImageAsset,
                  '.pvr': createImageAsset,
                  '.pkm': createImageAsset,
                  '.txt': createTextAsset,
                  '.xml': createTextAsset,
                  '.vsh': createTextAsset,
                  '.fsh': createTextAsset,
                  '.atlas': createTextAsset,
                  '.tmx': createTextAsset,
                  '.tsx': createTextAsset,
                  '.fnt': createTextAsset,
                  '.json': createJsonAsset,
                  '.ExportJson': createJsonAsset,
                  '.binary': createBufferAsset,
                  '.bin': createBufferAsset,
                  '.dbbin': createBufferAsset,
                  '.skel': createBufferAsset,
                  bundle: createBundle,
                  default: createAsset
                };
              }

              register(type, handler) {
                if (typeof type === 'object') {
                  js.mixin(this._producers, type);
                } else {
                  this._producers[type] = handler;
                }
              }

              create(id, data, type, options, onComplete) {
                const handler = this._producers[type] || this._producers.default;
                const asset = assets.get(id);

                if (!options.reloadAsset && asset) {
                  onComplete(null, asset);
                  return;
                }

                const creating = this._creating.get(id);

                if (creating) {
                  creating.push(onComplete);
                  return;
                }

                this._creating.add(id, [onComplete]);

                handler(id, data, options, (err, result) => {
                  if (!err && result instanceof Asset) {
                    result._uuid = id;
                    cache(id, result, options.cacheAsset);
                  }

                  const callbacks = this._creating.remove(id);

                  for (let i = 0, l = callbacks.length; i < l; i++) {
                    callbacks[i](err, result);
                  }
                });
              }

            }
            var factory = exports('di', new Factory());

            class PackManager {
              constructor() {
                this._loading = new Cache();
                this._unpackers = {
                  '.json': this.unpackJson
                };
              }

              unpackJson(pack, json, options, onComplete) {
                let out = js.createMap(true);
                let err = null;

                if (Array.isArray(json)) {
                  json = unpackJSONs(json);

                  if (json.length !== pack.length) {
                    errorID(4915);
                  }

                  for (let i = 0; i < pack.length; i++) {
                    out[`${pack[i]}@import`] = json[i];
                  }
                } else {
                  const textureType = js._getClassId(Texture2D);

                  const imageAssetType = js._getClassId(ImageAsset);

                  if (json.type === textureType && json.data) {
                    const datas = json.data;

                    if (datas.length !== pack.length) {
                      errorID(4915);
                    }

                    for (let i = 0; i < pack.length; i++) {
                      out[`${pack[i]}@import`] = packCustomObjData(textureType, {
                        base: datas[i][0],
                        mipmaps: datas[i][1]
                      });
                    }
                  } else if (json.type === imageAssetType && json.data) {
                    const datas = json.data;

                    if (datas.length !== pack.length) {
                      errorID(4915);
                    }

                    for (let i = 0; i < pack.length; i++) {
                      out[`${pack[i]}@import`] = datas[i];
                    }
                  } else {
                    err = new Error('unmatched type pack!');
                    out = null;
                  }
                }

                onComplete(err, out);
              }

              init() {
                this._loading.clear();
              }

              register(type, handler) {
                if (typeof type === 'object') {
                  js.mixin(this._unpackers, type);
                } else {
                  this._unpackers[type] = handler;
                }
              }

              unpack(pack, data, type, options, onComplete) {
                if (!data) {
                  onComplete(new Error('package data is wrong!'));
                  return;
                }

                const unpacker = this._unpackers[type];
                unpacker(pack, data, options, onComplete);
              }

              load(item, options, onComplete) {
                if (item.isNative || !item.info || !item.info.packs) {
                  downloader.download(item.id, item.url, item.ext, item.options, onComplete);
                  return;
                }

                if (files.has(item.id)) {
                  onComplete(null, files.get(item.id));
                  return;
                }

                const packs = item.info.packs;
                let pack = packs.find(val => this._loading.has(val.uuid));

                if (pack) {
                  this._loading.get(pack.uuid).push({
                    onComplete,
                    id: item.id
                  });

                  return;
                }

                pack = packs[0];

                this._loading.add(pack.uuid, [{
                  onComplete,
                  id: item.id
                }]);

                const url = transform(pack.uuid, {
                  ext: pack.ext,
                  bundle: item.config.name
                });
                downloader.download(pack.uuid, url, pack.ext, item.options, (err, data) => {
                  files.remove(pack.uuid);

                  if (err) {
                    error(err.message, err.stack);
                  }

                  this.unpack(pack.packedUuids, data, pack.ext, item.options, (err2, result) => {
                    if (!err2) {
                      for (const id in result) {
                        files.add(id, result[id]);
                      }
                    }

                    const callbacks = this._loading.remove(pack.uuid);

                    for (let i = 0, l = callbacks.length; i < l; i++) {
                      const cb = callbacks[i];

                      if (err || err2) {
                        cb.onComplete(err || err2);
                        continue;
                      }

                      const unpackedData = result[cb.id];

                      if (!unpackedData) {
                        cb.onComplete(new Error('can not retrieve data from package'));
                      } else {
                        cb.onComplete(null, unpackedData);
                      }
                    }
                  });
                });
              }

            }
            var packManager = new PackManager();

            function fetch$1(task, done) {
              let firstTask = false;

              if (!task.progress) {
                task.progress = {
                  finish: 0,
                  total: task.input.length,
                  canInvoke: true
                };
                firstTask = true;
              }

              const {
                options,
                progress
              } = task;
              const depends = [];
              const total = progress.total;
              const exclude = options.__exclude__ = options.__exclude__ || Object.create(null);
              task.output = [];
              forEach(task.input, (item, cb) => {
                if (!item.isNative && assets.has(item.uuid)) {
                  const asset = assets.get(item.uuid);
                  item.content = asset.addRef();
                  task.output.push(item);

                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }

                  cb();
                  return;
                }

                packManager.load(item, task.options, (err, data) => {
                  if (err) {
                    if (!task.isFinish) {
                      if (!legacyCC.assetManager.force || firstTask) {
                        error(err.message, err.stack);
                        progress.canInvoke = false;
                        done(err);
                      } else {
                        task.output.push(item);

                        if (progress.canInvoke) {
                          task.dispatch('progress', ++progress.finish, progress.total, item);
                        }
                      }
                    }
                  } else if (!task.isFinish) {
                    item.file = data;
                    task.output.push(item);

                    if (!item.isNative) {
                      exclude[item.uuid] = true;
                      getDepends(item.uuid, data, exclude, depends, item.config);
                      progress.total = total + depends.length;
                    }

                    if (progress.canInvoke) {
                      task.dispatch('progress', ++progress.finish, progress.total, item);
                    }
                  }

                  cb();
                });
              }, () => {
                if (task.isFinish) {
                  clear$1(task, true);
                  task.dispatch('error');
                  return;
                }

                if (depends.length > 0) {
                  const subTask = Task.create({
                    input: depends,
                    progress,
                    options,
                    onProgress: task.onProgress,
                    onError: Task.prototype.recycle,
                    onComplete: err => {
                      if (!err) {
                        task.output.push(...subTask.output);
                        subTask.recycle();
                      }

                      if (firstTask) {
                        decreaseRef(task);
                      }

                      done(err);
                    }
                  });
                  fetchPipeline.async(subTask);
                  return;
                }

                if (firstTask) {
                  decreaseRef(task);
                }

                done();
              });
            }

            function decreaseRef(task) {
              const output = task.output;

              for (let i = 0, l = output.length; i < l; i++) {
                if (output[i].content) {
                  output[i].content.decRef(false);
                }
              }
            }

            class SAXParser {
              constructor() {
                this._parser = null;

                if (window.DOMParser) {
                  this._parser = new DOMParser();
                }
              }

              parse(xmlTxt) {
                return this._parseXML(xmlTxt);
              }

              _parseXML(textxml) {
                if (this._parser) {
                  return this._parser.parseFromString(textxml, 'text/xml');
                }

                throw new Error('Dom parser is not supported in this platform!');
              }

            } exports('en', SAXParser);

            class PlistParser extends SAXParser {
              parse(xmlTxt) {
                const xmlDoc = this._parseXML(xmlTxt);

                const plist = xmlDoc.documentElement;

                if (plist.tagName !== 'plist') {
                  warnID(5100);
                  return {};
                }

                let node = null;

                for (let i = 0, len = plist.childNodes.length; i < len; i++) {
                  node = plist.childNodes[i];

                  if (node.nodeType === 1) {
                    break;
                  }
                }

                return this._parseNode(node);
              }

              _parseNode(node) {
                let data = null;
                const tagName = node.tagName;

                if (tagName === 'dict') {
                  data = this._parseDict(node);
                } else if (tagName === 'array') {
                  data = this._parseArray(node);
                } else if (tagName === 'string') {
                  if (node.childNodes.length === 1) {
                    data = node.firstChild.nodeValue;
                  } else {
                    data = '';

                    for (let i = 0; i < node.childNodes.length; i++) {
                      data += node.childNodes[i].nodeValue;
                    }
                  }
                } else if (tagName === 'false') {
                  data = false;
                } else if (tagName === 'true') {
                  data = true;
                } else if (tagName === 'real') {
                  data = parseFloat(node.firstChild.nodeValue);
                } else if (tagName === 'integer') {
                  data = parseInt(node.firstChild.nodeValue, 10);
                }

                return data;
              }

              _parseArray(node) {
                const data = [];

                for (let i = 0, len = node.childNodes.length; i < len; i++) {
                  const child = node.childNodes[i];

                  if (child.nodeType !== 1) {
                    continue;
                  }

                  data.push(this._parseNode(child));
                }

                return data;
              }

              _parseDict(node) {
                const data = {};
                let key = '';

                for (let i = 0, len = node.childNodes.length; i < len; i++) {
                  const child = node.childNodes[i];

                  if (child.nodeType !== 1) {
                    continue;
                  }

                  if (child.tagName === 'key') {
                    key = child.firstChild.nodeValue;
                  } else {
                    data[key] = this._parseNode(child);
                  }
                }

                return data;
              }

            }

            const plistParser = new PlistParser();

            const PVR_HEADER_LENGTH = 13;
            const PVR_MAGIC = 0x03525650;
            const PVR_HEADER_MAGIC = 0;
            const PVR_HEADER_HEIGHT = 6;
            const PVR_HEADER_WIDTH = 7;
            const PVR_HEADER_METADATA = 12;
            const ETC_PKM_HEADER_SIZE = 16;
            const ETC_PKM_FORMAT_OFFSET = 6;
            const ETC_PKM_ENCODED_WIDTH_OFFSET = 8;
            const ETC_PKM_ENCODED_HEIGHT_OFFSET = 10;
            const ETC_PKM_WIDTH_OFFSET = 12;
            const ETC_PKM_HEIGHT_OFFSET = 14;
            const ETC1_RGB_NO_MIPMAPS = 0;
            const ETC2_RGB_NO_MIPMAPS = 1;
            const ETC2_RGBA_NO_MIPMAPS = 3;
            const ASTC_MAGIC = 0x5CA1AB13;
            const ASTC_HEADER_LENGTH = 16;
            const ASTC_HEADER_MAGIC = 4;
            const ASTC_HEADER_SIZE_X_BEGIN = 7;
            const ASTC_HEADER_SIZE_Y_BEGIN = 10;
            const ASTC_HEADER_SIZE_Z_BEGIN = 13;

            function getASTCFormat(xdim, ydim) {
              if (xdim === 4) {
                return PixelFormat.RGBA_ASTC_4x4;
              }

              if (xdim === 5) {
                if (ydim === 4) {
                  return PixelFormat.RGBA_ASTC_5x4;
                }

                return PixelFormat.RGBA_ASTC_5x5;
              }

              if (xdim === 6) {
                if (ydim === 5) {
                  return PixelFormat.RGBA_ASTC_6x5;
                }

                return PixelFormat.RGBA_ASTC_6x6;
              }

              if (xdim === 8) {
                if (ydim === 5) {
                  return PixelFormat.RGBA_ASTC_8x5;
                }

                if (ydim === 6) {
                  return PixelFormat.RGBA_ASTC_8x6;
                }

                return PixelFormat.RGBA_ASTC_8x8;
              }

              if (xdim === 10) {
                if (ydim === 5) {
                  return PixelFormat.RGBA_ASTC_10x5;
                }

                if (ydim === 6) {
                  return PixelFormat.RGBA_ASTC_10x6;
                }

                if (ydim === 8) {
                  return PixelFormat.RGBA_ASTC_10x8;
                }

                return PixelFormat.RGBA_ASTC_10x10;
              }

              if (ydim === 10) {
                return PixelFormat.RGBA_ASTC_12x10;
              }

              return PixelFormat.RGBA_ASTC_12x12;
            }

            function readBEUint16(header, offset) {
              return header[offset] << 8 | header[offset + 1];
            }

            class Parser$1 {
              constructor() {
                this._parsing = new Cache();
                this._parsers = {
                  '.png': this.parseImage,
                  '.jpg': this.parseImage,
                  '.bmp': this.parseImage,
                  '.jpeg': this.parseImage,
                  '.gif': this.parseImage,
                  '.ico': this.parseImage,
                  '.tiff': this.parseImage,
                  '.webp': this.parseImage,
                  '.image': this.parseImage,
                  '.pvr': this.parsePVRTex,
                  '.pkm': this.parsePKMTex,
                  '.astc': this.parseASTCTex,
                  '.plist': this.parsePlist,
                  import: this.parseImport,
                  '.ccon': this.parseImport,
                  '.cconb': this.parseImport
                };
              }

              parseImage(file, options, onComplete) {
                if (file instanceof HTMLImageElement) {
                  onComplete(null, file);
                  return;
                }

                createImageBitmap(file, {
                  premultiplyAlpha: 'none'
                }).then(result => {
                  onComplete(null, result);
                }, err => {
                  onComplete(err, null);
                });
              }

              parsePVRTex(file, options, onComplete) {
                let err = null;
                let out = null;

                try {
                  const buffer = file instanceof ArrayBuffer ? file : file.buffer;
                  const header = new Int32Array(buffer, 0, PVR_HEADER_LENGTH);

                  if (header[PVR_HEADER_MAGIC] === PVR_MAGIC) {
                    const width = header[PVR_HEADER_WIDTH];
                    const height = header[PVR_HEADER_HEIGHT];
                    const dataOffset = header[PVR_HEADER_METADATA] + 52;
                    const pvrtcData = new Uint8Array(buffer, dataOffset);
                    out = {
                      _data: pvrtcData,
                      _compressed: true,
                      width,
                      height,
                      format: 0
                    };
                  } else if (header[11] === 0x21525650) {
                    const headerLength = header[0];
                    const height = header[1];
                    const width = header[2];
                    const pvrtcData = new Uint8Array(buffer, headerLength);
                    out = {
                      _data: pvrtcData,
                      _compressed: true,
                      width,
                      height,
                      format: 0
                    };
                  } else {
                    throw new Error('Invalid magic number in PVR header');
                  }
                } catch (e) {
                  err = e;
                }

                onComplete(err, out);
              }

              parsePKMTex(file, options, onComplete) {
                let err = null;
                let out = null;

                try {
                  const buffer = file instanceof ArrayBuffer ? file : file.buffer;
                  const header = new Uint8Array(buffer);
                  const format = readBEUint16(header, ETC_PKM_FORMAT_OFFSET);

                  if (format !== ETC1_RGB_NO_MIPMAPS && format !== ETC2_RGB_NO_MIPMAPS && format !== ETC2_RGBA_NO_MIPMAPS) {
                    throw new Error('Invalid magic number in ETC header');
                  }

                  const width = readBEUint16(header, ETC_PKM_WIDTH_OFFSET);
                  const height = readBEUint16(header, ETC_PKM_HEIGHT_OFFSET);
                  const encodedWidth = readBEUint16(header, ETC_PKM_ENCODED_WIDTH_OFFSET);
                  const encodedHeight = readBEUint16(header, ETC_PKM_ENCODED_HEIGHT_OFFSET);
                  const etcData = new Uint8Array(buffer, ETC_PKM_HEADER_SIZE);
                  out = {
                    _data: etcData,
                    _compressed: true,
                    width,
                    height,
                    format: 0
                  };
                } catch (e) {
                  err = e;
                }

                onComplete(err, out);
              }

              parseASTCTex(file, options, onComplete) {
                let err = null;
                let out = null;

                try {
                  const buffer = file instanceof ArrayBuffer ? file : file.buffer;
                  const header = new Uint8Array(buffer);
                  const magicval = header[0] + (header[1] << 8) + (header[2] << 16) + (header[3] << 24);

                  if (magicval !== ASTC_MAGIC) {
                    throw new Error('Invalid magic number in ASTC header');
                  }

                  const xdim = header[ASTC_HEADER_MAGIC];
                  const ydim = header[ASTC_HEADER_MAGIC + 1];
                  const zdim = header[ASTC_HEADER_MAGIC + 2];

                  if ((xdim < 3 || xdim > 6 || ydim < 3 || ydim > 6 || zdim < 3 || zdim > 6) && (xdim < 4 || xdim === 7 || xdim === 9 || xdim === 11 || xdim > 12 || ydim < 4 || ydim === 7 || ydim === 9 || ydim === 11 || ydim > 12 || zdim !== 1)) {
                    throw new Error('Invalid block number in ASTC header');
                  }

                  const format = getASTCFormat(xdim, ydim);
                  const xsize = header[ASTC_HEADER_SIZE_X_BEGIN] + (header[ASTC_HEADER_SIZE_X_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_X_BEGIN + 2] << 16);
                  const ysize = header[ASTC_HEADER_SIZE_Y_BEGIN] + (header[ASTC_HEADER_SIZE_Y_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_Y_BEGIN + 2] << 16);
                  const zsize = header[ASTC_HEADER_SIZE_Z_BEGIN] + (header[ASTC_HEADER_SIZE_Z_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_Z_BEGIN + 2] << 16);
                  const astcData = new Uint8Array(buffer, ASTC_HEADER_LENGTH);
                  out = {
                    _data: astcData,
                    _compressed: true,
                    width: xsize,
                    height: ysize,
                    format
                  };
                } catch (e) {
                  err = e;
                }

                onComplete(err, out);
              }

              parsePlist(file, options, onComplete) {
                let err = null;
                const result = plistParser.parse(file);

                if (!result) {
                  err = new Error('parse failed');
                }

                onComplete(err, result);
              }

              parseImport(file, options, onComplete) {
                if (!file) {
                  onComplete(new Error(`The json file of asset ${options.__uuid__} is empty or missing`));
                  return;
                }

                let result = null;
                let err = null;

                try {
                  result = deserializeAsset(file, options);
                } catch (e) {
                  err = e;
                }

                onComplete(err, result);
              }

              init() {
                this._parsing.clear();
              }

              register(type, handler) {
                if (typeof type === 'object') {
                  mixin(this._parsers, type);
                } else {
                  this._parsers[type] = handler;
                }
              }

              parse(id, file, type, options, onComplete) {
                const parsedAsset = parsed.get(id);

                if (parsedAsset) {
                  onComplete(null, parsedAsset);
                  return;
                }

                const parsing = this._parsing.get(id);

                if (parsing) {
                  parsing.push(onComplete);
                  return;
                }

                const parseHandler = this._parsers[type];

                if (!parseHandler) {
                  onComplete(null, file);
                  return;
                }

                this._parsing.add(id, [onComplete]);

                parseHandler(file, options, (err, data) => {
                  if (err) {
                    files.remove(id);
                  } else if (!isScene(data)) {
                    parsed.add(id, data);
                  }

                  const callbacks = this._parsing.remove(id);

                  for (let i = 0, l = callbacks.length; i < l; i++) {
                    callbacks[i](err, data);
                  }
                });
              }

            }
            var parser = new Parser$1();

            function load(task, done) {
              let firstTask = false;

              if (!task.progress) {
                task.progress = {
                  finish: 0,
                  total: task.input.length,
                  canInvoke: true
                };
                firstTask = true;
              }

              const {
                options,
                progress
              } = task;
              options.__exclude__ = options.__exclude__ || Object.create(null);
              task.output = [];
              forEach(task.input, (item, cb) => {
                const subTask = Task.create({
                  input: item,
                  onProgress: task.onProgress,
                  options,
                  progress,
                  onComplete: (err, result) => {
                    if (err && !task.isFinish) {
                      if (!legacyCC.assetManager.force || firstTask) {
                        {
                          error(err.message, err.stack);
                        }

                        progress.canInvoke = false;
                        done(err);
                      } else if (progress.canInvoke) {
                        task.dispatch('progress', ++progress.finish, progress.total, item);
                      }
                    }

                    task.output.push(result);
                    subTask.recycle();
                    cb(null);
                  }
                });
                loadOneAssetPipeline.async(subTask);
              }, () => {
                options.__exclude__ = null;

                if (task.isFinish) {
                  clear$1(task, true);
                  task.dispatch('error');
                  return;
                }

                gatherAsset(task);
                clear$1(task, true);
                done();
              });
            }
            const loadOneAssetPipeline = new Pipeline('loadOneAsset', [function fetch(task, done) {
              const item = task.output = task.input;
              const {
                options,
                isNative,
                uuid,
                file
              } = item;
              const {
                reloadAsset
              } = options;

              if (file || !reloadAsset && !isNative && assets.has(uuid)) {
                done();
                return;
              }

              packManager.load(item, task.options, (err, data) => {
                item.file = data;
                done(err);
              });
            }, function parse(task, done) {
              const item = task.output = task.input;
              const progress = task.progress;
              const exclude = task.options.__exclude__;
              const {
                id,
                file,
                options
              } = item;

              if (item.isNative) {
                parser.parse(id, file, item.ext, options, (err, asset) => {
                  if (err) {
                    done(err);
                    return;
                  }

                  item.content = asset;

                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }

                  files.remove(id);
                  parsed.remove(id);
                  done();
                });
              } else {
                const {
                  uuid
                } = item;

                if (uuid in exclude) {
                  const {
                    finish,
                    content,
                    err,
                    callbacks
                  } = exclude[uuid];

                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }

                  if (finish || checkCircleReference(uuid, uuid, exclude)) {
                    if (content) {
                      content.addRef();
                    }

                    item.content = content;
                    done(err);
                  } else {
                    callbacks.push({
                      done,
                      item
                    });
                  }
                } else if (!options.reloadAsset && assets.has(uuid)) {
                  const asset = assets.get(uuid);
                  item.content = asset.addRef();

                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }

                  done();
                } else {
                  options.__uuid__ = uuid;
                  parser.parse(id, file, 'import', options, (err, asset) => {
                    if (err) {
                      done(err);
                      return;
                    }

                    loadDepends(task, asset, done);
                  });
                }
              }
            }]);

            function loadDepends(task, asset, done) {
              const {
                input: item,
                progress
              } = task;
              const {
                uuid,
                id,
                options,
                config
              } = item;
              const {
                cacheAsset
              } = options;
              const depends = [];

              if (asset.addRef) {
                asset.addRef();
              }

              getDepends(uuid, asset, Object.create(null), depends, config);

              if (progress.canInvoke) {
                task.dispatch('progress', ++progress.finish, progress.total += depends.length, item);
              }

              const repeatItem = task.options.__exclude__[uuid] = {
                content: asset,
                finish: false,
                callbacks: [{
                  done,
                  item
                }]
              };
              const subTask = Task.create({
                input: depends,
                options: task.options,
                onProgress: task.onProgress,
                onError: Task.prototype.recycle,
                progress,
                onComplete: err => {
                  if (asset.decRef) {
                    asset.decRef(false);
                  }

                  repeatItem.finish = true;
                  repeatItem.err = err;

                  if (!err) {
                    const output = Array.isArray(subTask.output) ? subTask.output : [subTask.output];
                    const map = Object.create(null);

                    for (const dependAsset of output) {
                      if (!dependAsset) {
                        continue;
                      }

                      map[dependAsset instanceof Asset ? `${dependAsset._uuid}@import` : `${uuid}@native`] = dependAsset;
                    }

                    setProperties(uuid, asset, map);

                    try {
                      if (typeof asset.onLoaded === 'function' && !onLoadedInvokedMap.has(asset) && !nativeDependMap.has(asset)) {
                        asset.onLoaded();
                        onLoadedInvokedMap.add(asset);
                      }
                    } catch (e) {
                      error(`The asset ${uuid} is invalid for some reason, detail message: ${e.message}, stack: ${e.stack}`);
                    }

                    files.remove(id);
                    parsed.remove(id);

                    cache(uuid, asset, cacheAsset);
                    subTask.recycle();
                  }

                  const callbacks = repeatItem.callbacks;

                  for (let i = 0, l = callbacks.length; i < l; i++) {
                    const cb = callbacks[i];

                    if (asset.addRef) {
                      asset.addRef();
                    }

                    cb.item.content = asset;
                    cb.done(err);
                  }

                  callbacks.length = 0;
                }
              });
              pipeline.async(subTask);
            }

            function preprocess(task, done) {
              const options = task.options;
              const subOptions = Object.create(null);
              const leftOptions = Object.create(null);

              for (const op in options) {
                switch (op) {
                  case RequestType.PATH:
                  case RequestType.UUID:
                  case RequestType.DIR:
                  case RequestType.SCENE:
                  case RequestType.URL:
                    break;

                  case '__requestType__':
                  case '__isNative__':
                  case 'ext':
                  case 'type':
                  case '__nativeName__':
                  case 'audioLoadMode':
                  case 'bundle':
                    subOptions[op] = options[op];
                    break;

                  case '__exclude__':
                  case '__outputAsArray__':
                    leftOptions[op] = options[op];
                    break;

                  default:
                    subOptions[op] = options[op];
                    leftOptions[op] = options[op];
                    break;
                }
              }

              task.options = leftOptions;
              const subTask = Task.create({
                input: task.input,
                options: subOptions
              });
              let err = null;

              try {
                task.output = task.source = transformPipeline.sync(subTask);
              } catch (e) {
                err = e;

                for (let i = 0, l = subTask.output.length; i < l; i++) {
                  subTask.output[i].recycle();
                }
              }

              subTask.recycle();
              done(err);
            }

            class RequestItem {
              constructor() {
                this.uuid = '';
                this.url = '';
                this.ext = '.json';
                this.content = null;
                this.file = null;
                this.info = null;
                this.config = null;
                this.isNative = false;
                this.options = Object.create(null);
                this._id = '';
              }

              get id() {
                if (!this._id) {
                  this._id = `${this.uuid}@${this.isNative ? 'native' : 'import'}`;
                }

                return this._id;
              }

              static create() {
                let out;

                if (RequestItem._deadPool.length !== 0) {
                  out = RequestItem._deadPool.pop();
                } else {
                  out = new RequestItem();
                }

                return out;
              }

              recycle() {
                if (RequestItem._deadPool.length === RequestItem.MAX_DEAD_NUM) {
                  return;
                }

                this._id = '';
                this.uuid = '';
                this.url = '';
                this.ext = '.json';
                this.content = null;
                this.file = null;
                this.info = null;
                this.config = null;
                this.isNative = false;
                this.options = Object.create(null);

                RequestItem._deadPool.push(this);
              }

            }
            RequestItem.MAX_DEAD_NUM = 500;
            RequestItem._deadPool = [];

            const infos = [];
            function parse(task) {
              var _info2;

              const options = task.options;
              const input = Array.isArray(task.input) ? task.input : [task.input];
              task.output = [];

              for (let i = 0; i < input.length; i++) {
                let item = input[i];
                let out = RequestItem.create();
                let config = null;
                let info = null;

                if (typeof item === 'string') {
                  item = Object.create(null);
                  item[options.__requestType__ || RequestType.UUID] = input[i];
                }

                if (typeof item === 'object') {
                  addon(item, options);

                  if (item.preset) {
                    addon(item, presets[item.preset]);
                  }

                  for (const key in item) {
                    switch (key) {
                      case RequestType.UUID:
                        {
                          var _info;

                          const uuid = out.uuid = decodeUuid(item.uuid);

                          if (!item.bundle) {
                            const bundle = bundles.find(bundle => !!bundle.getAssetInfo(uuid));
                            item.bundle = bundle && bundle.name;
                          }

                          if (bundles.has(item.bundle)) {
                            config = bundles.get(item.bundle).config;
                            info = config.getAssetInfo(uuid);

                            if (info && info.redirect) {
                              if (!bundles.has(info.redirect)) {
                                throw new Error(`Please load bundle ${info.redirect} first`);
                              }

                              config = bundles.get(info.redirect).config;
                              info = config.getAssetInfo(uuid);
                            }

                            out.config = config;
                            out.info = info;
                          }

                          out.ext = item.ext || ((_info = info) === null || _info === void 0 ? void 0 : _info.extension) || '.json';
                          break;
                        }

                      case '__requestType__':
                      case 'ext':
                      case 'bundle':
                      case 'preset':
                      case 'type':
                        break;

                      case RequestType.DIR:
                        if (bundles.has(item.bundle)) {
                          bundles.get(item.bundle).config.getDirWithPath(item.dir, item.type, infos);

                          for (const assetInfo of infos) {
                            input.push({
                              uuid: assetInfo.uuid,
                              __isNative__: false,
                              ext: assetInfo.extension || '.json',
                              bundle: item.bundle
                            });
                          }

                          infos.length = 0;
                        }

                        out.recycle();
                        out = null;
                        break;

                      case RequestType.PATH:
                        if (bundles.has(item.bundle)) {
                          config = bundles.get(item.bundle).config;
                          info = config.getInfoWithPath(item.path, item.type);

                          if (info && info.redirect) {
                            if (!bundles.has(info.redirect)) {
                              throw new Error(`you need to load bundle ${info.redirect} first`);
                            }

                            config = bundles.get(info.redirect).config;
                            info = config.getAssetInfo(info.uuid);
                          }

                          if (!info) {
                            out.recycle();
                            throw new Error(`Bundle ${item.bundle} doesn't contain ${item.path}`);
                          }

                          out.config = config;
                          out.uuid = info.uuid;
                          out.info = info;
                        }

                        out.ext = item.ext || ((_info2 = info) === null || _info2 === void 0 ? void 0 : _info2.extension) || '.json';
                        break;

                      case RequestType.SCENE:
                        if (!item.bundle) {
                          const bundle = bundles.find(bundle => !!bundle.getSceneInfo(item.scene));
                          item.bundle = bundle && bundle.name;
                        }

                        if (bundles.has(item.bundle)) {
                          config = bundles.get(item.bundle).config;
                          info = config.getSceneInfo(item.scene);

                          if (info && info.redirect) {
                            if (!bundles.has(info.redirect)) {
                              throw new Error(`you need to load bundle ${info.redirect} first`);
                            }

                            config = bundles.get(info.redirect).config;
                            info = config.getAssetInfo(info.uuid);
                          }

                          if (!info) {
                            out.recycle();
                            throw new Error(`Bundle ${config.name} doesn't contain scene ${item.scene}`);
                          }

                          out.config = config;
                          out.uuid = info.uuid;
                          out.info = info;
                        }

                        break;

                      case '__isNative__':
                        out.isNative = item.__isNative__;
                        break;

                      case RequestType.URL:
                        out.url = item.url;
                        out.uuid = item.uuid || item.url;
                        out.ext = item.ext || extname(item.url);
                        out.isNative = item.__isNative__ !== undefined ? item.__isNative__ : true;
                        break;

                      default:
                        out.options[key] = item[key];
                    }

                    if (!out) {
                      break;
                    }
                  }
                }

                if (!out) {
                  continue;
                }

                task.output.push(out);

                if (!out.uuid && !out.url) {
                  throw new Error(`Can not parse this input:${JSON.stringify(item)}`);
                }
              }

              return null;
            }
            function combine(task) {
              const input = task.output = task.input;

              for (let i = 0; i < input.length; i++) {
                const item = input[i];

                if (item.url) {
                  continue;
                }

                let url = '';
                let base = '';
                const config = item.config;

                if (item.isNative) {
                  base = config && config.nativeBase ? config.base + config.nativeBase : legacyCC.assetManager.generalNativeBase;
                } else {
                  base = config && config.importBase ? config.base + config.importBase : legacyCC.assetManager.generalImportBase;
                }

                const uuid = item.uuid;
                let ver = '';

                if (item.info) {
                  if (item.isNative) {
                    ver = item.info.nativeVer ? `.${item.info.nativeVer}` : '';
                  } else {
                    ver = item.info.ver ? `.${item.info.ver}` : '';
                  }
                }

                if (item.ext === '.ttf') {
                  url = `${base}/${uuid.slice(0, 2)}/${uuid}${ver}/${item.options.__nativeName__}`;
                } else {
                  url = `${base}/${uuid.slice(0, 2)}/${uuid}${ver}${item.ext}`;
                }

                item.url = url;
              }

              return null;
            }

            class AssetManager {
              constructor() {
                this.pipeline = pipeline.append(preprocess).append(load);
                this.fetchPipeline = fetchPipeline.append(preprocess).append(fetch$1);
                this.transformPipeline = transformPipeline.append(parse).append(combine);
                this.bundles = bundles;
                this.assets = assets;
                this.generalImportBase = '';
                this.generalNativeBase = '';
                this.dependUtil = dependUtil;
                this.force =  PREVIEW;
                this.allowImageBitmap = !sys.isMobile;
                this.utils = helper;
                this.downloader = downloader;
                this.parser = parser;
                this.packManager = packManager;
                this.cacheAsset = true;
                this.cacheManager = null;
                this.presets = presets;
                this.factory = factory;
                this.preprocessPipe = preprocess;
                this.fetchPipe = fetch$1;
                this.loadPipe = load;
                this.references = references;
                this._releaseManager = releaseManager;
                this._files = files;
                this._parsed = parsed;
                this._parsePipeline =  null ;
              }

              get main() {
                return bundles.get(BuiltinBundleName.MAIN) || null;
              }

              get resources() {
                return bundles.get(BuiltinBundleName.RESOURCES) || null;
              }

              init(options = {}) {
                this._files.clear();

                this._parsed.clear();

                this._releaseManager.init();

                this.assets.clear();
                this.bundles.clear();
                this.packManager.init();
                this.downloader.init(options.server, options.bundleVers, options.remoteBundles);
                this.parser.init();
                this.dependUtil.init();
                let importBase = options.importBase || '';

                if (importBase && importBase.endsWith('/')) {
                  importBase = importBase.substr(0, importBase.length - 1);
                }

                let nativeBase = options.nativeBase || '';

                if (nativeBase && nativeBase.endsWith('/')) {
                  nativeBase = nativeBase.substr(0, nativeBase.length - 1);
                }

                this.generalImportBase = importBase;
                this.generalNativeBase = nativeBase;
              }

              getBundle(name) {
                return bundles.get(name) || null;
              }

              removeBundle(bundle) {
                bundle._destroy();

                bundles.remove(bundle.name);
              }

              loadAny(requests, options, onProgress, onComplete) {
                const {
                  options: opts,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseParameters(options, onProgress, onComplete);
                opts.preset = opts.preset || 'default';
                requests = Array.isArray(requests) ? requests.slice() : requests;
                const task = Task.create({
                  input: requests,
                  onProgress: onProg,
                  onComplete: asyncify(onComp),
                  options: opts
                });
                pipeline.async(task);
              }

              preloadAny(requests, options, onProgress, onComplete) {
                const {
                  options: opts,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseParameters(options, onProgress, onComplete);
                opts.preset = opts.preset || 'preload';
                requests = Array.isArray(requests) ? requests.slice() : requests;
                const task = Task.create({
                  input: requests,
                  onProgress: onProg,
                  onComplete: asyncify(onComp),
                  options: opts
                });
                fetchPipeline.async(task);
              }

              loadRemote(url, options, onComplete) {
                const {
                  options: opts,
                  onComplete: onComp
                } = parseParameters(options, undefined, onComplete);

                if (!opts.reloadAsset && this.assets.has(url)) {
                  asyncify(onComp)(null, this.assets.get(url));
                  return;
                }

                opts.__isNative__ = true;
                opts.preset = opts.preset || 'remote';
                this.loadAny({
                  url
                }, opts, null, (err, data) => {
                  if (err) {
                    error(err.message, err.stack);

                    if (onComp) {
                      onComp(err, data);
                    }
                  } else {
                    factory.create(url, data, opts.ext || extname(url), opts, (p1, p2) => {
                      if (onComp) {
                        onComp(p1, p2);
                      }
                    });
                  }
                });
              }

              loadBundle(nameOrUrl, options, onComplete) {
                const {
                  options: opts,
                  onComplete: onComp
                } = parseParameters(options, undefined, onComplete);
                const bundleName = basename(nameOrUrl);

                if (this.bundles.has(bundleName)) {
                  asyncify(onComp)(null, this.getBundle(bundleName));
                  return;
                }

                opts.preset = opts.preset || 'bundle';
                opts.ext = 'bundle';
                opts.__isNative__ = true;
                this.loadAny({
                  url: nameOrUrl
                }, opts, null, (err, data) => {
                  if (err) {
                    error(err.message, err.stack);

                    if (onComp) {
                      onComp(err, data);
                    }
                  } else {
                    factory.create(nameOrUrl, data, 'bundle', opts, (p1, p2) => {
                      if (onComp) {
                        onComp(p1, p2);
                      }
                    });
                  }
                });
              }

              releaseAsset(asset) {
                releaseManager.tryRelease(asset, true);
              }

              releaseUnusedAssets() {
                assets.forEach(asset => {
                  releaseManager.tryRelease(asset);
                });
              }

              releaseAll() {
                assets.forEach(asset => {
                  releaseManager.tryRelease(asset, true);
                });
              }

              loadWithJson(json, options, onProgress, onComplete) {
                {
                  throw new Error('Only valid in Editor');
                }
              }

            } exports('fG', AssetManager);
            AssetManager.Pipeline = Pipeline;
            AssetManager.Task = Task;
            AssetManager.Cache = Cache;
            AssetManager.RequestItem = RequestItem;
            AssetManager.Bundle = Bundle;
            AssetManager.BuiltinBundleName = BuiltinBundleName;
            var assetManager = exports('ea', legacyCC.assetManager = new AssetManager());
            legacyCC.AssetManager = AssetManager;

            const ImageFmts = ['.png', '.jpg', '.bmp', '.jpeg', '.gif', '.ico', '.tiff', '.webp', '.image', '.pvr', '.pkm', '.astc'];
            const AudioFmts = ['.mp3', '.ogg', '.wav', '.m4a'];

            function GetTrue() {
              return true;
            }

            const md5Pipe = {
              transformURL(url) {
                const uuid = getUuidFromURL(url);

                if (!uuid) {
                  return url;
                }

                const bundle = bundles.find(b => !!b.getAssetInfo(uuid));

                if (!bundle) {
                  return url;
                }

                let hashValue = '';
                const info = bundle.getAssetInfo(uuid);

                if (url.startsWith(bundle.base + bundle.config.nativeBase)) {
                  hashValue = info.nativeVer || '';
                } else {
                  hashValue = info.ver || '';
                }

                if (!hashValue || url.indexOf(hashValue) !== -1) {
                  return url;
                }

                let hashPatchInFolder = false;

                if (extname(url) === '.ttf') {
                  hashPatchInFolder = true;
                }

                if (hashPatchInFolder) {
                  const dirname$1 = dirname(url);
                  const basename$1 = basename(url);
                  url = `${dirname$1}.${hashValue}/${basename$1}`;
                } else {
                  url = url.replace(/.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/, (match, uuid) => `${match}.${hashValue}`);
                }

                return url;
              }

            };
            class CCLoader {
              constructor() {
                this._autoReleaseSetting = Object.create(null);
                this._parseLoadResArgs = parseLoadResArgs;
              }

              set onProgress(val) {
                setDefaultProgressCallback(val);
              }

              get _cache() {
                return assets._map;
              }

              load(res, progressCallback, completeCallback) {
                if (completeCallback === undefined) {
                  if (progressCallback !== undefined) {
                    completeCallback = progressCallback;
                    progressCallback = null;
                  }
                }

                const requests = Array.isArray(res) ? res : [res];

                for (let i = 0; i < requests.length; i++) {
                  const item = requests[i];

                  if (typeof item === 'string') {
                    requests[i] = {
                      url: item,
                      __isNative__: true
                    };
                  } else {
                    if (item.type) {
                      item.ext = `.${item.type}`;
                      item.type = undefined;
                    }

                    if (item.url) {
                      item.__isNative__ = true;
                    }
                  }
                }

                const images = [];
                const audios = [];
                assetManager.loadAny(requests, null, (finish, total, item) => {
                  if (item.content) {
                    if (ImageFmts.includes(item.ext)) {
                      images.push(item.content);
                    } else if (AudioFmts.includes(item.ext)) {
                      audios.push(item.content);
                    }
                  }

                  if (progressCallback) {
                    progressCallback(finish, total, item);
                  }
                }, (err, native) => {
                  let out = null;

                  if (!err) {
                    native = Array.isArray(native) ? native : [native];

                    for (let i = 0; i < native.length; i++) {
                      const item = native[i];

                      if (!(item instanceof Asset)) {
                        let asset = item;
                        const url = requests[i].url;

                        if (images.includes(asset)) {
                          factory.create(url, item, '.png', {}, (err, image) => {
                            asset = native[i] = image;
                          });
                        } else if (audios.includes(asset)) {
                          factory.create(url, item, '.mp3', {}, (err, audio) => {
                            asset = native[i] = audio;
                          });
                        }

                        assets.add(url, asset);
                      }
                    }

                    if (native.length > 1) {
                      const map = Object.create(null);
                      native.forEach(asset => {
                        map[asset._uuid] = asset;
                      });
                      out = {
                        isCompleted: GetTrue,
                        _map: map
                      };
                    } else {
                      out = native[0];
                    }
                  }

                  if (completeCallback) {
                    completeCallback(err, out);
                  }
                });
              }

              getXMLHttpRequest() {
                return new XMLHttpRequest();
              }

              getItem(id) {
                return assetManager.assets.has(id) ? {
                  content: assetManager.assets.get(id)
                } : null;
              }

              loadRes(url, type, progressCallback, completeCallback) {
                const {
                  type: _type,
                  onProgress,
                  onComplete
                } = this._parseLoadResArgs(type, progressCallback, completeCallback);

                const extname$1 = extname(url);

                if (extname$1 && !resources.getInfoWithPath(url, _type)) {
                  url = url.slice(0, -extname$1.length);
                }

                resources.load(url, _type, onProgress, onComplete);
              }

              loadResArray(urls, type, progressCallback, completeCallback) {
                const {
                  type: _type,
                  onProgress,
                  onComplete
                } = this._parseLoadResArgs(type, progressCallback, completeCallback);

                urls.forEach((url, i) => {
                  const extname$1 = extname(url);

                  if (extname$1 && !resources.getInfoWithPath(url, _type)) {
                    urls[i] = url.slice(0, -extname$1.length);
                  }
                });
                resources.load(urls, _type, onProgress, onComplete);
              }

              loadResDir(url, type, progressCallback, completeCallback) {
                const {
                  type: _type,
                  onProgress,
                  onComplete
                } = this._parseLoadResArgs(type, progressCallback, completeCallback);

                resources.loadDir(url, _type, onProgress, (err, out) => {
                  let urls = [];

                  if (!err) {
                    const infos = resources.getDirWithPath(url, _type);
                    urls = infos.map(info => info.path);
                  }

                  if (onComplete) {
                    onComplete(err, out, urls);
                  }
                });
              }

              getRes(url, type) {
                return assets.has(url) ? assets.get(url) : resources.get(url, type);
              }

              getResCount() {
                return assets.count;
              }

              getDependsRecursively(owner) {
                if (!owner) {
                  return [];
                }

                const uuid = typeof owner === 'string' ? owner : owner._uuid;
                return dependUtil.getDepsRecursively(uuid).concat([uuid]);
              }

              get md5Pipe() {
                return md5Pipe;
              }

              get downloader() {
                return downloader;
              }

              get loader() {
                return assetManager.parser;
              }

              addDownloadHandlers(extMap) {
                const handler = Object.create(null);

                for (const type in extMap) {
                  const func = extMap[type];

                  handler[`.${type}`] = (url, options, onComplete) => {
                    func({
                      url
                    }, onComplete);
                  };
                }

                downloader.register(handler);
              }

              addLoadHandlers(extMap) {
                const handler = Object.create(null);

                for (const type in extMap) {
                  const func = extMap[type];

                  handler[`.${type}`] = (file, options, onComplete) => {
                    func({
                      content: file
                    }, onComplete);
                  };
                }

                parser.register(handler);
              }

              release(asset) {
                if (Array.isArray(asset)) {
                  for (let i = 0; i < asset.length; i++) {
                    let key = asset[i];

                    if (typeof key === 'string') {
                      key = assets.get(key);
                    }

                    assetManager.releaseAsset(key);
                  }
                } else if (asset) {
                  if (typeof asset === 'string') {
                    asset = assets.get(asset);
                  }

                  assetManager.releaseAsset(asset);
                }
              }

              releaseAsset(asset) {
                assetManager.releaseAsset(asset);
              }

              releaseRes(res, type) {
                resources.release(res, type);
              }

              releaseAll() {
                assetManager.releaseAll();
                assets.clear();
              }

              removeItem(id) {
                return !!assets.remove(id);
              }

              setAutoRelease(asset, autoRelease) {
                if (typeof asset === 'object') {
                  asset = asset._uuid;
                }

                this._autoReleaseSetting[asset] = !!autoRelease;
              }

              setAutoReleaseRecursively(asset, autoRelease) {
                if (typeof asset === 'object') {
                  asset = asset._uuid;
                }

                autoRelease = !!autoRelease;
                this._autoReleaseSetting[asset] = autoRelease;
                const depends = dependUtil.getDepsRecursively(asset);

                for (let i = 0; i < depends.length; i++) {
                  this._autoReleaseSetting[depends[i]] = autoRelease;
                }
              }

              isAutoRelease(asset) {
                if (typeof asset === 'object') {
                  asset = asset._uuid;
                }

                return !!this._autoReleaseSetting[asset];
              }

            } exports('fI', CCLoader);
            const loader = exports('fJ', new CCLoader());
            const AssetLibrary = exports('fK', {
              init(options) {
                options.importBase = options.libraryPath;
                options.nativeBase =  options.rawAssetsBase ;
                assetManager.init(options);

                if (options.rawAssets) {
                  resources.init({
                    base: '',
                    deps: [],
                    scenes: {},
                    redirect: [],
                    debug: true,
                    packs: {},
                    types: [],
                    versions: {
                      import: [],
                      native: []
                    },
                    name: BuiltinBundleName.RESOURCES,
                    importBase: options.importBase,
                    nativeBase: options.nativeBase,
                    paths: options.rawAssets.assets,
                    uuids: Object.keys(options.rawAssets.assets),
                    extensionMap: {}
                  });
                }
              },

              loadAsset(uuid, callback, options) {
                assetManager.loadAny(uuid, callback);
              }

            });
            const url = exports('fL', {});
            replaceProperty(url, 'url', [{
              name: 'normalize',
              target: assetManager.utils,
              targetName: 'assetManager.utils',
              newName: 'normalize'
            }, {
              name: 'raw',
              targetName: 'Asset.prototype',
              newName: 'nativeUrl',
              customFunction: url => {
                if (url.startsWith('resources/')) {
                  return transform({
                    path: changeExtname(url.substr(10)),
                    bundle: BuiltinBundleName.RESOURCES,
                    __isNative__: true,
                    ext: extname(url)
                  });
                }

                return '';
              }
            }]);
            removeProperty(AssetLibrary, 'AssetLibrary', [{
              name: 'getLibUrlNoExt',
              suggest: 'AssetLibrary.getLibUrlNoExt was removed, if you want to transform url, please use cc.assetManager.utils.getUrlWithUuid instead'
            }, {
              name: 'queryAssetInfo',
              suggest: 'AssetLibrary.queryAssetInfo was removed'
            }]);
            removeProperty(loader, 'loader', [{
              name: 'releaseResDir',
              suggest: 'loader.releaseResDir was removed, please use assetManager.releaseAsset instead'
            }, {
              name: 'flowInDeps',
              suggest: 'loader.flowInDeps was removed'
            }, {
              name: 'assetLoader',
              suggest: 'cc.loader.assetLoader was removed, assetLoader and md5Pipe were merged into cc.assetManager.transformPipeline'
            }]);
            replaceProperty(legacyCC, 'cc', [{
              name: 'loader',
              newName: 'assetManager',
              logTimes: 1,
              customGetter: () => loader
            }, {
              name: 'AssetLibrary',
              newName: 'assetManager',
              logTimes: 1,
              customGetter: () => AssetLibrary
            }, {
              name: 'Pipeline',
              target: AssetManager,
              targetName: 'AssetManager',
              newName: 'Pipeline',
              logTimes: 1
            }, {
              name: 'url',
              targetName: 'assetManager',
              newName: 'utils',
              logTimes: 1,
              customGetter: () => url
            }]);
            removeProperty(legacyCC, 'cc', [{
              name: 'LoadingItems',
              suggest: getError(1400, 'cc.LoadingItems', 'cc.AssetManager.Task')
            }]);
            replaceProperty(macro, 'macro', [{
              name: 'DOWNLOAD_MAX_CONCURRENT',
              target: downloader,
              targetName: 'assetManager.downloader',
              newName: 'maxConcurrency'
            }]);
            replaceProperty(director, 'director', [{
              name: '_getSceneUuid',
              targetName: 'assetManager.main',
              newName: 'getSceneInfo',
              customFunction: sceneName => {
                if (assetManager.main) {
                  var _assetManager$main$ge;

                  return (_assetManager$main$ge = assetManager.main.getSceneInfo(sceneName)) === null || _assetManager$main$ge === void 0 ? void 0 : _assetManager$main$ge.uuid;
                }

                return '';
              }
            }]);
            replaceProperty(game, 'game', [{
              name: '_sceneInfos',
              targetName: 'assetManager.main',
              newName: 'getSceneInfo',
              customGetter: () => {
                const scenes = [];

                if (assetManager.main) {
                  assetManager.main.config.scenes.forEach(val => {
                    scenes.push(val);
                  });
                }

                return scenes;
              }
            }]);
            const _autoRelease = releaseManager._autoRelease;

            releaseManager._autoRelease = function (oldScene, newScene, persistNodes) {
              _autoRelease.call(releaseManager, oldScene, newScene, persistNodes);

              const releaseSettings = loader._autoReleaseSetting;
              const keys = Object.keys(releaseSettings);

              for (let i = 0; i < keys.length; i++) {
                const key = keys[i];

                if (releaseSettings[key] === true) {
                  const asset = assets.get(key);

                  if (asset) {
                    releaseManager.tryRelease(asset);
                  }
                }
              }
            };

            var _dec$v, _dec2$c, _dec3$6, _dec4$4, _dec5$3, _dec6$2, _class$v, _class2$r, _descriptor$o, _descriptor2$g, _descriptor3$b, _descriptor4$a, _descriptor5$8, _temp$s;
            let EventHandler = exports('dj', (_dec$v = ccclass('cc.ClickEvent'), _dec2$c = type(legacyCC.Node), _dec3$6 = tooltip(), _dec4$4 = tooltip(), _dec5$3 = tooltip(), _dec6$2 = tooltip(), _dec$v(_class$v = (_class2$r = (_temp$s = class EventHandler {
              constructor() {
                _initializerDefineProperty(this, "target", _descriptor$o, this);

                _initializerDefineProperty(this, "component", _descriptor2$g, this);

                _initializerDefineProperty(this, "_componentId", _descriptor3$b, this);

                _initializerDefineProperty(this, "handler", _descriptor4$a, this);

                _initializerDefineProperty(this, "customEventData", _descriptor5$8, this);
              }

              get _componentName() {
                this._genCompIdIfNeeded();

                return this._compId2Name(this._componentId);
              }

              set _componentName(value) {
                this._componentId = this._compName2Id(value);
              }

              static emitEvents(events, ...args) {
                for (let i = 0, l = events.length; i < l; i++) {
                  const event = events[i];

                  if (!(event instanceof EventHandler)) {
                    continue;
                  }

                  event.emit(args);
                }
              }

              emit(params) {
                const target = this.target;

                if (!legacyCC.isValid(target)) {
                  return;
                }

                this._genCompIdIfNeeded();

                const compType = legacyCC.js._getClassById(this._componentId);

                const comp = target.getComponent(compType);

                if (!legacyCC.isValid(comp)) {
                  return;
                }

                const handler = comp[this.handler];

                if (typeof handler !== 'function') {
                  return;
                }

                if (this.customEventData != null && this.customEventData !== '') {
                  params = params.slice();
                  params.push(this.customEventData);
                }

                handler.apply(comp, params);
              }

              _compName2Id(compName) {
                const comp = legacyCC.js.getClassByName(compName);
                return legacyCC.js._getClassId(comp);
              }

              _compId2Name(compId) {
                const comp = legacyCC.js._getClassById(compId);

                return legacyCC.js.getClassName(comp);
              }

              _genCompIdIfNeeded() {
                if (!this._componentId) {
                  this._componentName = this.component;
                  this.component = '';
                }
              }

            }, _temp$s), (_descriptor$o = _applyDecoratedDescriptor(_class2$r.prototype, "target", [serializable, _dec2$c, _dec3$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$g = _applyDecoratedDescriptor(_class2$r.prototype, "component", [serializable, editable, _dec4$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor3$b = _applyDecoratedDescriptor(_class2$r.prototype, "_componentId", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor4$a = _applyDecoratedDescriptor(_class2$r.prototype, "handler", [serializable, editable, _dec5$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor5$8 = _applyDecoratedDescriptor(_class2$r.prototype, "customEventData", [serializable, editable, _dec6$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class2$r)) || _class$v));
            legacyCC.Component.EventHandler = EventHandler;

            var _dec$w, _dec2$d, _dec3$7, _dec4$5, _dec5$4, _dec6$3, _dec7$2, _dec8$2, _dec9$2, _dec10$2, _dec11$2, _dec12$2, _dec13$2, _dec14$2, _dec15$2, _dec16$2, _dec17$2, _dec18$2, _dec19$2, _dec20$2, _dec21$2, _dec22$2, _dec23$2, _dec24$2, _dec25$2, _dec26$1, _dec27$1, _dec28$1, _dec29$1, _dec30$1, _dec31$1, _dec32$1, _dec33$1, _dec34$1, _dec35$1, _dec36$1, _dec37$1, _dec38$1, _dec39$1, _dec40$1, _dec41$1, _dec42$1, _dec43$1, _dec44$1, _dec45$1, _class$w, _class2$s, _descriptor$p, _descriptor2$h, _descriptor3$c, _descriptor4$b, _descriptor5$9, _descriptor6$4, _descriptor7$4, _descriptor8$4, _descriptor9$3, _descriptor10$3, _descriptor11$2, _descriptor12$2, _descriptor13$2, _descriptor14$2, _descriptor15$2, _descriptor16$2, _descriptor17$2, _descriptor18$2, _class3$b, _temp$t;

            const _temp_vec3_1 = new Vec3();

            const ProjectionType = Enum(CameraProjection);
            const FOVAxis = Enum(CameraFOVAxis);
            const Aperture = Enum(CameraAperture);
            const Shutter = Enum(CameraShutter);
            const ISO = Enum(CameraISO);
            const ClearFlag = Enum({
              SKYBOX: SKYBOX_FLAG | ClearFlagBit.DEPTH_STENCIL,
              SOLID_COLOR: ClearFlagBit.ALL,
              DEPTH_ONLY: ClearFlagBit.DEPTH_STENCIL,
              DONT_CLEAR: ClearFlagBit.NONE
            });
            let Camera$1 = exports('d4', (_dec$w = ccclass('cc.Camera'), _dec2$d = help(), _dec3$7 = menu(), _dec4$5 = displayOrder(), _dec5$4 = tooltip(), _dec6$3 = type(Layers.BitMask), _dec7$2 = displayOrder(), _dec8$2 = tooltip(), _dec9$2 = type(ClearFlag), _dec10$2 = displayOrder(), _dec11$2 = tooltip(), _dec12$2 = displayOrder(), _dec13$2 = tooltip(), _dec14$2 = displayOrder(), _dec15$2 = tooltip(), _dec16$2 = displayOrder(), _dec17$2 = tooltip(), _dec18$2 = type(ProjectionType), _dec19$2 = displayOrder(), _dec20$2 = tooltip(), _dec21$2 = type(FOVAxis), _dec22$2 = displayOrder(), _dec23$2 = tooltip(), _dec24$2 = displayOrder(), _dec25$2 = tooltip(), _dec26$1 = displayOrder(), _dec27$1 = tooltip(), _dec28$1 = displayOrder(), _dec29$1 = tooltip(), _dec30$1 = displayOrder(), _dec31$1 = tooltip(), _dec32$1 = type(Aperture), _dec33$1 = displayOrder(), _dec34$1 = tooltip(), _dec35$1 = type(Shutter), _dec36$1 = displayOrder(), _dec37$1 = tooltip(), _dec38$1 = type(ISO), _dec39$1 = displayOrder(), _dec40$1 = tooltip(), _dec41$1 = displayOrder(), _dec42$1 = tooltip(), _dec43$1 = type(RenderTexture), _dec44$1 = displayOrder(), _dec45$1 = tooltip(), _dec$w(_class$w = _dec2$d(_class$w = _dec3$7(_class$w = executeInEditMode(_class$w = (_class2$s = (_temp$t = _class3$b = class Camera extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_projection", _descriptor$p, this);

                _initializerDefineProperty(this, "_priority", _descriptor2$h, this);

                _initializerDefineProperty(this, "_fov", _descriptor3$c, this);

                _initializerDefineProperty(this, "_fovAxis", _descriptor4$b, this);

                _initializerDefineProperty(this, "_orthoHeight", _descriptor5$9, this);

                _initializerDefineProperty(this, "_near", _descriptor6$4, this);

                _initializerDefineProperty(this, "_far", _descriptor7$4, this);

                _initializerDefineProperty(this, "_color", _descriptor8$4, this);

                _initializerDefineProperty(this, "_depth", _descriptor9$3, this);

                _initializerDefineProperty(this, "_stencil", _descriptor10$3, this);

                _initializerDefineProperty(this, "_clearFlags", _descriptor11$2, this);

                _initializerDefineProperty(this, "_rect", _descriptor12$2, this);

                _initializerDefineProperty(this, "_aperture", _descriptor13$2, this);

                _initializerDefineProperty(this, "_shutter", _descriptor14$2, this);

                _initializerDefineProperty(this, "_iso", _descriptor15$2, this);

                _initializerDefineProperty(this, "_screenScale", _descriptor16$2, this);

                _initializerDefineProperty(this, "_visibility", _descriptor17$2, this);

                _initializerDefineProperty(this, "_targetTexture", _descriptor18$2, this);

                this._camera = null;
                this._inEditorMode = false;
                this._flows = undefined;
              }

              get camera() {
                return this._camera;
              }

              get priority() {
                return this._priority;
              }

              set priority(val) {
                this._priority = val;

                if (this._camera) {
                  this._camera.priority = val;
                }
              }

              get visibility() {
                return this._visibility;
              }

              set visibility(val) {
                this._visibility = val;

                if (this._camera) {
                  this._camera.visibility = val;
                }
              }

              get clearFlags() {
                return this._clearFlags;
              }

              set clearFlags(val) {
                this._clearFlags = val;

                if (this._camera) {
                  this._camera.clearFlag = val;
                }
              }

              get clearColor() {
                return this._color;
              }

              set clearColor(val) {
                this._color.set(val);

                if (this._camera) {
                  this._camera.clearColor = this._color;
                }
              }

              get clearDepth() {
                return this._depth;
              }

              set clearDepth(val) {
                this._depth = val;

                if (this._camera) {
                  this._camera.clearDepth = val;
                }
              }

              get clearStencil() {
                return this._stencil;
              }

              set clearStencil(val) {
                this._stencil = val;

                if (this._camera) {
                  this._camera.clearStencil = val;
                }
              }

              get projection() {
                return this._projection;
              }

              set projection(val) {
                this._projection = val;

                if (this._camera) {
                  this._camera.projectionType = val;
                }
              }

              get fovAxis() {
                return this._fovAxis;
              }

              set fovAxis(val) {
                if (val === this._fovAxis) {
                  return;
                }

                this._fovAxis = val;

                if (this._camera) {
                  this._camera.fovAxis = val;

                  if (val === CameraFOVAxis.VERTICAL) {
                    this.fov = this._fov * this._camera.aspect;
                  } else {
                    this.fov = this._fov / this._camera.aspect;
                  }
                }
              }

              get fov() {
                return this._fov;
              }

              set fov(val) {
                this._fov = val;

                if (this._camera) {
                  this._camera.fov = toRadian(val);
                }
              }

              get orthoHeight() {
                return this._orthoHeight;
              }

              set orthoHeight(val) {
                this._orthoHeight = val;

                if (this._camera) {
                  this._camera.orthoHeight = val;
                }
              }

              get near() {
                return this._near;
              }

              set near(val) {
                this._near = val;

                if (this._camera) {
                  this._camera.nearClip = val;
                }
              }

              get far() {
                return this._far;
              }

              set far(val) {
                this._far = val;

                if (this._camera) {
                  this._camera.farClip = val;
                }
              }

              get aperture() {
                return this._aperture;
              }

              set aperture(val) {
                this._aperture = val;

                if (this._camera) {
                  this._camera.aperture = val;
                }
              }

              get shutter() {
                return this._shutter;
              }

              set shutter(val) {
                this._shutter = val;

                if (this._camera) {
                  this._camera.shutter = val;
                }
              }

              get iso() {
                return this._iso;
              }

              set iso(val) {
                this._iso = val;

                if (this._camera) {
                  this._camera.iso = val;
                }
              }

              get rect() {
                return this._rect;
              }

              set rect(val) {
                this._rect = val;

                if (this._camera) {
                  this._camera.viewport = val;
                }
              }

              get targetTexture() {
                return this._targetTexture;
              }

              set targetTexture(value) {
                if (this._targetTexture === value) {
                  return;
                }

                const old = this._targetTexture;
                this._targetTexture = value;

                this._checkTargetTextureEvent(old);

                this._updateTargetTexture();

                if (!value && this._camera) {
                  this._camera.changeTargetWindow( null);

                  this._camera.isWindowSize = true;
                }

                this.node.emit(Camera.TARGET_TEXTURE_CHANGE, this);
              }

              get screenScale() {
                return this._screenScale;
              }

              set screenScale(val) {
                this._screenScale = val;

                if (this._camera) {
                  this._camera.screenScale = val;
                }
              }

              get inEditorMode() {
                return this._inEditorMode;
              }

              set inEditorMode(value) {
                this._inEditorMode = value;

                if (this._camera) {
                  this._camera.changeTargetWindow(value ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow);
                }
              }

              onLoad() {
                this._createCamera();
              }

              onEnable() {
                this.node.hasChangedFlags |= TransformBit.POSITION;

                if (this._camera) {
                  this._attachToScene();
                }
              }

              onDisable() {
                if (this._camera) {
                  this._detachFromScene();
                }
              }

              onDestroy() {
                if (this._camera) {
                  this._camera.destroy();

                  this._camera = null;
                }

                if (this._targetTexture) {
                  this._targetTexture.off('resize');
                }
              }

              screenPointToRay(x, y, out) {
                if (!out) {
                  out = Ray.create();
                }

                if (this._camera) {
                  this._camera.screenPointToRay(out, x, y);
                }

                return out;
              }

              worldToScreen(worldPos, out) {
                if (!out) {
                  out = new Vec3();
                }

                if (this._camera) {
                  this._camera.worldToScreen(out, worldPos);
                }

                return out;
              }

              screenToWorld(screenPos, out) {
                if (!out) {
                  out = this.node.getWorldPosition();
                }

                if (this._camera) {
                  this._camera.screenToWorld(out, screenPos);
                }

                return out;
              }

              convertToUINode(wpos, uiNode, out) {
                if (!out) {
                  out = new Vec3();
                }

                if (!this._camera) {
                  return out;
                }

                this.worldToScreen(wpos, _temp_vec3_1);
                const cmp = uiNode.getComponent('cc.UITransform');
                const designSize = view.getVisibleSize();
                const xoffset = _temp_vec3_1.x - this._camera.width * 0.5;
                const yoffset = _temp_vec3_1.y - this._camera.height * 0.5;
                _temp_vec3_1.x = xoffset / legacyCC.view.getScaleX() + designSize.width * 0.5;
                _temp_vec3_1.y = yoffset / legacyCC.view.getScaleY() + designSize.height * 0.5;

                if (cmp) {
                  cmp.convertToNodeSpaceAR(_temp_vec3_1, out);
                }

                return out;
              }

              _createCamera() {
                if (!this._camera) {
                  this._camera = legacyCC.director.root.createCamera();

                  this._camera.initialize({
                    name: this.node.name,
                    node: this.node,
                    projection: this._projection,
                    window: this._inEditorMode ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow,
                    priority: this._priority
                  });

                  this._camera.viewport = this._rect;
                  this._camera.fovAxis = this._fovAxis;
                  this._camera.fov = toRadian(this._fov);
                  this._camera.orthoHeight = this._orthoHeight;
                  this._camera.nearClip = this._near;
                  this._camera.farClip = this._far;
                  this._camera.clearColor = this._color;
                  this._camera.clearDepth = this._depth;
                  this._camera.clearStencil = this._stencil;
                  this._camera.clearFlag = this._clearFlags;
                  this._camera.visibility = this._visibility;
                  this._camera.aperture = this._aperture;
                  this._camera.shutter = this._shutter;
                  this._camera.iso = this._iso;
                }

                this._updateTargetTexture();
              }

              _attachToScene() {
                if (!this.node.scene || !this._camera) {
                  return;
                }

                if (this._camera && this._camera.scene) {
                  this._camera.scene.removeCamera(this._camera);
                }

                const rs = this._getRenderScene();

                rs.addCamera(this._camera);
              }

              _detachFromScene() {
                if (this._camera && this._camera.scene) {
                  this._camera.scene.removeCamera(this._camera);
                }
              }

              _checkTargetTextureEvent(old) {
                const resizeFunc = window => {
                  if (this._camera) {
                    this._camera.setFixedSize(window.width, window.height);
                  }
                };

                if (old) {
                  old.off('resize');
                }

                if (this._targetTexture) {
                  this._targetTexture.on('resize', resizeFunc, this);
                }
              }

              _updateTargetTexture() {
                if (!this._camera) {
                  return;
                }

                if (this._targetTexture) {
                  const window = this._targetTexture.window;

                  this._camera.changeTargetWindow(window);

                  this._camera.setFixedSize(window.width, window.height);
                }
              }

            }, _class3$b.ProjectionType = ProjectionType, _class3$b.FOVAxis = FOVAxis, _class3$b.ClearFlag = ClearFlag, _class3$b.Aperture = Aperture, _class3$b.Shutter = Shutter, _class3$b.ISO = ISO, _class3$b.TARGET_TEXTURE_CHANGE = 'tex-change', _temp$t), (_descriptor$p = _applyDecoratedDescriptor(_class2$s.prototype, "_projection", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ProjectionType.PERSPECTIVE;
              }
            }), _descriptor2$h = _applyDecoratedDescriptor(_class2$s.prototype, "_priority", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor3$c = _applyDecoratedDescriptor(_class2$s.prototype, "_fov", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 45;
              }
            }), _descriptor4$b = _applyDecoratedDescriptor(_class2$s.prototype, "_fovAxis", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return FOVAxis.VERTICAL;
              }
            }), _descriptor5$9 = _applyDecoratedDescriptor(_class2$s.prototype, "_orthoHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 10;
              }
            }), _descriptor6$4 = _applyDecoratedDescriptor(_class2$s.prototype, "_near", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor7$4 = _applyDecoratedDescriptor(_class2$s.prototype, "_far", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1000;
              }
            }), _descriptor8$4 = _applyDecoratedDescriptor(_class2$s.prototype, "_color", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color('#333333');
              }
            }), _descriptor9$3 = _applyDecoratedDescriptor(_class2$s.prototype, "_depth", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor10$3 = _applyDecoratedDescriptor(_class2$s.prototype, "_stencil", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor11$2 = _applyDecoratedDescriptor(_class2$s.prototype, "_clearFlags", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ClearFlag.SOLID_COLOR;
              }
            }), _descriptor12$2 = _applyDecoratedDescriptor(_class2$s.prototype, "_rect", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Rect(0, 0, 1, 1);
              }
            }), _descriptor13$2 = _applyDecoratedDescriptor(_class2$s.prototype, "_aperture", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Aperture.F16_0;
              }
            }), _descriptor14$2 = _applyDecoratedDescriptor(_class2$s.prototype, "_shutter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Shutter.D125;
              }
            }), _descriptor15$2 = _applyDecoratedDescriptor(_class2$s.prototype, "_iso", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ISO.ISO100;
              }
            }), _descriptor16$2 = _applyDecoratedDescriptor(_class2$s.prototype, "_screenScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor17$2 = _applyDecoratedDescriptor(_class2$s.prototype, "_visibility", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return CAMERA_DEFAULT_MASK;
              }
            }), _descriptor18$2 = _applyDecoratedDescriptor(_class2$s.prototype, "_targetTexture", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$s.prototype, "priority", [_dec4$5, _dec5$4], Object.getOwnPropertyDescriptor(_class2$s.prototype, "priority"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "visibility", [_dec6$3, _dec7$2, _dec8$2], Object.getOwnPropertyDescriptor(_class2$s.prototype, "visibility"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "clearFlags", [_dec9$2, _dec10$2, _dec11$2], Object.getOwnPropertyDescriptor(_class2$s.prototype, "clearFlags"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "clearColor", [_dec12$2, _dec13$2], Object.getOwnPropertyDescriptor(_class2$s.prototype, "clearColor"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "clearDepth", [_dec14$2, _dec15$2], Object.getOwnPropertyDescriptor(_class2$s.prototype, "clearDepth"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "clearStencil", [_dec16$2, _dec17$2], Object.getOwnPropertyDescriptor(_class2$s.prototype, "clearStencil"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "projection", [_dec18$2, _dec19$2, _dec20$2], Object.getOwnPropertyDescriptor(_class2$s.prototype, "projection"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "fovAxis", [_dec21$2, _dec22$2, _dec23$2], Object.getOwnPropertyDescriptor(_class2$s.prototype, "fovAxis"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "fov", [_dec24$2, _dec25$2], Object.getOwnPropertyDescriptor(_class2$s.prototype, "fov"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "orthoHeight", [_dec26$1, _dec27$1], Object.getOwnPropertyDescriptor(_class2$s.prototype, "orthoHeight"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "near", [_dec28$1, _dec29$1], Object.getOwnPropertyDescriptor(_class2$s.prototype, "near"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "far", [_dec30$1, _dec31$1], Object.getOwnPropertyDescriptor(_class2$s.prototype, "far"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "aperture", [_dec32$1, _dec33$1, _dec34$1], Object.getOwnPropertyDescriptor(_class2$s.prototype, "aperture"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "shutter", [_dec35$1, _dec36$1, _dec37$1], Object.getOwnPropertyDescriptor(_class2$s.prototype, "shutter"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "iso", [_dec38$1, _dec39$1, _dec40$1], Object.getOwnPropertyDescriptor(_class2$s.prototype, "iso"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "rect", [_dec41$1, _dec42$1], Object.getOwnPropertyDescriptor(_class2$s.prototype, "rect"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "targetTexture", [_dec43$1, _dec44$1, _dec45$1], Object.getOwnPropertyDescriptor(_class2$s.prototype, "targetTexture"), _class2$s.prototype)), _class2$s)) || _class$w) || _class$w) || _class$w) || _class$w));
            legacyCC.Camera = Camera$1;

            var _dec$x, _dec2$e, _dec3$8, _dec4$6, _dec5$5, _class$x, _class2$t, _descriptor$q, _descriptor2$i, _temp$u;
            const _matInsInfo = {
              parent: null,
              owner: null,
              subModelIdx: 0
            };
            let RenderableComponent = exports('c1', (_dec$x = ccclass('cc.RenderableComponent'), _dec2$e = type([Material]), _dec3$8 = type(Material), _dec4$6 = displayOrder(), _dec5$5 = displayName(), _dec$x(_class$x = (_class2$t = (_temp$u = class RenderableComponent extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_materials", _descriptor$q, this);

                _initializerDefineProperty(this, "_visFlags", _descriptor2$i, this);

                this._materialInstances = [];
                this._models = [];
              }

              get visibility() {
                return this._visFlags;
              }

              set visibility(val) {
                this._visFlags = val;

                this._onVisibilityChange(val);
              }

              get sharedMaterials() {
                return  this._materials;
              }

              set sharedMaterials(val) {
                for (let i = 0; i < val.length; i++) {
                  if (val[i] !== this._materials[i]) {
                    this.setMaterial(val[i], i);
                  }
                }

                if (val.length < this._materials.length) {
                  for (let i = val.length; i < this._materials.length; i++) {
                    this.setMaterial(null, i);
                  }

                  this._materials.splice(val.length);
                }
              }

              get materials() {
                for (let i = 0; i < this._materials.length; i++) {
                  this._materialInstances[i] = this.getMaterialInstance(i);
                }

                return this._materialInstances;
              }

              set materials(val) {
                const dLen = val.length - this._materials.length;

                if (dLen > 0) {
                  this._materials.length = val.length;
                  this._materialInstances.length = val.length;
                } else if (dLen < 0) {
                  for (let i = this._materials.length - dLen; i < this._materials.length; ++i) {
                    this.setMaterialInstance(null, i);
                  }
                }

                for (let i = 0; i < this._materialInstances.length; i++) {
                  if (this._materialInstances[i] != val[i]) {
                    this.setMaterialInstance(val[i], i);
                  }
                }
              }

              get sharedMaterial() {
                return this.getMaterial(0);
              }

              getMaterial(idx) {
                if (idx < 0 || idx >= this._materials.length) {
                  return null;
                }

                return this._materials[idx];
              }

              setMaterial(material, index) {
                if (material && material instanceof MaterialInstance) {
                  console.error('Can\'t set a material instance to a sharedMaterial slot');
                }

                this._materials[index] = material;
                const inst = this._materialInstances[index];

                if (inst) {
                  inst.destroy();
                  this._materialInstances[index] = null;
                }

                this._onMaterialModified(index, this._materials[index]);
              }

              get material() {
                return this.getMaterialInstance(0);
              }

              set material(val) {
                if (this._materials.length === 1 && !this._materialInstances[0] && this._materials[0] === val) {
                  return;
                }

                this.setMaterialInstance(val, 0);
              }

              getMaterialInstance(idx) {
                const mat = this._materials[idx];

                if (!mat) {
                  return null;
                }

                if (!this._materialInstances[idx]) {
                  _matInsInfo.parent = this._materials[idx];
                  _matInsInfo.owner = this;
                  _matInsInfo.subModelIdx = idx;
                  const instantiated = new MaterialInstance(_matInsInfo);
                  _matInsInfo.parent = null;
                  _matInsInfo.owner = null;
                  _matInsInfo.subModelIdx = 0;
                  this.setMaterialInstance(instantiated, idx);
                }

                return this._materialInstances[idx];
              }

              setMaterialInstance(matInst, index) {
                if (typeof matInst === 'number') {
                  warnID(12007);
                  const temp = matInst;
                  matInst = index;
                  index = temp;
                }

                const curInst = this._materialInstances[index];

                if (matInst && matInst.parent) {
                  if (matInst !== curInst) {
                    this._materialInstances[index] = matInst;

                    this._onMaterialModified(index, matInst);
                  }

                  return;
                }

                if (matInst !== this._materials[index] || curInst) {
                  this.setMaterial(matInst, index);
                }
              }

              getRenderMaterial(index) {
                return this._materialInstances[index] || this._materials[index];
              }

              _collectModels() {
                return this._models;
              }

              _attachToScene() {}

              _detachFromScene() {}

              _onMaterialModified(index, material) {}

              _onRebuildPSO(index, material) {}

              _clearMaterials() {}

              _onVisibilityChange(val) {}

            }, _temp$u), (_descriptor$q = _applyDecoratedDescriptor(_class2$t.prototype, "_materials", [_dec2$e], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2$i = _applyDecoratedDescriptor(_class2$t.prototype, "_visFlags", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Layers.Enum.NONE;
              }
            }), _applyDecoratedDescriptor(_class2$t.prototype, "sharedMaterials", [_dec3$8, _dec4$6, _dec5$5], Object.getOwnPropertyDescriptor(_class2$t.prototype, "sharedMaterials"), _class2$t.prototype)), _class2$t)) || _class$x));
            legacyCC.RenderableComponent = RenderableComponent;

            replaceProperty(Camera$1, 'Camera', [{
              name: 'CameraClearFlag',
              newName: 'ClearFlag'
            }]);
            replaceProperty(Camera$1.prototype, 'Camera.prototype', [{
              name: 'color',
              newName: 'clearColor'
            }, {
              name: 'depth',
              newName: 'clearDepth'
            }, {
              name: 'stencil',
              newName: 'clearStencil'
            }]);
            legacyCC.CameraComponent = Camera$1;
            js.setClassAlias(Camera$1, 'cc.CameraComponent');

            var _dec$y, _class$y, _class2$u, _descriptor$r, _temp$v, _dec2$f, _class4$4, _class5$4, _descriptor2$j, _temp2$4;
            function isPropertyPath(path) {
              return typeof path === 'string' || typeof path === 'number';
            }
            function isCustomPath(path, constructor) {
              return path instanceof constructor;
            }
            let HierarchyPath = exports('be', (_dec$y = ccclass('cc.animation.HierarchyPath'), _dec$y(_class$y = (_class2$u = (_temp$v = class HierarchyPath {
              constructor(path) {
                _initializerDefineProperty(this, "path", _descriptor$r, this);

                this.path = path || '';
              }

              get(target) {
                if (!(target instanceof Node$1)) {
                  warnID(3925);
                  return null;
                }

                const result = target.getChildByPath(this.path);

                if (!result) {
                  warnID(3926, target.name, this.path);
                  return null;
                }

                return result;
              }

            }, _temp$v), (_descriptor$r = _applyDecoratedDescriptor(_class2$u.prototype, "path", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class2$u)) || _class$y));
            let ComponentPath = exports('bf', (_dec2$f = ccclass('cc.animation.ComponentPath'), _dec2$f(_class4$4 = (_class5$4 = (_temp2$4 = class ComponentPath {
              constructor(component) {
                _initializerDefineProperty(this, "component", _descriptor2$j, this);

                this.component = component || '';
              }

              get(target) {
                if (!(target instanceof Node$1)) {
                  warnID(3927);
                  return null;
                }

                const result = target.getComponent(this.component);

                if (!result) {
                  warnID(3928, target.name, this.component);
                  return null;
                }

                return result;
              }

            }, _temp2$4), (_descriptor2$j = _applyDecoratedDescriptor(_class5$4.prototype, "component", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class5$4)) || _class4$4));

            var _dec$z, _class$z, _class2$v, _descriptor$s, _descriptor2$k, _descriptor3$d, _temp$w;
            let UniformProxyFactory = exports('b0', (_dec$z = ccclass('cc.animation.UniformProxyFactory'), _dec$z(_class$z = (_class2$v = (_temp$w = class UniformProxyFactory {
              constructor(uniformName, passIndex) {
                _initializerDefineProperty(this, "passIndex", _descriptor$s, this);

                _initializerDefineProperty(this, "uniformName", _descriptor2$k, this);

                _initializerDefineProperty(this, "channelIndex", _descriptor3$d, this);

                this.passIndex = passIndex || 0;
                this.uniformName = uniformName || '';
              }

              forTarget(target) {
                const pass = target.passes[this.passIndex];
                const handle = pass.getHandle(this.uniformName);

                if (!handle) {
                  throw new Error(`Material "${target.name}" has no uniform "${this.uniformName}"`);
                }

                const propertyType = Pass.getPropertyTypeFromHandle(handle);

                if (propertyType === PropertyType.BUFFER) {
                  const realHandle = this.channelIndex === undefined ? handle : pass.getHandle(this.uniformName, this.channelIndex, Type.FLOAT);

                  if (!realHandle) {
                    throw new Error(`Uniform "${this.uniformName} (in material ${target.name}) has no channel ${this.channelIndex}"`);
                  }

                  if (isUniformArray(pass, this.uniformName)) {
                    return {
                      set: value => {
                        pass.setUniformArray(realHandle, value);
                      }
                    };
                  }

                  return {
                    set: value => {
                      pass.setUniform(realHandle, value);
                    }
                  };
                }

                if (propertyType === PropertyType.TEXTURE) {
                  const binding = Pass.getBindingFromHandle(handle);
                  const prop = pass.properties[this.uniformName];
                  const texName = prop && prop.value ? `${prop.value}-texture` : getDefaultFromType(prop.type);
                  let dftTex = builtinResMgr.get(texName);

                  if (!dftTex) {
                    warn(`Illegal texture default value: ${texName}.`);
                    dftTex = builtinResMgr.get('default-texture');
                  }

                  return {
                    set: value => {
                      if (!value) {
                        value = dftTex;
                      }

                      const texture = value.getGFXTexture();

                      if (!texture || !texture.width || !texture.height) {
                        return;
                      }

                      pass.bindTexture(binding, texture);

                      if (value instanceof TextureBase) {
                        pass.bindSampler(binding, samplerLib.getSampler(legacyCC.game._gfxDevice, value.getSamplerHash()));
                      }
                    }
                  };
                }

                throw new Error(`Animations are not available for uniforms with property type ${propertyType}.`);
              }

            }, _temp$w), (_descriptor$s = _applyDecoratedDescriptor(_class2$v.prototype, "passIndex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$k = _applyDecoratedDescriptor(_class2$v.prototype, "uniformName", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor3$d = _applyDecoratedDescriptor(_class2$v.prototype, "channelIndex", [float], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return undefined;
              }
            })), _class2$v)) || _class$z));

            function isUniformArray(pass, name) {
              for (const block of pass.shaderInfo.blocks) {
                for (const uniform of block.members) {
                  if (uniform.name === name) {
                    return uniform.count > 1;
                  }
                }
              }

              return false;
            }

            var _dec$A, _class$A, _class2$w, _descriptor$t, _descriptor2$l, _temp$x, _dec2$g, _class4$5, _class5$5, _descriptor3$e, _temp2$5, _dec3$9, _class7$2;
            let MorphWeightValueProxy = exports('b1', (_dec$A = ccclass('cc.animation.MorphWeightValueProxy'), _dec$A(_class$A = (_class2$w = (_temp$x = class MorphWeightValueProxy {
              constructor() {
                _initializerDefineProperty(this, "subMeshIndex", _descriptor$t, this);

                _initializerDefineProperty(this, "shapeIndex", _descriptor2$l, this);
              }

              forTarget(target) {
                return {
                  set: value => {
                    target.setWeight(value, this.subMeshIndex, this.shapeIndex);
                  }
                };
              }

            }, _temp$x), (_descriptor$t = _applyDecoratedDescriptor(_class2$w.prototype, "subMeshIndex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$l = _applyDecoratedDescriptor(_class2$w.prototype, "shapeIndex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$w)) || _class$A));
            let MorphWeightsValueProxy = exports('b2', (_dec2$g = ccclass('cc.animation.MorphWeightsValueProxy'), _dec2$g(_class4$5 = (_class5$5 = (_temp2$5 = class MorphWeightsValueProxy {
              constructor() {
                _initializerDefineProperty(this, "subMeshIndex", _descriptor3$e, this);
              }

              forTarget(target) {
                return {
                  set: value => {
                    target.setWeights(value, this.subMeshIndex);
                  }
                };
              }

            }, _temp2$5), (_descriptor3$e = _applyDecoratedDescriptor(_class5$5.prototype, "subMeshIndex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class5$5)) || _class4$5));
            let MorphWeightsAllValueProxy = exports('b3', (_dec3$9 = ccclass('cc.animation.MorphWeightsAllValueProxy'), _dec3$9(_class7$2 = class MorphWeightsAllValueProxy {
              forTarget(target) {
                return {
                  set: value => {
                    var _target$mesh$struct$p, _target$mesh;

                    const nSubMeshes = (_target$mesh$struct$p = (_target$mesh = target.mesh) === null || _target$mesh === void 0 ? void 0 : _target$mesh.struct.primitives.length) !== null && _target$mesh$struct$p !== void 0 ? _target$mesh$struct$p : 0;

                    for (let iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                      target.setWeights(value, iSubMesh);
                    }
                  }
                };
              }

            }) || _class7$2));

            var _dec2$h, _class4$6, _class5$6, _descriptor4$c, _descriptor5$a, _descriptor6$5, _temp2$6;

            function makeCubicSplineValueConstructor(name, constructorX, scaleFx, scaleAndAdd) {
              var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;

              let tempValue = new constructorX();
              let m0 = new constructorX();
              let m1 = new constructorX();
              let CubicSplineValueClass = (_dec = ccclass(name), _dec(_class = (_class2 = (_temp = class CubicSplineValueClass {
                constructor(dataPoint, inTangent, outTangent) {
                  _initializerDefineProperty(this, "dataPoint", _descriptor, this);

                  _initializerDefineProperty(this, "inTangent", _descriptor2, this);

                  _initializerDefineProperty(this, "outTangent", _descriptor3, this);

                  this.dataPoint = dataPoint || new constructorX();
                  this.inTangent = inTangent || new constructorX();
                  this.outTangent = outTangent || new constructorX();
                }

                lerp(to, t, dt) {
                  const p0 = this.dataPoint;
                  const p1 = to.dataPoint;
                  m0 = scaleFx(m0, this.inTangent, dt);
                  m1 = scaleFx(m1, to.outTangent, dt);
                  const t_3 = t * t * t;
                  const t_2 = t * t;
                  const f_0 = 2 * t_3 - 3 * t_2 + 1;
                  const f_1 = t_3 - 2 * t_2 + t;
                  const f_2 = -2 * t_3 + 3 * t_2;
                  const f_3 = t_3 - t_2;
                  tempValue = scaleFx(tempValue, p0, f_0);
                  tempValue = scaleAndAdd(tempValue, tempValue, m0, f_1);
                  tempValue = scaleAndAdd(tempValue, tempValue, p1, f_2);
                  tempValue = scaleAndAdd(tempValue, tempValue, m1, f_3);
                  return tempValue;
                }

                getNoLerp() {
                  return this.dataPoint;
                }

              }, _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "dataPoint", [serializable], {
                configurable: true,
                enumerable: true,
                writable: true,
                initializer: function () {
                  return new constructorX();
                }
              }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "inTangent", [serializable], {
                configurable: true,
                enumerable: true,
                writable: true,
                initializer: function () {
                  return new constructorX();
                }
              }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "outTangent", [serializable], {
                configurable: true,
                enumerable: true,
                writable: true,
                initializer: function () {
                  return new constructorX();
                }
              })), _class2)) || _class);

              if (constructorX === Quat) {
                const lerp = CubicSplineValueClass.prototype.lerp;

                CubicSplineValueClass.prototype.lerp = function (to, t, dt) {
                  const result = lerp.call(this, to, t, dt);
                  Quat.normalize(result, result);
                  return result;
                };
              }

              return CubicSplineValueClass;
            }

            const CubicSplineVec2Value = exports('bg', makeCubicSplineValueConstructor('cc.CubicSplineVec2Value', Vec2, Vec2.multiplyScalar, Vec2.scaleAndAdd));
            legacyCC.CubicSplineVec2Value = CubicSplineVec2Value;
            const CubicSplineVec3Value = exports('bh', makeCubicSplineValueConstructor('cc.CubicSplineVec3Value', Vec3, Vec3.multiplyScalar, Vec3.scaleAndAdd));
            legacyCC.CubicSplineVec3Value = CubicSplineVec3Value;
            const CubicSplineVec4Value = exports('bi', makeCubicSplineValueConstructor('cc.CubicSplineVec4Value', Vec4, Vec4.multiplyScalar, Vec4.scaleAndAdd));
            legacyCC.CubicSplineVec4Value = CubicSplineVec4Value;
            const CubicSplineQuatValue = exports('bj', makeCubicSplineValueConstructor('cc.CubicSplineQuatValue', Quat, Quat.multiplyScalar, Quat.scaleAndAdd));
            legacyCC.CubicSplineQuatValue = CubicSplineQuatValue;
            let CubicSplineNumberValue = exports('bk', (_dec2$h = ccclass('cc.CubicSplineNumberValue'), _dec2$h(_class4$6 = (_class5$6 = (_temp2$6 = class CubicSplineNumberValue {
              constructor(dataPoint, inTangent, outTangent) {
                _initializerDefineProperty(this, "dataPoint", _descriptor4$c, this);

                _initializerDefineProperty(this, "inTangent", _descriptor5$a, this);

                _initializerDefineProperty(this, "outTangent", _descriptor6$5, this);

                this.dataPoint = dataPoint;
                this.inTangent = inTangent;
                this.outTangent = outTangent;
              }

              lerp(to, t, dt) {
                const p0 = this.dataPoint;
                const p1 = to.dataPoint;
                const m0 = this.outTangent * dt;
                const m1 = to.inTangent * dt;
                const t_3 = t * t * t;
                const t_2 = t * t;
                const f_0 = 2 * t_3 - 3 * t_2 + 1;
                const f_1 = t_3 - 2 * t_2 + t;
                const f_2 = -2 * t_3 + 3 * t_2;
                const f_3 = t_3 - t_2;
                return p0 * f_0 + m0 * f_1 + p1 * f_2 + m1 * f_3;
              }

              getNoLerp() {
                return this.dataPoint;
              }

            }, _temp2$6), (_descriptor4$c = _applyDecoratedDescriptor(_class5$6.prototype, "dataPoint", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor5$a = _applyDecoratedDescriptor(_class5$6.prototype, "inTangent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor6$5 = _applyDecoratedDescriptor(_class5$6.prototype, "outTangent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class5$6)) || _class4$6));
            legacyCC.CubicSplineNumberValue = CubicSplineNumberValue;

            const CLASS_NAME_PREFIX_ANIM = 'cc.animation.';
            const createEvalSymbol = Symbol('CreateEval');

            var _dec$B, _class$B, _class2$x, _descriptor$u, _temp$y, _dec2$i, _class4$7, _class5$7, _descriptor2$m, _descriptor3$f, _temp2$7, _dec3$a, _class7$3, _class8$2, _descriptor4$d, _temp3$2, _dec4$7, _class10$2, _class11$2, _descriptor5$b, _temp4$2, _dec5$6, _class13$2, _class14$2, _descriptor6$6, _temp5$2;
            const normalizedFollowTag = Symbol('NormalizedFollow');
            const parseTrsPathTag = Symbol('ConvertAsTrsPath');
            const trackBindingTag = Symbol('TrackBinding');
            let TrackPath = exports('b5', (_dec$B = ccclass(`${CLASS_NAME_PREFIX_ANIM}TrackPath`), _dec$B(_class$B = (_class2$x = (_temp$y = class TrackPath {
              constructor() {
                _initializerDefineProperty(this, "_paths", _descriptor$u, this);
              }

              get length() {
                return this._paths.length;
              }

              toProperty(name) {
                this._paths.push(name);

                return this;
              }

              toElement(index) {
                this._paths.push(index);

                return this;
              }

              toHierarchy(nodePath) {
                this._paths.push(new HierarchyPath(nodePath));

                return this;
              }

              toComponent(constructor) {
                const path = new ComponentPath(typeof constructor === 'string' ? constructor : js.getClassName(constructor));

                this._paths.push(path);

                return this;
              }

              toCustomized(resolver) {
                this._paths.push(resolver);

                return this;
              }

              append(...trackPaths) {
                const paths = this._paths.concat(...trackPaths.map(trackPath => trackPath._paths));

                this._paths = paths;
                return this;
              }

              isPropertyAt(index) {
                return typeof this._paths[index] === 'string';
              }

              parsePropertyAt(index) {
                return this._paths[index];
              }

              isElementAt(index) {
                return typeof this._paths[index] === 'number';
              }

              parseElementAt(index) {
                return this._paths[index];
              }

              isHierarchyAt(index) {
                return this._paths[index] instanceof HierarchyPath;
              }

              parseHierarchyAt(index) {
                assertIsTrue(this.isHierarchyAt(index));
                return this._paths[index].path;
              }

              isComponentAt(index) {
                return this._paths[index] instanceof ComponentPath;
              }

              parseComponentAt(index) {
                assertIsTrue(this.isComponentAt(index));
                return this._paths[index].component;
              }

              slice(beginIndex, endIndex) {
                const trackPath = new TrackPath();
                trackPath._paths = this._paths.slice(beginIndex, endIndex);
                return trackPath;
              }

              trace(object, beginIndex, endIndex) {
                var _beginIndex, _endIndex;

                (_beginIndex = beginIndex) !== null && _beginIndex !== void 0 ? _beginIndex : beginIndex = 0;
                (_endIndex = endIndex) !== null && _endIndex !== void 0 ? _endIndex : endIndex = this._paths.length;
                return this[normalizedFollowTag](object, beginIndex, endIndex);
              }

              [parseTrsPathTag]() {
                const {
                  _paths: paths
                } = this;
                const nPaths = paths.length;
                let iPath = 0;
                let nodePath = '';

                for (; iPath < nPaths; ++iPath) {
                  const path = paths[iPath];

                  if (!(path instanceof HierarchyPath)) {
                    break;
                  } else if (!path.path) {
                    continue;
                  } else if (nodePath) {
                    nodePath += `/${path.path}`;
                  } else {
                    nodePath = path.path;
                  }
                }

                if (iPath === nPaths) {
                  return null;
                }

                let prs;

                if (iPath !== nPaths - 1) {
                  return null;
                }

                switch (paths[iPath]) {
                  case 'position':
                  case 'scale':
                  case 'rotation':
                  case 'eulerAngles':
                    prs = paths[iPath];
                    break;

                  default:
                    return null;
                }

                return {
                  node: nodePath,
                  property: prs
                };
              }

              [normalizedFollowTag](root, beginIndex, endIndex) {
                const {
                  _paths: paths
                } = this;
                let result = root;

                for (let iPath = beginIndex; iPath < endIndex; ++iPath) {
                  const path = paths[iPath];

                  if (isPropertyPath(path)) {
                    if (!(path in result)) {
                      warnID(3929, path);
                      return null;
                    } else {
                      result = result[path];
                    }
                  } else {
                    result = path.get(result);
                  }

                  if (result === null) {
                    break;
                  }
                }

                return result;
              }

            }, _temp$y), (_descriptor$u = _applyDecoratedDescriptor(_class2$x.prototype, "_paths", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$x)) || _class$B));
            let TrackBinding = (_dec2$i = ccclass(`${CLASS_NAME_PREFIX_ANIM}TrackBinding`), _dec2$i(_class4$7 = uniquelyReferenced(_class4$7 = (_class5$7 = (_temp2$7 = class TrackBinding {
              constructor() {
                _initializerDefineProperty(this, "path", _descriptor2$m, this);

                _initializerDefineProperty(this, "proxy", _descriptor3$f, this);
              }

              parseTrsPath() {
                if (this.proxy) {
                  return null;
                } else {
                  return this.path[parseTrsPathTag]();
                }
              }

              createRuntimeBinding(target, poseOutput, isConstant) {
                const {
                  path,
                  proxy
                } = this;
                const nPaths = path.length;
                const iLastPath = nPaths - 1;

                if (nPaths !== 0 && (path.isPropertyAt(iLastPath) || path.isElementAt(iLastPath)) && !proxy) {
                  const lastPropertyKey = path.isPropertyAt(iLastPath) ? path.parsePropertyAt(iLastPath) : path.parseElementAt(iLastPath);
                  const resultTarget = path[normalizedFollowTag](target, 0, nPaths - 1);

                  if (resultTarget === null) {
                    return null;
                  }

                  if (poseOutput && resultTarget instanceof Node$1 && isTrsPropertyName(lastPropertyKey)) {
                    const blendStateWriter = poseOutput.createPoseWriter(resultTarget, lastPropertyKey, isConstant);
                    return blendStateWriter;
                  }

                  return {
                    setValue: value => {
                      resultTarget[lastPropertyKey] = value;
                    },
                    getValue: () => {
                      return resultTarget[lastPropertyKey];
                    }
                  };
                } else if (!proxy) {
                  errorID(3921);
                  return null;
                } else {
                  const resultTarget = path[normalizedFollowTag](target, 0, nPaths);

                  if (resultTarget === null) {
                    return null;
                  }

                  const runtimeProxy = proxy.forTarget(resultTarget);
                  const binding = {
                    setValue: value => {
                      runtimeProxy.set(value);
                    }
                  };
                  const proxyGet = runtimeProxy.get;

                  if (proxyGet) {
                    binding.getValue = () => proxyGet.call(runtimeProxy);
                  }

                  return binding;
                }
              }

            }, _temp2$7), (_descriptor2$m = _applyDecoratedDescriptor(_class5$7.prototype, "path", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new TrackPath();
              }
            }), _descriptor3$f = _applyDecoratedDescriptor(_class5$7.prototype, "proxy", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class5$7)) || _class4$7) || _class4$7);

            function isTrsPropertyName(name) {
              return name === 'position' || name === 'rotation' || name === 'scale' || name === 'eulerAngles';
            }
            let Track = exports('b4', (_dec3$a = ccclass(`${CLASS_NAME_PREFIX_ANIM}Track`), _dec3$a(_class7$3 = (_class8$2 = (_temp3$2 = class Track {
              constructor() {
                _initializerDefineProperty(this, "_binding", _descriptor4$d, this);
              }

              get path() {
                return this._binding.path;
              }

              set path(value) {
                this._binding.path = value;
              }

              get proxy() {
                return this._binding.proxy;
              }

              set proxy(value) {
                this._binding.proxy = value;
              }

              get [trackBindingTag]() {
                return this._binding;
              }

              channels() {
                return [];
              }

              range() {
                const range = {
                  min: Infinity,
                  max: -Infinity
                };

                for (const channel of this.channels()) {
                  range.min = Math.min(range.min, channel.curve.rangeMin);
                  range.max = Math.max(range.max, channel.curve.rangeMax);
                }

                return range;
              }

              [createEvalSymbol](runtimeBinding) {
                throw new Error(`No Impl`);
              }

            }, _temp3$2), (_descriptor4$d = _applyDecoratedDescriptor(_class8$2.prototype, "_binding", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new TrackBinding();
              }
            })), _class8$2)) || _class7$3));
            let Channel = (_dec4$7 = ccclass(`${CLASS_NAME_PREFIX_ANIM}Channel`), _dec4$7(_class10$2 = (_class11$2 = (_temp4$2 = class Channel {
              constructor(curve) {
                this.name = '';

                _initializerDefineProperty(this, "_curve", _descriptor5$b, this);

                this._curve = curve;
              }

              get curve() {
                return this._curve;
              }

            }, _temp4$2), (_descriptor5$b = _applyDecoratedDescriptor(_class11$2.prototype, "_curve", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class11$2)) || _class10$2);
            let SingleChannelTrack = (_dec5$6 = ccclass(`${CLASS_NAME_PREFIX_ANIM}SingleChannelTrack`), _dec5$6(_class13$2 = (_class14$2 = (_temp5$2 = class SingleChannelTrack extends Track {
              constructor() {
                super();

                _initializerDefineProperty(this, "_channel", _descriptor6$6, this);

                this._channel = new Channel(this.createCurve());
              }

              get channel() {
                return this._channel;
              }

              channels() {
                return [this._channel];
              }

              createCurve() {
                throw new Error(`Not impl`);
              }

              [createEvalSymbol](_runtimeBinding) {
                const {
                  curve
                } = this._channel;
                return new SingleChannelTrackEval(curve);
              }

            }, _temp5$2), (_descriptor6$6 = _applyDecoratedDescriptor(_class14$2.prototype, "_channel", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class14$2)) || _class13$2);

            class SingleChannelTrackEval {
              constructor(_curve) {
                this._curve = _curve;
              }

              evaluate(time) {
                return this._curve.evaluate(time);
              }

            }

            var _dec$C, _class$C;
            let RealTrack = exports('b6', (_dec$C = ccclass(`${CLASS_NAME_PREFIX_ANIM}RealTrack`), _dec$C(_class$C = class RealTrack extends SingleChannelTrack {
              createCurve() {
                return new RealCurve();
              }

            }) || _class$C));

            function maskIfEmpty(curve) {
              return curve.keyFramesCount === 0 ? undefined : curve;
            }

            var _dec$D, _class$D, _class2$y, _descriptor$v, _descriptor2$n, _temp$z;
            const CHANNEL_NAMES = ['X', 'Y', 'Z', 'W'];
            let VectorTrack = exports('b7', (_dec$D = ccclass(`${CLASS_NAME_PREFIX_ANIM}VectorTrack`), _dec$D(_class$D = (_class2$y = (_temp$z = class VectorTrack extends Track {
              constructor() {
                super();

                _initializerDefineProperty(this, "_channels", _descriptor$v, this);

                _initializerDefineProperty(this, "_nComponents", _descriptor2$n, this);

                this._channels = new Array(4);

                for (let i = 0; i < this._channels.length; ++i) {
                  const channel = new Channel(new RealCurve());
                  channel.name = CHANNEL_NAMES[i];
                  this._channels[i] = channel;
                }
              }

              get componentsCount() {
                return this._nComponents;
              }

              set componentsCount(value) {
                this._nComponents = value;
              }

              channels() {
                return this._channels;
              }

              [createEvalSymbol]() {
                switch (this._nComponents) {
                  default:
                  case 2:
                    return new Vec2TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve));

                  case 3:
                    return new Vec3TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve));

                  case 4:
                    return new Vec4TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve), maskIfEmpty(this._channels[3].curve));
                }
              }

            }, _temp$z), (_descriptor$v = _applyDecoratedDescriptor(_class2$y.prototype, "_channels", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor2$n = _applyDecoratedDescriptor(_class2$y.prototype, "_nComponents", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 4;
              }
            })), _class2$y)) || _class$D));
            class Vec2TrackEval {
              constructor(_x, _y) {
                this._result = new Vec2();
                this._x = _x;
                this._y = _y;
              }

              evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y) && runtimeBinding.getValue) {
                  Vec2.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.x = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.y = this._y.evaluate(time);
                }

                return this._result;
              }

            }
            class Vec3TrackEval {
              constructor(_x, _y, _z) {
                this._result = new Vec3();
                this._x = _x;
                this._y = _y;
                this._z = _z;
              }

              evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y || !this._z) && runtimeBinding.getValue) {
                  Vec3.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.x = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.y = this._y.evaluate(time);
                }

                if (this._z) {
                  this._result.z = this._z.evaluate(time);
                }

                return this._result;
              }

            }
            class Vec4TrackEval {
              constructor(_x, _y, _z, _w) {
                this._result = new Vec4();
                this._x = _x;
                this._y = _y;
                this._z = _z;
                this._w = _w;
              }

              evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y || !this._z || !this._w) && runtimeBinding.getValue) {
                  Vec4.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.x = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.y = this._y.evaluate(time);
                }

                if (this._z) {
                  this._result.z = this._z.evaluate(time);
                }

                if (this._w) {
                  this._result.w = this._w.evaluate(time);
                }

                return this._result;
              }

            }

            var _dec$E, _class$E;
            let QuatTrack = exports('b8', (_dec$E = ccclass(`${CLASS_NAME_PREFIX_ANIM}QuatTrack`), _dec$E(_class$E = class QuatTrack extends SingleChannelTrack {
              createCurve() {
                return new QuatCurve();
              }

              [createEvalSymbol]() {
                return new QuatTrackEval(this.channels()[0].curve);
              }

            }) || _class$E));
            class QuatTrackEval {
              constructor(_curve) {
                this._result = new Quat();
                this._curve = _curve;
              }

              evaluate(time) {
                this._curve.evaluate(time, this._result);

                return this._result;
              }

            }

            var _dec$F, _class$F, _class2$z, _descriptor$w, _temp$A;
            const CHANNEL_NAMES$1 = ['Red', 'Green', 'Blue', 'Alpha'];
            let ColorTrack = exports('b9', (_dec$F = ccclass(`${CLASS_NAME_PREFIX_ANIM}ColorTrack`), _dec$F(_class$F = (_class2$z = (_temp$A = class ColorTrack extends Track {
              constructor() {
                super();

                _initializerDefineProperty(this, "_channels", _descriptor$w, this);

                this._channels = new Array(4);

                for (let i = 0; i < this._channels.length; ++i) {
                  const channel = new Channel(new RealCurve());
                  channel.name = CHANNEL_NAMES$1[i];
                  this._channels[i] = channel;
                }
              }

              channels() {
                return this._channels;
              }

              [createEvalSymbol]() {
                return new ColorTrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve), maskIfEmpty(this._channels[3].curve));
              }

            }, _temp$A), (_descriptor$w = _applyDecoratedDescriptor(_class2$z.prototype, "_channels", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class2$z)) || _class$F));
            class ColorTrackEval {
              constructor(_x, _y, _z, _w) {
                this._result = new Color();
                this._x = _x;
                this._y = _y;
                this._z = _z;
                this._w = _w;
              }

              evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y || !this._z || !this._w) && runtimeBinding.getValue) {
                  Color.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.r = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.g = this._y.evaluate(time);
                }

                if (this._z) {
                  this._result.b = this._z.evaluate(time);
                }

                if (this._w) {
                  this._result.a = this._w.evaluate(time);
                }

                return this._result;
              }

            }

            var _dec$G, _class$G, _class2$A, _descriptor$x, _temp$B;
            const CHANNEL_NAMES$2 = ['Width', 'Height'];
            let SizeTrack = exports('ba', (_dec$G = ccclass(`${CLASS_NAME_PREFIX_ANIM}SizeTrack`), _dec$G(_class$G = (_class2$A = (_temp$B = class SizeTrack extends Track {
              constructor() {
                super();

                _initializerDefineProperty(this, "_channels", _descriptor$x, this);

                this._channels = new Array(2);

                for (let i = 0; i < this._channels.length; ++i) {
                  const channel = new Channel(new RealCurve());
                  channel.name = CHANNEL_NAMES$2[i];
                  this._channels[i] = channel;
                }
              }

              channels() {
                return this._channels;
              }

              [createEvalSymbol]() {
                return new SizeTrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve));
              }

            }, _temp$B), (_descriptor$x = _applyDecoratedDescriptor(_class2$A.prototype, "_channels", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class2$A)) || _class$G));
            class SizeTrackEval {
              constructor(_width, _height) {
                this._result = new Size();
                this._width = _width;
                this._height = _height;
              }

              evaluate(time, runtimeBinding) {
                if ((!this._width || !this._height) && runtimeBinding.getValue) {
                  const size = runtimeBinding.getValue();
                  this._result.x = size.x;
                  this._result.y = size.y;
                }

                if (this._width) {
                  this._result.width = this._width.evaluate(time);
                }

                if (this._height) {
                  this._result.height = this._height.evaluate(time);
                }

                return this._result;
              }

            }

            var _dec$H, _class$H;
            let ObjectTrack = exports('bb', (_dec$H = ccclass(`${CLASS_NAME_PREFIX_ANIM}ObjectTrack`), _dec$H(_class$H = class ObjectTrack extends SingleChannelTrack {
              createCurve() {
                return new ObjectCurve();
              }

            }) || _class$H));

            const BAKE_SKELETON_CURVE_SYMBOL = Symbol('BakeNodeCurves');

            class SkelAnimDataHub {
              static getOrExtract(clip) {
                let data = SkelAnimDataHub.pool.get(clip);

                if (!data || data.samples !== clip.sample) {
                  if (data) {
                    legacyCC.director.root.dataPoolManager.releaseAnimationClip(clip);
                  }

                  const frames = Math.ceil(clip.sample * clip.duration) + 1;
                  const step = clip.sample;
                  data = clip[BAKE_SKELETON_CURVE_SYMBOL](0, step, frames);
                  SkelAnimDataHub.pool.set(clip, data);
                }

                return data;
              }

              static destroy(clip) {
                SkelAnimDataHub.pool.delete(clip);
              }

            } exports('co', SkelAnimDataHub);
            SkelAnimDataHub.pool = new Map();

            class RatioSampler {
              constructor(ratios) {
                this.ratios = void 0;
                this._findRatio = void 0;
                this.ratios = ratios;
                let currRatioDif;
                let lastRatioDif;
                let canOptimize = true;
                const EPSILON = 1e-6;

                for (let i = 1, l = ratios.length; i < l; i++) {
                  currRatioDif = ratios[i] - ratios[i - 1];

                  if (i === 1) {
                    lastRatioDif = currRatioDif;
                  } else if (Math.abs(currRatioDif - lastRatioDif) > EPSILON) {
                    canOptimize = false;
                    break;
                  }
                }

                this._findRatio = canOptimize ? quickFindIndex : binarySearchEpsilon;
              }

              sample(ratio) {
                return this._findRatio(this.ratios, ratio);
              }

            } exports('f$', RatioSampler);
            legacyCC.RatioSampler = RatioSampler;
            class AnimCurve {
              static Bezier(controlPoints) {
                return controlPoints;
              }

              constructor(propertyCurveData, duration) {
                this.types = undefined;
                this.type = null;
                this._values = [];
                this._lerp = undefined;
                this._duration = void 0;
                this._array = void 0;
                this._duration = duration;
                this._values = propertyCurveData.values;

                const getCurveType = easingMethod => {
                  if (typeof easingMethod === 'string') {
                    return easingMethod;
                  } else if (Array.isArray(easingMethod)) {
                    if (easingMethod[0] === easingMethod[1] && easingMethod[2] === easingMethod[3]) {
                      return AnimCurve.Linear;
                    } else {
                      return AnimCurve.Bezier(easingMethod);
                    }
                  } else {
                    return AnimCurve.Linear;
                  }
                };

                if (propertyCurveData.easingMethod !== undefined) {
                  this.type = getCurveType(propertyCurveData.easingMethod);
                } else if (Array.isArray(propertyCurveData.easingMethods)) {
                  this.types = propertyCurveData.easingMethods.map(getCurveType);
                } else if (propertyCurveData.easingMethods !== undefined) {
                  this.types = new Array(this._values.length).fill(null);

                  for (const index of Object.keys(propertyCurveData.easingMethods)) {
                    this.types[index] = getCurveType(propertyCurveData.easingMethods[index]);
                  }
                } else {
                  this.type = null;
                }

                const firstValue = propertyCurveData.values[0];
                const interpolate = propertyCurveData.interpolate === undefined ? true : propertyCurveData.interpolate;

                if (interpolate) {
                  this._lerp = selectLerpFx(firstValue);
                }

                if (propertyCurveData._arrayLength !== undefined) {
                  this._array = new Array(propertyCurveData._arrayLength);
                }
              }

              hasLerp() {
                return !!this._lerp;
              }

              valueAt(index) {
                if (this._array === undefined) {
                  const value = this._values[index];

                  if (value && value.getNoLerp) {
                    return value.getNoLerp();
                  } else {
                    return value;
                  }
                } else {
                  for (let i = 0; i < this._array.length; ++i) {
                    this._array[i] = this._values[this._array.length * index + i];
                  }

                  return this._array;
                }
              }

              valueBetween(ratio, from, fromRatio, to, toRatio) {
                if (this._lerp) {
                  const type = this.types ? this.types[from] : this.type;
                  const dRatio = toRatio - fromRatio;
                  let ratioBetweenFrames = (ratio - fromRatio) / dRatio;

                  if (type) {
                    ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type);
                  }

                  if (this._array === undefined) {
                    const fromVal = this._values[from];
                    const toVal = this._values[to];

                    const value = this._lerp(fromVal, toVal, ratioBetweenFrames, dRatio * this._duration);

                    return value;
                  } else {
                    for (let i = 0; i < this._array.length; ++i) {
                      const fromVal = this._values[this._array.length * from + i];
                      const toVal = this._values[this._array.length * to + i];
                      this._array[i] = this._lerp(fromVal, toVal, ratioBetweenFrames, dRatio * this._duration);
                    }

                    return this._array;
                  }
                } else if (this._array === undefined) {
                  return this.valueAt(from);
                } else {
                  for (let i = 0; i < this._array.length; ++i) {
                    this._array[i] = this._values[this._array.length * from + i];
                  }

                  return this._array;
                }
              }

              empty() {
                return this._values.length === 0;
              }

              constant() {
                return this._values.length === 1;
              }

            } exports('g0', AnimCurve);
            AnimCurve.Linear = null;
            legacyCC.AnimCurve = AnimCurve;
            class EventInfo {
              constructor() {
                this.events = [];
              }

              add(func, params) {
                this.events.push({
                  func: func || '',
                  params: params || []
                });
              }

            } exports('g1', EventInfo);
            function sampleAnimationCurve(curve, sampler, ratio) {
              let index = sampler.sample(ratio);

              if (index < 0) {
                index = ~index;

                if (index <= 0) {
                  index = 0;
                } else if (index >= sampler.ratios.length) {
                  index = sampler.ratios.length - 1;
                } else {
                  return curve.valueBetween(ratio, index - 1, sampler.ratios[index - 1], index, sampler.ratios[index]);
                }
              }

              return curve.valueAt(index);
            }
            legacyCC.sampleAnimationCurve = sampleAnimationCurve;
            function computeRatioByType(ratio, type) {
              if (typeof type === 'string') {
                const func = easing[type];

                if (func) {
                  ratio = func(ratio);
                } else {
                  errorID(3906, type);
                }
              } else if (Array.isArray(type)) {
                ratio = bezierByTime(type, ratio);
              }

              return ratio;
            }

            function quickFindIndex(ratios, ratio) {
              const length = ratios.length - 1;

              if (length === 0) {
                return 0;
              }

              const start = ratios[0];

              if (ratio < start) {
                return 0;
              }

              const end = ratios[length];

              if (ratio > end) {
                return length;
              }

              ratio = (ratio - start) / (end - start);
              const eachLength = 1 / length;
              const index = ratio / eachLength;
              const floorIndex = index | 0;
              const EPSILON = 1e-6;

              if (index - floorIndex < EPSILON) {
                return floorIndex;
              } else if (floorIndex + 1 - index < EPSILON) {
                return floorIndex + 1;
              }

              return ~(floorIndex + 1);
            }

            const selectLerpFx = (() => {
              function makeValueTypeLerpFx(constructor) {
                const tempValue = new constructor();
                return (from, to, ratio) => {
                  constructor.lerp(tempValue, from, to, ratio);
                  return tempValue;
                };
              }

              function callLerpable(from, to, t, dt) {
                return from.lerp(to, t, dt);
              }

              function makeQuatSlerpFx() {
                const tempValue = new Quat();
                return (from, to, t, dt) => Quat.slerp(tempValue, from, to, t);
              }

              return value => {
                if (value === null) {
                  return undefined;
                }

                if (typeof value === 'number') {
                  return lerp;
                } else if (typeof value === 'object' && value.constructor) {
                  if (value instanceof Quat) {
                    return makeQuatSlerpFx();
                  } else if (value instanceof ValueType) {
                    return makeValueTypeLerpFx(value.constructor);
                  } else if (value.constructor === Number) {
                    return lerp;
                  } else if (isLerpable(value)) {
                    return callLerpable;
                  }
                }

                return undefined;
              };
            })();

            var _dec$I, _class$I, _class2$B, _descriptor$y, _temp$C, _dec2$j, _class4$8, _class5$8, _descriptor2$o, _temp2$8;
            let UntypedTrackChannel = (_dec$I = ccclass(`${CLASS_NAME_PREFIX_ANIM}UntypedTrackChannel`), _dec$I(_class$I = (_class2$B = (_temp$C = class UntypedTrackChannel extends Channel {
              constructor() {
                super(new RealCurve());

                _initializerDefineProperty(this, "property", _descriptor$y, this);
              }

            }, _temp$C), (_descriptor$y = _applyDecoratedDescriptor(_class2$B.prototype, "property", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class2$B)) || _class$I);
            let UntypedTrack = (_dec2$j = ccclass(`${CLASS_NAME_PREFIX_ANIM}UntypedTrack`), _dec2$j(_class4$8 = (_class5$8 = (_temp2$8 = class UntypedTrack extends Track {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_channels", _descriptor2$o, this);
              }

              channels() {
                return this._channels;
              }

              [createEvalSymbol](runtimeBinding) {
                if (!runtimeBinding.getValue) {
                  throw new Error(getError(3930));
                }

                const trySearchCurve = property => {
                  var _this$_channels$find;

                  return (_this$_channels$find = this._channels.find(channel => channel.property === property)) === null || _this$_channels$find === void 0 ? void 0 : _this$_channels$find.curve;
                };

                const value = runtimeBinding.getValue();

                switch (true) {
                  default:
                    throw new Error(getError(3931));

                  case value instanceof Vec2:
                    return new Vec2TrackEval(trySearchCurve('x'), trySearchCurve('y'));

                  case value instanceof Vec3:
                    return new Vec3TrackEval(trySearchCurve('x'), trySearchCurve('y'), trySearchCurve('z'));

                  case value instanceof Vec4:
                    return new Vec4TrackEval(trySearchCurve('x'), trySearchCurve('y'), trySearchCurve('z'), trySearchCurve('w'));

                  case value instanceof Color:
                    return new ColorTrackEval(trySearchCurve('r'), trySearchCurve('g'), trySearchCurve('b'), trySearchCurve('a'));

                  case value instanceof Size:
                    return new SizeTrackEval(trySearchCurve('width'), trySearchCurve('height'));
                }
              }

              addChannel(property) {
                const channel = new UntypedTrackChannel();
                channel.property = property;

                this._channels.push(channel);

                return channel;
              }

              upgrade(refine) {
                const trySearchChannel = (property, outChannel) => {
                  const untypedChannel = this.channels().find(channel => channel.property === property);

                  if (untypedChannel) {
                    outChannel.name = untypedChannel.name;
                    outChannel.curve.assignSorted(Array.from(untypedChannel.curve.times()), Array.from(untypedChannel.curve.values()));
                  }
                };

                const kind = refine(this.path, this.proxy);

                switch (kind) {
                  default:
                    break;

                  case 'vec2':
                  case 'vec3':
                  case 'vec4':
                    {
                      const track = new VectorTrack();
                      track.path = this.path;
                      track.proxy = this.proxy;
                      track.componentsCount = kind === 'vec2' ? 2 : kind === 'vec3' ? 3 : 4;
                      const [x, y, z, w] = track.channels();

                      switch (kind) {
                        case 'vec4':
                          trySearchChannel('w', w);

                        case 'vec3':
                          trySearchChannel('z', z);

                        default:
                        case 'vec2':
                          trySearchChannel('x', x);
                          trySearchChannel('y', y);
                      }

                      return track;
                    }

                  case 'color':
                    {
                      const track = new ColorTrack();
                      const [r, g, b, a] = track.channels();
                      trySearchChannel('r', r);
                      trySearchChannel('g', g);
                      trySearchChannel('b', b);
                      trySearchChannel('a', a);
                      trySearchChannel('x', r);
                      trySearchChannel('y', g);
                      trySearchChannel('z', b);
                      trySearchChannel('w', a);
                      return track;
                    }

                  case 'size':
                    break;
                }

                return null;
              }

            }, _temp2$8), (_descriptor2$o = _applyDecoratedDescriptor(_class5$8.prototype, "_channels", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class5$8)) || _class4$8);

            class AnimationClipLegacyData {
              constructor(duration) {
                this._keys = [];
                this._curves = [];
                this._commonTargets = [];
                this._ratioSamplers = [];
                this._runtimeCurves = void 0;
                this._data = null;
                this._duration = void 0;
                this._duration = duration;
              }

              get keys() {
                return this._keys;
              }

              set keys(value) {
                this._keys = value;
              }

              get curves() {
                return this._curves;
              }

              set curves(value) {
                this._curves = value;
                delete this._runtimeCurves;
              }

              get commonTargets() {
                return this._commonTargets;
              }

              set commonTargets(value) {
                this._commonTargets = value;
              }

              get data() {
                return this._data;
              }

              getPropertyCurves() {
                if (!this._runtimeCurves) {
                  this._createPropertyCurves();
                }

                return this._runtimeCurves;
              }

              toTracks() {
                const newTracks = [];
                const {
                  keys: legacyKeys,
                  curves: legacyCurves,
                  commonTargets: legacyCommonTargets
                } = this;

                const convertTrackPath = (track, modifiers, valueAdapter) => {
                  const trackPath = new TrackPath();

                  for (const modifier of modifiers) {
                    if (typeof modifier === 'string') {
                      trackPath.toProperty(modifier);
                    } else if (typeof modifier === 'number') {
                      trackPath.toElement(modifier);
                    } else if (modifier instanceof HierarchyPath) {
                      trackPath.toHierarchy(modifier.path);
                    } else if (modifier instanceof ComponentPath) {
                      trackPath.toComponent(modifier.component);
                    } else {
                      trackPath.toCustomized(modifier);
                    }
                  }

                  track.path = trackPath;
                  track.proxy = valueAdapter;
                };

                const untypedTracks = legacyCommonTargets.map(legacyCommonTarget => {
                  const track = new UntypedTrack();
                  convertTrackPath(track, legacyCommonTarget.modifiers, legacyCommonTarget.valueAdapter);
                  newTracks.push(track);
                  return track;
                });

                for (const legacyCurve of legacyCurves) {
                  var _legacyCurveData$inte;

                  const legacyCurveData = legacyCurve.data;
                  const legacyValues = legacyCurveData.values;

                  if (legacyValues.length === 0) {
                    continue;
                  }

                  const legacyKeysIndex = legacyCurveData.keys;
                  const times = legacyKeysIndex < 0 ? [0.0] : legacyKeys[legacyCurveData.keys];
                  const firstValue = legacyValues[0];
                  const interpolate = (_legacyCurveData$inte = legacyCurveData.interpolate) !== null && _legacyCurveData$inte !== void 0 ? _legacyCurveData$inte : true;
                  assertIsTrue(typeof legacyCurveData._arrayLength !== 'number' || typeof firstValue === 'number');
                  const legacyEasingMethodConverter = new LegacyEasingMethodConverter(legacyCurveData, times.length);

                  const installPathAndSetter = track => {
                    convertTrackPath(track, legacyCurve.modifiers, legacyCurve.valueAdapter);
                  };

                  let legacyCommonTargetCurve;

                  if (typeof legacyCurve.commonTarget === 'number') {
                    if (!legacyValues.every(value => typeof value === 'number')) {
                      warnID(3932);
                      continue;
                    }

                    if (legacyCurve.valueAdapter || legacyCurve.modifiers.length !== 1 || typeof legacyCurve.modifiers[0] !== 'string') {
                      warnID(3933);
                      continue;
                    }

                    const propertyName = legacyCurve.modifiers[0];
                    const untypedTrack = untypedTracks[legacyCurve.commonTarget];
                    const {
                      curve
                    } = untypedTrack.addChannel(propertyName);
                    legacyCommonTargetCurve = curve;
                  }

                  const convertCurve = () => {
                    if (typeof firstValue === 'number') {
                      if (!legacyValues.every(value => typeof value === 'number')) {
                        warnID(3934);
                        return;
                      }

                      let realCurve;

                      if (legacyCommonTargetCurve) {
                        realCurve = legacyCommonTargetCurve;
                      } else {
                        const track = new RealTrack();
                        installPathAndSetter(track);
                        newTracks.push(track);
                        realCurve = track.channel.curve;
                      }

                      const interpolationMethod = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;
                      realCurve.assignSorted(times, legacyValues.map(value => ({
                        value,
                        interpolationMode: interpolationMethod
                      })));
                      legacyEasingMethodConverter.convert(realCurve);
                      return;
                    } else if (typeof firstValue === 'object') {
                      switch (true) {
                        default:
                          break;

                        case everyInstanceOf(legacyValues, Vec2):
                        case everyInstanceOf(legacyValues, Vec3):
                        case everyInstanceOf(legacyValues, Vec4):
                          {
                            const components = firstValue instanceof Vec2 ? 2 : firstValue instanceof Vec3 ? 3 : 4;
                            const track = new VectorTrack();
                            installPathAndSetter(track);
                            track.componentsCount = components;
                            const [{
                              curve: x
                            }, {
                              curve: y
                            }, {
                              curve: z
                            }, {
                              curve: w
                            }] = track.channels();
                            const interpolationMode = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            const valueToFrame = value => ({
                              value,
                              interpolationMode
                            });

                            switch (components) {
                              case 4:
                                w.assignSorted(times, legacyValues.map(value => valueToFrame(value.w)));
                                legacyEasingMethodConverter.convert(w);

                              case 3:
                                z.assignSorted(times, legacyValues.map(value => valueToFrame(value.z)));
                                legacyEasingMethodConverter.convert(z);

                              default:
                                x.assignSorted(times, legacyValues.map(value => valueToFrame(value.x)));
                                legacyEasingMethodConverter.convert(x);
                                y.assignSorted(times, legacyValues.map(value => valueToFrame(value.y)));
                                legacyEasingMethodConverter.convert(y);
                                break;
                            }

                            newTracks.push(track);
                            return;
                          }

                        case everyInstanceOf(legacyValues, Quat):
                          {
                            const track = new QuatTrack();
                            installPathAndSetter(track);
                            const interpolationMode = interpolate ? QuatInterpolationMode.SLERP : QuatInterpolationMode.CONSTANT;
                            track.channel.curve.assignSorted(times, legacyValues.map(value => ({
                              value: Quat.clone(value),
                              interpolationMode
                            })));
                            legacyEasingMethodConverter.convertQuatCurve(track.channel.curve);
                            newTracks.push(track);
                            return;
                          }

                        case everyInstanceOf(legacyValues, Color):
                          {
                            const track = new ColorTrack();
                            installPathAndSetter(track);
                            const [{
                              curve: r
                            }, {
                              curve: g
                            }, {
                              curve: b
                            }, {
                              curve: a
                            }] = track.channels();
                            const interpolationMode = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            const valueToFrame = value => ({
                              value,
                              interpolationMode
                            });

                            r.assignSorted(times, legacyValues.map(value => valueToFrame(value.r)));
                            legacyEasingMethodConverter.convert(r);
                            g.assignSorted(times, legacyValues.map(value => valueToFrame(value.g)));
                            legacyEasingMethodConverter.convert(g);
                            b.assignSorted(times, legacyValues.map(value => valueToFrame(value.b)));
                            legacyEasingMethodConverter.convert(b);
                            a.assignSorted(times, legacyValues.map(value => valueToFrame(value.a)));
                            legacyEasingMethodConverter.convert(a);
                            newTracks.push(track);
                            return;
                          }

                        case everyInstanceOf(legacyValues, Size):
                          {
                            const track = new SizeTrack();
                            installPathAndSetter(track);
                            const [{
                              curve: width
                            }, {
                              curve: height
                            }] = track.channels();
                            const interpolationMode = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            const valueToFrame = value => ({
                              value,
                              interpolationMode
                            });

                            width.assignSorted(times, legacyValues.map(value => valueToFrame(value.width)));
                            legacyEasingMethodConverter.convert(width);
                            height.assignSorted(times, legacyValues.map(value => valueToFrame(value.height)));
                            legacyEasingMethodConverter.convert(height);
                            newTracks.push(track);
                            return;
                          }

                        case everyInstanceOf(legacyValues, CubicSplineNumberValue):
                          {
                            assertIsTrue(legacyEasingMethodConverter.nil);
                            const track = new RealTrack();
                            installPathAndSetter(track);
                            const interpolationMode = interpolate ? RealInterpolationMode.CUBIC : RealInterpolationMode.CONSTANT;
                            track.channel.curve.assignSorted(times, legacyValues.map(value => ({
                              value: value.dataPoint,
                              leftTangent: value.inTangent,
                              rightTangent: value.outTangent,
                              interpolationMode
                            })));
                            newTracks.push(track);
                            return;
                          }

                        case everyInstanceOf(legacyValues, CubicSplineVec2Value):
                        case everyInstanceOf(legacyValues, CubicSplineVec3Value):
                        case everyInstanceOf(legacyValues, CubicSplineVec4Value):
                          {
                            assertIsTrue(legacyEasingMethodConverter.nil);
                            const components = firstValue instanceof CubicSplineVec2Value ? 2 : firstValue instanceof CubicSplineVec3Value ? 3 : 4;
                            const track = new VectorTrack();
                            installPathAndSetter(track);
                            track.componentsCount = components;
                            const [x, y, z, w] = track.channels();
                            const interpolationMode = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            const valueToFrame = (value, inTangent, outTangent) => ({
                              value,
                              leftTangent: inTangent,
                              rightTangent: outTangent,
                              interpolationMode
                            });

                            switch (components) {
                              case 4:
                                w.curve.assignSorted(times, legacyValues.map(value => valueToFrame(value.dataPoint.w, value.inTangent.w, value.outTangent.w)));

                              case 3:
                                z.curve.assignSorted(times, legacyValues.map(value => valueToFrame(value.dataPoint.z, value.inTangent.z, value.outTangent.z)));

                              default:
                                x.curve.assignSorted(times, legacyValues.map(value => valueToFrame(value.dataPoint.y, value.inTangent.y, value.outTangent.y)));
                                y.curve.assignSorted(times, legacyValues.map(value => valueToFrame(value.dataPoint.x, value.inTangent.x, value.outTangent.x)));
                                break;
                            }

                            newTracks.push(track);
                            return;
                          }

                        case legacyValues.every(value => value instanceof CubicSplineQuatValue):
                          {
                            warnID(3935);
                            break;
                          }
                      }
                    }

                    const objectTrack = new ObjectTrack();
                    installPathAndSetter(objectTrack);
                    objectTrack.channel.curve.assignSorted(times, legacyValues);
                    newTracks.push(objectTrack);
                  };

                  convertCurve();
                }

                return newTracks;
              }

              _createPropertyCurves() {
                this._ratioSamplers = this._keys.map(keys => new RatioSampler(keys.map(key => key / this._duration)));
                this._runtimeCurves = this._curves.map(targetCurve => ({
                  curve: new AnimCurve(targetCurve.data, this._duration),
                  modifiers: targetCurve.modifiers,
                  valueAdapter: targetCurve.valueAdapter,
                  sampler: this._ratioSamplers[targetCurve.data.keys],
                  commonTarget: targetCurve.commonTarget
                }));
              }

            }

            function everyInstanceOf(array, constructor) {
              return array.every(element => element instanceof constructor);
            }

            class LegacyEasingMethodConverter {
              constructor(legacyCurveData, keyframesCount) {
                this._easingMethods = void 0;
                const {
                  easingMethods
                } = legacyCurveData;

                if (Array.isArray(easingMethods)) {
                  if (easingMethods.length === 0 && keyframesCount !== 0) {
                    this._easingMethods = new Array(keyframesCount).fill(null);
                  } else {
                    this._easingMethods = easingMethods;
                  }
                } else if (easingMethods === undefined) {
                  this._easingMethods = new Array(keyframesCount).fill(legacyCurveData.easingMethod);
                } else {
                  this._easingMethods = Array.from({
                    length: keyframesCount
                  }, (_, index) => {
                    var _easingMethods$index;

                    return (_easingMethods$index = easingMethods[index]) !== null && _easingMethods$index !== void 0 ? _easingMethods$index : null;
                  });
                }
              }

              get nil() {
                return !this._easingMethods || this._easingMethods.every(easingMethod => easingMethod === null || easingMethod === undefined);
              }

              convert(curve) {
                const {
                  _easingMethods: easingMethods
                } = this;

                if (!easingMethods) {
                  return;
                }

                const nKeyframes = curve.keyFramesCount;

                if (curve.keyFramesCount < 2) {
                  return;
                }

                if (Array.isArray(easingMethods)) {
                  assertIsTrue(nKeyframes === easingMethods.length);
                }

                const iLastKeyframe = nKeyframes - 1;

                for (let iKeyframe = 0; iKeyframe < iLastKeyframe; ++iKeyframe) {
                  const easingMethod = easingMethods[iKeyframe];

                  if (!easingMethod) {
                    continue;
                  }

                  if (Array.isArray(easingMethod)) {
                    timeBezierToTangents(easingMethod, curve.getKeyframeTime(iKeyframe), curve.getKeyframeValue(iKeyframe), curve.getKeyframeTime(iKeyframe + 1), curve.getKeyframeValue(iKeyframe + 1));
                  } else {
                    applyLegacyEasingMethodName(easingMethod, curve, iKeyframe);
                  }
                }
              }

              convertQuatCurve(curve) {
                const {
                  _easingMethods: easingMethods
                } = this;

                if (!easingMethods) {
                  return;
                }

                const nKeyframes = curve.keyFramesCount;

                if (curve.keyFramesCount < 2) {
                  return;
                }

                if (Array.isArray(easingMethods)) {
                  assertIsTrue(nKeyframes === easingMethods.length);
                }

                const iLastKeyframe = nKeyframes - 1;

                for (let iKeyframe = 0; iKeyframe < iLastKeyframe; ++iKeyframe) {
                  const easingMethod = easingMethods[iKeyframe];

                  if (!easingMethod) {
                    continue;
                  }

                  if (Array.isArray(easingMethod)) {
                    curve.getKeyframeValue(iKeyframe).easingMethod = easingMethod.slice();
                  } else {
                    applyLegacyEasingMethodNameIntoQuatCurve(easingMethod, curve, iKeyframe);
                  }
                }
              }

            }

            function applyLegacyEasingMethodName(easingMethodName, curve, keyframeIndex) {
              assertIsTrue(keyframeIndex !== curve.keyFramesCount - 1);
              assertIsTrue(easingMethodName in easingMethodNameMap);
              const keyframeValue = curve.getKeyframeValue(keyframeIndex);
              const easingMethod = easingMethodNameMap[easingMethodName];

              if (easingMethod === EasingMethod.CONSTANT) {
                keyframeValue.interpolationMode = RealInterpolationMode.CONSTANT;
              } else {
                keyframeValue.interpolationMode = RealInterpolationMode.LINEAR;
                keyframeValue.easingMethod = easingMethod;
              }
            }

            function applyLegacyEasingMethodNameIntoQuatCurve(easingMethodName, curve, keyframeIndex) {
              assertIsTrue(keyframeIndex !== curve.keyFramesCount - 1);
              assertIsTrue(easingMethodName in easingMethodNameMap);
              const keyframeValue = curve.getKeyframeValue(keyframeIndex);
              const easingMethod = easingMethodNameMap[easingMethodName];
              keyframeValue.easingMethod = easingMethod;
            }

            const easingMethodNameMap = {
              constant: EasingMethod.CONSTANT,
              linear: EasingMethod.LINEAR,
              quadIn: EasingMethod.QUAD_IN,
              quadOut: EasingMethod.QUAD_OUT,
              quadInOut: EasingMethod.QUAD_IN_OUT,
              quadOutIn: EasingMethod.QUAD_OUT_IN,
              cubicIn: EasingMethod.CUBIC_IN,
              cubicOut: EasingMethod.CUBIC_OUT,
              cubicInOut: EasingMethod.CUBIC_IN_OUT,
              cubicOutIn: EasingMethod.CUBIC_OUT_IN,
              quartIn: EasingMethod.QUART_IN,
              quartOut: EasingMethod.QUART_OUT,
              quartInOut: EasingMethod.QUART_IN_OUT,
              quartOutIn: EasingMethod.QUART_OUT_IN,
              quintIn: EasingMethod.QUINT_IN,
              quintOut: EasingMethod.QUINT_OUT,
              quintInOut: EasingMethod.QUINT_IN_OUT,
              quintOutIn: EasingMethod.QUINT_OUT_IN,
              sineIn: EasingMethod.SINE_IN,
              sineOut: EasingMethod.SINE_OUT,
              sineInOut: EasingMethod.SINE_IN_OUT,
              sineOutIn: EasingMethod.SINE_OUT_IN,
              expoIn: EasingMethod.EXPO_IN,
              expoOut: EasingMethod.EXPO_OUT,
              expoInOut: EasingMethod.EXPO_IN_OUT,
              expoOutIn: EasingMethod.EXPO_OUT_IN,
              circIn: EasingMethod.CIRC_IN,
              circOut: EasingMethod.CIRC_OUT,
              circInOut: EasingMethod.CIRC_IN_OUT,
              circOutIn: EasingMethod.CIRC_OUT_IN,
              elasticIn: EasingMethod.ELASTIC_IN,
              elasticOut: EasingMethod.ELASTIC_OUT,
              elasticInOut: EasingMethod.ELASTIC_IN_OUT,
              elasticOutIn: EasingMethod.ELASTIC_OUT_IN,
              backIn: EasingMethod.BACK_IN,
              backOut: EasingMethod.BACK_OUT,
              backInOut: EasingMethod.BACK_IN_OUT,
              backOutIn: EasingMethod.BACK_OUT_IN,
              bounceIn: EasingMethod.BOUNCE_IN,
              bounceOut: EasingMethod.BOUNCE_OUT,
              bounceInOut: EasingMethod.BOUNCE_IN_OUT,
              bounceOutIn: EasingMethod.BOUNCE_OUT_IN,
              smooth: EasingMethod.SMOOTH,
              fade: EasingMethod.FADE
            };
            function timeBezierToTangents(timeBezierPoints, previousTime, previousKeyframe, nextTime, nextKeyframe) {
              const [p1X, p1Y, p2X, p2Y] = timeBezierPoints;
              const {
                value: previousValue
              } = previousKeyframe;
              const {
                value: nextValue
              } = nextKeyframe;
              const dValue = nextValue - previousValue;
              const dTime = nextTime - previousTime;
              const fx = 3 * dTime;
              const fy = 3 * dValue;
              const t1x = p1X * fx;
              const t1y = p1Y * fy;
              const t2x = (1.0 - p2X) * fx;
              const t2y = (1.0 - p2Y) * fy;
              const ONE_THIRD = 1.0 / 3.0;
              const previousTangent = t1y / t1x;
              const previousTangentWeight = Math.sqrt(t1x * t1x + t1y * t1y) * ONE_THIRD;
              const nextTangent = t2y / t2x;
              const nextTangentWeight = Math.sqrt(t2x * t2x + t2y * t2y) * ONE_THIRD;
              previousKeyframe.interpolationMode = RealInterpolationMode.CUBIC;
              previousKeyframe.tangentWeightMode = ensureRightTangentWeightMode(previousKeyframe.tangentWeightMode);
              previousKeyframe.rightTangent = previousTangent;
              previousKeyframe.rightTangentWeight = previousTangentWeight;
              nextKeyframe.tangentWeightMode = ensureLeftTangentWeightMode(nextKeyframe.tangentWeightMode);
              nextKeyframe.leftTangent = nextTangent;
              nextKeyframe.leftTangentWeight = nextTangentWeight;
            }

            function ensureLeftTangentWeightMode(tangentWeightMode) {
              if (tangentWeightMode === TangentWeightMode.NONE) {
                return TangentWeightMode.LEFT;
              } else if (tangentWeightMode === TangentWeightMode.RIGHT) {
                return TangentWeightMode.BOTH;
              } else {
                return tangentWeightMode;
              }
            }

            function ensureRightTangentWeightMode(tangentWeightMode) {
              if (tangentWeightMode === TangentWeightMode.NONE) {
                return TangentWeightMode.RIGHT;
              } else if (tangentWeightMode === TangentWeightMode.LEFT) {
                return TangentWeightMode.BOTH;
              } else {
                return tangentWeightMode;
              }
            }

            var _dec$J, _class$J, _class2$C, _descriptor$z, _temp$D, _dec2$k, _class4$9, _class5$9, _descriptor2$p, _descriptor3$g, _descriptor4$e, _descriptor5$c, _temp2$9, _dec3$b, _class7$4, _class8$3, _descriptor6$7, _descriptor7$5, _temp3$3, _dec4$8, _class10$3, _dec5$7, _class11$3, _dec6$4, _class12, _class13$3, _descriptor8$5, _descriptor9$4, _temp4$3, _dec7$3, _class15, _class16$1, _descriptor10$4, _descriptor11$3, _descriptor12$3, _descriptor13$3, _temp5$3;

            function throwIfSplitMethodIsNotValid() {
              throw new Error(`split() only valid in Editor.`);
            }

            let ExoticAnimation = (_dec$J = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticAnimation`), _dec$J(_class$J = (_class2$C = (_temp$D = class ExoticAnimation {
              constructor() {
                _initializerDefineProperty(this, "_nodeAnimations", _descriptor$z, this);
              }

              createEvaluator(binder) {
                return new ExoticTrsAnimationEvaluator(this._nodeAnimations, binder);
              }

              addNodeAnimation(path) {
                const nodeAnimation = new ExoticNodeAnimation(path);

                this._nodeAnimations.push(nodeAnimation);

                return nodeAnimation;
              }

              collectAnimatedJoints() {
                return Array.from(new Set(this._nodeAnimations.map(({
                  path
                }) => path)));
              }

              split(from, to) {
                {
                  return throwIfSplitMethodIsNotValid();
                }
              }

              toHashString() {
                return this._nodeAnimations.map(nodeAnimation => nodeAnimation.toHashString()).join('\n');
              }

            }, _temp$D), (_descriptor$z = _applyDecoratedDescriptor(_class2$C.prototype, "_nodeAnimations", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$C)) || _class$J);
            let ExoticNodeAnimation = (_dec2$k = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticNodeAnimation`), _dec2$k(_class4$9 = (_class5$9 = (_temp2$9 = class ExoticNodeAnimation {
              constructor(path) {
                _initializerDefineProperty(this, "_path", _descriptor2$p, this);

                _initializerDefineProperty(this, "_position", _descriptor3$g, this);

                _initializerDefineProperty(this, "_rotation", _descriptor4$e, this);

                _initializerDefineProperty(this, "_scale", _descriptor5$c, this);

                this._path = path;
              }

              createPosition(times, values) {
                this._position = new ExoticTrack(times, new ExoticVec3TrackValues(values));
              }

              createRotation(times, values) {
                this._rotation = new ExoticTrack(times, new ExoticQuatTrackValues(values));
              }

              createScale(times, values) {
                this._scale = new ExoticTrack(times, new ExoticVec3TrackValues(values));
              }

              createEvaluator(binder) {
                return new ExoticNodeAnimationEvaluator(this._path, this._position, this._rotation, this._scale, binder);
              }

              split(from, to, splitInfoCache) {
                {
                  return throwIfSplitMethodIsNotValid();
                }
              }

              get path() {
                return this._path;
              }

              toHashString() {
                var _this$_position$toHas, _this$_position, _this$_scale$toHashSt, _this$_scale, _this$_rotation$toHas, _this$_rotation;

                return `${this._path}\n${(_this$_position$toHas = (_this$_position = this._position) === null || _this$_position === void 0 ? void 0 : _this$_position.toHashString()) !== null && _this$_position$toHas !== void 0 ? _this$_position$toHas : ''}${(_this$_scale$toHashSt = (_this$_scale = this._scale) === null || _this$_scale === void 0 ? void 0 : _this$_scale.toHashString()) !== null && _this$_scale$toHashSt !== void 0 ? _this$_scale$toHashSt : ''}${(_this$_rotation$toHas = (_this$_rotation = this._rotation) === null || _this$_rotation === void 0 ? void 0 : _this$_rotation.toHashString()) !== null && _this$_rotation$toHas !== void 0 ? _this$_rotation$toHas : ''}`;
              }

            }, _temp2$9), (_descriptor2$p = _applyDecoratedDescriptor(_class5$9.prototype, "_path", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor3$g = _applyDecoratedDescriptor(_class5$9.prototype, "_position", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor4$e = _applyDecoratedDescriptor(_class5$9.prototype, "_rotation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor5$c = _applyDecoratedDescriptor(_class5$9.prototype, "_scale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class5$9)) || _class4$9);

            function floatToHashString(value) {
              return value.toPrecision(2);
            }

            function floatArrayToHashString(values) {
              return values.map(floatToHashString).join(' ');
            }

            let ExoticVectorLikeTrackValues = (_dec3$b = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticVectorLikeTrackValues`), _dec3$b(_class7$4 = (_class8$3 = (_temp3$3 = class ExoticVectorLikeTrackValues {
              constructor(values) {
                _initializerDefineProperty(this, "_values", _descriptor6$7, this);

                _initializerDefineProperty(this, "_isQuantized", _descriptor7$5, this);

                this._values = values;
                this._isQuantized = false;
              }

              get precision() {
                return this._isQuantized ? this._values.originalPrecision : getFloatArrayPrecision(this._values);
              }

              quantize(type) {
                assertIsTrue(!this._isQuantized);
                this._values = quantize(this._values, type);
                this._isQuantized = true;
              }

              toHashString() {
                const {
                  _isQuantized: isQuantized,
                  _values: values
                } = this;
                return `${isQuantized} ${isQuantized ? values.toHashString() : floatArrayToHashString(values)}`;
              }

            }, _temp3$3), (_descriptor6$7 = _applyDecoratedDescriptor(_class8$3.prototype, "_values", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor7$5 = _applyDecoratedDescriptor(_class8$3.prototype, "_isQuantized", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class8$3)) || _class7$4);
            let ExoticVec3TrackValues = (_dec4$8 = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticVec3TrackValues`), _dec4$8(_class10$3 = class ExoticVec3TrackValues extends ExoticVectorLikeTrackValues {
              static imitate(values, model) {
                const trackValues = new ExoticVec3TrackValues(values);

                if (model._isQuantized) {
                  trackValues.quantize(model._values.quantizationType);
                }

                return trackValues;
              }

              get(index, resultValue) {
                const {
                  _values: values,
                  _isQuantized: isQuantized
                } = this;

                if (isQuantized) {
                  loadVec3FromQuantized(values, index, resultValue);
                } else {
                  Vec3.fromArray(resultValue, values, index * 3);
                }
              }

              lerp(prevIndex, nextIndex, ratio, prevValue, nextValue, resultValue) {
                const {
                  _values: values,
                  _isQuantized: isQuantized
                } = this;

                if (isQuantized) {
                  loadVec3FromQuantized(values, prevIndex, prevValue);
                  loadVec3FromQuantized(values, nextIndex, nextValue);
                } else {
                  Vec3.fromArray(prevValue, values, prevIndex * 3);
                  Vec3.fromArray(nextValue, values, nextIndex * 3);
                }

                Vec3.lerp(resultValue, prevValue, nextValue, ratio);
              }

            }) || _class10$3);
            let ExoticQuatTrackValues = (_dec5$7 = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticQuatTrackValues`), _dec5$7(_class11$3 = class ExoticQuatTrackValues extends ExoticVectorLikeTrackValues {
              static imitate(values, model) {
                const trackValues = new ExoticQuatTrackValues(values);

                if (model._isQuantized) {
                  trackValues.quantize(model._values.quantizationType);
                }

                return trackValues;
              }

              get(index, resultValue) {
                const {
                  _values: values,
                  _isQuantized: isQuantized
                } = this;

                if (isQuantized) {
                  loadQuatFromQuantized(values, index, resultValue);
                } else {
                  Quat.fromArray(resultValue, values, index * 4);
                }
              }

              lerp(prevIndex, nextIndex, ratio, prevValue, nextValue, resultValue) {
                const {
                  _values: values,
                  _isQuantized: isQuantized
                } = this;

                if (isQuantized) {
                  loadQuatFromQuantized(values, prevIndex, prevValue);
                  loadQuatFromQuantized(values, nextIndex, nextValue);
                } else {
                  Quat.fromArray(prevValue, values, prevIndex * 4);
                  Quat.fromArray(nextValue, values, nextIndex * 4);
                }

                Quat.slerp(resultValue, prevValue, nextValue, ratio);
              }

            }) || _class11$3);
            let ExoticTrack = (_dec6$4 = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticTrack`), _dec6$4(_class12 = (_class13$3 = (_temp4$3 = class ExoticTrack {
              constructor(times, values) {
                _initializerDefineProperty(this, "times", _descriptor8$5, this);

                _initializerDefineProperty(this, "values", _descriptor9$4, this);

                this.times = times;
                this.values = values;
              }

              toHashString() {
                const {
                  times,
                  values
                } = this;
                return `times: ${floatArrayToHashString(times)}; values: ${values.toHashString()}`;
              }

            }, _temp4$3), (_descriptor8$5 = _applyDecoratedDescriptor(_class13$3.prototype, "times", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor9$4 = _applyDecoratedDescriptor(_class13$3.prototype, "values", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class13$3)) || _class12);

            class ExoticTrsAnimationEvaluator {
              constructor(nodeAnimations, binder) {
                this._nodeEvaluations = void 0;
                this._nodeEvaluations = nodeAnimations.map(nodeAnimation => nodeAnimation.createEvaluator(binder));
              }

              evaluate(time) {
                this._nodeEvaluations.forEach(nodeEvaluator => {
                  nodeEvaluator.evaluate(time);
                });
              }

            }

            class ExoticNodeAnimationEvaluator {
              constructor(path, position, rotation, scale, binder) {
                this._position = null;
                this._rotation = null;
                this._scale = null;

                if (position) {
                  this._position = createExoticTrackEvaluationRecord(position.times, position.values, Vec3, path, 'position', binder);
                }

                if (rotation) {
                  this._rotation = createExoticTrackEvaluationRecord(rotation.times, rotation.values, Quat, path, 'rotation', binder);
                }

                if (scale) {
                  this._scale = createExoticTrackEvaluationRecord(scale.times, scale.values, Vec3, path, 'scale', binder);
                }
              }

              evaluate(time) {
                if (this._position) {
                  const value = this._position.evaluator.evaluate(time);

                  this._position.runtimeBinding.setValue(value);
                }

                if (this._rotation) {
                  const value = this._rotation.evaluator.evaluate(time);

                  this._rotation.runtimeBinding.setValue(value);
                }

                if (this._scale) {
                  const value = this._scale.evaluator.evaluate(time);

                  this._scale.runtimeBinding.setValue(value);
                }
              }

            }

            class ExoticTrackEvaluator {
              constructor(times, values, ValueConstructor) {
                this._times = void 0;
                this._inputSampleResultCache = {
                  just: false,
                  index: -1,
                  nextIndex: -1,
                  ratio: 0.0
                };
                this._values = void 0;
                this._prevValue = void 0;
                this._nextValue = void 0;
                this._resultValue = void 0;
                this._times = times;
                this._values = values;
                this._prevValue = new ValueConstructor();
                this._nextValue = new ValueConstructor();
                this._resultValue = new ValueConstructor();
              }

              evaluate(time) {
                const {
                  _times: times,
                  _values: values,
                  _resultValue: resultValue
                } = this;
                const nFrames = times.length;

                if (nFrames === 0) {
                  return resultValue;
                }

                const inputSampleResult = sampleInput(times, time, this._inputSampleResultCache);

                if (inputSampleResult.just) {
                  values.get(inputSampleResult.index, resultValue);
                } else {
                  values.lerp(inputSampleResult.index, inputSampleResult.nextIndex, inputSampleResult.ratio, this._prevValue, this._nextValue, resultValue);
                }

                return resultValue;
              }

            }

            function sampleInput(values, time, result) {
              const nFrames = values.length;
              assertIsTrue(nFrames !== 0);
              const firstTime = values[0];
              const lastTime = values[nFrames - 1];

              if (time < firstTime) {
                result.just = true;
                result.index = 0;
              } else if (time > lastTime) {
                result.just = true;
                result.index = nFrames - 1;
              } else {
                const index = binarySearchEpsilon(values, time);

                if (index >= 0) {
                  result.just = true;
                  result.index = index;
                } else {
                  const nextIndex = ~index;
                  assertIsTrue(nextIndex !== 0 && nextIndex !== nFrames && nFrames > 1);
                  const prevIndex = nextIndex - 1;
                  const prevTime = values[prevIndex];
                  const nextTime = values[nextIndex];
                  const ratio = (time - values[prevIndex]) / (nextTime - prevTime);
                  result.just = false;
                  result.index = prevIndex;
                  result.nextIndex = nextIndex;
                  result.ratio = ratio;
                }
              }

              return result;
            }

            const QUANTIZATION_TYPE_TO_ARRAY_VIEW_CONSTRUCTOR_MAP = {
              uint8: Uint8Array,
              uint16: Uint16Array
            };
            var FloatPrecision;

            (function (FloatPrecision) {
              FloatPrecision[FloatPrecision["FLOAT_32"] = 0] = "FLOAT_32";
              FloatPrecision[FloatPrecision["FLOAT_64"] = 1] = "FLOAT_64";
            })(FloatPrecision || (FloatPrecision = {}));

            function getFloatArrayPrecision(array) {
              switch (array.BYTES_PER_ELEMENT) {
                default:
                  assertIsTrue(false);

                case 4:
                  return FloatPrecision.FLOAT_32;

                case 8:
                  return FloatPrecision.FLOAT_64;
              }
            }

            let QuantizedFloatArray = (_dec7$3 = ccclass(`${CLASS_NAME_PREFIX_ANIM}QuantizedFloatArray`), _dec7$3(_class15 = (_class16$1 = (_temp5$3 = class QuantizedFloatArray {
              get quantizationType() {
                switch (this.values.BYTES_PER_ELEMENT) {
                  default:
                  case 1:
                    return 'uint8';

                  case 2:
                    return 'uint16';
                }
              }

              constructor(originalPrecision, values, extent, min = 0.0) {
                _initializerDefineProperty(this, "originalPrecision", _descriptor10$4, this);

                _initializerDefineProperty(this, "min", _descriptor11$3, this);

                _initializerDefineProperty(this, "extent", _descriptor12$3, this);

                _initializerDefineProperty(this, "values", _descriptor13$3, this);

                this.originalPrecision = originalPrecision;
                this.values = values;
                this.extent = extent;
                this.min = min;
              }

              toHashString() {
                const {
                  originalPrecision,
                  min,
                  extent,
                  values
                } = this;
                return `${originalPrecision} ${floatToHashString(min)} ${floatToHashString(extent)} ${values.join(' ')}`;
              }

            }, _temp5$3), (_descriptor10$4 = _applyDecoratedDescriptor(_class16$1.prototype, "originalPrecision", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor11$3 = _applyDecoratedDescriptor(_class16$1.prototype, "min", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor12$3 = _applyDecoratedDescriptor(_class16$1.prototype, "extent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor13$3 = _applyDecoratedDescriptor(_class16$1.prototype, "values", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class16$1)) || _class15);

            function quantize(values, type) {
              const TypedArrayViewConstructor = QUANTIZATION_TYPE_TO_ARRAY_VIEW_CONSTRUCTOR_MAP[type];
              const MAX = 1 << TypedArrayViewConstructor.BYTES_PER_ELEMENT;
              let min = Number.POSITIVE_INFINITY;
              let max = Number.NEGATIVE_INFINITY;
              values.forEach(value => {
                min = Math.min(value, min);
                max = Math.max(value, max);
              });
              const extent = max - min;
              const normalized = TypedArrayViewConstructor.from(values, value => (value - min) / extent * MAX);
              return new QuantizedFloatArray(getFloatArrayPrecision(values), normalized, extent, min);
            }

            function indexQuantized(quantized, index) {
              const quantizedValue = quantized.values[index];
              const MAX_VALUE = 1 << quantized.values.BYTES_PER_ELEMENT;
              return quantizedValue / MAX_VALUE * quantized.extent + quantized.min;
            }

            function createExoticTrackEvaluationRecord(times, values, ValueConstructor, path, property, binder) {
              const trackBinding = new TrackBinding();
              trackBinding.path = new TrackPath().toHierarchy(path).toProperty(property);
              const runtimeBinding = binder(trackBinding);

              if (!runtimeBinding) {
                return null;
              }

              const evaluator = new ExoticTrackEvaluator(times, values, ValueConstructor);
              return {
                runtimeBinding,
                evaluator
              };
            }

            function loadVec3FromQuantized(values, index, out) {
              Vec3.set(out, indexQuantized(values, 3 * index + 0), indexQuantized(values, 3 * index + 1), indexQuantized(values, 3 * index + 2));
            }

            function loadQuatFromQuantized(values, index, out) {
              Quat.set(out, indexQuantized(values, 4 * index + 0), indexQuantized(values, 4 * index + 1), indexQuantized(values, 4 * index + 2), indexQuantized(values, 4 * index + 3));
            }

            var _dec$K, _class$K, _class2$D, _descriptor$A, _descriptor2$q, _descriptor3$h, _descriptor4$f, _descriptor5$d, _descriptor6$8, _descriptor7$6, _descriptor8$6, _descriptor9$5, _class3$c, _temp$E;
            const searchForRootBonePathSymbol = Symbol('SearchForRootBonePath');
            const exoticAnimationTag = Symbol('ExoticAnimation');
            let AnimationClip = exports('fY', (_dec$K = ccclass('cc.AnimationClip'), _dec$K(_class$K = (_class2$D = (_temp$E = _class3$c = class AnimationClip extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "sample", _descriptor$A, this);

                _initializerDefineProperty(this, "speed", _descriptor2$q, this);

                _initializerDefineProperty(this, "wrapMode", _descriptor3$h, this);

                _initializerDefineProperty(this, "enableTrsBlending", _descriptor4$f, this);

                _initializerDefineProperty(this, "_duration", _descriptor5$d, this);

                _initializerDefineProperty(this, "_hash", _descriptor6$8, this);

                this.frameRate = 0;

                _initializerDefineProperty(this, "_tracks", _descriptor7$6, this);

                _initializerDefineProperty(this, "_exoticAnimation", _descriptor8$6, this);

                this._legacyData = undefined;
                this._legacyDataDirty = false;

                _initializerDefineProperty(this, "_events", _descriptor9$5, this);

                this._runtimeEvents = {
                  ratios: [],
                  eventGroups: []
                };
              }

              static createWithSpriteFrames(spriteFrames, sample) {
                const clip = new AnimationClip();
                clip.sample = sample || clip.sample;
                clip.duration = spriteFrames.length / clip.sample;
                const step = 1 / clip.sample;
                const track = new ObjectTrack();
                track.path = new TrackPath().toComponent('cc.Sprite').toProperty('spriteFrame');
                const curve = track.channels()[0].curve;
                curve.assignSorted(spriteFrames.map((spriteFrame, index) => [step * index, spriteFrame]));
                return clip;
              }

              get duration() {
                return this._duration;
              }

              set duration(value) {
                this._duration = value;
              }

              get tracksCount() {
                return this._tracks.length;
              }

              get tracks() {
                return this._tracks;
              }

              get hash() {
                var _this$_exoticAnimatio, _this$_exoticAnimatio2;

                if (this._hash) {
                  return this._hash;
                }

                const hashString = `Exotic:${(_this$_exoticAnimatio = (_this$_exoticAnimatio2 = this._exoticAnimation) === null || _this$_exoticAnimatio2 === void 0 ? void 0 : _this$_exoticAnimatio2.toHashString()) !== null && _this$_exoticAnimatio !== void 0 ? _this$_exoticAnimatio : ''}`;
                return this._hash = murmurhash2_32_gc(hashString, 666);
              }

              get events() {
                return this._events;
              }

              set events(value) {
                this._events = value;
                const ratios = [];
                const eventGroups = [];
                const events = this.events.sort((a, b) => a.frame - b.frame);
                const nEvents = events.length;

                for (let iEvent = 0; iEvent < nEvents; ++iEvent) {
                  const eventData = events[iEvent];
                  const ratio = eventData.frame / this._duration;
                  let i = ratios.findIndex(r => r === ratio);

                  if (i < 0) {
                    i = ratios.length;
                    ratios.push(ratio);
                    eventGroups.push({
                      events: []
                    });
                  }

                  eventGroups[i].events.push({
                    functionName: eventData.func,
                    parameters: eventData.params
                  });
                }

                this._runtimeEvents = {
                  ratios,
                  eventGroups
                };
              }

              get [exoticAnimationTag]() {
                return this._exoticAnimation;
              }

              set [exoticAnimationTag](value) {
                this._exoticAnimation = value;
              }

              onLoaded() {
                this.frameRate = this.sample;
                this.events = this._events;
              }

              range() {
                const range = {
                  min: Infinity,
                  max: -Infinity
                };
                const {
                  _tracks: tracks
                } = this;
                const nTracks = tracks.length;

                for (let iTrack = 0; iTrack < nTracks; ++iTrack) {
                  const track = tracks[iTrack];
                  const trackRange = track.range();
                  range.min = Math.min(range.min, trackRange.min);
                  range.max = Math.max(range.max, trackRange.max);
                }

                return range;
              }

              getTrack(index) {
                return this._tracks[index];
              }

              addTrack(track) {
                const index = this._tracks.length;

                this._tracks.push(track);

                return index;
              }

              removeTrack(index) {
                this._tracks.splice(index, 1);
              }

              clearTracks() {
                this._tracks.length = 0;
              }

              createEventEvaluator(targetNode) {
                return new EventEvaluator(targetNode, this._runtimeEvents.ratios, this._runtimeEvents.eventGroups, this.wrapMode);
              }

              createEvaluator(context) {
                const {
                  target
                } = context;

                const binder = binding => {
                  const trackTarget = binding.createRuntimeBinding(target, this.enableTrsBlending ? context.pose : undefined, false);
                  return trackTarget !== null && trackTarget !== void 0 ? trackTarget : undefined;
                };

                return this._createEvalWithBinder(target, binder, context.rootMotion);
              }

              destroy() {
                var _legacyCC$director$ro;

                if ((_legacyCC$director$ro = legacyCC.director.root) === null || _legacyCC$director$ro === void 0 ? void 0 : _legacyCC$director$ro.dataPoolManager) {
                  legacyCC.director.root.dataPoolManager.releaseAnimationClip(this);
                }

                SkelAnimDataHub.destroy(this);
                return super.destroy();
              }

              [BAKE_SKELETON_CURVE_SYMBOL](start, samples, frames) {
                const step = 1.0 / samples;

                const animatedJoints = this._collectAnimatedJoints();

                const nAnimatedJoints = animatedJoints.length;
                const jointsBakeInfo = {};

                for (let iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
                  const joint = animatedJoints[iAnimatedJoint];
                  jointsBakeInfo[joint] = {
                    transforms: Array.from({
                      length: frames
                    }, () => new Mat4())
                  };
                }

                const skeletonFrames = animatedJoints.reduce((result, joint) => {
                  result[joint] = new BoneGlobalTransform();
                  return result;
                }, {});

                for (const joint in skeletonFrames) {
                  const skeletonFrame = skeletonFrames[joint];
                  const parentJoint = joint.lastIndexOf('/');

                  if (parentJoint >= 0) {
                    const parentJointName = joint.substring(0, parentJoint);
                    const parentJointFrame = skeletonFrames[parentJointName];

                    if (parentJointFrame) {
                      skeletonFrame.parent = parentJointFrame;
                    }
                  }
                }

                const binder = binding => {
                  const trsPath = binding.parseTrsPath();

                  if (!trsPath) {
                    return undefined;
                  }

                  const jointFrame = skeletonFrames[trsPath.node];

                  if (!jointFrame) {
                    return undefined;
                  }

                  return createBoneTransformBinding(jointFrame, trsPath.property);
                };

                const evaluator = this._createEvalWithBinder(undefined, binder, undefined);

                for (let iFrame = 0; iFrame < frames; ++iFrame) {
                  const time = start + step * iFrame;
                  evaluator.evaluate(time);

                  for (let iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
                    const joint = animatedJoints[iAnimatedJoint];
                    Mat4.copy(jointsBakeInfo[joint].transforms[iFrame], skeletonFrames[joint].globalTransform);
                  }

                  for (let iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
                    const joint = animatedJoints[iAnimatedJoint];
                    skeletonFrames[joint].invalidate();
                  }
                }

                return {
                  samples,
                  frames,
                  joints: jointsBakeInfo
                };
              }

              upgradeUntypedTracks(refine) {
                const newTracks = [];
                const removals = [];
                const {
                  _tracks: tracks
                } = this;
                const nTracks = tracks.length;

                for (let iTrack = 0; iTrack < nTracks; ++iTrack) {
                  const track = tracks[iTrack];

                  if (!(track instanceof UntypedTrack)) {
                    continue;
                  }

                  const newTrack = track.upgrade(refine);

                  if (newTrack) {
                    newTracks.push(newTrack);
                    removals.push(track);
                  }
                }

                const nRemovalTracks = removals.length;

                for (let iRemovalTrack = 0; iRemovalTrack < nRemovalTracks; ++iRemovalTrack) {
                  array.remove(tracks, removals[iRemovalTrack]);
                }

                tracks.push(...newTracks);
              }

              [searchForRootBonePathSymbol]() {
                return this._searchForRootBonePath();
              }

              get keys() {
                return this._getLegacyData().keys;
              }

              set keys(value) {
                this._legacyDataDirty = true;
                this._getLegacyData().keys = value;
              }

              get curves() {
                this._legacyDataDirty = true;
                return this._getLegacyData().curves;
              }

              set curves(value) {
                this._getLegacyData().curves = value;
              }

              get commonTargets() {
                return this._getLegacyData().commonTargets;
              }

              set commonTargets(value) {
                this._legacyDataDirty = true;
                this._getLegacyData().commonTargets = value;
              }

              get data() {
                return this._getLegacyData().data;
              }

              getPropertyCurves() {
                return this._getLegacyData().getPropertyCurves();
              }

              get eventGroups() {
                return this._runtimeEvents.eventGroups;
              }

              updateEventDatas() {}

              hasEvents() {
                return this.events.length !== 0;
              }

              syncLegacyData() {
                if (this._legacyData) {
                  this._fromLegacy(this._legacyData);

                  this._legacyData = undefined;
                }
              }

              _createEvalWithBinder(target, binder, rootMotionOptions) {
                if (this._legacyDataDirty) {
                  this._legacyDataDirty = false;
                  this.syncLegacyData();
                }

                const rootMotionTrackExcludes = [];
                let rootMotionEvaluation;

                if (rootMotionOptions) {
                  rootMotionEvaluation = this._createRootMotionEvaluation(target, rootMotionOptions, rootMotionTrackExcludes);
                }

                const trackEvalStatues = [];
                let exoticAnimationEvaluator;
                const {
                  _tracks: tracks
                } = this;
                const nTracks = tracks.length;

                for (let iTrack = 0; iTrack < nTracks; ++iTrack) {
                  const track = tracks[iTrack];

                  if (rootMotionTrackExcludes.includes(track)) {
                    continue;
                  }

                  const trackTarget = binder(track[trackBindingTag]);

                  if (!trackTarget) {
                    continue;
                  }

                  const trackEval = track[createEvalSymbol](trackTarget);
                  trackEvalStatues.push({
                    binding: trackTarget,
                    trackEval
                  });
                }

                if (this._exoticAnimation) {
                  exoticAnimationEvaluator = this._exoticAnimation.createEvaluator(binder);
                }

                const evaluation = new AnimationClipEvaluation(trackEvalStatues, exoticAnimationEvaluator, rootMotionEvaluation);
                return evaluation;
              }

              _createRootMotionEvaluation(target, rootMotionOptions, rootMotionTrackExcludes) {
                if (!(target instanceof Node$1)) {
                  errorID(3920);
                  return undefined;
                }

                const rootBonePath = this._searchForRootBonePath();

                if (!rootBonePath) {
                  warnID(3923);
                  return undefined;
                }

                const rootBone = target.getChildByPath(rootBonePath);

                if (!rootBone) {
                  warnID(3924);
                  return undefined;
                }

                const boneTransform = new BoneTransform();
                const rootMotionsTrackEvaluations = [];
                const {
                  _tracks: tracks
                } = this;
                const nTracks = tracks.length;

                for (let iTrack = 0; iTrack < nTracks; ++iTrack) {
                  const track = tracks[iTrack];
                  const {
                    [trackBindingTag]: trackBinding
                  } = track;
                  const trsPath = trackBinding.parseTrsPath();

                  if (!trsPath) {
                    continue;
                  }

                  const bonePath = trsPath.node;

                  if (bonePath !== rootBonePath) {
                    continue;
                  }

                  rootMotionTrackExcludes.push(track);
                  const property = trsPath.property;
                  const trackTarget = createBoneTransformBinding(boneTransform, property);

                  if (!trackTarget) {
                    continue;
                  }

                  const trackEval = track[createEvalSymbol](trackTarget);
                  rootMotionsTrackEvaluations.push({
                    binding: trackTarget,
                    trackEval
                  });
                }

                const rootMotionEvaluation = new RootMotionEvaluation(rootBone, this._duration, boneTransform, rootMotionsTrackEvaluations);
                return rootMotionEvaluation;
              }

              _searchForRootBonePath() {
                const paths = this._tracks.map(track => {
                  const trsPath = track[trackBindingTag].parseTrsPath();

                  if (trsPath) {
                    const nodePath = trsPath.node;
                    return {
                      path: nodePath,
                      rank: nodePath.split('/').length
                    };
                  } else {
                    return {
                      path: '',
                      rank: 0
                    };
                  }
                });

                paths.sort((a, b) => a.rank - b.rank);
                const iNonEmptyPath = paths.findIndex(p => p.rank !== 0);

                if (iNonEmptyPath < 0) {
                  return '';
                }

                const nPaths = paths.length;
                const firstPath = paths[iNonEmptyPath];
                let highestPathsAreSame = true;

                for (let iPath = iNonEmptyPath + 1; iPath < nPaths; ++iPath) {
                  const path = paths[iPath];

                  if (path.rank !== firstPath.rank) {
                    break;
                  }

                  if (path.path !== firstPath.path) {
                    highestPathsAreSame = false;
                    break;
                  }
                }

                return highestPathsAreSame ? firstPath.path : '';
              }

              _getLegacyData() {
                if (!this._legacyData) {
                  this._legacyData = this._toLegacy();
                }

                return this._legacyData;
              }

              _toLegacy() {
                const keys = [];
                const legacyCurves = [];
                const commonTargets = [];
                const legacyClipData = new AnimationClipLegacyData(this._duration);
                legacyClipData.keys = keys;
                legacyClipData.curves = legacyCurves;
                legacyClipData.commonTargets = commonTargets;
                return legacyClipData;
              }

              _fromLegacy(legacyData) {
                const newTracks = legacyData.toTracks();
                const nNewTracks = newTracks.length;

                for (let iNewTrack = 0; iNewTrack < nNewTracks; ++iNewTrack) {
                  this.addTrack(newTracks[iNewTrack]);
                }
              }

              _collectAnimatedJoints() {
                const joints = new Set();
                const {
                  _tracks: tracks
                } = this;
                const nTracks = tracks.length;

                for (let iTrack = 0; iTrack < nTracks; ++iTrack) {
                  const track = tracks[iTrack];
                  const trsPath = track[trackBindingTag].parseTrsPath();

                  if (trsPath) {
                    joints.add(trsPath.node);
                  }
                }

                if (this._exoticAnimation) {
                  const animatedJoints = this._exoticAnimation.collectAnimatedJoints();

                  const nAnimatedJoints = animatedJoints.length;

                  for (let iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
                    joints.add(animatedJoints[iAnimatedJoint]);
                  }
                }

                return Array.from(joints);
              }

            }, _class3$c.WrapMode = WrapMode, _temp$E), (_descriptor$A = _applyDecoratedDescriptor(_class2$D.prototype, "sample", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 60;
              }
            }), _descriptor2$q = _applyDecoratedDescriptor(_class2$D.prototype, "speed", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor3$h = _applyDecoratedDescriptor(_class2$D.prototype, "wrapMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return WrapMode.Normal;
              }
            }), _descriptor4$f = _applyDecoratedDescriptor(_class2$D.prototype, "enableTrsBlending", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor5$d = _applyDecoratedDescriptor(_class2$D.prototype, "_duration", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor6$8 = _applyDecoratedDescriptor(_class2$D.prototype, "_hash", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor7$6 = _applyDecoratedDescriptor(_class2$D.prototype, "_tracks", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor8$6 = _applyDecoratedDescriptor(_class2$D.prototype, "_exoticAnimation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor9$5 = _applyDecoratedDescriptor(_class2$D.prototype, "_events", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$D)) || _class$K));
            legacyCC.AnimationClip = AnimationClip;

            class AnimationClipEvaluation {
              constructor(trackEvalStatuses, exoticAnimationEvaluator, rootMotionEvaluation) {
                this._exoticAnimationEvaluator = void 0;
                this._trackEvalStatues = [];
                this._rootMotionEvaluation = undefined;
                this._trackEvalStatues = trackEvalStatuses;
                this._exoticAnimationEvaluator = exoticAnimationEvaluator;
                this._rootMotionEvaluation = rootMotionEvaluation;
              }

              evaluate(time) {
                const {
                  _trackEvalStatues: trackEvalStatuses,
                  _exoticAnimationEvaluator: exoticAnimationEvaluator
                } = this;
                const nTrackEvalStatuses = trackEvalStatuses.length;

                for (let iTrackEvalStatus = 0; iTrackEvalStatus < nTrackEvalStatuses; ++iTrackEvalStatus) {
                  const {
                    trackEval,
                    binding
                  } = trackEvalStatuses[iTrackEvalStatus];
                  const value = trackEval.evaluate(time, binding);
                  binding.setValue(value);
                }

                if (exoticAnimationEvaluator) {
                  exoticAnimationEvaluator.evaluate(time);
                }
              }

              evaluateRootMotion(time, motionLength) {
                const {
                  _rootMotionEvaluation: rootMotionEvaluation
                } = this;

                if (rootMotionEvaluation) {
                  rootMotionEvaluation.evaluate(time, motionLength);
                }
              }

            }

            class BoneTransform {
              constructor() {
                this.position = new Vec3();
                this.scale = new Vec3(1.0, 1.0, 1.0);
                this.rotation = new Quat();
                this.eulerAngles = new Vec3();
              }

              getTransform(out) {
                Mat4.fromRTS(out, this.rotation, this.position, this.scale);
              }

            }

            class BoneGlobalTransform extends BoneTransform {
              constructor(...args) {
                super(...args);
                this.parent = null;
                this._dirty = true;
                this._transform = new Mat4();
              }

              get globalTransform() {
                const transform = this._transform;

                if (this._dirty) {
                  this._dirty = false;
                  Mat4.fromRTS(transform, this.rotation, this.position, this.scale);

                  if (this.parent) {
                    Mat4.multiply(transform, this.parent.globalTransform, transform);
                  }
                }

                return this._transform;
              }

              invalidate() {
                this._dirty = true;
              }

            }

            const motionTransformCache = new Mat4();

            class RootMotionEvaluation {
              constructor(_rootBone, _duration, _boneTransform, _trackEvalStatuses) {
                this._initialTransformCache = new Mat4();
                this._clipEndTransformCache = new Mat4();
                this._startTransformCache = new Mat4();
                this._endTransformCache = new Mat4();
                this._motionTransformCache = new Mat4();
                this._translationMotionCache = new Vec3();
                this._rotationMotionCache = new Quat();
                this._scaleMotionCache = new Vec3();
                this._rootBone = _rootBone;
                this._duration = _duration;
                this._boneTransform = _boneTransform;
                this._trackEvalStatuses = _trackEvalStatuses;
              }

              evaluate(time, motionLength) {
                const motionTransform = this._calcMotionTransform(time, motionLength, this._motionTransformCache);

                const {
                  _translationMotionCache: translationMotion,
                  _rotationMotionCache: rotationMotion,
                  _scaleMotionCache: scaleMotion,
                  _rootBone: rootBone
                } = this;
                Mat4.toRTS(motionTransform, rotationMotion, translationMotion, scaleMotion);
                Vec3.add(translationMotion, translationMotion, rootBone.position);
                rootBone.setPosition(translationMotion);
                Quat.multiply(rotationMotion, rotationMotion, rootBone.rotation);
                rootBone.setRotation(rotationMotion);
                Vec3.multiply(scaleMotion, scaleMotion, rootBone.scale);
                rootBone.setScale(scaleMotion);
              }

              _calcMotionTransform(time, motionLength, outTransform) {
                const {
                  _duration: duration
                } = this;
                const remainLength = duration - time;
                assertIsTrue(remainLength >= 0);

                const startTransform = this._evaluateAt(time, this._startTransformCache);

                if (motionLength < remainLength) {
                  const endTransform = this._evaluateAt(time + motionLength, this._endTransformCache);

                  relativeTransform(outTransform, startTransform, endTransform);
                } else {
                  Mat4.identity(outTransform);

                  const accumulateMotionTransform = (from, to) => {
                    relativeTransform(motionTransformCache, from, to);
                    Mat4.multiply(outTransform, outTransform, motionTransformCache);
                  };

                  const diff = motionLength - remainLength;
                  const repeatCount = Math.floor(diff / duration);
                  const lastRemainTime = diff - repeatCount * duration;

                  const clipStartTransform = this._evaluateAt(0, this._initialTransformCache);

                  const clipEndTransform = this._evaluateAt(duration, this._clipEndTransformCache);

                  const endTransform = this._evaluateAt(lastRemainTime, this._endTransformCache);

                  accumulateMotionTransform(startTransform, clipEndTransform);
                  relativeTransform(motionTransformCache, clipStartTransform, clipEndTransform);

                  for (let i = 0; i < repeatCount; ++i) {
                    Mat4.multiply(outTransform, outTransform, motionTransformCache);
                  }

                  accumulateMotionTransform(clipStartTransform, endTransform);
                }

                return outTransform;
              }

              _evaluateAt(time, outTransform) {
                const {
                  _trackEvalStatuses: trackEvalStatuses
                } = this;
                const nTrackEvalStatuses = trackEvalStatuses.length;

                for (let iTrackEvalStatus = 0; iTrackEvalStatus < nTrackEvalStatuses; ++iTrackEvalStatus) {
                  const {
                    trackEval,
                    binding
                  } = trackEvalStatuses[iTrackEvalStatus];
                  const value = trackEval.evaluate(time, binding);
                  binding.setValue(value);
                }

                this._boneTransform.getTransform(outTransform);

                return outTransform;
              }

            }

            function relativeTransform(out, from, to) {
              Mat4.invert(out, from);
              Mat4.multiply(out, to, out);
            }

            function createBoneTransformBinding(boneTransform, property) {
              switch (property) {
                default:
                  return undefined;

                case 'position':
                  return {
                    setValue(value) {
                      Vec3.copy(boneTransform.position, value);
                    }

                  };

                case 'rotation':
                  return {
                    setValue(value) {
                      Quat.copy(boneTransform.rotation, value);
                    }

                  };

                case 'scale':
                  return {
                    setValue(value) {
                      Vec3.copy(boneTransform.scale, value);
                    }

                  };

                case 'eulerAngles':
                  return {
                    setValue(value) {
                      Vec3.copy(boneTransform.eulerAngles, value);
                    }

                  };
              }
            }

            const InvalidIndex = -1;

            class EventEvaluator {
              constructor(_targetNode, _ratios, _eventGroups, _wrapMode) {
                this._lastFrameIndex = -1;
                this._lastIterations = 0.0;
                this._lastDirection = 0;
                this._ignoreIndex = InvalidIndex;
                this._sampled = false;
                this._targetNode = _targetNode;
                this._ratios = _ratios;
                this._eventGroups = _eventGroups;
                this._wrapMode = _wrapMode;
              }

              setWrapMode(wrapMode) {
                this._wrapMode = wrapMode;
              }

              ignore(ratio, direction) {
                this._ignoreIndex = InvalidIndex;
                this._sampled = false;
                let frameIndex = getEventGroupIndexAtRatio(ratio, this._ratios);

                if (frameIndex < 0) {
                  frameIndex = ~frameIndex - 1;

                  if (direction < 0) {
                    frameIndex += 1;
                  }

                  this._ignoreIndex = frameIndex;
                }
              }

              sample(ratio, direction, iterations) {
                const length = this._eventGroups.length;
                let eventIndex = getEventGroupIndexAtRatio(ratio, this._ratios);

                if (eventIndex < 0) {
                  eventIndex = ~eventIndex - 1;

                  if (direction < 0) {
                    eventIndex += 1;
                  }
                }

                if (this._ignoreIndex !== eventIndex) {
                  this._ignoreIndex = InvalidIndex;
                }

                if (!this._sampled) {
                  this._sampled = true;

                  this._doFire(eventIndex, false);

                  this._lastFrameIndex = eventIndex;
                  this._lastIterations = iterations;
                  this._lastDirection = direction;
                  return;
                }

                const wrapMode = this._wrapMode;
                const currentIterations = wrapIterations(iterations);
                let lastIterations = wrapIterations(this._lastIterations);
                let lastIndex = this._lastFrameIndex;
                const lastDirection = this._lastDirection;
                const iterationsChanged = lastIterations !== -1 && currentIterations !== lastIterations;

                if (lastIndex === eventIndex && iterationsChanged && length === 1) {
                  this._doFire(0, false);
                } else if (lastIndex !== eventIndex || iterationsChanged) {
                  direction = lastDirection;

                  do {
                    if (lastIndex !== eventIndex) {
                      if (direction === -1 && lastIndex === 0 && eventIndex > 0) {
                        if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                          direction *= -1;
                        } else {
                          lastIndex = length;
                        }

                        lastIterations++;
                      } else if (direction === 1 && lastIndex === length - 1 && eventIndex < length - 1) {
                        if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                          direction *= -1;
                        } else {
                          lastIndex = -1;
                        }

                        lastIterations++;
                      }

                      if (lastIndex === eventIndex) {
                        break;
                      }

                      if (lastIterations > currentIterations) {
                        break;
                      }
                    }

                    lastIndex += direction;

                    this._doFire(lastIndex, true);
                  } while (lastIndex !== eventIndex && lastIndex > -1 && lastIndex < length);
                }

                this._lastFrameIndex = eventIndex;
                this._lastIterations = iterations;
                this._lastDirection = direction;
              }

              _doFire(eventIndex, delay) {
                if (delay) {
                  legacyCC.director.getAnimationManager().pushDelayEvent(this._checkAndFire, this, [eventIndex]);
                } else {
                  this._checkAndFire(eventIndex);
                }
              }

              _checkAndFire(eventIndex) {
                if (!this._targetNode || !this._targetNode.isValid) {
                  return;
                }

                const {
                  _eventGroups: eventGroups
                } = this;

                if (eventIndex < 0 || eventIndex >= eventGroups.length || this._ignoreIndex === eventIndex) {
                  return;
                }

                const eventGroup = eventGroups[eventIndex];
                const components = this._targetNode.components;
                const nEvents = eventGroup.events.length;

                for (let iEvent = 0; iEvent < nEvents; ++iEvent) {
                  const event = eventGroup.events[iEvent];
                  const {
                    functionName
                  } = event;
                  const nComponents = components.length;

                  for (let iComponent = 0; iComponent < nComponents; ++iComponent) {
                    const component = components[iComponent];
                    const fx = component[functionName];

                    if (typeof fx === 'function') {
                      fx.apply(component, event.parameters);
                    }
                  }
                }
              }

            }

            function wrapIterations(iterations) {
              if (iterations - (iterations | 0) === 0) {
                iterations -= 1;
              }

              return iterations | 0;
            }

            function getEventGroupIndexAtRatio(ratio, ratios) {
              const result = binarySearchEpsilon(ratios, ratio);
              return result;
            }

            class Playable {
              constructor() {
                this._isPlaying = false;
                this._isPaused = false;
                this._stepOnce = false;
              }

              get isPlaying() {
                return this._isPlaying;
              }

              get isPaused() {
                return this._isPaused;
              }

              get isMotionless() {
                return !this.isPlaying || this.isPaused;
              }

              play() {
                if (this._isPlaying) {
                  if (this._isPaused) {
                    this._isPaused = false;
                    this.onResume();
                  } else {
                    this.onError(getError(3912));
                  }
                } else {
                  this._isPlaying = true;
                  this.onPlay();
                }
              }

              stop() {
                if (this._isPlaying) {
                  this._isPlaying = false;
                  this.onStop();
                  this._isPaused = false;
                }
              }

              pause() {
                if (this._isPlaying && !this._isPaused) {
                  this._isPaused = true;
                  this.onPause();
                }
              }

              resume() {
                if (this._isPlaying && this._isPaused) {
                  this._isPaused = false;
                  this.onResume();
                }
              }

              step() {
                this.pause();
                this._stepOnce = true;

                if (!this._isPlaying) {
                  this.play();
                }
              }

              update(deltaTime) {}

              onPlay() {}

              onPause() {}

              onResume() {}

              onStop() {}

              onError(message) {}

            }

            class PoseOutput {
              constructor(pose) {
                this.weight = 0.0;
                this._pose = void 0;
                this._blendStateWriters = [];
                this._pose = pose;
              }

              destroy() {
                for (let iBlendStateWriter = 0; iBlendStateWriter < this._blendStateWriters.length; ++iBlendStateWriter) {
                  this._pose.destroyWriter(this._blendStateWriters[iBlendStateWriter]);
                }

                this._blendStateWriters.length = 0;
              }

              createPoseWriter(node, property, constants) {
                const writer = this._pose.createWriter(node, property, this, constants);

                this._blendStateWriters.push(writer);

                return writer;
              }

            }

            let EventType;

            (function (EventType) {
              EventType["PLAY"] = "play";
              EventType["STOP"] = "stop";
              EventType["PAUSE"] = "pause";
              EventType["RESUME"] = "resume";
              EventType["LASTFRAME"] = "lastframe";
              EventType["FINISHED"] = "finished";
            })(EventType || (EventType = {}));

            ccenum(EventType);
            class AnimationState extends Playable {
              get clip() {
                return this._clip;
              }

              get name() {
                return this._name;
              }

              get length() {
                return this.duration;
              }

              get wrapMode() {
                return this._wrapMode;
              }

              set wrapMode(value) {
                var _this$_clipEventEval;

                this._wrapMode = value;
                this.time = 0;

                if (value & WrapModeMask.Loop) {
                  this.repeatCount = Infinity;
                } else {
                  this.repeatCount = 1;
                }

                (_this$_clipEventEval = this._clipEventEval) === null || _this$_clipEventEval === void 0 ? void 0 : _this$_clipEventEval.setWrapMode(value);
              }

              get repeatCount() {
                return this._repeatCount;
              }

              set repeatCount(value) {
                this._repeatCount = value;
                const shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
                const reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;

                if (value === Infinity && !shouldWrap && !reverse) {
                  this._useSimpleProcess = true;
                } else {
                  this._useSimpleProcess = false;
                }
              }

              get delay() {
                return this._delay;
              }

              set delay(value) {
                this._delayTime = this._delay = value;
              }

              get playbackRange() {
                return this._playbackRange;
              }

              set playbackRange(value) {
                assertIsTrue(value.max > value.min);
                this._playbackRange.min = Math.max(value.min, 0);
                this._playbackRange.max = Math.min(value.max, this.duration);
                this._playbackDuration = this._playbackRange.max - this._playbackRange.min;
                this.setTime(0.0);
              }

              get current() {
                return this.getWrappedInfo(this.time).time;
              }

              get ratio() {
                return this.current / this.duration;
              }

              get weight() {
                return this._weight;
              }

              set weight(value) {
                this._weight = value;

                if (this._poseOutput) {
                  this._poseOutput.weight = value;
                }
              }

              constructor(clip, name = '') {
                super();
                this.duration = 1.0;
                this.speed = 1.0;
                this.time = 0.0;
                this.frameRate = 0;
                this._targetNode = null;
                this._curveLoaded = false;
                this._clip = void 0;
                this._useSimpleProcess = false;
                this._target = null;
                this._wrapMode = WrapMode.Normal;
                this._repeatCount = 1;
                this._delay = 0.0;
                this._delayTime = 0.0;
                this._currentFramePlayed = false;
                this._name = void 0;
                this._lastIterations = NaN;
                this._lastWrapInfo = null;
                this._wrappedInfo = new WrappedInfo();
                this._allowLastFrame = false;
                this._blendStateWriterHost = {
                  weight: 0.0
                };
                this._playbackDuration = 0.0;
                this._invDuration = 1.0;
                this._poseOutput = null;
                this._weight = 0.0;
                this._clipEval = void 0;
                this._clipEventEval = void 0;
                this._doNotCreateEval = false;
                this._clip = clip;
                this._name = name || clip && clip.name;
                this._playbackRange = {
                  min: 0.0,
                  max: clip.duration
                };
                this._playbackDuration = clip.duration;

                if (!clip.duration) {
                  debug(`Clip ${clip.name} has zero duration.`);
                }
              }

              get curveLoaded() {
                return this._curveLoaded;
              }

              initialize(root) {
                if (this._curveLoaded) {
                  return;
                }

                this._curveLoaded = true;

                if (this._poseOutput) {
                  this._poseOutput.destroy();

                  this._poseOutput = null;
                }

                if (this._clipEval) {
                  this._clipEval = undefined;
                }

                this._targetNode = root;
                const clip = this._clip;
                this.duration = clip.duration;
                this._invDuration = 1.0 / this.duration;
                this.speed = clip.speed;
                this.wrapMode = clip.wrapMode;
                this.frameRate = clip.sample;
                this._playbackRange.min = 0.0;
                this._playbackRange.max = clip.duration;
                this._playbackDuration = clip.duration;

                if ((this.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop) {
                  this.repeatCount = Infinity;
                } else {
                  this.repeatCount = 1;
                }

                if (!this._doNotCreateEval) {
                  var _legacyCC$director$ge, _legacyCC$director$ge2, _this$_poseOutput;

                  const pose = (_legacyCC$director$ge = (_legacyCC$director$ge2 = legacyCC.director.getAnimationManager()) === null || _legacyCC$director$ge2 === void 0 ? void 0 : _legacyCC$director$ge2.blendState) !== null && _legacyCC$director$ge !== void 0 ? _legacyCC$director$ge : null;

                  if (pose) {
                    this._poseOutput = new PoseOutput(pose);
                  }

                  this._clipEval = clip.createEvaluator({
                    target: root,
                    pose: (_this$_poseOutput = this._poseOutput) !== null && _this$_poseOutput !== void 0 ? _this$_poseOutput : undefined
                  });
                }

                {
                  this._clipEventEval = clip.createEventEvaluator(this._targetNode);
                }
              }

              destroy() {
                if (!this.isMotionless) {
                  legacyCC.director.getAnimationManager().removeAnimation(this);
                }

                if (this._poseOutput) {
                  this._poseOutput.destroy();

                  this._poseOutput = null;
                }

                this._clipEval = undefined;
              }

              emit(...args) {
                legacyCC.director.getAnimationManager().pushDelayEvent(this._emit, this, args);
              }

              on(type, callback, target) {
                if (this._target && this._target.isValid) {
                  return this._target.on(type, callback, target);
                } else {
                  return null;
                }
              }

              once(type, callback, target) {
                if (this._target && this._target.isValid) {
                  return this._target.once(type, callback, target);
                } else {
                  return null;
                }
              }

              off(type, callback, target) {
                if (this._target && this._target.isValid) {
                  this._target.off(type, callback, target);
                }
              }

              allowLastFrameEvent(allowed) {
                this._allowLastFrame = allowed;
              }

              _setEventTarget(target) {
                this._target = target;
              }

              setTime(time) {
                this._currentFramePlayed = false;
                this.time = time || 0.0;

                {
                  var _this$_clipEventEval2;

                  const info = this.getWrappedInfo(time, this._wrappedInfo);
                  (_this$_clipEventEval2 = this._clipEventEval) === null || _this$_clipEventEval2 === void 0 ? void 0 : _this$_clipEventEval2.ignore(info.ratio, info.direction);
                }
              }

              update(delta) {
                if (this._delayTime > 0.0) {
                  this._delayTime -= delta;

                  if (this._delayTime > 0.0) {
                    return;
                  }
                }

                if (this._currentFramePlayed) {
                  this.time += delta * this.speed;
                } else {
                  this._currentFramePlayed = true;
                }

                this._process();
              }

              sample() {
                const info = this.getWrappedInfo(this.time, this._wrappedInfo);

                this._sampleCurves(info.time);

                {
                  this._sampleEvents(info);
                }

                return info;
              }

              onPlay() {
                this.setTime(0.0);
                this._delayTime = this._delay;

                this._onReplayOrResume();

                this.emit(EventType.PLAY, this);
              }

              onStop() {
                if (!this.isPaused) {
                  this._onPauseOrStop();
                }

                this.emit(EventType.STOP, this);
              }

              onResume() {
                this._onReplayOrResume();

                this.emit(EventType.RESUME, this);
              }

              onPause() {
                this._onPauseOrStop();

                this.emit(EventType.PAUSE, this);
              }

              _sampleCurves(time) {
                const {
                  _poseOutput: poseOutput,
                  _clipEval: clipEval
                } = this;

                if (poseOutput) {
                  poseOutput.weight = this.weight;
                }

                if (clipEval) {
                  clipEval.evaluate(time);
                }
              }

              _process() {
                if (this._useSimpleProcess) {
                  this.simpleProcess();
                } else {
                  this.process();
                }
              }

              process() {
                const info = this.sample();

                if (this._allowLastFrame) {
                  let lastInfo;

                  if (!this._lastWrapInfo) {
                    lastInfo = this._lastWrapInfo = new WrappedInfo(info);
                  } else {
                    lastInfo = this._lastWrapInfo;
                  }

                  if (this.repeatCount > 1 && (info.iterations | 0) > (lastInfo.iterations | 0)) {
                    this.emit(EventType.LASTFRAME, this);
                  }

                  lastInfo.set(info);
                }

                if (info.stopped) {
                  this.stop();
                  this.emit(EventType.FINISHED, this);
                }
              }

              simpleProcess() {
                const playbackStart = this._playbackRange.min;
                const playbackDuration = this._playbackDuration;
                let time = this.time % playbackDuration;

                if (time < 0.0) {
                  time += playbackDuration;
                }

                const realTime = playbackStart + time;
                const ratio = realTime * this._invDuration;

                this._sampleCurves(playbackStart + time);

                {
                  this._sampleEvents(this.getWrappedInfo(this.time, this._wrappedInfo));
                }

                if (this._allowLastFrame) {
                  if (Number.isNaN(this._lastIterations)) {
                    this._lastIterations = ratio;
                  }

                  if (this.time > 0 && this._lastIterations > ratio || this.time < 0 && this._lastIterations < ratio) {
                    this.emit(EventType.LASTFRAME, this);
                  }

                  this._lastIterations = ratio;
                }
              }

              _needReverse(currentIterations) {
                const wrapMode = this.wrapMode;
                let needReverse = false;

                if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                  const isEnd = currentIterations - (currentIterations | 0) === 0;

                  if (isEnd && currentIterations > 0) {
                    currentIterations -= 1;
                  }

                  const isOddIteration = currentIterations & 1;

                  if (isOddIteration) {
                    needReverse = !needReverse;
                  }
                }

                if ((wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse) {
                  needReverse = !needReverse;
                }

                return needReverse;
              }

              getWrappedInfo(time, info) {
                info = info || new WrappedInfo();

                const playbackStart = this._getPlaybackStart();

                const playbackEnd = this._getPlaybackEnd();

                const playbackDuration = playbackEnd - playbackStart;
                let stopped = false;
                const repeatCount = this.repeatCount;
                let currentIterations = time > 0 ? time / playbackDuration : -(time / playbackDuration);

                if (currentIterations >= repeatCount) {
                  currentIterations = repeatCount;
                  stopped = true;
                  let tempRatio = repeatCount - (repeatCount | 0);

                  if (tempRatio === 0) {
                    tempRatio = 1;
                  }

                  time = tempRatio * playbackDuration * (time > 0 ? 1 : -1);
                }

                if (time > playbackDuration) {
                  const tempTime = time % playbackDuration;
                  time = tempTime === 0 ? playbackDuration : tempTime;
                } else if (time < 0) {
                  time %= playbackDuration;

                  if (time !== 0) {
                    time += playbackDuration;
                  }
                }

                let needReverse = false;
                const shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;

                if (shouldWrap) {
                  needReverse = this._needReverse(currentIterations);
                }

                let direction = needReverse ? -1 : 1;

                if (this.speed < 0) {
                  direction *= -1;
                }

                if (shouldWrap && needReverse) {
                  time = playbackDuration - time;
                }

                info.time = playbackStart + time;
                info.ratio = info.time / this.duration;
                info.direction = direction;
                info.stopped = stopped;
                info.iterations = currentIterations;
                return info;
              }

              _getPlaybackStart() {
                return this._playbackRange.min;
              }

              _getPlaybackEnd() {
                return this._playbackRange.max;
              }

              _sampleEvents(wrapInfo) {
                var _this$_clipEventEval3;

                (_this$_clipEventEval3 = this._clipEventEval) === null || _this$_clipEventEval3 === void 0 ? void 0 : _this$_clipEventEval3.sample(wrapInfo.ratio, wrapInfo.direction, wrapInfo.iterations);
              }

              _emit(type, state) {
                if (this._target && this._target.isValid) {
                  this._target.emit(type, type, state);
                }
              }

              _onReplayOrResume() {
                legacyCC.director.getAnimationManager().addAnimation(this);
              }

              _onPauseOrStop() {
                legacyCC.director.getAnimationManager().removeAnimation(this);
              }

            } exports('cG', AnimationState);
            legacyCC.AnimationState = AnimationState;

            class CrossFade extends Playable {
              constructor(scheduler) {
                super();
                this._managedStates = [];
                this._fadings = [];
                this._scheduled = false;
                this._scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : legacyCC.director.getAnimationManager();
              }

              update(deltaTime) {
                if (this.isMotionless) {
                  return;
                }

                const managedStates = this._managedStates;
                const fadings = this._fadings;

                if (managedStates.length === 1 && fadings.length === 1) {
                  const state = managedStates[0].state;

                  if (state) {
                    state.weight = 1.0;
                  }
                } else {
                  this._calculateWeights(deltaTime);
                }

                if (managedStates.length === 1 && fadings.length === 1) {
                  this._unscheduleThis();
                }
              }

              crossFade(state, duration) {
                var _target$state;

                if (this._managedStates.length === 0) {
                  duration = 0;
                }

                if (duration === 0) {
                  this.clear();
                }

                let target = this._managedStates.find(weightedState => weightedState.state === state);

                if (!target) {
                  target = {
                    state,
                    reference: 0
                  };

                  if (state) {
                    state.play();
                  }

                  this._managedStates.push(target);
                } else if ((_target$state = target.state) === null || _target$state === void 0 ? void 0 : _target$state.isMotionless) {
                  target.state.play();
                }

                ++target.reference;

                this._fadings.unshift({
                  easeDuration: duration,
                  easeTime: 0,
                  target
                });

                if (!this.isMotionless) {
                  this._scheduleThis();
                }
              }

              clear() {
                for (let iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                  const state = this._managedStates[iManagedState].state;

                  if (state) {
                    state.stop();
                  }
                }

                this._managedStates.length = 0;
                this._fadings.length = 0;
              }

              onPlay() {
                super.onPlay();

                this._scheduleThis();
              }

              onPause() {
                super.onPause();

                for (let iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                  const state = this._managedStates[iManagedState].state;

                  if (state) {
                    state.pause();
                  }
                }

                this._unscheduleThis();
              }

              onResume() {
                super.onResume();

                for (let iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                  const state = this._managedStates[iManagedState].state;

                  if (state) {
                    state.resume();
                  }
                }

                this._scheduleThis();
              }

              onStop() {
                super.onStop();
                this.clear();
              }

              _calculateWeights(deltaTime) {
                const managedStates = this._managedStates;
                const fadings = this._fadings;

                for (let iManagedState = 0; iManagedState < managedStates.length; ++iManagedState) {
                  const state = managedStates[iManagedState].state;

                  if (state) {
                    state.weight = 0;
                  }
                }

                let absoluteWeight = 1.0;
                let deadFadingBegin = fadings.length;

                for (let iFading = 0; iFading < fadings.length; ++iFading) {
                  const fading = fadings[iFading];
                  fading.easeTime += deltaTime;
                  const relativeWeight = fading.easeDuration === 0 ? 1 : clamp01(fading.easeTime / fading.easeDuration);
                  const weight = relativeWeight * absoluteWeight;
                  absoluteWeight *= 1.0 - relativeWeight;

                  if (fading.target.state) {
                    fading.target.state.weight += weight;
                  }

                  if (fading.easeTime >= fading.easeDuration) {
                    deadFadingBegin = iFading + 1;
                    fading.easeTime = fading.easeDuration;
                    break;
                  }
                }

                if (deadFadingBegin !== fadings.length) {
                  for (let iDeadFading = deadFadingBegin; iDeadFading < fadings.length; ++iDeadFading) {
                    const deadFading = fadings[iDeadFading];
                    --deadFading.target.reference;

                    if (deadFading.target.reference <= 0) {
                      if (deadFading.target.state) {
                        deadFading.target.state.stop();
                      }

                      remove(this._managedStates, deadFading.target);
                    }
                  }

                  fadings.splice(deadFadingBegin);
                }
              }

              _scheduleThis() {
                if (!this._scheduled) {
                  this._scheduler.addCrossFade(this);

                  this._scheduled = true;
                }
              }

              _unscheduleThis() {
                if (this._scheduled) {
                  this._scheduler.removeCrossFade(this);

                  this._scheduled = false;
                }
              }

            }

            var _dec$L, _dec2$l, _dec3$c, _dec4$9, _dec5$8, _dec6$5, _dec7$4, _dec8$3, _dec9$3, _dec10$3, _class$L, _class2$E, _descriptor$B, _descriptor2$r, _descriptor3$i, _class3$d, _temp$F;
            let Animation = exports('cH', (_dec$L = ccclass('cc.Animation'), _dec2$l = help(), _dec3$c = executionOrder(99), _dec4$9 = menu(), _dec5$8 = type([AnimationClip]), _dec6$5 = tooltip(), _dec7$4 = type(AnimationClip), _dec8$3 = tooltip(), _dec9$3 = tooltip(), _dec10$3 = type([AnimationClip]), _dec$L(_class$L = _dec2$l(_class$L = _dec3$c(_class$L = executeInEditMode(_class$L = _dec4$9(_class$L = (_class2$E = (_temp$F = _class3$d = class Animation extends Eventify(Component) {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "playOnLoad", _descriptor$B, this);

                this._crossFade = new CrossFade();
                this._nameToState = createMap(true);

                _initializerDefineProperty(this, "_clips", _descriptor2$r, this);

                _initializerDefineProperty(this, "_defaultClip", _descriptor3$i, this);

                this._hasBeenPlayed = false;
              }

              get clips() {
                return this._clips;
              }

              set clips(value) {
                if (this._crossFade) {
                  this._crossFade.clear();
                }

                for (const clip of this._clips) {
                  if (clip) {
                    this._removeStateOfAutomaticClip(clip);
                  }
                }

                for (const clip of value) {
                  if (clip) {
                    this.createState(clip);
                  }
                }

                const newDefaultClip = value.find(clip => equalClips(clip, this._defaultClip));

                if (newDefaultClip) {
                  this._defaultClip = newDefaultClip;
                } else {
                  this._defaultClip = null;
                }

                this._clips = value;
              }

              get defaultClip() {
                return this._defaultClip;
              }

              set defaultClip(value) {
                this._defaultClip = value;

                if (!value) {
                  return;
                }

                const isBoundedDefaultClip = this._clips.findIndex(clip => equalClips(clip, value)) >= 0;

                if (!isBoundedDefaultClip) {
                  this._clips.push(value);

                  this.createState(value);
                }
              }

              onLoad() {
                this.clips = this._clips;

                for (const stateName in this._nameToState) {
                  const state = this._nameToState[stateName];
                  state.initialize(this.node);
                }
              }

              start() {
                if ( this.playOnLoad && !this._hasBeenPlayed && this._defaultClip) {
                  this.crossFade(this._defaultClip.name, 0);
                }
              }

              onEnable() {
                this._crossFade.resume();
              }

              onDisable() {
                this._crossFade.pause();
              }

              onDestroy() {
                this._crossFade.stop();

                for (const name in this._nameToState) {
                  const state = this._nameToState[name];
                  state.destroy();
                }

                this._nameToState = createMap(true);
              }

              play(name) {
                this._hasBeenPlayed = true;

                if (!name) {
                  if (!this._defaultClip) {
                    return;
                  }

                  name = this._defaultClip.name;
                }

                this.crossFade(name, 0);
              }

              crossFade(name, duration = 0.3) {
                this._hasBeenPlayed = true;
                const state = this._nameToState[name];

                if (state) {
                  this._crossFade.play();

                  this._crossFade.crossFade(state, duration);
                }
              }

              pause() {
                this._crossFade.pause();
              }

              resume() {
                this._crossFade.resume();
              }

              stop() {
                this._crossFade.stop();
              }

              getAnimationState(name) {
                return this.getState(name);
              }

              getState(name) {
                const state = this._nameToState[name];

                if (state && !state.curveLoaded) {
                  state.initialize(this.node);
                }

                return state || null;
              }

              createState(clip, name) {
                name = name || clip.name;
                this.removeState(name);
                return this._doCreateState(clip, name);
              }

              removeState(name) {
                const state = this._nameToState[name];

                if (state) {
                  state.allowLastFrameEvent(false);
                  state.stop();
                  delete this._nameToState[name];
                }
              }

              addClip(clip, name) {
                if (!contains(this._clips, clip)) {
                  this._clips.push(clip);
                }

                return this.createState(clip, name);
              }

              removeClip(clip, force) {
                let removalState;

                for (const name in this._nameToState) {
                  const state = this._nameToState[name];
                  const stateClip = state.clip;

                  if (stateClip === clip) {
                    removalState = state;
                    break;
                  }
                }

                if (clip === this._defaultClip) {
                  if (force) {
                    this._defaultClip = null;
                  } else {
                    {
                      warnID(3902);
                    }

                    return;
                  }
                }

                if (removalState && removalState.isPlaying) {
                  if (force) {
                    removalState.stop();
                  } else {
                    {
                      warnID(3903);
                    }

                    return;
                  }
                }

                this._clips = this._clips.filter(item => item !== clip);

                if (removalState) {
                  delete this._nameToState[removalState.name];
                }
              }

              on(type, callback, thisArg, once) {
                const ret = super.on(type, callback, thisArg, once);

                if (type === EventType.LASTFRAME) {
                  this._syncAllowLastFrameEvent();
                }

                return ret;
              }

              once(type, callback, thisArg) {
                const ret = super.once(type, callback, thisArg);

                if (type === EventType.LASTFRAME) {
                  this._syncAllowLastFrameEvent();
                }

                return ret;
              }

              off(type, callback, thisArg) {
                super.off(type, callback, thisArg);

                if (type === EventType.LASTFRAME) {
                  this._syncDisallowLastFrameEvent();
                }
              }

              _createState(clip, name) {
                return new AnimationState(clip, name);
              }

              _doCreateState(clip, name) {
                const state = this._createState(clip, name);

                state._setEventTarget(this);

                state.allowLastFrameEvent(this.hasEventListener(EventType.LASTFRAME));

                if (this.node) {
                  state.initialize(this.node);
                }

                this._nameToState[state.name] = state;
                return state;
              }

              _getStateByNameOrDefaultClip(name) {
                if (!name) {
                  if (!this._defaultClip) {
                    return null;
                  }

                  name = this._defaultClip.name;
                }

                const state = this._nameToState[name];

                if (state) {
                  return state;
                }

                return null;
              }

              _removeStateOfAutomaticClip(clip) {
                for (const name in this._nameToState) {
                  const state = this._nameToState[name];

                  if (equalClips(clip, state.clip)) {
                    state.stop();
                    delete this._nameToState[name];
                  }
                }
              }

              _syncAllowLastFrameEvent() {
                if (this.hasEventListener(EventType.LASTFRAME)) {
                  for (const stateName in this._nameToState) {
                    this._nameToState[stateName].allowLastFrameEvent(true);
                  }
                }
              }

              _syncDisallowLastFrameEvent() {
                if (!this.hasEventListener(EventType.LASTFRAME)) {
                  for (const stateName in this._nameToState) {
                    this._nameToState[stateName].allowLastFrameEvent(false);
                  }
                }
              }

            }, _class3$d.EventType = EventType, _temp$F), (_applyDecoratedDescriptor(_class2$E.prototype, "clips", [_dec5$8, _dec6$5], Object.getOwnPropertyDescriptor(_class2$E.prototype, "clips"), _class2$E.prototype), _applyDecoratedDescriptor(_class2$E.prototype, "defaultClip", [_dec7$4, _dec8$3], Object.getOwnPropertyDescriptor(_class2$E.prototype, "defaultClip"), _class2$E.prototype), _descriptor$B = _applyDecoratedDescriptor(_class2$E.prototype, "playOnLoad", [serializable, _dec9$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$r = _applyDecoratedDescriptor(_class2$E.prototype, "_clips", [_dec10$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor3$i = _applyDecoratedDescriptor(_class2$E.prototype, "_defaultClip", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$E)) || _class$L) || _class$L) || _class$L) || _class$L) || _class$L));

            function equalClips(clip1, clip2) {
              if (clip1 === clip2) {
                return true;
              }

              return !!clip1 && !!clip2 && clip1._uuid === clip2._uuid && clip1._uuid;
            }

            replaceProperty(Animation.prototype, 'Animation', [{
              name: 'getAnimationState',
              newName: 'getState'
            }, {
              name: 'addClip',
              newName: 'createState'
            }, {
              name: 'removeClip',
              newName: 'removeState',

              customFunction(...args) {
                const arg0 = args[0];
                return Animation.prototype.removeState.call(this, arg0.name);
              }

            }]);
            legacyCC.AnimationComponent = Animation;
            js.setClassAlias(Animation, 'cc.AnimationComponent');

            class BlendStateBuffer {
              constructor() {
                this._nodeBlendStates = new Map();
              }

              createWriter(node, property, host, constants) {
                const propertyBlendState = this.ref(node, property);
                return new BlendStateWriterInternal(node, property, propertyBlendState, host, constants);
              }

              destroyWriter(writer) {
                const internal = writer;
                this.deRef(internal.node, internal.property);
              }

              ref(node, property) {
                let nodeBlendState = this._nodeBlendStates.get(node);

                if (!nodeBlendState) {
                  nodeBlendState = new NodeBlendState();

                  this._nodeBlendStates.set(node, nodeBlendState);
                }

                const propertyBlendState = nodeBlendState.refProperty(property);
                return propertyBlendState;
              }

              deRef(node, property) {
                const nodeBlendState = this._nodeBlendStates.get(node);

                if (!nodeBlendState) {
                  return;
                }

                nodeBlendState.deRefProperty(property);

                if (nodeBlendState.empty) {
                  this._nodeBlendStates.delete(node);
                }
              }

              apply() {
                this._nodeBlendStates.forEach((nodeBlendState, node) => {
                  nodeBlendState.apply(node);
                });
              }

            }

            class BlendStateWriterInternal {
              constructor(_node, _property, _propertyBlendState, _host, _constants) {
                this._node = _node;
                this._property = _property;
                this._propertyBlendState = _propertyBlendState;
                this._host = _host;
                this._constants = _constants;
              }

              get node() {
                return this._node;
              }

              get property() {
                return this._property;
              }

              getValue() {
                return this._node[this._property];
              }

              setValue(value) {
                const {
                  _propertyBlendState: propertyBlendState,
                  _host: host
                } = this;
                const weight = host.weight;
                propertyBlendState.blend(value, weight);
              }

            }

            class PropertyBlendState {
              constructor(value) {
                this.blendedWeight = 0.0;
                this.blendedValue = void 0;
                this.refCount = 0;
                this.blendedValue = value;
              }

            }

            class Vec3PropertyBlendState extends PropertyBlendState {
              constructor() {
                super(new Vec3());
              }

              blend(value, weight) {
                const {
                  blendedValue
                } = this;

                if (weight === 1.0) {
                  Vec3.copy(blendedValue, value);
                } else {
                  Vec3.scaleAndAdd(blendedValue, blendedValue, value, weight);
                }

                this.blendedWeight += weight;
              }

              reset() {
                this.blendedWeight = 0.0;
                Vec3.zero(this.blendedValue);
              }

            }

            class QuatPropertyBlendState extends PropertyBlendState {
              constructor() {
                super(new Quat());
              }

              blend(value, weight) {
                if (weight === 0.0) {
                  return;
                }

                const {
                  blendedValue,
                  blendedWeight
                } = this;

                if (weight === 1.0) {
                  Quat.copy(blendedValue, value);
                } else {
                  const t = weight / (blendedWeight + weight);
                  Quat.slerp(blendedValue, blendedValue, value, t);
                }

                this.blendedWeight += weight;
              }

              reset() {
                this.blendedWeight = 0.0;
                Quat.identity(this.blendedValue);
              }

            }

            class NodeBlendState {
              constructor() {
                this._properties = {};
              }

              get empty() {
                const {
                  _properties: properties
                } = this;
                return !properties.position && !properties.rotation && !properties.eulerAngles && !properties.scale;
              }

              refProperty(property) {
                var _properties$property, _properties$property2;

                const {
                  _properties: properties
                } = this;
                let propertyBlendState;

                switch (property) {
                  default:
                  case 'position':
                  case 'scale':
                  case 'eulerAngles':
                    propertyBlendState = (_properties$property = properties[property]) !== null && _properties$property !== void 0 ? _properties$property : properties[property] = new Vec3PropertyBlendState();
                    break;

                  case 'rotation':
                    propertyBlendState = (_properties$property2 = properties[property]) !== null && _properties$property2 !== void 0 ? _properties$property2 : properties[property] = new QuatPropertyBlendState();
                    break;
                }

                ++propertyBlendState.refCount;
                return propertyBlendState;
              }

              deRefProperty(property) {
                const {
                  _properties: properties
                } = this;
                const propertyBlendState = properties[property];

                if (!propertyBlendState) {
                  return;
                }

                --propertyBlendState.refCount;

                if (propertyBlendState.refCount > 0) {
                  return;
                }

                delete properties[property];
              }

              apply(node) {
                const {
                  _properties: {
                    position,
                    scale,
                    rotation,
                    eulerAngles
                  }
                } = this;
                let t;
                let s;
                let r;
                let tFlags = false;
                let sFlags = false;
                let rFlags = false;
                let eFlags = false;

                if (position && position.blendedWeight) {
                  tFlags = true;

                  if (position.blendedWeight < 1.0) {
                    position.blend(node.position, 1.0 - position.blendedWeight);
                  }

                  t = position.blendedValue;
                }

                if (scale && scale.blendedWeight) {
                  sFlags = true;

                  if (scale.blendedWeight < 1.0) {
                    scale.blend(node.scale, 1.0 - scale.blendedWeight);
                  }

                  s = scale.blendedValue;
                }

                if (eulerAngles && eulerAngles.blendedWeight) {
                  eFlags = true;

                  if (eulerAngles.blendedWeight < 1.0) {
                    eulerAngles.blend(node.eulerAngles, 1.0 - eulerAngles.blendedWeight);
                  }

                  r = eulerAngles.blendedValue;
                }

                if (rotation && rotation.blendedWeight) {
                  rFlags = true;

                  if (rotation.blendedWeight < 1.0) {
                    rotation.blend(node.rotation, 1.0 - rotation.blendedWeight);
                  }

                  r = rotation.blendedValue;
                }

                if (r || t || s) {
                  node.setRTS(r, t, s);
                }

                if (tFlags) {
                  position.reset();
                }

                if (sFlags) {
                  scale.reset();
                }

                if (rFlags) {
                  rotation.reset();
                }

                if (eFlags) {
                  eulerAngles.reset();
                }
              }

            }

            const stack = [];
            const pool = new Map();
            function getWorldMatrix(transform, stamp) {
              let i = 0;
              let res = Mat4.IDENTITY;

              while (transform) {
                if (transform.stamp === stamp || transform.stamp + 1 === stamp && !transform.node.hasChangedFlags) {
                  res = transform.world;
                  transform.stamp = stamp;
                  break;
                }

                transform.stamp = stamp;
                stack[i++] = transform;
                transform = transform.parent;
              }

              while (i > 0) {
                transform = stack[--i];
                stack[i] = null;
                const node = transform.node;
                Mat4.fromRTS(transform.local, node.rotation, node.position, node.scale);
                res = Mat4.multiply(transform.world, res, transform.local);
              }

              return res;
            }
            function getTransform(node, root) {
              let joint = null;
              let i = 0;

              while (node !== root) {
                const id = node.uuid;

                if (pool.has(id)) {
                  joint = pool.get(id);
                  break;
                } else {
                  joint = {
                    node,
                    local: new Mat4(),
                    world: new Mat4(),
                    stamp: -1,
                    parent: null
                  };
                  pool.set(id, joint);
                }

                stack[i++] = joint;
                node = node.parent;
                joint = null;
              }

              let child;

              while (i > 0) {
                child = stack[--i];
                stack[i] = null;
                child.parent = joint;
                joint = child;
              }

              return joint;
            }
            function deleteTransform(node) {
              let transform = pool.get(node.uuid) || null;

              while (transform) {
                pool.delete(transform.node.uuid);
                transform = transform.parent;
              }
            }

            var _class$M, _class2$F, _temp$G;
            let AnimationManager = exports('g4', ccclass(_class$M = (_temp$G = _class2$F = class AnimationManager extends System {
              constructor(...args) {
                super(...args);
                this._anims = new MutableForwardIterator([]);
                this._crossFades = new MutableForwardIterator([]);
                this._delayEvents = [];
                this._blendStateBuffer = new BlendStateBuffer();
                this._sockets = [];
              }

              get blendState() {
                return this._blendStateBuffer;
              }

              addCrossFade(crossFade) {
                const index = this._crossFades.array.indexOf(crossFade);

                if (index === -1) {
                  this._crossFades.push(crossFade);
                }
              }

              removeCrossFade(crossFade) {
                const index = this._crossFades.array.indexOf(crossFade);

                if (index >= 0) {
                  this._crossFades.fastRemoveAt(index);
                } else {
                  errorID(3907);
                }
              }

              update(dt) {
                const {
                  _delayEvents,
                  _crossFades: crossFadesIter,
                  _sockets
                } = this;
                {
                  const crossFades = crossFadesIter.array;

                  for (crossFadesIter.i = 0; crossFadesIter.i < crossFades.length; ++crossFadesIter.i) {
                    const crossFade = crossFades[crossFadesIter.i];
                    crossFade.update(dt);
                  }
                }
                const iterator = this._anims;
                const array = iterator.array;

                for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                  const anim = array[iterator.i];

                  if (!anim.isMotionless) {
                    anim.update(dt);
                  }
                }

                this._blendStateBuffer.apply();

                const stamp = legacyCC.director.getTotalFrames();

                for (let i = 0, l = _sockets.length; i < l; i++) {
                  const {
                    target,
                    transform
                  } = _sockets[i];
                  target.matrix = getWorldMatrix(transform, stamp);
                }

                for (let i = 0, l = _delayEvents.length; i < l; i++) {
                  const event = _delayEvents[i];
                  event.fn.apply(event.thisArg, event.args);
                }

                _delayEvents.length = 0;
              }

              destruct() {}

              addAnimation(anim) {
                const index = this._anims.array.indexOf(anim);

                if (index === -1) {
                  this._anims.push(anim);
                }
              }

              removeAnimation(anim) {
                const index = this._anims.array.indexOf(anim);

                if (index >= 0) {
                  this._anims.fastRemoveAt(index);
                } else {
                  errorID(3907);
                }
              }

              pushDelayEvent(fn, thisArg, args) {
                this._delayEvents.push({
                  fn,
                  thisArg,
                  args
                });
              }

              addSockets(root, sockets) {
                for (let i = 0; i < sockets.length; ++i) {
                  const socket = sockets[i];

                  if (this._sockets.find(s => s.target === socket.target)) {
                    continue;
                  }

                  const targetNode = root.getChildByPath(socket.path);
                  const transform = socket.target && targetNode && getTransform(targetNode, root);

                  if (transform) {
                    this._sockets.push({
                      target: socket.target,
                      transform
                    });
                  }
                }
              }

              removeSockets(root, sockets) {
                for (let i = 0; i < sockets.length; ++i) {
                  const socketToRemove = sockets[i];

                  for (let j = 0; j < this._sockets.length; ++j) {
                    const socket = this._sockets[j];

                    if (socket.target === socketToRemove.target) {
                      deleteTransform(socket.transform.node);
                      this._sockets[j] = this._sockets[this._sockets.length - 1];
                      this._sockets.length--;
                      break;
                    }
                  }
                }
              }

            }, _class2$F.ID = 'animation', _temp$G)) || _class$M);
            director.on(Director.EVENT_INIT, () => {
              const animationManager = new AnimationManager();
              director.registerSystem(AnimationManager.ID, animationManager, System.Priority.HIGH);
            });
            legacyCC.AnimationManager = AnimationManager;

            const m4_1$2 = new Mat4();
            function getPathFromRoot(target, root) {
              let node = target;
              let path = '';

              while (node !== null && node !== root) {
                path = `${node.name}/${path}`;
                node = node.parent;
              }

              return path.slice(0, -1);
            }
            function getWorldTransformUntilRoot(target, root, outMatrix) {
              Mat4.identity(outMatrix);

              while (target !== root) {
                Mat4.fromRTS(m4_1$2, target.rotation, target.position, target.scale);
                Mat4.multiply(outMatrix, m4_1$2, outMatrix);
                target = target.parent;
              }

              return outMatrix;
            }

            var _dec$M, _class$N, _dec2$m, _class2$G, _dec3$d, _class3$e, _dec4$a, _class4$a;
            legacyCC.easing = easing;
            let HierachyModifier = exports('fR', (_dec$M = ccclass('cc.HierachyModifier'), _dec$M(_class$N = class HierachyModifier extends HierarchyPath {}) || _class$N));
            legacyCC.HierachyModifier = HierachyModifier;
            let ComponentModifier = exports('fS', (_dec2$m = ccclass('cc.ComponentModifier'), _dec2$m(_class2$G = class ComponentModifier extends ComponentPath {}) || _class2$G));
            legacyCC.ComponentModifier = ComponentModifier;
            let CurveValueAdapter = exports('fT', (_dec3$d = ccclass('cc.CurveValueAdapter'), _dec3$d(_class3$e = class CurveValueAdapter {
              forTarget(target) {
                return {
                  set: () => {}
                };
              }

            }) || _class3$e));
            legacyCC.CurveValueAdapter = CurveValueAdapter;
            let UniformCurveValueAdapter = exports('fU', (_dec4$a = ccclass('cc.UniformCurveValueAdapter'), _dec4$a(_class4$a = class UniformCurveValueAdapter extends UniformProxyFactory {}) || _class4$a));
            legacyCC.UniformCurveValueAdapter = UniformCurveValueAdapter;
            function isPropertyModifier(path) {
              return typeof path === 'string';
            }
            legacyCC.isPropertyModifier = isPropertyModifier;
            function isElementModifier(path) {
              return typeof path === 'number';
            }
            legacyCC.isElementModifier = isElementModifier;
            function isCustomTargetModifier(path, constructor) {
              return path instanceof constructor;
            }
            legacyCC.isCustomTargetModifier = isCustomTargetModifier;

            legacyCC.math = math;
            legacyCC.geometry = geometry;

            class NodePool$1 {
              constructor(poolHandlerComp) {
                this.poolHandlerComp = void 0;
                this._pool = void 0;
                this.poolHandlerComp = poolHandlerComp;
                this._pool = [];
              }

              size() {
                return this._pool.length;
              }

              clear() {
                const count = this._pool.length;

                for (let i = 0; i < count; ++i) {
                  this._pool[i].destroy();
                }

                this._pool.length = 0;
              }

              put(obj) {
                if (obj && this._pool.indexOf(obj) === -1) {
                  obj.removeFromParent();
                  const handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;

                  if (handler && handler.unuse) {
                    handler.unuse();
                  }

                  this._pool.push(obj);
                }
              }

              get(...args) {
                const last = this._pool.length - 1;

                if (last < 0) {
                  return null;
                } else {
                  const obj = this._pool[last];
                  this._pool.length = last;
                  const handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;

                  if (handler && handler.reuse) {
                    handler.reuse(arguments);
                  }

                  return obj;
                }
              }

            } exports('gc', NodePool$1);
            legacyCC.NodePool = NodePool$1;

            legacyCC.renderer = renderer;

            var commonjsGlobal = exports('e0', typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {});

            function unwrapExports (x) {
            	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
            }

            function createCommonjsModule(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var ammo = createCommonjsModule(function (module, exports) {
            // This is ammo.js, a port of Bullet Physics to JavaScript. zlib licensed.
              
            var Ammo = (function() {
              var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
              
              return (
            function(Ammo) {
              Ammo = Ammo || {};


            var a;a||(a=typeof Ammo !== 'undefined' ? Ammo : {});var aa;a.ready=new Promise(function(b){aa=b;});var ba={},ca;for(ca in a)a.hasOwnProperty(ca)&&(ba[ca]=a[ca]);var da=!1,ea=!1;da="object"===typeof window;ea="function"===typeof importScripts;var fa="",ha;
            if(da||ea)ea?fa=self.location.href:document.currentScript&&(fa=document.currentScript.src),_scriptDir&&(fa=_scriptDir),fa=0!==fa.indexOf("blob:")?fa.substr(0,fa.lastIndexOf("/")+1):"",ea&&(ha=function(b){try{var c=new XMLHttpRequest;c.open("GET",b,!1);c.responseType="arraybuffer";c.send(null);return new Uint8Array(c.response)}catch(d){if(b=ia(b))return b;throw d;}});var ja=a.print||console.log.bind(console),ka=a.printErr||console.warn.bind(console);for(ca in ba)ba.hasOwnProperty(ca)&&(a[ca]=ba[ca]);
            ba=null;var la=[],ma,na;a.wasmBinary&&(na=a.wasmBinary);var noExitRuntime;a.noExitRuntime&&(noExitRuntime=a.noExitRuntime);function oa(){return {buffer:new ArrayBuffer(pa/65536*65536),grow:function(b){return qa(b)}}}function ra(){return {exports:(
            // EMSCRIPTEN_START_ASM
            function a(asmLibraryArg,wasmMemory,wasmTable){var scratchBuffer=new ArrayBuffer(8);var b=new Int32Array(scratchBuffer);var c=new Float32Array(scratchBuffer);var d=new Float64Array(scratchBuffer);function e(index,value){b[index]=value;}function f(){return d[0]}function g(value){c[0]=value;}function h(index){return b[index]}function i(){return c[0]}function j(global,env,buffer){var k=env.memory;var l=wasmTable;var m=new global.Int8Array(buffer);var n=new global.Int16Array(buffer);var o=new global.Int32Array(buffer);var p=new global.Uint8Array(buffer);var q=new global.Uint16Array(buffer);var r=new global.Uint32Array(buffer);var s=new global.Float32Array(buffer);var t=new global.Float64Array(buffer);var u=global.Math.imul;var v=global.Math.fround;var w=global.Math.abs;var x=global.Math.clz32;var y=global.Math.min;var z=global.Math.max;var A=global.Math.floor;var B=global.Math.ceil;var C=global.Math.sqrt;var D=env.abort;var E=global.NaN;var F=global.Infinity;var G=env.gettimeofday;var H=env.emscripten_memcpy_big;var I=env.emscripten_resize_heap;var J=env.abort;var K=5268592;var L=0;
            // EMSCRIPTEN_START_FUNCS
            function Hn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=v(0),i=v(0),j=v(0),k=0,m=v(0),n=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=0,O=0,P=v(0),Q=v(0),R=v(0);c=K-176|0;K=c;d=l[o[o[a>>2]+20>>2]](a)|0;k=l[o[o[d>>2]+56>>2]](d)|0;d=l[o[o[a>>2]+20>>2]](a)|0;g=l[o[o[d>>2]+56>>2]](d)|0;M=s[b+40>>2];a:{if(M<=v(0)){break a}d=o[b+4>>2]+ -3|0;if(d>>>0>9){break a}f=k&2048;O=g&4096;b:{switch(d-1|0){default:o[c+124>>2]=0;o[c+128>>2]=0;o[c+136>>2]=0;o[c+140>>2]=0;o[c+132>>2]=1065353216;o[c+156>>2]=0;o[c+160>>2]=0;o[c+152>>2]=1065353216;o[c+164>>2]=0;o[c+168>>2]=0;o[c+172>>2]=0;o[c+116>>2]=0;o[c+120>>2]=0;o[c+112>>2]=1065353216;o[c+144>>2]=0;o[c+148>>2]=0;d=o[b+28>>2];I=s[d+52>>2];t=s[d+8>>2];C=s[d+12>>2];D=s[d+56>>2];F=s[d+28>>2];n=s[d+20>>2];q=s[d+24>>2];r=s[d+60>>2];E=s[b+308>>2];m=s[d+44>>2];G=s[b+300>>2];j=s[d+36>>2];H=s[b+304>>2];h=s[d+40>>2];i=s[d+4>>2];o[c+172>>2]=0;s[c+168>>2]=r+v(v(v(G*j)+v(H*h))+v(E*m));s[c+164>>2]=D+v(v(v(G*n)+v(H*q))+v(E*F));s[c+160>>2]=I+v(v(v(G*i)+v(H*t))+v(E*C));d=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[d>>2]+64>>2]](d,c+112|0,M);d=o[b+32>>2];I=s[d+52>>2];t=s[d+8>>2];C=s[d+12>>2];D=s[d+56>>2];F=s[d+28>>2];n=s[d+20>>2];q=s[d+24>>2];r=s[d+60>>2];E=s[b+324>>2];m=s[d+44>>2];G=s[b+316>>2];j=s[d+36>>2];H=s[b+320>>2];h=s[d+40>>2];i=s[d+4>>2];o[c+172>>2]=0;s[c+168>>2]=r+v(v(v(G*j)+v(H*h))+v(E*m));s[c+164>>2]=D+v(v(v(G*n)+v(H*q))+v(E*F));s[c+160>>2]=I+v(v(v(G*i)+v(H*t))+v(E*C));if(!f){break a}a=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[a>>2]+64>>2]](a,c+112|0,M);break a;case 0:d=o[b+28>>2];j=s[d+52>>2];w=s[d+8>>2];x=s[d+12>>2];E=s[b+584>>2];G=s[b+552>>2];H=s[b+568>>2];h=s[d+56>>2];i=s[d+60>>2];I=s[b+608>>2];t=s[b+600>>2];C=s[b+604>>2];u=s[d+28>>2];y=s[d+20>>2];z=s[d+24>>2];D=s[b+588>>2];F=s[b+556>>2];n=s[b+572>>2];q=s[b+592>>2];A=s[d+44>>2];r=s[b+560>>2];B=s[d+36>>2];m=s[b+576>>2];J=s[d+40>>2];L=s[d+4>>2];o[c+172>>2]=0;o[c+156>>2]=0;o[c+140>>2]=0;s[c+152>>2]=v(v(r*B)+v(m*J))+v(q*A);s[c+148>>2]=v(v(F*B)+v(n*J))+v(D*A);s[c+136>>2]=v(v(r*y)+v(m*z))+v(q*u);s[c+132>>2]=v(v(F*y)+v(n*z))+v(D*u);s[c+168>>2]=i+v(v(v(B*t)+v(J*C))+v(A*I));s[c+164>>2]=h+v(v(v(y*t)+v(z*C))+v(u*I));o[c+124>>2]=0;s[c+144>>2]=v(v(G*B)+v(H*J))+v(E*A);s[c+128>>2]=v(v(G*y)+v(H*z))+v(E*u);s[c+120>>2]=v(v(L*r)+v(w*m))+v(x*q);s[c+116>>2]=v(v(L*F)+v(w*n))+v(x*D);s[c+112>>2]=v(v(G*L)+v(H*w))+v(E*x);s[c+160>>2]=j+v(v(v(L*t)+v(w*C))+v(x*I));c:{if(f){d=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[d>>2]+64>>2]](d,c+112|0,M);d=o[b+32>>2];j=s[d+52>>2];h=s[d+56>>2];i=s[d+60>>2];E=s[b+672>>2];G=s[b+664>>2];H=s[b+668>>2];w=s[d+8>>2];x=s[d+12>>2];u=s[d+28>>2];y=s[d+20>>2];z=s[d+24>>2];I=s[b+648>>2];t=s[b+616>>2];C=s[b+632>>2];D=s[b+652>>2];F=s[b+620>>2];n=s[b+636>>2];q=s[b+656>>2];A=s[d+44>>2];r=s[b+624>>2];B=s[d+36>>2];m=s[b+640>>2];J=s[d+40>>2];L=s[d+4>>2];o[c+172>>2]=0;o[c+156>>2]=0;o[c+140>>2]=0;o[c+124>>2]=0;s[c+152>>2]=v(v(r*B)+v(m*J))+v(q*A);s[c+148>>2]=v(v(F*B)+v(n*J))+v(D*A);s[c+144>>2]=v(v(t*B)+v(C*J))+v(I*A);s[c+136>>2]=v(v(r*y)+v(m*z))+v(q*u);s[c+132>>2]=v(v(F*y)+v(n*z))+v(D*u);s[c+128>>2]=v(v(t*y)+v(C*z))+v(I*u);s[c+120>>2]=v(v(L*r)+v(w*m))+v(x*q);s[c+116>>2]=v(v(L*F)+v(w*n))+v(x*D);s[c+112>>2]=v(v(t*L)+v(C*w))+v(I*x);s[c+168>>2]=i+v(v(v(B*G)+v(J*H))+v(A*E));s[c+164>>2]=h+v(v(v(y*G)+v(z*H))+v(u*E));s[c+160>>2]=j+v(v(v(L*G)+v(w*H))+v(x*E));d=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[d>>2]+64>>2]](d,c+112|0,M);break c}d=o[b+32>>2];j=s[d+52>>2];h=s[d+56>>2];i=s[d+60>>2];E=s[b+672>>2];G=s[b+664>>2];H=s[b+668>>2];w=s[d+8>>2];x=s[d+12>>2];u=s[d+28>>2];y=s[d+20>>2];z=s[d+24>>2];I=s[b+648>>2];t=s[b+616>>2];C=s[b+632>>2];D=s[b+652>>2];F=s[b+620>>2];n=s[b+636>>2];q=s[b+656>>2];A=s[d+44>>2];r=s[b+624>>2];B=s[d+36>>2];m=s[b+640>>2];J=s[d+40>>2];L=s[d+4>>2];o[c+172>>2]=0;o[c+156>>2]=0;o[c+140>>2]=0;o[c+124>>2]=0;s[c+152>>2]=v(v(r*B)+v(m*J))+v(q*A);s[c+148>>2]=v(v(F*B)+v(n*J))+v(D*A);s[c+144>>2]=v(v(t*B)+v(C*J))+v(I*A);s[c+136>>2]=v(v(r*y)+v(m*z))+v(q*u);s[c+132>>2]=v(v(F*y)+v(n*z))+v(D*u);s[c+128>>2]=v(v(t*y)+v(C*z))+v(I*u);s[c+120>>2]=v(v(L*r)+v(w*m))+v(x*q);s[c+116>>2]=v(v(L*F)+v(w*n))+v(x*D);s[c+112>>2]=v(v(t*L)+v(C*w))+v(I*x);s[c+168>>2]=i+v(v(v(B*G)+v(J*H))+v(A*E));s[c+164>>2]=h+v(v(v(y*G)+v(z*H))+v(u*E));s[c+160>>2]=j+v(v(v(L*G)+v(w*H))+v(x*E));}d=b+688|0;j=Tb(d);h=Ub(d);if(!O|j==h){break a}i=s[b+692>>2];o[c+96>>2]=o[c+120>>2];o[c+100>>2]=o[c+136>>2];o[c+108>>2]=0;o[c+104>>2]=o[c+152>>2];o[c+80>>2]=o[c+112>>2];o[c+84>>2]=o[c+128>>2];o[c+92>>2]=0;o[c+88>>2]=o[c+144>>2];b=l[o[o[a>>2]+20>>2]](a)|0;o[c+72>>2]=0;o[c+76>>2]=0;o[c+64>>2]=0;o[c+68>>2]=0;a=i>v(0);l[o[o[b>>2]+68>>2]](b,c+160|0,c+96|0,c+80|0,M,M,a?j:v(0),a?h:v(6.2831854820251465),c- -64|0,a,v(10));break a;case 1:d=o[b+28>>2];j=s[d+52>>2];w=s[d+8>>2];x=s[d+12>>2];E=s[b+332>>2];G=s[b+300>>2];H=s[b+316>>2];h=s[d+56>>2];i=s[d+60>>2];I=s[b+356>>2];t=s[b+348>>2];C=s[b+352>>2];u=s[d+28>>2];y=s[d+20>>2];z=s[d+24>>2];D=s[b+336>>2];F=s[b+304>>2];n=s[b+320>>2];q=s[b+340>>2];A=s[d+44>>2];r=s[b+308>>2];B=s[d+36>>2];m=s[b+324>>2];J=s[d+40>>2];L=s[d+4>>2];o[c+172>>2]=0;o[c+156>>2]=0;o[c+140>>2]=0;s[c+152>>2]=v(v(r*B)+v(m*J))+v(q*A);s[c+148>>2]=v(v(F*B)+v(n*J))+v(D*A);s[c+136>>2]=v(v(r*y)+v(m*z))+v(q*u);s[c+132>>2]=v(v(F*y)+v(n*z))+v(D*u);s[c+168>>2]=i+v(v(v(B*t)+v(J*C))+v(A*I));s[c+164>>2]=h+v(v(v(y*t)+v(z*C))+v(u*I));o[c+124>>2]=0;s[c+144>>2]=v(v(G*B)+v(H*J))+v(E*A);s[c+128>>2]=v(v(G*y)+v(H*z))+v(E*u);s[c+120>>2]=v(v(L*r)+v(w*m))+v(x*q);s[c+116>>2]=v(v(L*F)+v(w*n))+v(x*D);s[c+112>>2]=v(v(G*L)+v(H*w))+v(E*x);s[c+160>>2]=j+v(v(v(L*t)+v(w*C))+v(x*I));d:{if(f){d=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[d>>2]+64>>2]](d,c+112|0,M);d=o[b+32>>2];j=s[d+52>>2];h=s[d+56>>2];i=s[d+60>>2];E=s[b+420>>2];G=s[b+412>>2];H=s[b+416>>2];w=s[d+8>>2];x=s[d+12>>2];u=s[d+28>>2];y=s[d+20>>2];z=s[d+24>>2];I=s[b+396>>2];t=s[b+364>>2];C=s[b+380>>2];D=s[b+400>>2];F=s[b+368>>2];n=s[b+384>>2];q=s[b+404>>2];A=s[d+44>>2];r=s[b+372>>2];B=s[d+36>>2];m=s[b+388>>2];J=s[d+40>>2];L=s[d+4>>2];o[c+172>>2]=0;o[c+156>>2]=0;o[c+140>>2]=0;o[c+124>>2]=0;s[c+152>>2]=v(v(r*B)+v(m*J))+v(q*A);s[c+148>>2]=v(v(F*B)+v(n*J))+v(D*A);s[c+144>>2]=v(v(t*B)+v(C*J))+v(I*A);s[c+136>>2]=v(v(r*y)+v(m*z))+v(q*u);s[c+132>>2]=v(v(F*y)+v(n*z))+v(D*u);s[c+128>>2]=v(v(t*y)+v(C*z))+v(I*u);s[c+120>>2]=v(v(L*r)+v(w*m))+v(x*q);s[c+116>>2]=v(v(L*F)+v(w*n))+v(x*D);s[c+112>>2]=v(v(t*L)+v(C*w))+v(I*x);s[c+168>>2]=i+v(v(v(B*G)+v(J*H))+v(A*E));s[c+164>>2]=h+v(v(v(y*G)+v(z*H))+v(u*E));s[c+160>>2]=j+v(v(v(L*G)+v(w*H))+v(x*E));d=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[d>>2]+64>>2]](d,c+112|0,M);break d}d=o[b+32>>2];j=s[d+52>>2];h=s[d+56>>2];i=s[d+60>>2];E=s[b+420>>2];G=s[b+412>>2];H=s[b+416>>2];w=s[d+8>>2];x=s[d+12>>2];u=s[d+28>>2];y=s[d+20>>2];z=s[d+24>>2];I=s[b+396>>2];t=s[b+364>>2];C=s[b+380>>2];D=s[b+400>>2];F=s[b+368>>2];n=s[b+384>>2];q=s[b+404>>2];A=s[d+44>>2];r=s[b+372>>2];B=s[d+36>>2];m=s[b+388>>2];J=s[d+40>>2];L=s[d+4>>2];o[c+172>>2]=0;o[c+156>>2]=0;o[c+140>>2]=0;o[c+124>>2]=0;s[c+152>>2]=v(v(r*B)+v(m*J))+v(q*A);s[c+148>>2]=v(v(F*B)+v(n*J))+v(D*A);s[c+144>>2]=v(v(t*B)+v(C*J))+v(I*A);s[c+136>>2]=v(v(r*y)+v(m*z))+v(q*u);s[c+132>>2]=v(v(F*y)+v(n*z))+v(D*u);s[c+128>>2]=v(v(t*y)+v(C*z))+v(I*u);s[c+120>>2]=v(v(L*r)+v(w*m))+v(x*q);s[c+116>>2]=v(v(L*F)+v(w*n))+v(x*D);s[c+112>>2]=v(v(t*L)+v(C*w))+v(I*x);s[c+168>>2]=i+v(v(v(B*G)+v(J*H))+v(A*E));s[c+164>>2]=h+v(v(v(y*G)+v(z*H))+v(u*E));s[c+160>>2]=j+v(v(v(L*G)+v(w*H))+v(x*E));}if(!O){break a}of(c+96|0,b,v(6.0868353843688965),M);o[c+108>>2]=0;j=s[c+96>>2];h=s[c+100>>2];i=s[c+104>>2];s[c+104>>2]=v(v(v(j*s[c+144>>2])+v(h*s[c+148>>2]))+v(i*s[c+152>>2]))+s[c+168>>2];s[c+100>>2]=v(v(v(j*s[c+128>>2])+v(h*s[c+132>>2]))+v(i*s[c+136>>2]))+s[c+164>>2];s[c+96>>2]=v(v(v(j*s[c+112>>2])+v(h*s[c+116>>2]))+v(i*s[c+120>>2]))+s[c+160>>2];d=c+160|0;k=0;while(1){of(c+80|0,b,v(v(v(k|0)*v(6.283185005187988))*v(.03125)),M);o[c+92>>2]=0;j=s[c+80>>2];h=s[c+84>>2];i=s[c+88>>2];s[c+88>>2]=v(v(v(j*s[c+144>>2])+v(h*s[c+148>>2]))+v(i*s[c+152>>2]))+s[c+168>>2];s[c+84>>2]=v(v(v(j*s[c+128>>2])+v(h*s[c+132>>2]))+v(i*s[c+136>>2]))+s[c+164>>2];s[c+80>>2]=v(v(v(j*s[c+112>>2])+v(h*s[c+116>>2]))+v(i*s[c+120>>2]))+s[c+160>>2];g=l[o[o[a>>2]+20>>2]](a)|0;o[c+72>>2]=0;o[c+76>>2]=0;o[c+64>>2]=0;o[c+68>>2]=0;l[o[o[g>>2]+16>>2]](g,c+96|0,c+80|0,c- -64|0);if(!(k&3)){g=l[o[o[a>>2]+20>>2]](a)|0;o[c+72>>2]=0;o[c+76>>2]=0;o[c+64>>2]=0;o[c+68>>2]=0;l[o[o[g>>2]+16>>2]](g,d,c+80|0,c- -64|0);}g=o[c+92>>2];o[c+104>>2]=o[c+88>>2];o[c+108>>2]=g;g=o[c+84>>2];o[c+96>>2]=o[c+80>>2];o[c+100>>2]=g;k=k+1|0;if((k|0)!=32){continue}break}J=s[b+512>>2];L=s[b+452>>2];k=o[b+32>>2];e:{if(s[k+404>>2]>v(0)){P=s[k+36>>2];h=s[b+412>>2];t=s[k+40>>2];i=s[b+416>>2];E=v(v(P*h)+v(t*i));w=s[k+20>>2];x=s[k+24>>2];u=s[k+28>>2];C=s[b+420>>2];G=v(v(v(w*h)+v(x*i))+v(u*C));y=s[k+4>>2];z=s[k+8>>2];A=s[k+12>>2];H=v(v(v(y*h)+v(z*i))+v(A*C));D=s[b+372>>2];F=s[b+388>>2];n=s[b+404>>2];B=s[k+44>>2];I=v(v(v(D*P)+v(F*t))+v(n*B));q=s[b+368>>2];r=s[b+384>>2];m=s[b+400>>2];Q=v(v(v(q*P)+v(r*t))+v(m*B));j=s[b+364>>2];h=s[b+380>>2];i=s[b+396>>2];R=v(v(v(j*P)+v(h*t))+v(i*B));t=v(v(v(D*w)+v(F*x))+v(n*u));P=v(v(v(q*w)+v(r*x))+v(m*u));u=v(v(v(j*w)+v(h*x))+v(i*u));n=v(v(v(y*D)+v(z*F))+v(A*n));q=v(v(v(y*q)+v(z*r))+v(A*m));r=v(v(v(j*y)+v(h*z))+v(i*A));m=v(B*C);break e}k=o[b+28>>2];P=s[k+36>>2];h=s[b+348>>2];t=s[k+40>>2];i=s[b+352>>2];E=v(v(P*h)+v(t*i));w=s[k+20>>2];x=s[k+24>>2];u=s[k+28>>2];C=s[b+356>>2];G=v(v(v(w*h)+v(x*i))+v(u*C));y=s[k+4>>2];z=s[k+8>>2];A=s[k+12>>2];H=v(v(v(y*h)+v(z*i))+v(A*C));D=s[b+308>>2];F=s[b+324>>2];n=s[b+340>>2];B=s[k+44>>2];I=v(v(v(D*P)+v(F*t))+v(n*B));q=s[b+304>>2];r=s[b+320>>2];m=s[b+336>>2];Q=v(v(v(q*P)+v(r*t))+v(m*B));j=s[b+300>>2];h=s[b+316>>2];i=s[b+332>>2];R=v(v(v(j*P)+v(h*t))+v(i*B));t=v(v(v(D*w)+v(F*x))+v(n*u));P=v(v(v(q*w)+v(r*x))+v(m*u));u=v(v(v(j*w)+v(h*x))+v(i*u));n=v(v(v(y*D)+v(z*F))+v(A*n));q=v(v(v(y*q)+v(z*r))+v(A*m));r=v(v(v(j*y)+v(h*z))+v(i*A));m=v(B*C);}j=s[k+52>>2];h=s[k+56>>2];i=s[k+60>>2];o[c+172>>2]=0;o[c+156>>2]=0;s[c+152>>2]=I;s[c+148>>2]=Q;s[c+144>>2]=R;o[c+140>>2]=0;s[c+136>>2]=t;s[c+132>>2]=P;s[c+128>>2]=u;o[c+124>>2]=0;s[c+120>>2]=n;s[c+116>>2]=q;s[c+112>>2]=r;s[c+168>>2]=i+v(E+m);s[c+164>>2]=G+h;s[c+160>>2]=j+H;b=o[d+12>>2];o[c+88>>2]=o[d+8>>2];o[c+92>>2]=b;b=o[d+4>>2];o[c+80>>2]=o[d>>2];o[c+84>>2]=b;o[c+76>>2]=0;s[c+72>>2]=R;s[c+68>>2]=u;s[c+64>>2]=r;o[c+60>>2]=0;s[c+56>>2]=Q;s[c+52>>2]=P;s[c+48>>2]=q;a=l[o[o[a>>2]+20>>2]](a)|0;o[c+40>>2]=0;o[c+44>>2]=0;o[c+32>>2]=0;o[c+36>>2]=0;l[o[o[a>>2]+68>>2]](a,c+80|0,c- -64|0,c+48|0,M,M,v(v(-J)-L),v(L-J),c+32|0,1,v(10));break a;case 2:case 5:g=b+1072|0;d=o[g+4>>2];o[c+120>>2]=o[g>>2];o[c+124>>2]=d;N=b+1064|0;g=N;d=o[g+4>>2];o[c+112>>2]=o[g>>2];o[c+116>>2]=d;g=b+1088|0;d=o[g+4>>2];o[c+136>>2]=o[g>>2];o[c+140>>2]=d;k=b+1080|0;g=k;d=o[g+4>>2];o[c+128>>2]=o[g>>2];o[c+132>>2]=d;g=b+1104|0;d=o[g+4>>2];o[c+152>>2]=o[g>>2];o[c+156>>2]=d;g=b+1096|0;e=g;d=o[e+4>>2];o[c+144>>2]=o[e>>2];o[c+148>>2]=d;e=b+1120|0;d=o[e+4>>2];o[c+168>>2]=o[e>>2];o[c+172>>2]=d;d=b+1112|0;e=o[d+4>>2];o[c+160>>2]=o[d>>2];o[c+164>>2]=e;f:{if(f){e=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[e>>2]+64>>2]](e,c+112|0,M);f=b+1136|0;e=o[f+4>>2];o[c+120>>2]=o[f>>2];o[c+124>>2]=e;f=b+1128|0;e=o[f+4>>2];o[c+112>>2]=o[f>>2];o[c+116>>2]=e;f=b+1152|0;e=o[f+4>>2];o[c+136>>2]=o[f>>2];o[c+140>>2]=e;f=b+1144|0;e=o[f+4>>2];o[c+128>>2]=o[f>>2];o[c+132>>2]=e;f=b+1168|0;e=o[f+4>>2];o[c+152>>2]=o[f>>2];o[c+156>>2]=e;f=b+1160|0;e=o[f+4>>2];o[c+144>>2]=o[f>>2];o[c+148>>2]=e;f=b+1184|0;e=o[f+4>>2];o[c+168>>2]=o[f>>2];o[c+172>>2]=e;f=b+1176|0;e=o[f+4>>2];o[c+160>>2]=o[f>>2];o[c+164>>2]=e;e=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[e>>2]+64>>2]](e,c+112|0,M);break f}f=b+1136|0;e=o[f+4>>2];o[c+120>>2]=o[f>>2];o[c+124>>2]=e;f=b+1128|0;e=o[f+4>>2];o[c+112>>2]=o[f>>2];o[c+116>>2]=e;f=b+1152|0;e=o[f+4>>2];o[c+136>>2]=o[f>>2];o[c+140>>2]=e;f=b+1144|0;e=o[f+4>>2];o[c+128>>2]=o[f>>2];o[c+132>>2]=e;f=b+1168|0;e=o[f+4>>2];o[c+152>>2]=o[f>>2];o[c+156>>2]=e;f=b+1160|0;e=o[f+4>>2];o[c+144>>2]=o[f>>2];o[c+148>>2]=e;f=b+1184|0;e=o[f+4>>2];o[c+168>>2]=o[f>>2];o[c+172>>2]=e;f=b+1176|0;e=o[f+4>>2];o[c+160>>2]=o[f>>2];o[c+164>>2]=e;}if(!O){break a}e=N;f=o[e+12>>2];o[c+120>>2]=o[e+8>>2];o[c+124>>2]=f;f=o[e+4>>2];o[c+112>>2]=o[e>>2];o[c+116>>2]=f;e=k;f=o[e+12>>2];o[c+136>>2]=o[e+8>>2];o[c+140>>2]=f;f=o[e+4>>2];o[c+128>>2]=o[e>>2];o[c+132>>2]=f;e=g;f=o[e+12>>2];o[c+152>>2]=o[e+8>>2];o[c+156>>2]=f;f=o[e+4>>2];o[c+144>>2]=o[e>>2];o[c+148>>2]=f;f=o[d+12>>2];o[c+168>>2]=o[d+8>>2];o[c+172>>2]=f;f=o[d+4>>2];o[c+160>>2]=o[d>>2];o[c+164>>2]=f;o[c+96>>2]=o[c+120>>2];o[c+100>>2]=o[c+136>>2];o[c+108>>2]=0;o[c+104>>2]=o[c+152>>2];o[c+80>>2]=o[c+112>>2];o[c+84>>2]=o[c+128>>2];o[c+92>>2]=0;o[c+88>>2]=o[c+144>>2];m=s[b+1e3>>2];j=s[b+996>>2];h=s[b+936>>2];i=s[b+932>>2];e=l[o[o[a>>2]+20>>2]](a)|0;o[c+72>>2]=0;o[c+76>>2]=0;o[c+64>>2]=0;o[c+68>>2]=0;O=b+1176|0;l[o[o[e>>2]+72>>2]](e,O,c+96|0,c+80|0,v(M*v(.8999999761581421)),i,h,j,m,c- -64|0,v(10),1);o[c+92>>2]=0;o[c+88>>2]=o[c+148>>2];o[c+84>>2]=o[c+132>>2];o[c+80>>2]=o[c+116>>2];h=s[b+1196>>2];n=s[c+80>>2];i=s[b+1200>>2];q=va(i);r=s[c+84>>2];m=wa(i);s[c+68>>2]=v(r*m)-v(q*n);j=va(h);i=s[c+88>>2];h=wa(h);s[c+72>>2]=v(v(n*v(m*j))+v(r*v(j*q)))+v(i*h);s[c+64>>2]=v(v(n*v(h*m))+v(r*v(h*q)))-v(j*i);f=b+1136|0;e=o[f+4>>2];o[c+120>>2]=o[f>>2];o[c+124>>2]=e;f=b+1128|0;e=o[f+4>>2];o[c+112>>2]=o[f>>2];o[c+116>>2]=e;f=b+1152|0;e=o[f+4>>2];o[c+136>>2]=o[f>>2];o[c+140>>2]=e;f=b+1144|0;e=o[f+4>>2];o[c+128>>2]=o[f>>2];o[c+132>>2]=e;f=b+1168|0;e=o[f+4>>2];o[c+152>>2]=o[f>>2];o[c+156>>2]=e;f=b+1160|0;e=o[f+4>>2];o[c+144>>2]=o[f>>2];o[c+148>>2]=e;e=o[O+4>>2];o[c+160>>2]=o[O>>2];o[c+164>>2]=e;f=b+1184|0;e=o[f+4>>2];o[c+168>>2]=o[f>>2];o[c+172>>2]=e;o[c+60>>2]=0;s[c+56>>2]=-s[c+144>>2];s[c+52>>2]=-s[c+128>>2];s[c+48>>2]=-s[c+112>>2];h=s[b+868>>2];i=s[b+872>>2];g:{if(!!(h>i)){e=l[o[o[a>>2]+20>>2]](a)|0;o[c+40>>2]=0;o[c+44>>2]=0;o[c+32>>2]=0;o[c+36>>2]=0;l[o[o[e>>2]+68>>2]](e,O,c+48|0,c- -64|0,M,M,v(-3.1415927410125732),v(3.1415927410125732),c+32|0,0,v(10));break g}if(!(h<i)){break g}e=l[o[o[a>>2]+20>>2]](a)|0;o[c+40>>2]=0;o[c+44>>2]=0;o[c+32>>2]=0;o[c+36>>2]=0;l[o[o[e>>2]+68>>2]](e,O,c+48|0,c- -64|0,M,M,h,i,c+32|0,1,v(10));}e=o[N+12>>2];o[c+120>>2]=o[N+8>>2];o[c+124>>2]=e;e=o[N+4>>2];o[c+112>>2]=o[N>>2];o[c+116>>2]=e;N=o[k+12>>2];o[c+136>>2]=o[k+8>>2];o[c+140>>2]=N;N=o[k+4>>2];o[c+128>>2]=o[k>>2];o[c+132>>2]=N;k=o[g+12>>2];o[c+152>>2]=o[g+8>>2];o[c+156>>2]=k;k=o[g+4>>2];o[c+144>>2]=o[g>>2];o[c+148>>2]=k;g=o[d+12>>2];o[c+168>>2]=o[d+8>>2];o[c+172>>2]=g;g=o[d+4>>2];o[c+160>>2]=o[d>>2];o[c+164>>2]=g;d=o[b+692>>2];o[c+40>>2]=o[b+688>>2];o[c+44>>2]=d;d=o[b+684>>2];o[c+32>>2]=o[b+680>>2];o[c+36>>2]=d;d=o[b+708>>2];o[c+24>>2]=o[b+704>>2];o[c+28>>2]=d;d=o[b+700>>2];o[c+16>>2]=o[b+696>>2];o[c+20>>2]=d;a=l[o[o[a>>2]+20>>2]](a)|0;o[c+8>>2]=0;o[c+12>>2]=0;o[c>>2]=0;o[c+4>>2]=0;l[o[o[a>>2]+80>>2]](a,c+32|0,c+16|0,c+112|0,c);break a;case 8:g=b+1244|0;d=o[g+4>>2];o[c+120>>2]=o[g>>2];o[c+124>>2]=d;N=b+1236|0;g=N;d=o[g+4>>2];o[c+112>>2]=o[g>>2];o[c+116>>2]=d;g=b+1260|0;d=o[g+4>>2];o[c+136>>2]=o[g>>2];o[c+140>>2]=d;k=b+1252|0;g=k;d=o[g+4>>2];o[c+128>>2]=o[g>>2];o[c+132>>2]=d;g=b+1276|0;d=o[g+4>>2];o[c+152>>2]=o[g>>2];o[c+156>>2]=d;g=b+1268|0;e=g;d=o[e+4>>2];o[c+144>>2]=o[e>>2];o[c+148>>2]=d;e=b+1292|0;d=o[e+4>>2];o[c+168>>2]=o[e>>2];o[c+172>>2]=d;d=b+1284|0;e=o[d+4>>2];o[c+160>>2]=o[d>>2];o[c+164>>2]=e;h:{if(f){e=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[e>>2]+64>>2]](e,c+112|0,M);f=b+1308|0;e=o[f+4>>2];o[c+120>>2]=o[f>>2];o[c+124>>2]=e;f=b+1300|0;e=o[f+4>>2];o[c+112>>2]=o[f>>2];o[c+116>>2]=e;f=b+1324|0;e=o[f+4>>2];o[c+136>>2]=o[f>>2];o[c+140>>2]=e;f=b+1316|0;e=o[f+4>>2];o[c+128>>2]=o[f>>2];o[c+132>>2]=e;f=b+1340|0;e=o[f+4>>2];o[c+152>>2]=o[f>>2];o[c+156>>2]=e;f=b+1332|0;e=o[f+4>>2];o[c+144>>2]=o[f>>2];o[c+148>>2]=e;f=b+1356|0;e=o[f+4>>2];o[c+168>>2]=o[f>>2];o[c+172>>2]=e;f=b+1348|0;e=o[f+4>>2];o[c+160>>2]=o[f>>2];o[c+164>>2]=e;e=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[e>>2]+64>>2]](e,c+112|0,M);break h}f=b+1308|0;e=o[f+4>>2];o[c+120>>2]=o[f>>2];o[c+124>>2]=e;f=b+1300|0;e=o[f+4>>2];o[c+112>>2]=o[f>>2];o[c+116>>2]=e;f=b+1324|0;e=o[f+4>>2];o[c+136>>2]=o[f>>2];o[c+140>>2]=e;f=b+1316|0;e=o[f+4>>2];o[c+128>>2]=o[f>>2];o[c+132>>2]=e;f=b+1340|0;e=o[f+4>>2];o[c+152>>2]=o[f>>2];o[c+156>>2]=e;f=b+1332|0;e=o[f+4>>2];o[c+144>>2]=o[f>>2];o[c+148>>2]=e;f=b+1356|0;e=o[f+4>>2];o[c+168>>2]=o[f>>2];o[c+172>>2]=e;f=b+1348|0;e=o[f+4>>2];o[c+160>>2]=o[f>>2];o[c+164>>2]=e;}if(!O){break a}e=N;f=o[e+12>>2];o[c+120>>2]=o[e+8>>2];o[c+124>>2]=f;f=o[e+4>>2];o[c+112>>2]=o[e>>2];o[c+116>>2]=f;e=k;f=o[e+12>>2];o[c+136>>2]=o[e+8>>2];o[c+140>>2]=f;f=o[e+4>>2];o[c+128>>2]=o[e>>2];o[c+132>>2]=f;e=g;f=o[e+12>>2];o[c+152>>2]=o[e+8>>2];o[c+156>>2]=f;f=o[e+4>>2];o[c+144>>2]=o[e>>2];o[c+148>>2]=f;f=o[d+12>>2];o[c+168>>2]=o[d+8>>2];o[c+172>>2]=f;f=o[d+4>>2];o[c+160>>2]=o[d>>2];o[c+164>>2]=f;o[c+96>>2]=o[c+120>>2];o[c+100>>2]=o[c+136>>2];o[c+108>>2]=0;o[c+104>>2]=o[c+152>>2];o[c+80>>2]=o[c+112>>2];o[c+84>>2]=o[c+128>>2];o[c+92>>2]=0;o[c+88>>2]=o[c+144>>2];m=s[b+1148>>2];j=s[b+1144>>2];h=s[b+1060>>2];i=s[b+1056>>2];e=l[o[o[a>>2]+20>>2]](a)|0;o[c+72>>2]=0;o[c+76>>2]=0;o[c+64>>2]=0;o[c+68>>2]=0;O=b+1348|0;l[o[o[e>>2]+72>>2]](e,O,c+96|0,c+80|0,v(M*v(.8999999761581421)),i,h,j,m,c- -64|0,v(10),1);o[c+92>>2]=0;r=s[c+148>>2];o[c+88>>2]=o[c+148>>2];h=s[c+132>>2];o[c+84>>2]=o[c+132>>2];i=s[c+116>>2];o[c+80>>2]=o[c+116>>2];j=s[b+1372>>2];n=va(j);q=wa(j);j=s[b+1368>>2];s[c+68>>2]=v(q*h)-v(n*i);m=va(j);j=wa(j);s[c+72>>2]=v(v(v(q*m)*i)+v(v(m*n)*h))+v(j*r);s[c+64>>2]=v(v(v(j*q)*i)+v(v(j*n)*h))-v(m*r);f=b+1308|0;e=o[f+4>>2];o[c+120>>2]=o[f>>2];o[c+124>>2]=e;f=b+1300|0;e=o[f+4>>2];o[c+112>>2]=o[f>>2];o[c+116>>2]=e;f=b+1324|0;e=o[f+4>>2];o[c+136>>2]=o[f>>2];o[c+140>>2]=e;f=b+1316|0;e=o[f+4>>2];o[c+128>>2]=o[f>>2];o[c+132>>2]=e;f=b+1340|0;e=o[f+4>>2];o[c+152>>2]=o[f>>2];o[c+156>>2]=e;f=b+1332|0;e=o[f+4>>2];o[c+144>>2]=o[f>>2];o[c+148>>2]=e;f=b+1356|0;e=o[f+4>>2];o[c+168>>2]=o[f>>2];o[c+172>>2]=e;e=o[O+4>>2];o[c+160>>2]=o[O>>2];o[c+164>>2]=e;o[c+60>>2]=0;s[c+56>>2]=-s[c+144>>2];s[c+52>>2]=-s[c+128>>2];s[c+48>>2]=-s[c+112>>2];h=s[b+968>>2];i=s[b+972>>2];i:{if(!!(h>i)){e=l[o[o[a>>2]+20>>2]](a)|0;o[c+40>>2]=0;o[c+44>>2]=0;o[c+32>>2]=0;o[c+36>>2]=0;l[o[o[e>>2]+68>>2]](e,O,c+48|0,c- -64|0,M,M,v(-3.1415927410125732),v(3.1415927410125732),c+32|0,0,v(10));break i}if(!(h<i)){break i}e=l[o[o[a>>2]+20>>2]](a)|0;o[c+40>>2]=0;o[c+44>>2]=0;o[c+32>>2]=0;o[c+36>>2]=0;l[o[o[e>>2]+68>>2]](e,O,c+48|0,c- -64|0,M,M,h,i,c+32|0,1,v(10));}e=o[N+12>>2];o[c+120>>2]=o[N+8>>2];o[c+124>>2]=e;e=o[N+4>>2];o[c+112>>2]=o[N>>2];o[c+116>>2]=e;N=o[k+12>>2];o[c+136>>2]=o[k+8>>2];o[c+140>>2]=N;N=o[k+4>>2];o[c+128>>2]=o[k>>2];o[c+132>>2]=N;k=o[g+12>>2];o[c+152>>2]=o[g+8>>2];o[c+156>>2]=k;k=o[g+4>>2];o[c+144>>2]=o[g>>2];o[c+148>>2]=k;g=o[d+12>>2];o[c+168>>2]=o[d+8>>2];o[c+172>>2]=g;g=o[d+4>>2];o[c+160>>2]=o[d>>2];o[c+164>>2]=g;d=o[b+692>>2];o[c+40>>2]=o[b+688>>2];o[c+44>>2]=d;d=o[b+684>>2];o[c+32>>2]=o[b+680>>2];o[c+36>>2]=d;d=o[b+708>>2];o[c+24>>2]=o[b+704>>2];o[c+28>>2]=d;d=o[b+700>>2];o[c+16>>2]=o[b+696>>2];o[c+20>>2]=d;a=l[o[o[a>>2]+20>>2]](a)|0;o[c+8>>2]=0;o[c+12>>2]=0;o[c>>2]=0;o[c+4>>2]=0;l[o[o[a>>2]+80>>2]](a,c+32|0,c+16|0,c+112|0,c);break a;case 4:case 6:case 7:break a;case 3:break b}}d=o[b+836>>2];o[c+120>>2]=o[b+832>>2];o[c+124>>2]=d;k=b+824|0;g=k;d=o[g+4>>2];o[c+112>>2]=o[g>>2];o[c+116>>2]=d;d=o[b+852>>2];o[c+136>>2]=o[b+848>>2];o[c+140>>2]=d;d=o[b+844>>2];o[c+128>>2]=o[b+840>>2];o[c+132>>2]=d;d=o[b+868>>2];o[c+152>>2]=o[b+864>>2];o[c+156>>2]=d;d=o[b+860>>2];o[c+144>>2]=o[b+856>>2];o[c+148>>2]=d;d=o[b+884>>2];o[c+168>>2]=o[b+880>>2];o[c+172>>2]=d;d=o[b+876>>2];o[c+160>>2]=o[b+872>>2];o[c+164>>2]=d;j:{if(f){d=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[d>>2]+64>>2]](d,c+112|0,M);d=o[b+900>>2];o[c+120>>2]=o[b+896>>2];o[c+124>>2]=d;d=o[b+892>>2];o[c+112>>2]=o[b+888>>2];o[c+116>>2]=d;d=o[b+916>>2];o[c+136>>2]=o[b+912>>2];o[c+140>>2]=d;d=o[b+908>>2];o[c+128>>2]=o[b+904>>2];o[c+132>>2]=d;d=o[b+932>>2];o[c+152>>2]=o[b+928>>2];o[c+156>>2]=d;d=o[b+924>>2];o[c+144>>2]=o[b+920>>2];o[c+148>>2]=d;d=o[b+948>>2];o[c+168>>2]=o[b+944>>2];o[c+172>>2]=d;d=o[b+940>>2];o[c+160>>2]=o[b+936>>2];o[c+164>>2]=d;d=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[d>>2]+64>>2]](d,c+112|0,M);break j}d=o[b+900>>2];o[c+120>>2]=o[b+896>>2];o[c+124>>2]=d;d=o[b+892>>2];o[c+112>>2]=o[b+888>>2];o[c+116>>2]=d;d=o[b+916>>2];o[c+136>>2]=o[b+912>>2];o[c+140>>2]=d;d=o[b+908>>2];o[c+128>>2]=o[b+904>>2];o[c+132>>2]=d;d=o[b+932>>2];o[c+152>>2]=o[b+928>>2];o[c+156>>2]=d;d=o[b+924>>2];o[c+144>>2]=o[b+920>>2];o[c+148>>2]=d;d=o[b+948>>2];o[c+168>>2]=o[b+944>>2];o[c+172>>2]=d;d=o[b+940>>2];o[c+160>>2]=o[b+936>>2];o[c+164>>2]=d;}if(!O){break a}d=p[b+180|0];g=d?k:b+888|0;G=s[g+48>>2];F=s[g+8>>2];n=s[g+4>>2];f=o[g+4>>2];H=s[g+52>>2];m=s[g+24>>2];I=s[g+16>>2];e=o[g+16>>2];j=s[g+20>>2];N=o[g+20>>2];t=s[g+56>>2];h=s[g+40>>2];C=s[g+32>>2];k=o[g+32>>2];i=s[g+36>>2];g=o[g+36>>2];d=(d?824:888)+b|0;D=s[d>>2];d=o[d>>2];E=s[b+184>>2];o[c+108>>2]=0;q=v(h*v(0));r=v(i*v(0));s[c+104>>2]=t+v(q+v(r+v(E*C)));m=v(m*v(0));j=v(j*v(0));s[c+100>>2]=H+v(m+v(j+v(E*I)));h=v(F*v(0));i=v(n*v(0));s[c+96>>2]=G+v(h+v(i+v(E*D)));n=s[b+188>>2];o[c+92>>2]=0;s[c+88>>2]=t+v(q+v(r+v(n*C)));s[c+84>>2]=H+v(m+v(j+v(n*I)));s[c+80>>2]=G+v(h+v(i+v(n*D)));O=l[o[o[a>>2]+20>>2]](a)|0;o[c+72>>2]=0;o[c+76>>2]=0;o[c+64>>2]=0;o[c+68>>2]=0;l[o[o[O>>2]+16>>2]](O,c+96|0,c+80|0,c- -64|0);o[c+76>>2]=0;o[c+72>>2]=k;o[c+68>>2]=e;o[c+64>>2]=d;o[c+60>>2]=0;o[c+56>>2]=g;o[c+52>>2]=N;o[c+48>>2]=f;h=s[b+196>>2];i=s[b+192>>2];a=l[o[o[a>>2]+20>>2]](a)|0;o[c+40>>2]=0;o[c+44>>2]=0;o[c+32>>2]=0;o[c+36>>2]=0;l[o[o[a>>2]+68>>2]](a,b+936|0,c- -64|0,c+48|0,M,M,i,h,c+32|0,1,v(10));}K=c+176|0;}function Mh(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0,q=v(0),r=0,t=v(0),w=v(0),x=0,y=0,z=v(0),A=0,B=v(0),D=0,E=0,F=0,G=v(0),H=v(0);c=K-240|0;K=c;d=o[a+56>>2];if(d){l[o[o[d>>2]>>2]](d)|0;d=o[a+56>>2];if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[6257]=o[6257]+1;d=l[o[4968]](132,16)|0;zi(d);o[a+56>>2]=d;o[c+228>>2]=0;o[c+220>>2]=0;o[c+224>>2]=0;m[c+232|0]=1;a:{if((l[o[o[a>>2]+96>>2]](a)|0)<1){break a}while(1){b:{if((g|0)!=(i|0)){d=h;break b}e=i?i<<1:1;if((i|0)>=(e|0)){d=h;break b}f=0;d=0;if(e){o[6257]=o[6257]+1;d=l[o[4968]](e<<4,16)|0;}c:{d:{if((i|0)>=1){while(1){j=f<<4;r=j+d|0;k=r;j=h+j|0;x=o[j+4>>2];o[k>>2]=o[j>>2];o[k+4>>2]=x;k=o[j+12>>2];o[r+8>>2]=o[j+8>>2];o[r+12>>2]=k;f=f+1|0;if((i|0)!=(f|0)){continue}break d}}if(!h){break c}}if(p[c+232|0]){if(h){o[6258]=o[6258]+1;l[o[4969]](h);}}o[c+228>>2]=0;}o[c+228>>2]=d;m[c+232|0]=1;o[c+224>>2]=e;}o[c+220>>2]=g+1;e=g<<4;d=e+d|0;g=o[c+156>>2];o[d>>2]=o[c+152>>2];o[d+4>>2]=g;g=o[c+164>>2];o[d+8>>2]=o[c+160>>2];o[d+12>>2]=g;h=o[c+228>>2];l[o[o[a>>2]+108>>2]](a,n,e+h|0);n=n+1|0;if((n|0)>=(l[o[o[a>>2]+96>>2]](a)|0)){break a}i=o[c+224>>2];g=o[c+220>>2];continue}}m[c+188|0]=1;o[c+184>>2]=0;m[c+208|0]=1;o[c+176>>2]=0;o[c+180>>2]=0;o[c+204>>2]=0;o[c+196>>2]=0;o[c+200>>2]=0;o[c+164>>2]=0;m[c+168|0]=1;o[c+156>>2]=0;o[c+160>>2]=0;e:{if(!b){Sg(c+152|0,h,o[c+220>>2]);break e}o[c+60>>2]=0;m[c+64|0]=1;o[c+52>>2]=0;o[c+56>>2]=0;wu(c+216|0,c+48|0);o[c+140>>2]=0;m[c+144|0]=1;o[c+132>>2]=0;o[c+136>>2]=0;if(o[c+52>>2]>=1){h=0;while(1){b=o[c+60>>2]+(h<<4)|0;o[c+112>>2]=o[b+8>>2];d=o[b+4>>2];o[c+104>>2]=o[b>>2];o[c+108>>2]=d;q=v(s[b+12>>2]-v(l[o[o[a>>2]+48>>2]](a)));i=o[c+132>>2];f:{if((i|0)!=o[c+136>>2]){break f}b=i?i<<1:1;if((i|0)>=(b|0)){break f}f=0;d=0;if(b){o[6257]=o[6257]+1;d=l[o[4968]](b<<4,16)|0;i=o[c+132>>2];}if((i|0)>=1){while(1){e=f<<4;g=e+d|0;e=e+o[c+140>>2]|0;r=o[e+4>>2];o[g>>2]=o[e>>2];o[g+4>>2]=r;j=o[e+12>>2];o[g+8>>2]=o[e+8>>2];o[g+12>>2]=j;f=f+1|0;if((i|0)!=(f|0)){continue}break}}e=o[c+140>>2];if(e){if(p[c+144|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[c+140>>2]=0;}o[c+140>>2]=d;m[c+144|0]=1;o[c+136>>2]=b;i=o[c+132>>2];}d=o[c+108>>2];b=o[c+140>>2]+(i<<4)|0;o[b>>2]=o[c+104>>2];o[b+4>>2]=d;d=o[c+112>>2];s[b+12>>2]=q;o[b+8>>2]=d;o[c+132>>2]=o[c+132>>2]+1;h=h+1|0;if((h|0)<o[c+52>>2]){continue}break}}o[c+116>>2]=0;m[c+120|0]=1;o[c+108>>2]=0;o[c+112>>2]=0;vu(c+128|0,c+104|0);Sg(c+152|0,o[c+116>>2],o[c+108>>2]);b=o[c+116>>2];if(b){if(p[c+120|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[c+116>>2]=0;}b=o[c+140>>2];if(b){if(p[c+144|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[c+140>>2]=0;}b=o[c+60>>2];if(!b){break e}if(p[c+64|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[c+60>>2]=0;}e=0;j=o[c+196>>2];if((j|0)>=1){f=0;o[6257]=o[6257]+1;D=l[o[4968]](j<<4,16)|0;while(1){g=o[c+52>>2];b=(f<<4)+D|0;d=b;o[d>>2]=o[c+48>>2];o[d+4>>2]=g;d=o[c+60>>2];o[b+8>>2]=o[c+56>>2];o[b+12>>2]=d;f=f+1|0;if((j|0)!=(f|0)){continue}break}}o[c+140>>2]=0;m[c+144|0]=1;o[c+132>>2]=0;o[c+136>>2]=0;m[c+63|0]=0;m[c+64|0]=0;m[c+65|0]=0;m[c+66|0]=0;o[c+56>>2]=0;o[c+60>>2]=0;o[c+48>>2]=0;o[c+52>>2]=0;g:{if((j|0)<=-1){d=j;while(1){b=u(d,36)+e|0;e=b;g=o[e+12>>2];if(g){if(p[b+16|0]){if(g){o[6258]=o[6258]+1;l[o[4969]](g);}}o[e+12>>2]=0;}m[b+16|0]=1;o[e+12>>2]=0;o[b+4>>2]=0;o[b+8>>2]=0;b=d+1|0;if(b>>>0<d>>>0){break g}e=o[c+140>>2];d=b;continue}}if(!j){break g}Wd(c+128|0,j);e=c+48|3;g=e;d=0;while(1){b=o[c+140>>2]+u(d,36)|0;o[b+4>>2]=0;o[b+8>>2]=0;m[b+16|0]=1;o[b+12>>2]=0;h=p[e+4|0]|p[e+5|0]<<8|(p[e+6|0]<<16|p[e+7|0]<<24);f=p[e|0]|p[e+1|0]<<8|(p[e+2|0]<<16|p[e+3|0]<<24);m[b+20|0]=f;m[b+21|0]=f>>>8;m[b+22|0]=f>>>16;m[b+23|0]=f>>>24;m[b+24|0]=h;m[b+25|0]=h>>>8;m[b+26|0]=h>>>16;m[b+27|0]=h>>>24;h=p[g+12|0]|p[g+13|0]<<8|(p[g+14|0]<<16|p[g+15|0]<<24);f=p[g+8|0]|p[g+9|0]<<8|(p[g+10|0]<<16|p[g+11|0]<<24);m[b+28|0]=f;m[b+29|0]=f>>>8;m[b+30|0]=f>>>16;m[b+31|0]=f>>>24;m[b+32|0]=h;m[b+33|0]=h>>>8;m[b+34|0]=h>>>16;m[b+35|0]=h>>>24;d=d+1|0;if((j|0)!=(d|0)){continue}break}}o[c+132>>2]=j;d=o[a+56>>2];f=o[d+8>>2];h=o[c+156>>2];if((f|0)<(h|0)){if(o[d+12>>2]<(h|0)){h:{if(!h){g=0;b=f;break h}o[6257]=o[6257]+1;g=l[o[4968]](h<<4,16)|0;b=o[d+8>>2];}if((b|0)>=1){e=0;while(1){i=e<<4;r=i+g|0;n=r;i=i+o[d+16>>2]|0;k=o[i+4>>2];o[n>>2]=o[i>>2];o[n+4>>2]=k;n=o[i+12>>2];o[r+8>>2]=o[i+8>>2];o[r+12>>2]=n;e=e+1|0;if((b|0)!=(e|0)){continue}break}}b=o[d+16>>2];if(b){if(p[d+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[d+16>>2]=0;}o[d+16>>2]=g;o[d+12>>2]=h;m[d+20|0]=1;}while(1){g=o[c+52>>2];b=o[d+16>>2]+(f<<4)|0;e=b;o[e>>2]=o[c+48>>2];o[e+4>>2]=g;e=o[c+60>>2];o[b+8>>2]=o[c+56>>2];o[b+12>>2]=e;f=f+1|0;if((h|0)!=(f|0)){continue}break}}o[d+8>>2]=h;f=0;if((h|0)>0){while(1){d=f<<4;b=d+o[o[a+56>>2]+16>>2]|0;d=d+o[c+164>>2]|0;e=o[d+4>>2];o[b>>2]=o[d>>2];o[b+4>>2]=e;e=o[d+12>>2];o[b+8>>2]=o[d+8>>2];o[b+12>>2]=e;f=f+1|0;if((h|0)!=(f|0)){continue}break}}if((j|0)>=1){b=0;while(1){h=0;A=o[c+184>>2]+u(o[o[c+204>>2]+(b<<2)>>2],12)|0;d=A;while(1){x=u(b,36);g=x+o[c+140>>2]|0;r=g;y=o[(u(o[d+4>>2],12)+d|0)+8>>2];e=o[g+4>>2];i:{if((e|0)!=o[g+8>>2]){break i}k=e?e<<1:1;if((e|0)>=(k|0)){break i}f=0;i=0;if(k){o[6257]=o[6257]+1;i=l[o[4968]](k<<2,16)|0;e=o[r+4>>2];}n=o[g+12>>2];j:{k:{if((e|0)>=1){while(1){E=f<<2;o[E+i>>2]=o[n+E>>2];f=f+1|0;if((f|0)!=(e|0)){continue}break k}}if(!n){break j}}if(p[g+16|0]){if(n){o[6258]=o[6258]+1;l[o[4969]](n);}}o[g+12>>2]=0;e=o[r+4>>2];}m[g+16|0]=1;o[g+12>>2]=i;o[g+8>>2]=k;}o[o[g+12>>2]+(e<<2)>>2]=y;o[r+4>>2]=o[r+4>>2]+1;if((h|0)<=1){g=o[c+164>>2];e=g+(y<<4)|0;q=s[e+4>>2];g=g+(o[d+8>>2]<<4)|0;t=s[g+4>>2];w=s[e>>2];z=s[g>>2];B=s[e+8>>2];G=s[g+8>>2];e=(c+48|0)+(h<<4)|0;o[e+12>>2]=0;w=v(z-w);t=v(t-q);z=v(G-B);q=v(v(1)/v(C(v(v(v(w*w)+v(t*t))+v(z*z)))));s[e+8>>2]=z*q;s[e+4>>2]=t*q;s[e>>2]=w*q;h=h+1|0;}d=u(o[d+4>>2],12)+d|0;d=u(o[d>>2],12)+d|0;if((A|0)!=(d|0)){continue}break}l:{if((h|0)==2){q=s[c+52>>2];w=s[c+68>>2];t=s[c+64>>2];z=s[c+56>>2];B=s[c+48>>2];G=s[c+72>>2];e=(b<<4)+D|0;o[e+12>>2]=0;H=v(v(w*B)-v(q*t));w=v(v(q*G)-v(z*w));t=v(v(z*t)-v(G*B));q=v(v(1)/v(C(v(v(H*H)+v(v(w*w)+v(t*t))))));s[e+8>>2]=H*q;s[e+4>>2]=t*q;q=v(w*q);s[e>>2]=q;d=o[c+140>>2];g=x+d|0;s[g+20>>2]=q;o[g+24>>2]=o[e+4>>2];e=o[e+8>>2];o[g+32>>2]=1900671690;o[g+28>>2]=e;break l}d=(b<<4)+D|0;o[d>>2]=0;o[d+4>>2]=0;o[d+8>>2]=0;o[d+12>>2]=0;d=o[c+140>>2];}d=d+x|0;g=o[d+4>>2];m:{if((g|0)<1){q=v(1.0000000150474662e+30);break m}h=o[d+12>>2];e=(b<<4)+D|0;w=s[e+8>>2];t=s[e+4>>2];z=s[e>>2];i=o[o[a+56>>2]+16>>2];q=v(1.0000000150474662e+30);f=0;while(1){e=i+(o[h+(f<<2)>>2]<<4)|0;B=v(v(v(s[e>>2]*z)+v(s[e+4>>2]*t))+v(s[e+8>>2]*w));q=q>B?B:q;f=f+1|0;if((g|0)!=(f|0)){continue}break}}s[d+32>>2]=-q;b=b+1|0;if((j|0)!=(b|0)){continue}break}}j=0;n:{if(o[c+132>>2]>0){r=0;i=0;while(1){o:{if((i|0)!=(j|0)){break o}i=j?j<<1:1;if(j>>>0>=i>>>0){i=j;break o}f=0;o[6257]=o[6257]+1;b=l[o[4968]](i<<2,16)|0;p:{q:{if(j){while(1){d=f<<2;o[d+b>>2]=o[d+r>>2];f=f+1|0;if((j|0)!=(f|0)){continue}break q}}if(r){break q}i=1;break p}if(r){o[6258]=o[6258]+1;l[o[4969]](r);}}r=b;}o[(j<<2)+r>>2]=j;j=j+1|0;if((j|0)<o[c+132>>2]){continue}break}while(1){g=j+ -1|0;b=o[(g<<2)+r>>2];o[6257]=o[6257]+1;d=l[o[4968]](4,16)|0;o[d>>2]=b;r:{s:{if((j|0)<2){i=1;b=d;j=g;break s}f=o[c+140>>2];b=f+u(b,36)|0;q=s[b+20>>2];w=s[b+28>>2];t=s[b+24>>2];h=j+ -2|0;e=1;j=g;i=1;while(1){n=o[(h<<2)+r>>2];b=u(n,36)+f|0;t:{if(!(v(v(v(q*s[b+20>>2])+v(t*s[b+24>>2]))+v(w*s[b+28>>2]))>v(.9990000128746033))){g=e;b=d;break t}u:{v:{if((e|0)!=(i|0)){break v}g=e?e<<1:1;if((e|0)>=(g|0)){break v}f=0;b=0;if(g){o[6257]=o[6257]+1;b=l[o[4968]](g<<2,16)|0;}w:{if((e|0)>=1){while(1){k=f<<2;o[k+b>>2]=o[d+k>>2];f=f+1|0;if((f|0)!=(e|0)){continue}break w}}if(!d){break u}}if(d){o[6258]=o[6258]+1;l[o[4969]](d);}break u}g=e;b=d;}o[(i<<2)+b>>2]=n;i=i+1|0;f=0;if((j|0)<1){break t}while(1){d=(f<<2)+r|0;if((n|0)!=o[d>>2]){f=f+1|0;if((j|0)!=(f|0)){continue}break t}break}if((j|0)<=(f|0)){break t}e=d;j=j+ -1|0;d=(j<<2)+r|0;o[e>>2]=o[d>>2];o[d>>2]=n;}if((h|0)>=1){h=h+ -1|0;f=o[c+140>>2];d=b;e=g;continue}break}x:{if((i|0)<=1){break x}d=0;o[c+116>>2]=0;m[c+120|0]=1;o[c+108>>2]=0;o[c+112>>2]=0;o[c+40>>2]=0;o[c+44>>2]=0;o[c+32>>2]=0;o[c+36>>2]=0;q=v(0);w=v(0);t=v(0);g=0;while(1){e=o[c+140>>2]+u(o[(g<<2)+b>>2],36)|0;z=s[e+24>>2];B=s[e+28>>2];s[c+32>>2]=s[e+20>>2]+t;s[c+40>>2]=B+q;s[c+36>>2]=z+w;h=o[e+4>>2];if((h|0)>=1){n=0;while(1){E=o[o[e+12>>2]+(n<<2)>>2];f=o[o[a+56>>2]+16>>2]+(E<<4)|0;k=o[f+12>>2];o[c+16>>2]=o[f+8>>2];o[c+20>>2]=k;k=o[f+4>>2];o[c+8>>2]=o[f>>2];o[c+12>>2]=k;y:{if((d|0)>=1){k=(d|0)>1?d:1;f=0;x=o[c+116>>2];while(1){if((E|0)==o[(x+u(f,24)|0)+20>>2]){break y}f=f+1|0;if((k|0)!=(f|0)){continue}break}}h=o[c+20>>2];o[c+56>>2]=o[c+16>>2];o[c+60>>2]=h;h=o[c+12>>2];o[c+48>>2]=o[c+8>>2];o[c+52>>2]=h;z:{if(o[c+112>>2]!=(d|0)){break z}A=d?d<<1:1;if((d|0)>=(A|0)){break z}f=0;h=0;if(A){o[6257]=o[6257]+1;h=l[o[4968]](u(A,24),16)|0;d=o[c+108>>2];}x=o[c+116>>2];A:{B:{if((d|0)>=1){while(1){k=u(f,24);y=k+h|0;k=k+x|0;F=o[k+4>>2];o[y>>2]=o[k>>2];o[y+4>>2]=F;F=o[k+20>>2];o[y+16>>2]=o[k+16>>2];o[y+20>>2]=F;F=o[k+12>>2];o[y+8>>2]=o[k+8>>2];o[y+12>>2]=F;f=f+1|0;if((f|0)!=(d|0)){continue}break B}}if(!x){break A}}if(p[c+120|0]){if(x){o[6258]=o[6258]+1;l[o[4969]](x);}d=o[c+108>>2];}o[c+116>>2]=0;}o[c+116>>2]=h;m[c+120|0]=1;o[c+112>>2]=A;}h=o[c+52>>2];d=o[c+116>>2]+u(d,24)|0;o[d>>2]=o[c+48>>2];o[d+4>>2]=h;h=o[c+60>>2];f=o[c+56>>2];k=o[c- -64>>2];o[d+20>>2]=E;o[d+16>>2]=k;o[d+8>>2]=f;o[d+12>>2]=h;d=o[c+108>>2]+1|0;o[c+108>>2]=d;h=o[e+4>>2];}n=n+1|0;if((n|0)<(h|0)){continue}break}}q=s[c+40>>2];w=s[c+36>>2];t=s[c+32>>2];g=g+1|0;if((i|0)!=(g|0)){continue}break}o[c+60>>2]=0;m[c+64|0]=1;o[c+52>>2]=0;o[c+56>>2]=0;d=o[c+140>>2]+u(o[b>>2],36)|0;o[c+68>>2]=o[d+20>>2];o[c+72>>2]=o[d+24>>2];o[c+76>>2]=o[d+28>>2];o[c+80>>2]=o[d+32>>2];z=t;t=v(v(1)/v(C(v(v(v(t*t)+v(w*w))+v(q*q)))));s[c+32>>2]=z*t;s[c+36>>2]=w*t;s[c+40>>2]=q*t;o[c+20>>2]=0;m[c+24|0]=1;o[c+12>>2]=0;o[c+16>>2]=0;Lh(c+104|0,c+8|0,c+32|0);C:{if(o[c+12>>2]<=0){d=o[c+108>>2];break C}g=0;h=o[c+52>>2];while(1){k=u(g,24);x=k+o[c+20>>2]|0;D:{if(o[c+56>>2]!=(h|0)){break D}n=h?h<<1:1;if((h|0)>=(n|0)){break D}f=0;e=0;if(n){o[6257]=o[6257]+1;e=l[o[4968]](n<<2,16)|0;h=o[c+52>>2];}d=o[c+60>>2];E:{F:{if((h|0)>=1){while(1){y=f<<2;o[y+e>>2]=o[d+y>>2];f=f+1|0;if((h|0)!=(f|0)){continue}break F}}if(!d){break E}}if(p[c+64|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[c+60>>2]=0;h=o[c+52>>2];}o[c+60>>2]=e;m[c+64|0]=1;o[c+56>>2]=n;}o[o[c+60>>2]+(h<<2)>>2]=o[x+20>>2];h=o[c+52>>2]+1|0;o[c+52>>2]=h;d=o[c+108>>2];G:{if((d|0)<1){break G}e=o[(k+o[c+20>>2]|0)+20>>2];f=0;n=o[c+116>>2];while(1){k=n+u(f,24)|0;if((e|0)!=o[k+20>>2]){f=f+1|0;if((f|0)!=(d|0)){continue}break G}break}o[k+20>>2]=-1;}g=g+1|0;if((g|0)<o[c+12>>2]){continue}break}}if((d|0)>=1){n=0;h=o[c+140>>2];g=o[c+132>>2];k=o[c+116>>2];while(1){x=o[(k+u(n,24)|0)+20>>2];H:{if((x|0)==-1){break H}e=0;if((g|0)<1){break H}while(1){f=0;I:{if((i|0)>0){while(1){if(o[(f<<2)+b>>2]==(e|0)){break I}f=f+1|0;if((i|0)!=(f|0)){continue}break}}f=h+u(e,36)|0;y=o[f+4>>2];if((y|0)<1){break I}A=o[f+12>>2];f=0;while(1){if((x|0)!=o[A+(f<<2)>>2]){f=f+1|0;if((f|0)<(y|0)){continue}break I}break}d=o[c+20>>2];if(d){if(p[c+24|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[c+20>>2]=0;}d=o[c+60>>2];if(d){if(p[c+64|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[c+60>>2]=0;}d=o[c+116>>2];if(!d){break x}if(p[c+120|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[c+116>>2]=0;break x}e=e+1|0;if((g|0)!=(e|0)){continue}break}}n=n+1|0;if((n|0)!=(d|0)){continue}break}}Vd(o[a+56>>2]+24|0,c+48|0);d=o[c+20>>2];if(d){if(p[c+24|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[c+20>>2]=0;}d=o[c+60>>2];if(d){if(p[c+64|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[c+60>>2]=0;}d=o[c+116>>2];if(!d){break r}if(p[c+120|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[c+116>>2]=0;break r}if((i|0)<1){break r}}n=0;while(1){d=o[(n<<2)+b>>2];o[c+60>>2]=0;o[c+52>>2]=0;o[c+56>>2]=0;e=o[c+140>>2];m[c+64|0]=1;d=e+u(d,36)|0;e=o[d+4>>2];J:{if((e|0)>=1){o[6257]=o[6257]+1;k=e<<2;h=l[o[4968]](k,16)|0;f=0;g=o[c+60>>2];x=o[c+52>>2];K:{L:{if((x|0)>=1){while(1){y=f<<2;o[y+h>>2]=o[g+y>>2];f=f+1|0;if((x|0)!=(f|0)){continue}break L}}if(!g){break K}}if(!p[c+64|0]){break K}if(g){o[6258]=o[6258]+1;l[o[4969]](g);}}o[c+60>>2]=h;m[c+64|0]=1;o[c+56>>2]=e;f=0;$(h,0,k);o[c+52>>2]=e;g=o[d+12>>2];h=o[c+60>>2];while(1){k=f<<2;o[k+h>>2]=o[g+k>>2];f=f+1|0;if((e|0)!=(f|0)){continue}break}break J}o[c+52>>2]=e;}e=o[d+24>>2];o[c+68>>2]=o[d+20>>2];o[c+72>>2]=e;e=o[d+32>>2];o[c+76>>2]=o[d+28>>2];o[c+80>>2]=e;Vd(o[a+56>>2]+24|0,c+48|0);d=o[c+60>>2];if(d){if(p[c+64|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[c+60>>2]=0;}n=n+1|0;if((n|0)!=(i|0)){continue}break}}if(b){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}if(j){continue}break}fe(o[a+56>>2]);if(!r){break n}if(r){o[6258]=o[6258]+1;l[o[4969]](r);}break n}fe(o[a+56>>2]);}g=o[c+132>>2];if((g|0)>=1){d=0;while(1){a=o[c+140>>2]+u(d,36)|0;b=a;e=o[b+12>>2];if(e){if(p[a+16|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[b+12>>2]=0;}m[a+16|0]=1;o[b+12>>2]=0;o[a+4>>2]=0;o[a+8>>2]=0;d=d+1|0;if((g|0)!=(d|0)){continue}break}}a=o[c+140>>2];if(a){if(p[c+144|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+140>>2]=0;}if(D){if(D){o[6258]=o[6258]+1;l[o[4969]](D);}}a=o[c+204>>2];if(a){if(p[c+208|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+204>>2]=0;}o[c+204>>2]=0;m[c+208|0]=1;o[c+196>>2]=0;o[c+200>>2]=0;a=o[c+184>>2];if(a){if(p[c+188|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+184>>2]=0;}o[c+184>>2]=0;m[c+188|0]=1;o[c+176>>2]=0;o[c+180>>2]=0;a=o[c+164>>2];if(a){if(p[c+168|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+164>>2]=0;}a=o[c+228>>2];if(a){if(p[c+232|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+228>>2]=0;}K=c+240|0;return 1}function Cj(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=v(0),j=v(0),k=0,n=v(0),q=0,r=v(0),t=0,u=0,x=0,z=v(0),A=0,B=0,D=v(0),E=v(0),F=v(0),G=0,H=v(0),I=v(0),J=v(0),L=v(0),M=0,N=v(0),O=0,P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0),Z=v(0),_=v(0),$=v(0),aa=v(0),ba=v(0),ca=v(0),ea=v(0),fa=0,ga=v(0),ha=v(0);f=K-928|0;K=f;g=o[a+56>>2];if(!g){g=o[a+4>>2];g=l[o[o[g>>2]+12>>2]](g,o[b+8>>2],o[c+8>>2])|0;m[a+52|0]=1;o[a+56>>2]=g;}o[e+4>>2]=g;h=o[c+4>>2];a:{b:{u=o[b+4>>2];q=o[u+4>>2]+ -8|0;if(q>>>0>2){break b}c:{switch(q-1|0){case 1:q=o[h+4>>2]+ -8|0;if(q>>>0>2){break b}d:{switch(q-1|0){case 1:d=u+32|0;a=o[u+56>>2];i=s[d+(a<<2)>>2];r=s[d+((a+2|0)%3<<2)>>2];d=o[h+56>>2];h=h+32|0;j=s[g+848>>2];i=Nc(f+432|0,f+8|0,i,r,s[(d<<2)+h>>2],s[h+((d+2|0)%3<<2)>>2],a,d,o[b+12>>2],o[c+12>>2],j);if(!!(i<j)){l[o[o[e>>2]+16>>2]](e,f+432|0,f+8|0,i);}a=o[e+4>>2];if(!o[a+844>>2]){break a}b=o[a+836>>2];c=o[o[e+8>>2]+8>>2];if((b|0)!=(c|0)){da(a,o[o[e+12>>2]+8>>2]+4|0,c+4|0);break a}da(a,b+4|0,o[o[e+12>>2]+8>>2]+4|0);break a;case 0:break b;default:break d}}d=u+32|0;a=o[u+56>>2];j=s[g+848>>2];i=Nc(f+432|0,f+8|0,s[d+(a<<2)>>2],s[d+((a+2|0)%3<<2)>>2],v(0),v(s[h+32>>2]*s[h+16>>2]),a,1,o[b+12>>2],o[c+12>>2],j);if(!!(i<j)){l[o[o[e>>2]+16>>2]](e,f+432|0,f+8|0,i);}a=o[e+4>>2];if(!o[a+844>>2]){break a}b=o[a+836>>2];c=o[o[e+8>>2]+8>>2];if((b|0)!=(c|0)){da(a,o[o[e+12>>2]+8>>2]+4|0,c+4|0);break a}da(a,b+4|0,o[o[e+12>>2]+8>>2]+4|0);break a;case 0:break b;default:break c}}if(o[h+4>>2]!=10){break b}d=h+32|0;a=o[h+56>>2];j=s[g+848>>2];i=Nc(f+432|0,f+8|0,v(0),v(s[u+32>>2]*s[u+16>>2]),s[d+(a<<2)>>2],s[d+((a+2|0)%3<<2)>>2],1,a,o[b+12>>2],o[c+12>>2],j);if(!!(i<j)){l[o[o[e>>2]+16>>2]](e,f+432|0,f+8|0,i);}a=o[e+4>>2];if(!o[a+844>>2]){break a}b=o[a+836>>2];c=o[o[e+8>>2]+8>>2];if((b|0)!=(c|0)){da(a,o[o[e+12>>2]+8>>2]+4|0,c+4|0);break a}da(a,b+4|0,o[o[e+12>>2]+8>>2]+4|0);break a}o[f+920>>2]=1566444395;m[f+764|0]=0;o[f+740>>2]=953267991;G=Wc(f+352|0,u,h,f+432|0,o[a+8>>2]);o[G+32>>2]=h;o[G+28>>2]=u;j=v(v(v(v(l[o[o[u>>2]+48>>2]](u))+v(l[o[o[h>>2]+48>>2]](h)))+s[o[a+56>>2]+848>>2])+s[e+32>>2]);s[f+920>>2]=j*j;g=o[b+12>>2];q=o[g+12>>2];o[f+800>>2]=o[g+8>>2];o[f+804>>2]=q;q=o[g+4>>2];o[f+792>>2]=o[g>>2];o[f+796>>2]=q;q=o[g+28>>2];o[f+816>>2]=o[g+24>>2];o[f+820>>2]=q;q=o[g+20>>2];o[f+808>>2]=o[g+16>>2];o[f+812>>2]=q;q=o[g+44>>2];o[f+832>>2]=o[g+40>>2];o[f+836>>2]=q;q=o[g+36>>2];o[f+824>>2]=o[g+32>>2];o[f+828>>2]=q;q=o[g+60>>2];o[f+848>>2]=o[g+56>>2];o[f+852>>2]=q;q=o[g+52>>2];o[f+840>>2]=o[g+48>>2];o[f+844>>2]=q;g=o[c+12>>2];q=o[g+12>>2];o[f+864>>2]=o[g+8>>2];o[f+868>>2]=q;q=o[g+4>>2];o[f+856>>2]=o[g>>2];o[f+860>>2]=q;t=o[g+20>>2];q=f+872|0;o[q>>2]=o[g+16>>2];o[q+4>>2]=t;A=o[g+28>>2];o[f+880>>2]=o[g+24>>2];o[f+884>>2]=A;x=o[g+36>>2];A=f+888|0;t=A;o[t>>2]=o[g+32>>2];o[t+4>>2]=x;t=o[g+44>>2];o[f+896>>2]=o[g+40>>2];o[f+900>>2]=t;B=o[g+52>>2];t=f+904|0;o[t>>2]=o[g+48>>2];o[t+4>>2]=B;x=o[g+60>>2];o[f+912>>2]=o[g+56>>2];o[f+916>>2]=x;e:{x=o[u+4>>2];if((x|0)>6){break e}g=o[h+4>>2];if((g|0)>6){break e}o[f+344>>2]=9976;j=v(0);if(x){j=v(l[o[o[u>>2]+48>>2]](u));g=o[h+4>>2];}if(g){i=v(l[o[o[h>>2]+48>>2]](h));}m[f+44|0]=0;s[f+36>>2]=i;s[f+32>>2]=j;o[f+12>>2]=e;o[f+8>>2]=10152;if(!o[u+56>>2]){break e}if(o[h+56>>2]){i=s[o[a+56>>2]+848>>2];f:{g:{if(p[d+24|0]){j=v(-1.0000000150474662e+30);if(Gj(o[u+56>>2],o[h+56>>2],o[b+12>>2],o[c+12>>2],f+248|0,e)){break g}break f}Ha(G,f+792|0,f+8|0,o[d+20>>2]);d=o[f+28>>2];o[f+256>>2]=o[f+24>>2];o[f+260>>2]=d;d=o[f+20>>2];o[f+248>>2]=o[f+16>>2];o[f+252>>2]=d;j=s[f+40>>2];if(!p[f+44|0]|j<v(0)^1){break f}}g=o[a+16>>2];if((g|0)<=-1){if(o[a+20>>2]<=-1){d=o[a+24>>2];if(d){if(p[a+28|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+24>>2]=0;}o[a+20>>2]=0;o[a+24>>2]=0;m[a+28|0]=1;}while(1){G=o[f+332>>2];d=o[a+24>>2]+(g<<4)|0;q=d;o[q>>2]=o[f+328>>2];o[q+4>>2]=G;q=o[f+340>>2];o[d+8>>2]=o[f+336>>2];o[d+12>>2]=q;d=g+1|0;q=d>>>0>=g>>>0;g=d;if(q){continue}break}}o[a+16>>2]=0;Fj(f+248|0,o[u+56>>2],o[h+56>>2],o[b+12>>2],o[c+12>>2],v(j-i),i,a+12|0,a+32|0,e);}if(!p[a+52|0]){break a}a=o[e+4>>2];if(!o[a+844>>2]){break a}b=o[a+836>>2];c=o[o[e+8>>2]+8>>2];if((b|0)!=(c|0)){da(a,o[o[e+12>>2]+8>>2]+4|0,c+4|0);break a}da(a,b+4|0,o[o[e+12>>2]+8>>2]+4|0);break a}if(o[h+4>>2]!=1){break e}o[f+252>>2]=0;g=o[c+12>>2];r=s[g+52>>2];E=s[g+20>>2];L=s[g+24>>2];N=s[g+56>>2];Q=s[g+36>>2];R=s[g+40>>2];j=s[h+68>>2];i=s[h+60>>2];n=s[h- -64>>2];W=s[g+16>>2];S=s[g+32>>2];z=s[g+48>>2];D=s[g+8>>2];T=s[g>>2];U=s[g+4>>2];o[6257]=o[6257]+1;g=l[o[4968]](16,16)|0;o[f+260>>2]=g;m[f+264|0]=1;o[f+256>>2]=1;o[g+12>>2]=0;s[g>>2]=z+v(v(v(i*T)+v(n*U))+v(j*D));s[g+8>>2]=N+v(v(v(i*S)+v(n*Q))+v(j*R));s[g+4>>2]=r+v(v(v(i*W)+v(n*E))+v(j*L));q=o[f+252>>2]+1|0;o[f+252>>2]=q;j=s[h+76>>2];g=o[c+12>>2];i=s[h+80>>2];n=s[h+84>>2];r=v(v(v(v(j*s[g+32>>2])+v(i*s[g+36>>2]))+v(n*s[g+40>>2]))+s[g+56>>2]);E=v(v(v(v(j*s[g+16>>2])+v(i*s[g+20>>2]))+v(n*s[g+24>>2]))+s[g+52>>2]);j=v(v(v(v(j*s[g>>2])+v(i*s[g+4>>2]))+v(n*s[g+8>>2]))+s[g+48>>2]);h:{if(o[f+256>>2]!=(q|0)){break h}t=q?q<<1:1;if((q|0)>=(t|0)){break h}g=0;A=0;if(t){o[6257]=o[6257]+1;A=l[o[4968]](t<<4,16)|0;q=o[f+252>>2];}if((q|0)>=1){while(1){x=g<<4;B=x+A|0;x=x+o[f+260>>2]|0;O=o[x+4>>2];o[B>>2]=o[x>>2];o[B+4>>2]=O;M=o[x+12>>2];o[B+8>>2]=o[x+8>>2];o[B+12>>2]=M;g=g+1|0;if((q|0)!=(g|0)){continue}break}}g=o[f+260>>2];if(g){if(p[f+264|0]){if(g){o[6258]=o[6258]+1;l[o[4969]](g);}}o[f+260>>2]=0;}o[f+260>>2]=A;m[f+264|0]=1;o[f+256>>2]=t;q=o[f+252>>2];}g=o[f+260>>2]+(q<<4)|0;o[g+12>>2]=0;s[g+8>>2]=r;s[g+4>>2]=E;s[g>>2]=j;q=o[f+252>>2]+1|0;o[f+252>>2]=q;j=s[h+92>>2];c=o[c+12>>2];i=s[h+96>>2];n=s[h+100>>2];r=v(v(v(v(j*s[c>>2])+v(i*s[c+4>>2]))+v(n*s[c+8>>2]))+s[c+48>>2]);E=v(v(v(v(j*s[c+32>>2])+v(i*s[c+36>>2]))+v(n*s[c+40>>2]))+s[c+56>>2]);j=v(v(v(v(j*s[c+16>>2])+v(i*s[c+20>>2]))+v(n*s[c+24>>2]))+s[c+52>>2]);i:{if(o[f+256>>2]!=(q|0)){break i}c=q?q<<1:1;if((q|0)>=(c|0)){break i}g=0;A=0;if(c){o[6257]=o[6257]+1;A=l[o[4968]](c<<4,16)|0;q=o[f+252>>2];}if((q|0)>=1){while(1){t=g<<4;x=t+A|0;t=t+o[f+260>>2]|0;M=o[t+4>>2];o[x>>2]=o[t>>2];o[x+4>>2]=M;B=o[t+12>>2];o[x+8>>2]=o[t+8>>2];o[x+12>>2]=B;g=g+1|0;if((q|0)!=(g|0)){continue}break}}g=o[f+260>>2];if(g){if(p[f+264|0]){if(g){o[6258]=o[6258]+1;l[o[4969]](g);}}o[f+260>>2]=0;}o[f+260>>2]=A;m[f+264|0]=1;o[f+256>>2]=c;q=o[f+252>>2];}c=o[f+260>>2]+(q<<4)|0;o[c+12>>2]=0;s[c+8>>2]=E;s[c+4>>2]=j;s[c>>2]=r;o[f+252>>2]=o[f+252>>2]+1;j=s[o[a+56>>2]+848>>2];Ha(G,f+792|0,f+344|0,o[d+20>>2]);i=s[G+4>>2];n=s[G+8>>2];r=s[G+12>>2];E=v(v(v(i*i)+v(n*n))+v(r*r));if(!!(E>v(1.1920928955078125e-7))){o[f+340>>2]=0;z=r;r=v(v(1)/E);s[f+336>>2]=z*r;s[f+332>>2]=n*r;s[f+328>>2]=i*r;i=v(v(s[G+56>>2]-v(l[o[o[u>>2]+48>>2]](u)))-v(l[o[o[h>>2]+48>>2]](h)));g=o[a+36>>2];if((g|0)<=-1){if(o[a+40>>2]<=-1){c=o[a+44>>2];if(c){if(p[a+48|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+44>>2]=0;}o[a+40>>2]=0;o[a+44>>2]=0;m[a+48|0]=1;}while(1){h=o[f+316>>2];c=o[a+44>>2]+(g<<4)|0;o[c>>2]=o[f+312>>2];o[c+4>>2]=h;d=o[f+324>>2];o[c+8>>2]=o[f+320>>2];o[c+12>>2]=d;c=g+1|0;d=c>>>0>=g>>>0;g=c;if(d){continue}break}}o[a+36>>2]=0;Ce(f+328|0,o[u+56>>2],o[b+12>>2],f+248|0,a+32|0,v(i-j),j,e);}j:{if(!p[a+52|0]){break j}a=o[e+4>>2];if(!o[a+844>>2]){break j}b=o[a+836>>2];c=o[o[e+8>>2]+8>>2];if((b|0)!=(c|0)){da(a,o[o[e+12>>2]+8>>2]+4|0,c+4|0);break j}da(a,b+4|0,o[o[e+12>>2]+8>>2]+4|0);}a=o[f+260>>2];if(!a){break a}if(p[f+264|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[f+260>>2]=0;break a}Ha(G,f+792|0,e,o[d+20>>2]);k:{if(!o[a+64>>2]|o[o[e+4>>2]+844>>2]>=o[a+68>>2]){break k}j=s[G+4>>2];i=s[G+8>>2];n=s[G+12>>2];r=v(v(v(j*j)+v(i*i))+v(n*n));if(!(r>v(1.1920928955078125e-7))){break k}x=f+856|0;B=f+840|0;M=f+824|0;O=f+808|0;z=i;i=v(v(1)/r);E=v(z*i);W=v(j*i);S=v(n*i);l:{if(!!(v(w(S))>v(.7071067690849304))){j=v(v(1)/v(C(v(v(S*S)+v(E*E)))));i=v(E*j);j=v(j*v(-S));n=v(0);break l}i=v(v(1)/v(C(v(v(W*W)+v(E*E)))));j=v(W*i);n=v(i*v(-E));i=v(0);}r=v(l[o[o[u>>2]+16>>2]](u));L=v(l[o[o[h>>2]+16>>2]](h));N=s[4962];u=r<L;g=u?f+792|0:x;h=o[g+12>>2];o[f+256>>2]=o[g+8>>2];o[f+260>>2]=h;h=o[g+4>>2];o[f+248>>2]=o[g>>2];o[f+252>>2]=h;g=u?O:q;h=o[g+12>>2];o[f+272>>2]=o[g+8>>2];o[f+276>>2]=h;h=o[g+4>>2];o[f+264>>2]=o[g>>2];o[f+268>>2]=h;g=u?M:A;h=o[g+12>>2];o[f+288>>2]=o[g+8>>2];o[f+292>>2]=h;h=o[g+4>>2];o[f+280>>2]=o[g>>2];o[f+284>>2]=h;g=u?B:t;h=o[g+12>>2];o[f+304>>2]=o[g+8>>2];o[f+308>>2]=h;h=o[g+4>>2];o[f+296>>2]=o[g>>2];o[f+300>>2]=h;h=o[a+64>>2];if((h|0)<1){break k}z=i;r=v(v(y(v(N/(u?r:L)),v(.39269909262657166)))*v(.5));ga=v(v(v(n*n)+v(j*j))+v(i*i));i=v(va(r)/v(C(ga)));L=v(z*i);N=v(j*i);Q=v(n*i);ha=v(C(v(v(S*S)+v(v(W*W)+v(E*E)))));fa=f- -64|0;R=wa(r);g=0;while(1){if(!!(ga>v(1.1920928955078125e-7))){r=v(v(v(v(6.2831854820251465)/v(h|0))*v(g|0))*v(.5));n=v(va(r)/ha);j=v(S*n);i=v(E*n);n=v(W*n);r=wa(r);m:{if(!!u){h=o[b+12>>2];T=s[h+36>>2];U=s[h+20>>2];X=s[h+40>>2];Y=s[h+24>>2];Z=s[h+32>>2];_=s[h>>2];$=s[h+16>>2];aa=s[h+4>>2];ba=s[h+8>>2];o[f+836>>2]=0;o[f+820>>2]=0;o[f+804>>2]=0;F=v(v(L*n)+v(v(v(N*r)-v(R*i))-v(Q*j)));H=v(v(L*j)+v(v(N*i)+v(v(R*r)+v(Q*n))));I=v(v(N*j)+v(v(v(Q*r)-v(R*n))-v(L*i)));J=v(v(Q*i)+v(v(v(L*r)-v(R*j))-v(N*n)));z=v(v(v(j*F)+v(v(n*H)+v(r*I)))-v(i*J));D=v(v(v(v(r*H)-v(n*I))-v(i*F))-v(j*J));V=v(v(v(i*I)+v(v(j*H)+v(r*J)))-v(n*F));j=v(v(v(n*J)+v(v(r*F)+v(i*H)))-v(j*I));i=v(v(2)/v(v(D*D)+v(v(V*V)+v(v(z*z)+v(j*j)))));n=v(V*i);H=v(z*n);r=v(j*i);I=v(D*r);F=v(H-I);J=v(j*n);P=v(z*i);ca=v(D*P);i=v(J+ca);P=v(z*P);ea=v(j*r);j=v(v(1)-v(P+ea));s[f+832>>2]=v(v(ba*F)+v(Y*i))+v(X*j);s[f+828>>2]=v(v(F*aa)+v(i*U))+v(j*T);s[f+824>>2]=v(v(F*_)+v(i*$))+v(j*Z);r=v(z*r);z=v(D*n);j=v(r+z);D=v(V*n);i=v(v(1)-v(P+D));n=v(J-ca);s[f+816>>2]=v(v(ba*j)+v(Y*i))+v(X*n);s[f+812>>2]=v(v(j*aa)+v(i*U))+v(n*T);s[f+808>>2]=v(v(j*_)+v(i*$))+v(n*Z);j=v(v(1)-v(ea+D));i=v(r-z);n=v(H+I);s[f+800>>2]=v(v(ba*j)+v(Y*i))+v(X*n);s[f+796>>2]=v(v(j*aa)+v(i*U))+v(n*T);s[f+792>>2]=v(v(j*_)+v(i*$))+v(n*Z);h=o[c+12>>2];k=o[h+4>>2];o[x>>2]=o[h>>2];o[x+4>>2]=k;k=o[h+12>>2];o[x+8>>2]=o[h+8>>2];o[x+12>>2]=k;k=o[h+28>>2];o[q+8>>2]=o[h+24>>2];o[q+12>>2]=k;k=o[h+20>>2];o[q>>2]=o[h+16>>2];o[q+4>>2]=k;k=o[h+44>>2];o[A+8>>2]=o[h+40>>2];o[A+12>>2]=k;k=o[h+36>>2];o[A>>2]=o[h+32>>2];o[A+4>>2]=k;k=o[h+60>>2];o[t+8>>2]=o[h+56>>2];o[t+12>>2]=k;k=o[h+52>>2];o[t>>2]=o[h+48>>2];o[t+4>>2]=k;break m}h=o[b+12>>2];k=o[h+12>>2];o[f+800>>2]=o[h+8>>2];o[f+804>>2]=k;k=o[h+4>>2];o[f+792>>2]=o[h>>2];o[f+796>>2]=k;k=o[h+28>>2];o[O+8>>2]=o[h+24>>2];o[O+12>>2]=k;k=o[h+20>>2];o[O>>2]=o[h+16>>2];o[O+4>>2]=k;k=o[h+44>>2];o[M+8>>2]=o[h+40>>2];o[M+12>>2]=k;k=o[h+36>>2];o[M>>2]=o[h+32>>2];o[M+4>>2]=k;k=o[h+60>>2];o[B+8>>2]=o[h+56>>2];o[B+12>>2]=k;k=o[h+52>>2];o[B>>2]=o[h+48>>2];o[B+4>>2]=k;h=o[c+12>>2];T=s[h+36>>2];U=s[h+20>>2];X=s[h+40>>2];Y=s[h+24>>2];Z=s[h+32>>2];_=s[h>>2];$=s[h+16>>2];aa=s[h+4>>2];ba=s[h+8>>2];o[f+900>>2]=0;o[f+884>>2]=0;o[f+868>>2]=0;F=v(v(L*n)+v(v(v(N*r)-v(R*i))-v(Q*j)));H=v(v(L*j)+v(v(N*i)+v(v(R*r)+v(Q*n))));I=v(v(N*j)+v(v(v(Q*r)-v(R*n))-v(L*i)));J=v(v(Q*i)+v(v(v(L*r)-v(R*j))-v(N*n)));z=v(v(v(j*F)+v(v(n*H)+v(r*I)))-v(i*J));D=v(v(v(v(r*H)-v(n*I))-v(i*F))-v(j*J));V=v(v(v(i*I)+v(v(j*H)+v(r*J)))-v(n*F));j=v(v(v(n*J)+v(v(r*F)+v(i*H)))-v(j*I));i=v(v(2)/v(v(D*D)+v(v(V*V)+v(v(z*z)+v(j*j)))));n=v(V*i);H=v(z*n);r=v(j*i);I=v(D*r);F=v(H-I);J=v(j*n);P=v(z*i);ca=v(D*P);i=v(J+ca);P=v(z*P);ea=v(j*r);j=v(v(1)-v(P+ea));s[f+896>>2]=v(v(ba*F)+v(Y*i))+v(X*j);s[f+892>>2]=v(v(F*aa)+v(i*U))+v(j*T);s[f+888>>2]=v(v(F*_)+v(i*$))+v(j*Z);r=v(z*r);z=v(D*n);j=v(r+z);D=v(V*n);i=v(v(1)-v(P+D));n=v(J-ca);s[f+880>>2]=v(v(ba*j)+v(Y*i))+v(X*n);s[f+876>>2]=v(v(j*aa)+v(i*U))+v(n*T);s[f+872>>2]=v(v(j*_)+v(i*$))+v(n*Z);j=v(v(1)-v(ea+D));i=v(r-z);n=v(H+I);s[f+864>>2]=v(v(ba*j)+v(Y*i))+v(X*n);s[f+860>>2]=v(v(j*aa)+v(i*U))+v(n*T);s[f+856>>2]=v(v(j*_)+v(i*$))+v(n*Z);}h=o[d+20>>2];o[f+44>>2]=e;o[f+8>>2]=10336;o[f+40>>2]=0;k=o[f+804>>2];o[f+56>>2]=o[f+800>>2];o[f+60>>2]=k;k=o[f+796>>2];o[f+48>>2]=o[f+792>>2];o[f+52>>2]=k;k=o[O+12>>2];o[fa+8>>2]=o[O+8>>2];o[fa+12>>2]=k;k=o[O+4>>2];o[fa>>2]=o[O>>2];o[fa+4>>2]=k;k=o[M+12>>2];o[f+88>>2]=o[M+8>>2];o[f+92>>2]=k;k=o[M+4>>2];o[f+80>>2]=o[M>>2];o[f+84>>2]=k;k=o[B+12>>2];o[f+104>>2]=o[B+8>>2];o[f+108>>2]=k;k=o[B+4>>2];o[f+96>>2]=o[B>>2];o[f+100>>2]=k;k=o[x+12>>2];o[f+120>>2]=o[x+8>>2];o[f+124>>2]=k;k=o[x+4>>2];o[f+112>>2]=o[x>>2];o[f+116>>2]=k;k=o[q+12>>2];o[f+136>>2]=o[q+8>>2];o[f+140>>2]=k;k=o[q+4>>2];o[f+128>>2]=o[q>>2];o[f+132>>2]=k;k=o[A+12>>2];o[f+152>>2]=o[A+8>>2];o[f+156>>2]=k;k=o[A+4>>2];o[f+144>>2]=o[A>>2];o[f+148>>2]=k;k=o[t+12>>2];o[f+168>>2]=o[t+8>>2];o[f+172>>2]=k;k=o[t+4>>2];o[f+160>>2]=o[t>>2];o[f+164>>2]=k;k=o[f+260>>2];o[f+184>>2]=o[f+256>>2];o[f+188>>2]=k;k=o[f+252>>2];o[f+176>>2]=o[f+248>>2];o[f+180>>2]=k;k=o[f+276>>2];o[f+200>>2]=o[f+272>>2];o[f+204>>2]=k;k=o[f+268>>2];o[f+192>>2]=o[f+264>>2];o[f+196>>2]=k;k=o[f+292>>2];o[f+216>>2]=o[f+288>>2];o[f+220>>2]=k;k=o[f+284>>2];o[f+208>>2]=o[f+280>>2];o[f+212>>2]=k;k=o[f+300>>2];o[f+224>>2]=o[f+296>>2];o[f+228>>2]=k;k=o[f+308>>2];o[f+232>>2]=o[f+304>>2];o[f+236>>2]=k;o[f+244>>2]=h;m[f+240|0]=u;Ha(G,f+792|0,f+8|0,h);h=o[a+64>>2];}g=g+1|0;if((g|0)<(h|0)){continue}break}}if(!p[a+52|0]){break a}a=o[e+4>>2];if(!o[a+844>>2]){break a}b=o[a+836>>2];c=o[o[e+8>>2]+8>>2];if((b|0)!=(c|0)){da(a,o[o[e+12>>2]+8>>2]+4|0,c+4|0);break a}da(a,b+4|0,o[o[e+12>>2]+8>>2]+4|0);}K=f+928|0;}function Bk(a,b,c,d,e,f,g,h,i,j){var k=0,m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=0,D=0,E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=0,Z=v(0),_=v(0),$=v(0),aa=v(0),ba=v(0),ca=v(0),da=v(0),ea=v(0),fa=v(0),ga=0,ha=v(0),ia=v(0),ja=v(0),ka=v(0),la=v(0),ma=0,na=v(0),oa=0,pa=0,qa=0,sa=0,ta=0,ua=0,va=v(0),wa=v(0),xa=0,ya=0,za=0,Aa=0,Ba=0;k=K-384|0;K=k;H=s[b+36>>2];T=s[b+4>>2];y=s[b+20>>2];O=s[b+40>>2];ea=s[b+8>>2];Z=s[b+24>>2];x=s[a+8>>2];A=s[d+8>>2];r=s[a>>2];t=s[d>>2];L=s[a+4>>2];M=s[d+4>>2];m=s[b+32>>2];na=s[b>>2];n=s[b+16>>2];p=v(s[c>>2]*v(.5));s[k+372>>2]=p;q=v(s[c+4>>2]*v(.5));s[k+376>>2]=q;E=v(s[c+8>>2]*v(.5));s[k+380>>2]=E;I=v(s[f>>2]*v(.5));s[k+360>>2]=I;F=v(s[f+4>>2]*v(.5));s[k+364>>2]=F;z=v(s[f+8>>2]*v(.5));s[k+368>>2]=z;r=v(t-r);t=v(M-L);x=v(A-x);A=v(v(v(na*r)+v(n*t))+v(m*x));_=s[e>>2];P=s[e+16>>2];U=s[e+32>>2];L=v(v(v(na*_)+v(n*P))+v(m*U));ha=v(w(L));G=s[e+4>>2];$=s[e+20>>2];aa=s[e+36>>2];M=v(v(v(na*G)+v(n*$))+v(m*aa));va=v(w(M));ba=s[e+8>>2];ca=s[e+24>>2];fa=s[e+40>>2];Q=v(v(v(na*ba)+v(n*ca))+v(m*fa));wa=v(w(Q));n=v(v(w(A))-v(v(v(p+v(I*ha))+v(F*va))+v(z*wa)));a:{if(n>v(0)){break a}R=v(v(v(T*ba)+v(y*ca))+v(H*fa));ia=v(w(R));V=v(v(v(T*G)+v(y*$))+v(H*aa));da=v(w(V));W=v(v(v(T*_)+v(y*P))+v(H*U));X=v(w(W));m=v(-3.4028234663852886e+38);c=0;if(!!(n>v(-3.4028234663852886e+38))){B=A<v(0);m=n;D=b;c=1;}H=v(v(v(r*T)+v(t*y))+v(x*H));n=v(v(w(H))-v(v(v(q+v(I*X))+v(F*da))+v(z*ia)));if(n>v(0)){break a}S=v(v(v(ea*ba)+v(Z*ca))+v(O*fa));ja=v(w(S));N=v(v(v(ea*G)+v(Z*$))+v(O*aa));ka=v(w(N));J=v(v(v(ea*_)+v(Z*P))+v(O*U));la=v(w(J));if(!!(n>m)){D=b+4|0;B=H<v(0);m=n;c=2;}y=v(v(v(r*ea)+v(t*Z))+v(x*O));n=v(v(w(y))-v(v(v(E+v(I*la))+v(F*ka))+v(z*ja)));if(n>v(0)){break a}if(!!(n>m)){D=b+8|0;B=y<v(0);m=n;c=3;}O=v(v(v(r*_)+v(t*P))+v(x*U));n=v(v(w(O))-v(I+v(v(E*la)+v(v(p*ha)+v(q*X)))));if(n>v(0)){break a}if(!!(n>m)){B=O<v(0);m=n;D=e;c=4;}O=v(v(v(r*G)+v(t*$))+v(x*aa));n=v(v(w(O))-v(F+v(v(E*ka)+v(v(p*va)+v(q*da)))));if(n>v(0)){break a}if(!!(n>m)){D=e+4|0;B=O<v(0);m=n;c=5;}r=v(v(v(r*ba)+v(t*ca))+v(x*fa));n=v(v(w(r))-v(z+v(v(E*ja)+v(v(p*wa)+v(q*ia)))));if(n>v(0)){break a}if(!!(n>m)){D=e+8|0;B=r<v(0);m=n;c=6;}U=v(v(y*W)-v(H*J));$=v(va+v(9999999747378752e-21));aa=v(la+v(9999999747378752e-21));ba=v(X+v(9999999747378752e-21));ca=v(wa+v(9999999747378752e-21));n=v(v(w(U))-v(v(z*$)+v(v(v(q*aa)+v(E*ba))+v(F*ca))));if(n>v(1.1920928955078125e-7)){break a}O=v(ka+v(9999999747378752e-21));Z=v(da+v(9999999747378752e-21));_=v(ha+v(9999999747378752e-21));t=v(0);fa=v(W*W);da=v(v(J*J)+v(0));P=v(C(v(fa+da)));b:{if(!(P>v(1.1920928955078125e-7))){x=v(0);r=v(0);break b}x=v(0);n=v(n/P);r=v(0);if(!(v(n*v(1.0499999523162842))>m)){break b}B=U<v(0);x=v(v(-J)/P);t=v(v(0)/P);D=0;c=7;m=n;r=v(W/P);}X=v(v(y*V)-v(H*N));n=v(v(w(X))-v(v(z*_)+v(v(v(q*O)+v(E*Z))+v(I*ca))));if(n>v(1.1920928955078125e-7)){break a}P=v(ja+v(9999999747378752e-21));U=v(ia+v(9999999747378752e-21));ia=v(V*V);ja=v(v(N*N)+v(0));G=v(C(v(ia+ja)));c:{if(!(G>v(1.1920928955078125e-7))){break c}n=v(n/G);if(!(v(n*v(1.0499999523162842))>m)){break c}B=X<v(0);r=v(V/G);x=v(v(-N)/G);t=v(v(0)/G);D=0;c=8;m=n;}X=v(v(y*R)-v(H*S));n=v(v(w(X))-v(v(F*_)+v(v(I*$)+v(v(q*P)+v(E*U)))));if(n>v(1.1920928955078125e-7)){break a}ka=v(R*R);la=v(v(S*S)+v(0));G=v(C(v(ka+la)));d:{if(!(G>v(1.1920928955078125e-7))){break d}n=v(n/G);if(!(v(n*v(1.0499999523162842))>m)){break d}B=X<v(0);r=v(R/G);x=v(v(-S)/G);t=v(v(0)/G);D=0;c=9;m=n;}X=v(v(A*J)-v(y*L));n=v(v(w(X))-v(v(z*Z)+v(v(v(p*aa)+v(E*_))+v(F*U))));if(n>v(1.1920928955078125e-7)){break a}ha=v(L*L);G=v(C(v(ha+da)));e:{if(!(G>v(1.1920928955078125e-7))){break e}n=v(n/G);if(!(v(n*v(1.0499999523162842))>m)){break e}B=X<v(0);r=v(v(-L)/G);x=v(v(0)/G);t=v(J/G);D=0;c=10;m=n;}G=v(v(A*N)-v(y*M));n=v(v(w(G))-v(v(z*ba)+v(v(v(p*O)+v(E*$))+v(I*U))));if(n>v(1.1920928955078125e-7)){break a}da=v(M*M);J=v(C(v(da+ja)));f:{if(!(J>v(1.1920928955078125e-7))){break f}n=v(n/J);if(!(v(n*v(1.0499999523162842))>m)){break f}B=G<v(0);r=v(v(-M)/J);x=v(v(0)/J);t=v(N/J);D=0;c=11;m=n;}N=v(v(A*S)-v(y*Q));n=v(v(w(N))-v(v(F*ba)+v(v(I*Z)+v(v(p*P)+v(E*ca)))));if(n>v(1.1920928955078125e-7)){break a}J=v(Q*Q);y=v(C(v(J+la)));g:{if(!(y>v(1.1920928955078125e-7))){break g}n=v(n/y);if(!(v(n*v(1.0499999523162842))>m)){break g}B=N<v(0);r=v(v(-Q)/y);x=v(v(0)/y);t=v(S/y);D=0;c=12;m=n;}S=v(v(H*L)-v(A*W));n=v(v(w(S))-v(v(z*O)+v(v(v(p*ba)+v(q*_))+v(F*P))));if(n>v(1.1920928955078125e-7)){break a}y=v(C(v(v(fa+ha)+v(0))));h:{if(!(y>v(1.1920928955078125e-7))){break h}n=v(n/y);if(!(v(n*v(1.0499999523162842))>m)){break h}B=S<v(0);r=v(v(0)/y);x=v(L/y);t=v(v(-W)/y);D=0;c=13;m=n;}y=v(v(H*M)-v(A*V));n=v(v(w(y))-v(v(z*aa)+v(v(v(p*Z)+v(q*$))+v(I*P))));if(n>v(1.1920928955078125e-7)){break a}z=v(C(v(v(ia+da)+v(0))));i:{if(!(z>v(1.1920928955078125e-7))){break i}n=v(n/z);if(!(v(n*v(1.0499999523162842))>m)){break i}B=y<v(0);r=v(v(0)/z);x=v(M/z);t=v(v(-V)/z);D=0;c=14;m=n;}z=v(v(H*Q)-v(A*R));n=v(v(w(z))-v(v(F*aa)+v(v(I*O)+v(v(p*U)+v(q*ca)))));if(n>v(1.1920928955078125e-7)){break a}j:{k:{l:{m:{p=v(C(v(v(ka+J)+v(0))));if(!(p>v(1.1920928955078125e-7))){break m}n=v(n/p);if(!(v(n*v(1.0499999523162842))>m)){break m}B=z<v(0);r=v(v(0)/p);x=v(Q/p);t=v(v(-R)/p);c=15;break l}if(!c){break a}if(D){break k}n=m;}p=v(v(v(na*t)+v(T*x))+v(ea*r));s[g>>2]=p;q=v(v(v(t*s[b+16>>2])+v(x*s[b+20>>2]))+v(r*s[b+24>>2]));s[g+4>>2]=q;t=v(v(v(t*s[b+32>>2])+v(x*s[b+36>>2]))+v(r*s[b+40>>2]));s[g+8>>2]=t;break j}p=s[D>>2];o[g>>2]=o[D>>2];q=s[D+16>>2];o[g+4>>2]=o[D+16>>2];t=s[D+32>>2];o[g+8>>2]=o[D+32>>2];n=m;}if(B){s[g+8>>2]=-t;s[g+4>>2]=-q;s[g>>2]=-p;}s[h>>2]=-n;if((c|0)>=7){o[k+120>>2]=o[a+8>>2];f=o[a+4>>2];o[k+112>>2]=o[a>>2];o[k+116>>2]=f;q=v(0);F=s[k+112>>2];z=s[k+116>>2];m=s[k+372>>2];y=m;t=v(-m);m=s[g>>2];A=s[b>>2];r=s[g+4>>2];H=s[b+16>>2];p=s[g+8>>2];x=s[b+32>>2];t=v(v(v(m*A)+v(r*H))+v(p*x))>v(0)?y:t;G=v(s[k+120>>2]+v(t*x));x=s[k+376>>2];y=s[b+4>>2];L=s[b+20>>2];M=s[b+36>>2];x=v(v(v(m*y)+v(r*L))+v(p*M))>v(0)?x:v(-x);G=v(G+v(x*M));M=s[b+8>>2];Q=s[b+24>>2];R=s[b+40>>2];E=v(v(v(m*M)+v(r*Q))+v(p*R))>v(0)?E:v(-E);s[k+120>>2]=G+v(E*R);s[k+116>>2]=v(v(z+v(t*H))+v(x*L))+v(E*Q);s[k+112>>2]=v(v(F+v(t*A))+v(x*y))+v(E*M);o[k+216>>2]=o[d+8>>2];a=o[d+4>>2];o[k+208>>2]=o[d>>2];o[k+212>>2]=a;y=v(-I);A=I;E=s[e>>2];I=s[e+16>>2];x=s[e+32>>2];t=v(v(v(m*E)+v(r*I))+v(p*x))>v(0)?y:A;y=v(s[k+216>>2]+v(t*x));x=s[k+364>>2];F=s[e+4>>2];z=s[e+20>>2];A=s[e+36>>2];x=v(v(v(m*F)+v(r*z))+v(p*A))>v(0)?v(-x):x;G=v(y+v(x*A));A=s[k+368>>2];J=v(-A);y=A;A=s[e+8>>2];H=s[e+24>>2];m=v(v(m*A)+v(r*H));r=s[e+40>>2];m=v(m+v(p*r))>v(0)?J:y;r=v(G+v(m*r));s[k+216>>2]=r;p=v(v(v(s[k+212>>2]+v(t*I))+v(x*z))+v(m*H));s[k+212>>2]=p;m=v(v(v(s[k+208>>2]+v(t*E))+v(x*F))+v(m*A));s[k+208>>2]=m;a=b;b=c+ -7|0;d=(b|0)/3|0;a=a+(d<<2)|0;F=s[a>>2];b=(b-u(d,3)<<2)+e|0;t=s[b>>2];z=s[a+16>>2];x=s[b+16>>2];A=s[a+32>>2];E=s[b+32>>2];I=v(v(v(F*t)+v(z*x))+v(A*E));H=v(v(1)-v(I*I));if(!(H<=v(9999999747378752e-20))){q=v(m-s[k+112>>2]);y=v(q*F);F=v(p-s[k+116>>2]);y=v(y+v(F*z));z=v(r-s[k+120>>2]);q=v(v(v(v(y+v(z*A))*I)-v(v(v(q*t)+v(F*x))+v(z*E)))*v(v(1)/H));}s[k+216>>2]=r+v(q*E);s[k+212>>2]=p+v(q*x);s[k+208>>2]=m+v(q*t);m=s[g>>2];r=s[g+4>>2];p=s[g+8>>2];o[k+300>>2]=0;s[k+296>>2]=-p;s[k+292>>2]=-r;s[k+288>>2]=-m;l[o[o[j>>2]+16>>2]](j,k+288|0,k+208|0,n);o[i>>2]=c;break a}x=s[g>>2];n:{if((c|0)<=3){n=s[g+8>>2];r=s[g+4>>2];sa=k+372|0;B=e;D=k+360|0;break n}x=v(-x);n=v(-s[g+8>>2]);r=v(-s[g+4>>2]);f=d;sa=k+360|0;d=a;a=f;B=b;b=e;D=k+372|0;}p=v(v(v(x*s[B>>2])+v(r*s[B+16>>2]))+v(n*s[B+32>>2]));s[k+344>>2]=p;q=v(v(v(x*s[B+4>>2])+v(r*s[B+20>>2]))+v(n*s[B+36>>2]));s[k+348>>2]=q;m=v(v(v(x*s[B+8>>2])+v(r*s[B+24>>2]))+v(n*s[B+40>>2]));s[k+352>>2]=m;m=v(w(m));q=v(w(q));p=v(w(p));o:{if(!!(q>p)){h=q>m;e=h?1:2;f=0;break o}h=p>m;e=(h^1)<<1;f=h;}za=f;f=e<<2;m=s[f+D>>2];p=v(m*s[f+B>>2]);q=v(s[d>>2]-s[a>>2]);Aa=h?2:1;e=k;p:{if(!(s[f+(k+344|0)>>2]<v(0))){p=v(q-p);s[k+328>>2]=p;q=v(v(s[d+4>>2]-s[a+4>>2])-v(m*s[(f|16)+B>>2]));s[k+332>>2]=q;m=v(v(s[d+8>>2]-s[a+8>>2])-v(m*s[(f|32)+B>>2]));break p}p=v(q+p);s[k+328>>2]=p;q=v(v(s[d+4>>2]-s[a+4>>2])+v(m*s[(f|16)+B>>2]));s[k+332>>2]=q;m=v(v(s[d+8>>2]-s[a+8>>2])+v(m*s[(f|32)+B>>2]));}s[e+336>>2]=m;e=1;xa=((c|0)<4?-1:-4)+c|0;q:{r:{if(xa>>>0<=1){d=2;if(xa-1){break q}break r}d=1;}e=0;}f=e<<2;e=f+b|0;t=s[e+32>>2];E=s[e>>2];I=s[e+16>>2];d=d<<2;b=d+b|0;F=s[b>>2];z=s[b+16>>2];A=s[b+32>>2];H=v(v(v(p*F)+v(q*z))+v(m*A));b=za<<2;ta=b+B|0;L=s[ta>>2];M=s[ta+16>>2];Q=s[ta+32>>2];y=v(v(v(F*L)+v(z*M))+v(A*Q));R=s[b+D>>2];V=v(y*R);W=v(H+V);b=Aa<<2;ua=b+B|0;S=s[ua>>2];N=s[ua+16>>2];J=s[ua+32>>2];z=v(v(v(F*S)+v(z*N))+v(A*J));T=s[b+D>>2];F=v(z*T);s[k+316>>2]=W-F;A=v(v(v(p*E)+v(q*I))+v(m*t));L=v(v(v(E*L)+v(I*M))+v(t*Q));p=v(R*L);q=v(A+p);E=v(v(v(E*S)+v(I*N))+v(t*J));m=v(T*E);s[k+312>>2]=q-m;s[k+308>>2]=W+F;s[k+304>>2]=q+m;q=v(H-V);s[k+300>>2]=q+F;p=v(A-p);s[k+296>>2]=p+m;s[k+292>>2]=q-F;s[k+288>>2]=p-m;o[k+280>>2]=o[f+sa>>2];o[k+284>>2]=o[d+sa>>2];b=4;f=k+208|0;D=k+288|0;e=0;s:{while(1){t:{ya=e;u:{if((b|0)>0){Ba=ya^1;ga=ya<<2;ma=ga+(k+280|0)|0;d=f;e=D;h=0;while(1){p=s[ma>>2];Y=e+ga|0;q=s[Y>>2];t=v(-q);if(!!(p>t)){o[d>>2]=o[e>>2];o[d+4>>2]=o[e+4>>2];h=h+1|0;if(h&8){break t}p=s[ma>>2];q=s[Y>>2];t=v(-q);d=d+8|0;}oa=t<p;Y=e+8|0;pa=(b|0)>1;qa=pa?Y:D;t=s[qa+ga>>2];if((oa|0)!=(p>v(-t)|0)){oa=e;e=Ba<<2;m=s[oa+e>>2];s[d+e>>2]=m+v(v(v(-p)-q)*v(v(s[e+qa>>2]-m)/v(t-q)));s[d+ga>>2]=-s[ma>>2];h=h+1|0;if(h&8){break t}d=d+8|0;}b=b+ -1|0;e=Y;if(pa){continue}break}b=0;D=(k+208|0)==(f|0)?k+112|0:k+208|0;if((h|0)<=0){break u}d=D;e=f;while(1){Y=e+ga|0;q=s[Y>>2];p=s[ma>>2];if(!!(q<p)){o[d>>2]=o[e>>2];o[d+4>>2]=o[e+4>>2];b=b+1|0;if(b&8){break s}p=s[ma>>2];q=s[Y>>2];d=d+8|0;}Y=e+8|0;pa=(h|0)>1;qa=pa?Y:f;t=s[qa+ga>>2];if((q<p|0)!=(t<p|0)){oa=e;e=Ba<<2;m=s[oa+e>>2];s[d+e>>2]=m+v(v(p-q)*v(v(s[e+qa>>2]-m)/v(t-q)));o[d+ga>>2]=o[ma>>2];b=b+1|0;if(b&8){break s}d=d+8|0;}h=h+ -1|0;e=Y;if(pa){continue}break}break u}D=(k+208|0)==(f|0)?k+112|0:k+208|0;b=0;}f=(k+208|0)==(D|0)?k+112|0:k+208|0;e=1;if(!ya){continue}break s}break}D=f;b=h;}if((k+208|0)!=(D|0)){ra(k+208|0,D,b<<3);}if((b|0)<1){break a}m=v(v(1)/v(v(L*z)-v(y*E)));q=v(m*v(-y));t=v(z*m);E=v(E*m);I=v(L*m);F=s[(xa<<2)+sa>>2];d=Aa<<2;z=s[(d|32)+B>>2];e=za<<2;y=s[(e|32)+B>>2];L=s[(d|16)+B>>2];M=s[(e|16)+B>>2];Q=s[ua>>2];R=s[ta>>2];e=0;V=s[k+336>>2];W=s[k+332>>2];S=s[k+328>>2];d=0;while(1){f=(k+112|0)+u(e,12)|0;h=d<<3;N=s[h+(k+208|0)>>2];p=v(N-A);J=s[(k+208|0)+(h|4)>>2];T=v(J-H);m=v(v(t*p)-v(E*T));p=v(v(q*p)+v(I*T));T=v(v(S+v(m*R))+v(p*Q));s[f>>2]=T;ea=v(v(W+v(m*M))+v(p*L));s[f+4>>2]=ea;m=v(v(V+v(m*y))+v(p*z));s[f+8>>2]=m;m=v(F-v(v(v(x*T)+v(r*ea))+v(n*m)));s[(k+80|0)+(e<<2)>>2]=m;if(!!(m>=v(0))){f=e<<3;s[f+(k+208|0)>>2]=N;s[(k+208|0)+(f|4)>>2]=J;e=e+1|0;}d=d+1|0;if((d|0)!=(b|0)){continue}break}if((e|0)<1){break a}b=(e|0)<4?e:4;f=(b|0)>1?b:1;v:{if((e|0)<=(f|0)){if((c|0)>=4){b=0;while(1){d=(k+112|0)+u(b,12)|0;n=s[g>>2];m=s[(k+80|0)+(b<<2)>>2];s[k+32>>2]=v(s[d>>2]+s[a>>2])-v(n*m);r=s[g+4>>2];s[k+36>>2]=v(s[d+4>>2]+s[a+4>>2])-v(m*r);p=s[g+8>>2];s[k+40>>2]=v(s[d+8>>2]+s[a+8>>2])-v(m*p);o[k+76>>2]=0;s[k+72>>2]=-p;s[k+68>>2]=-r;s[k+64>>2]=-n;l[o[o[j>>2]+16>>2]](j,k- -64|0,k+32|0,v(-m));b=b+1|0;if((e|0)!=(b|0)){continue}break}break v}b=0;while(1){d=(k+112|0)+u(b,12)|0;s[k+32>>2]=s[d>>2]+s[a>>2];s[k+36>>2]=s[d+4>>2]+s[a+4>>2];s[k+40>>2]=s[d+8>>2]+s[a+8>>2];m=s[g>>2];n=s[g+4>>2];r=s[g+8>>2];o[k+76>>2]=0;s[k+72>>2]=-r;s[k+68>>2]=-n;s[k+64>>2]=-m;l[o[o[j>>2]+16>>2]](j,k- -64|0,k+32|0,v(-s[(k+80|0)+(b<<2)>>2]));b=b+1|0;if((e|0)!=(b|0)){continue}break}break v}d=0;if((e|0)>=2){p=s[k+80>>2];b=1;while(1){m=s[(k+80|0)+(b<<2)>>2];h=m>p;p=h?m:p;d=h?b:d;b=b+1|0;if((e|0)!=(b|0)){continue}break}}Ck(e,k+208|0,f,d,k+32|0);h=(c|0)>3;b=0;while(1){d=o[(k+32|0)+(b<<2)>>2];e=(k+112|0)+u(d,12)|0;p=v(s[e>>2]+s[a>>2]);s[k+64>>2]=p;q=v(s[e+4>>2]+s[a+4>>2]);s[k+68>>2]=q;t=v(s[e+8>>2]+s[a+8>>2]);s[k+72>>2]=t;w:{if(!h){m=s[g>>2];n=s[g+4>>2];r=s[g+8>>2];o[k+28>>2]=0;s[k+24>>2]=-r;s[k+20>>2]=-n;s[k+16>>2]=-m;l[o[o[j>>2]+16>>2]](j,k+16|0,k- -64|0,v(-s[(k+80|0)+(d<<2)>>2]));break w}n=s[g>>2];r=s[g+4>>2];m=s[g+8>>2];o[k+28>>2]=0;s[k+24>>2]=-m;s[k+20>>2]=-r;s[k+16>>2]=-n;o[k+12>>2]=0;A=m;m=s[(k+80|0)+(d<<2)>>2];s[k+8>>2]=t-v(A*m);s[k+4>>2]=q-v(r*m);s[k>>2]=p-v(n*m);l[o[o[j>>2]+16>>2]](j,k+16|0,k,v(-m));}b=b+1|0;if((f|0)!=(b|0)){continue}break}}o[i>>2]=c;}K=k+384|0;}function Bd(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;l=K-16|0;K=l;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{if(a>>>0<=244){f=o[6261];g=a>>>0<11?16:a+11&-8;a=g>>>3|0;b=f>>>a|0;if(b&3){c=a+((b^-1)&1)|0;e=c<<3;b=o[e+25092>>2];a=b+8|0;d=o[b+8>>2];e=e+25084|0;l:{if((d|0)==(e|0)){o[6261]=Rw(c)&f;break l}o[d+12>>2]=e;o[e+8>>2]=d;}c=c<<3;o[b+4>>2]=c|3;b=b+c|0;o[b+4>>2]=o[b+4>>2]|1;break a}i=o[6263];if(g>>>0<=i>>>0){break k}if(b){c=2<<a;a=(0-c|c)&b<<a;a=(0-a&a)+ -1|0;b=a>>>12&16;c=b;a=a>>>b|0;b=a>>>5&8;c=c|b;a=a>>>b|0;b=a>>>2&4;c=c|b;a=a>>>b|0;b=a>>>1&2;c=c|b;a=a>>>b|0;b=a>>>1&1;c=(c|b)+(a>>>b|0)|0;d=c<<3;b=o[d+25092>>2];a=o[b+8>>2];d=d+25084|0;m:{if((a|0)==(d|0)){f=Rw(c)&f;o[6261]=f;break m}o[a+12>>2]=d;o[d+8>>2]=a;}a=b+8|0;o[b+4>>2]=g|3;h=b+g|0;c=c<<3;e=c-g|0;o[h+4>>2]=e|1;o[b+c>>2]=e;if(i){c=i>>>3|0;b=(c<<3)+25084|0;d=o[6266];c=1<<c;n:{if(!(c&f)){o[6261]=c|f;c=b;break n}c=o[b+8>>2];}o[b+8>>2]=d;o[c+12>>2]=d;o[d+12>>2]=b;o[d+8>>2]=c;}o[6266]=h;o[6263]=e;break a}k=o[6262];if(!k){break k}a=(k&0-k)+ -1|0;b=a>>>12&16;c=b;a=a>>>b|0;b=a>>>5&8;c=c|b;a=a>>>b|0;b=a>>>2&4;c=c|b;a=a>>>b|0;b=a>>>1&2;c=c|b;a=a>>>b|0;b=a>>>1&1;b=o[((c|b)+(a>>>b|0)<<2)+25348>>2];d=(o[b+4>>2]&-8)-g|0;c=b;while(1){o:{a=o[c+16>>2];if(!a){a=o[c+20>>2];if(!a){break o}}e=(o[a+4>>2]&-8)-g|0;c=e>>>0<d>>>0;d=c?e:d;b=c?a:b;c=a;continue}break}j=o[b+24>>2];e=o[b+12>>2];if((e|0)!=(b|0)){a=o[b+8>>2];o[a+12>>2]=e;o[e+8>>2]=a;break b}c=b+20|0;a=o[c>>2];if(!a){a=o[b+16>>2];if(!a){break j}c=b+16|0;}while(1){h=c;e=a;c=a+20|0;a=o[c>>2];if(a){continue}c=e+16|0;a=o[e+16>>2];if(a){continue}break}o[h>>2]=0;break b}g=-1;if(a>>>0>4294967231){break k}b=a+11|0;g=b&-8;i=o[6262];if(!i){break k}c=0-g|0;b=b>>>8|0;f=0;p:{if(!b){break p}f=31;if(g>>>0>16777215){break p}d=b+1048320>>>16&8;b=b<<d;a=b+520192>>>16&4;f=b<<a;b=f+245760>>>16&2;a=(f<<b>>>15|0)-(b|(a|d))|0;f=(a<<1|g>>>a+21&1)+28|0;}d=o[(f<<2)+25348>>2];q:{r:{s:{if(!d){a=0;break s}b=g<<((f|0)==31?0:25-(f>>>1|0)|0);a=0;while(1){t:{h=(o[d+4>>2]&-8)-g|0;if(h>>>0>=c>>>0){break t}e=d;c=h;if(c){break t}c=0;a=d;break r}h=o[d+20>>2];d=o[((b>>>29&4)+d|0)+16>>2];a=h?(h|0)==(d|0)?a:h:a;b=b<<((d|0)!=0);if(d){continue}break}}if(!(a|e)){a=2<<f;a=(0-a|a)&i;if(!a){break k}a=(a&0-a)+ -1|0;b=a>>>12&16;d=b;a=a>>>b|0;b=a>>>5&8;d=d|b;a=a>>>b|0;b=a>>>2&4;d=d|b;a=a>>>b|0;b=a>>>1&2;d=d|b;a=a>>>b|0;b=a>>>1&1;a=o[((d|b)+(a>>>b|0)<<2)+25348>>2];}if(!a){break q}}while(1){d=(o[a+4>>2]&-8)-g|0;b=d>>>0<c>>>0;c=b?d:c;e=b?a:e;b=o[a+16>>2];if(b){a=b;}else {a=o[a+20>>2];}if(a){continue}break}}if(!e|c>>>0>=o[6263]-g>>>0){break k}h=o[e+24>>2];b=o[e+12>>2];if((e|0)!=(b|0)){a=o[e+8>>2];o[a+12>>2]=b;o[b+8>>2]=a;break c}d=e+20|0;a=o[d>>2];if(!a){a=o[e+16>>2];if(!a){break i}d=e+16|0;}while(1){f=d;b=a;d=a+20|0;a=o[d>>2];if(a){continue}d=b+16|0;a=o[b+16>>2];if(a){continue}break}o[f>>2]=0;break c}b=o[6263];if(b>>>0>=g>>>0){a=o[6266];c=b-g|0;u:{if(c>>>0>=16){o[6263]=c;d=a+g|0;o[6266]=d;o[d+4>>2]=c|1;o[a+b>>2]=c;o[a+4>>2]=g|3;break u}o[6266]=0;o[6263]=0;o[a+4>>2]=b|3;b=a+b|0;o[b+4>>2]=o[b+4>>2]|1;}a=a+8|0;break a}d=o[6264];if(d>>>0>g>>>0){b=d-g|0;o[6264]=b;a=o[6267];c=a+g|0;o[6267]=c;o[c+4>>2]=b|1;o[a+4>>2]=g|3;a=a+8|0;break a}a=0;e=g+47|0;c=e;if(o[6379]){b=o[6381];}else {o[6382]=-1;o[6383]=-1;o[6380]=4096;o[6381]=4096;o[6379]=l+12&-16^1431655768;o[6384]=0;o[6372]=0;b=4096;}f=c+b|0;h=0-b|0;c=f&h;if(c>>>0<=g>>>0){break a}b=o[6371];if(b){i=o[6369];j=i+c|0;if(j>>>0<=i>>>0|j>>>0>b>>>0){break a}}if(p[25488]&4){break f}v:{w:{b=o[6267];if(b){a=25492;while(1){i=o[a>>2];if(i+o[a+4>>2]>>>0>b>>>0?i>>>0<=b>>>0:0){break w}a=o[a+8>>2];if(a){continue}break}}b=Ua(0);if((b|0)==-1){break g}f=c;a=o[6380];d=a+ -1|0;if(d&b){f=(c-b|0)+(b+d&0-a)|0;}if(f>>>0<=g>>>0|f>>>0>2147483646){break g}a=o[6371];if(a){d=o[6369];h=d+f|0;if(h>>>0<=d>>>0|h>>>0>a>>>0){break g}}a=Ua(f);if((b|0)!=(a|0)){break v}break e}f=h&f-d;if(f>>>0>2147483646){break g}b=Ua(f);if((b|0)==(o[a>>2]+o[a+4>>2]|0)){break h}a=b;}if(!((a|0)==-1|g+48>>>0<=f>>>0)){b=o[6381];b=b+(e-f|0)&0-b;if(b>>>0>2147483646){b=a;break e}if((Ua(b)|0)!=-1){f=b+f|0;b=a;break e}Ua(0-f|0);break g}b=a;if((a|0)!=-1){break e}break g}e=0;break b}b=0;break c}if((b|0)!=-1){break e}}o[6372]=o[6372]|4;}if(c>>>0>2147483646){break d}b=Ua(c);a=Ua(0);if(b>>>0>=a>>>0|(b|0)==-1|(a|0)==-1){break d}f=a-b|0;if(f>>>0<=g+40>>>0){break d}}a=o[6369]+f|0;o[6369]=a;if(a>>>0>r[6370]){o[6370]=a;}x:{y:{z:{c=o[6267];if(c){a=25492;while(1){d=o[a>>2];e=o[a+4>>2];if((d+e|0)==(b|0)){break z}a=o[a+8>>2];if(a){continue}break}break y}a=o[6265];if(!(b>>>0>=a>>>0?a:0)){o[6265]=b;}a=0;o[6374]=f;o[6373]=b;o[6269]=-1;o[6270]=o[6379];o[6376]=0;while(1){c=a<<3;d=c+25084|0;o[c+25092>>2]=d;o[c+25096>>2]=d;a=a+1|0;if((a|0)!=32){continue}break}a=f+ -40|0;c=b+8&7?-8-b&7:0;d=a-c|0;o[6264]=d;c=b+c|0;o[6267]=c;o[c+4>>2]=d|1;o[(a+b|0)+4>>2]=40;o[6268]=o[6383];break x}if(p[a+12|0]&8|b>>>0<=c>>>0|d>>>0>c>>>0){break y}o[a+4>>2]=e+f;a=c+8&7?-8-c&7:0;b=a+c|0;o[6267]=b;d=o[6264]+f|0;a=d-a|0;o[6264]=a;o[b+4>>2]=a|1;o[(c+d|0)+4>>2]=40;o[6268]=o[6383];break x}e=o[6265];if(b>>>0<e>>>0){o[6265]=b;e=0;}d=b+f|0;a=25492;A:{B:{C:{D:{E:{F:{while(1){if((d|0)!=o[a>>2]){a=o[a+8>>2];if(a){continue}break F}break}if(!(p[a+12|0]&8)){break E}}a=25492;while(1){d=o[a>>2];if(d>>>0<=c>>>0){e=d+o[a+4>>2]|0;if(e>>>0>c>>>0){break D}}a=o[a+8>>2];continue}}o[a>>2]=b;o[a+4>>2]=o[a+4>>2]+f;j=(b+8&7?-8-b&7:0)+b|0;o[j+4>>2]=g|3;b=d+(d+8&7?-8-d&7:0)|0;a=(b-j|0)-g|0;h=g+j|0;if((b|0)==(c|0)){o[6267]=h;a=o[6264]+a|0;o[6264]=a;o[h+4>>2]=a|1;break B}if(o[6266]==(b|0)){o[6266]=h;a=o[6263]+a|0;o[6263]=a;o[h+4>>2]=a|1;o[a+h>>2]=a;break B}c=o[b+4>>2];if((c&3)==1){k=c&-8;G:{if(c>>>0<=255){e=c>>>3|0;c=o[b+8>>2];d=o[b+12>>2];if((d|0)==(c|0)){o[6261]=o[6261]&Rw(e);break G}o[c+12>>2]=d;o[d+8>>2]=c;break G}i=o[b+24>>2];f=o[b+12>>2];H:{if((f|0)!=(b|0)){c=o[b+8>>2];o[c+12>>2]=f;o[f+8>>2]=c;break H}I:{d=b+20|0;g=o[d>>2];if(g){break I}d=b+16|0;g=o[d>>2];if(g){break I}f=0;break H}while(1){c=d;f=g;d=g+20|0;g=o[d>>2];if(g){continue}d=f+16|0;g=o[f+16>>2];if(g){continue}break}o[c>>2]=0;}if(!i){break G}c=o[b+28>>2];d=(c<<2)+25348|0;J:{if(o[d>>2]==(b|0)){o[d>>2]=f;if(f){break J}o[6262]=o[6262]&Rw(c);break G}o[i+(o[i+16>>2]==(b|0)?16:20)>>2]=f;if(!f){break G}}o[f+24>>2]=i;c=o[b+16>>2];if(c){o[f+16>>2]=c;o[c+24>>2]=f;}c=o[b+20>>2];if(!c){break G}o[f+20>>2]=c;o[c+24>>2]=f;}b=b+k|0;a=a+k|0;}o[b+4>>2]=o[b+4>>2]&-2;o[h+4>>2]=a|1;o[a+h>>2]=a;if(a>>>0<=255){b=a>>>3|0;a=(b<<3)+25084|0;c=o[6261];b=1<<b;K:{if(!(c&b)){o[6261]=b|c;b=a;break K}b=o[a+8>>2];}o[a+8>>2]=h;o[b+12>>2]=h;o[h+12>>2]=a;o[h+8>>2]=b;break B}c=h;d=a>>>8|0;b=0;L:{if(!d){break L}b=31;if(a>>>0>16777215){break L}e=d+1048320>>>16&8;d=d<<e;b=d+520192>>>16&4;g=d<<b;d=g+245760>>>16&2;b=(g<<d>>>15|0)-(d|(b|e))|0;b=(b<<1|a>>>b+21&1)+28|0;}o[c+28>>2]=b;o[h+16>>2]=0;o[h+20>>2]=0;c=(b<<2)+25348|0;d=o[6262];e=1<<b;M:{if(!(d&e)){o[6262]=d|e;o[c>>2]=h;break M}d=a<<((b|0)==31?0:25-(b>>>1|0)|0);b=o[c>>2];while(1){c=b;if((o[b+4>>2]&-8)==(a|0)){break C}b=d>>>29|0;d=d<<1;e=(b&4)+c|0;b=o[e+16>>2];if(b){continue}break}o[e+16>>2]=h;}o[h+24>>2]=c;o[h+12>>2]=h;o[h+8>>2]=h;break B}a=f+ -40|0;d=b+8&7?-8-b&7:0;h=a-d|0;o[6264]=h;d=b+d|0;o[6267]=d;o[d+4>>2]=h|1;o[(a+b|0)+4>>2]=40;o[6268]=o[6383];a=(e+(e+ -39&7?39-e&7:0)|0)+ -47|0;d=a>>>0<c+16>>>0?c:a;o[d+4>>2]=27;a=o[6376];o[d+16>>2]=o[6375];o[d+20>>2]=a;a=o[6374];o[d+8>>2]=o[6373];o[d+12>>2]=a;o[6375]=d+8;o[6374]=f;o[6373]=b;o[6376]=0;a=d+24|0;while(1){o[a+4>>2]=7;b=a+8|0;a=a+4|0;if(e>>>0>b>>>0){continue}break}if((c|0)==(d|0)){break x}o[d+4>>2]=o[d+4>>2]&-2;e=d-c|0;o[c+4>>2]=e|1;o[d>>2]=e;if(e>>>0<=255){b=e>>>3|0;a=(b<<3)+25084|0;d=o[6261];b=1<<b;N:{if(!(d&b)){o[6261]=b|d;b=a;break N}b=o[a+8>>2];}o[a+8>>2]=c;o[b+12>>2]=c;o[c+12>>2]=a;o[c+8>>2]=b;break x}o[c+16>>2]=0;o[c+20>>2]=0;b=c;d=e>>>8|0;a=0;O:{if(!d){break O}a=31;if(e>>>0>16777215){break O}f=d+1048320>>>16&8;d=d<<f;a=d+520192>>>16&4;h=d<<a;d=h+245760>>>16&2;a=(h<<d>>>15|0)-(d|(a|f))|0;a=(a<<1|e>>>a+21&1)+28|0;}o[b+28>>2]=a;b=(a<<2)+25348|0;d=o[6262];f=1<<a;P:{if(!(d&f)){o[6262]=d|f;o[b>>2]=c;o[c+24>>2]=b;break P}a=e<<((a|0)==31?0:25-(a>>>1|0)|0);b=o[b>>2];while(1){d=b;if((e|0)==(o[b+4>>2]&-8)){break A}b=a>>>29|0;a=a<<1;f=d+(b&4)|0;b=o[f+16>>2];if(b){continue}break}o[f+16>>2]=c;o[c+24>>2]=d;}o[c+12>>2]=c;o[c+8>>2]=c;break x}a=o[c+8>>2];o[a+12>>2]=h;o[c+8>>2]=h;o[h+24>>2]=0;o[h+12>>2]=c;o[h+8>>2]=a;}a=j+8|0;break a}a=o[d+8>>2];o[a+12>>2]=c;o[d+8>>2]=c;o[c+24>>2]=0;o[c+12>>2]=d;o[c+8>>2]=a;}a=o[6264];if(a>>>0<=g>>>0){break d}b=a-g|0;o[6264]=b;a=o[6267];c=a+g|0;o[6267]=c;o[c+4>>2]=b|1;o[a+4>>2]=g|3;a=a+8|0;break a}o[6259]=48;a=0;break a}Q:{if(!h){break Q}a=o[e+28>>2];d=(a<<2)+25348|0;R:{if(o[d>>2]==(e|0)){o[d>>2]=b;if(b){break R}i=Rw(a)&i;o[6262]=i;break Q}o[h+(o[h+16>>2]==(e|0)?16:20)>>2]=b;if(!b){break Q}}o[b+24>>2]=h;a=o[e+16>>2];if(a){o[b+16>>2]=a;o[a+24>>2]=b;}a=o[e+20>>2];if(!a){break Q}o[b+20>>2]=a;o[a+24>>2]=b;}S:{if(c>>>0<=15){a=c+g|0;o[e+4>>2]=a|3;a=a+e|0;o[a+4>>2]=o[a+4>>2]|1;break S}o[e+4>>2]=g|3;d=e+g|0;o[d+4>>2]=c|1;o[c+d>>2]=c;if(c>>>0<=255){b=c>>>3|0;a=(b<<3)+25084|0;c=o[6261];b=1<<b;T:{if(!(c&b)){o[6261]=b|c;b=a;break T}b=o[a+8>>2];}o[a+8>>2]=d;o[b+12>>2]=d;o[d+12>>2]=a;o[d+8>>2]=b;break S}b=d;g=c>>>8|0;a=0;U:{if(!g){break U}a=31;if(c>>>0>16777215){break U}f=g+1048320>>>16&8;g=g<<f;a=g+520192>>>16&4;h=g<<a;g=h+245760>>>16&2;a=(h<<g>>>15|0)-(g|(a|f))|0;a=(a<<1|c>>>a+21&1)+28|0;}o[b+28>>2]=a;o[d+16>>2]=0;o[d+20>>2]=0;b=(a<<2)+25348|0;V:{g=1<<a;W:{if(!(g&i)){o[6262]=g|i;o[b>>2]=d;break W}a=c<<((a|0)==31?0:25-(a>>>1|0)|0);g=o[b>>2];while(1){b=g;if((o[b+4>>2]&-8)==(c|0)){break V}g=a>>>29|0;a=a<<1;f=(g&4)+b|0;g=o[f+16>>2];if(g){continue}break}o[f+16>>2]=d;}o[d+24>>2]=b;o[d+12>>2]=d;o[d+8>>2]=d;break S}a=o[b+8>>2];o[a+12>>2]=d;o[b+8>>2]=d;o[d+24>>2]=0;o[d+12>>2]=b;o[d+8>>2]=a;}a=e+8|0;break a}X:{if(!j){break X}a=o[b+28>>2];c=(a<<2)+25348|0;Y:{if(o[c>>2]==(b|0)){o[c>>2]=e;if(e){break Y}o[6262]=Rw(a)&k;break X}o[j+(o[j+16>>2]==(b|0)?16:20)>>2]=e;if(!e){break X}}o[e+24>>2]=j;a=o[b+16>>2];if(a){o[e+16>>2]=a;o[a+24>>2]=e;}a=o[b+20>>2];if(!a){break X}o[e+20>>2]=a;o[a+24>>2]=e;}Z:{if(d>>>0<=15){a=d+g|0;o[b+4>>2]=a|3;a=a+b|0;o[a+4>>2]=o[a+4>>2]|1;break Z}o[b+4>>2]=g|3;g=b+g|0;o[g+4>>2]=d|1;o[d+g>>2]=d;if(i){c=i>>>3|0;a=(c<<3)+25084|0;e=o[6266];c=1<<c;_:{if(!(c&f)){o[6261]=c|f;c=a;break _}c=o[a+8>>2];}o[a+8>>2]=e;o[c+12>>2]=e;o[e+12>>2]=a;o[e+8>>2]=c;}o[6266]=g;o[6263]=d;}a=b+8|0;}K=l+16|0;return a|0}function rm(a,b,c,d,e,f,g,h,i){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,n=0,q=0,r=v(0),t=0,x=0,y=v(0),z=v(0),A=0,B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=0,M=v(0),N=v(0),O=v(0),P=v(0),Q=0,R=v(0),S=v(0),T=0,U=0,V=0,W=0,X=v(0),Y=v(0),Z=v(0),_=v(0),aa=v(0),ba=v(0),ca=v(0),da=v(0),ea=v(0),fa=v(0),ga=v(0),ha=v(0),ia=v(0),ja=v(0),ka=v(0),la=v(0),ma=v(0),na=v(0),oa=v(0),pa=v(0);x=K-256|0;K=x;o[a+188>>2]=-1;l[o[4966]](3808);i=o[h+72>>2];if((i|0)!=o[a+224>>2]){o[a+224>>2]=i;o[a+220>>2]=144;o[a+216>>2]=143;o[a+212>>2]=142;}i=0;o[a+184>>2]=0;if((c|0)>0){while(1){o[o[(i<<2)+b>>2]+212>>2]=-1;i=i+1|0;if((i|0)!=(c|0)){continue}break}}n=o[a+12>>2];if((n|0)<=(c|0)){n=c+1|0;i=0;a:{if(!n){break a}o[6257]=o[6257]+1;i=l[o[4968]](u(n,244),16)|0;}A=o[a+8>>2];if((A|0)>=1){while(1){j=u(q,244);k=j+i|0;j=j+o[a+16>>2]|0;L=o[j+4>>2];o[k>>2]=o[j>>2];o[k+4>>2]=L;t=o[j+12>>2];o[k+8>>2]=o[j+8>>2];o[k+12>>2]=t;t=o[j+28>>2];o[k+24>>2]=o[j+24>>2];o[k+28>>2]=t;t=o[j+20>>2];o[k+16>>2]=o[j+16>>2];o[k+20>>2]=t;t=o[j+44>>2];o[k+40>>2]=o[j+40>>2];o[k+44>>2]=t;t=o[j+36>>2];o[k+32>>2]=o[j+32>>2];o[k+36>>2]=t;t=o[j+52>>2];o[k+48>>2]=o[j+48>>2];o[k+52>>2]=t;t=o[j+60>>2];o[k+56>>2]=o[j+56>>2];o[k+60>>2]=t;ra(k- -64|0,j- -64|0,180);q=q+1|0;if((A|0)!=(q|0)){continue}break}}j=o[a+16>>2];if(j){if(p[a+20|0]){if(j){o[6258]=o[6258]+1;l[o[4969]](j);}}o[a+16>>2]=0;}o[a+16>>2]=i;o[a+12>>2]=n;m[a+20|0]=1;}k=$(x,0,244);i=o[a+8>>2];if((i|0)<=-1){if((n|0)<=-1){j=o[a+16>>2];if(j){if(p[a+20|0]){if(j){o[6258]=o[6258]+1;l[o[4969]](j);}}o[a+16>>2]=0;}o[a+12>>2]=0;o[a+16>>2]=0;m[a+20|0]=1;}q=k- -64|0;while(1){n=o[k+4>>2];j=o[a+16>>2]+u(i,244)|0;o[j>>2]=o[k>>2];o[j+4>>2]=n;n=o[k+12>>2];o[j+8>>2]=o[k+8>>2];o[j+12>>2]=n;n=o[k+28>>2];o[j+24>>2]=o[k+24>>2];o[j+28>>2]=n;n=o[k+20>>2];o[j+16>>2]=o[k+16>>2];o[j+20>>2]=n;n=o[k+44>>2];o[j+40>>2]=o[k+40>>2];o[j+44>>2]=n;n=o[k+36>>2];o[j+32>>2]=o[k+32>>2];o[j+36>>2]=n;n=o[k+52>>2];o[j+48>>2]=o[k+48>>2];o[j+52>>2]=n;n=o[k+60>>2];o[j+56>>2]=o[k+56>>2];o[j+60>>2]=n;ra(j- -64|0,q,180);j=i+1|0;n=j>>>0>=i>>>0;i=j;if(n){continue}break}}o[a+8>>2]=0;if((c|0)>=1){i=0;while(1){j=(i<<2)+b|0;n=Ra(a,o[j>>2],s[h+12>>2]);q=o[j>>2];b:{if(!q|!(o[q+252>>2]&2)|s[q+404>>2]==v(0)){break b}x=o[a+16>>2];j=o[q+564>>2];if(j&2){vo(k,q,s[h+84>>2]);B=s[q+364>>2];C=s[q+332>>2];I=s[q+348>>2];G=s[q+360>>2];F=s[q+328>>2];H=s[q+344>>2];j=x+u(n,244)|0;r=s[k>>2];y=s[k+4>>2];D=s[k+8>>2];z=s[h+12>>2];s[j+224>>2]=s[j+224>>2]-v(v(v(v(r*s[q+324>>2])+v(y*s[q+340>>2]))+v(D*s[q+356>>2]))*z);s[j+228>>2]=s[j+228>>2]-v(z*v(v(v(r*F)+v(y*H))+v(D*G)));s[j+232>>2]=s[j+232>>2]-v(z*v(v(v(r*C)+v(y*I))+v(D*B)));j=o[q+564>>2];}if(j&4){to(k,q,s[h+12>>2]);r=s[k+8>>2];y=s[k+4>>2];j=x+u(n,244)|0;s[j+224>>2]=s[k>>2]+s[j+224>>2];s[j+228>>2]=y+s[j+228>>2];s[j+232>>2]=r+s[j+232>>2];j=o[q+564>>2];}if(!(j&8)){break b}uo(k,q,s[h+12>>2]);r=s[k+8>>2];y=s[k+4>>2];j=x+u(n,244)|0;s[j+224>>2]=s[k>>2]+s[j+224>>2];s[j+228>>2]=y+s[j+228>>2];s[j+232>>2]=r+s[j+232>>2];}i=i+1|0;if((i|0)!=(c|0)){continue}break}}i=0;if((g|0)>0){while(1){b=o[(i<<2)+f>>2];l[o[o[b>>2]+8>>2]](b);o[b+36>>2]=0;i=i+1|0;if((i|0)!=(g|0)){continue}break}}c=o[a+168>>2];if(!((c|0)>=(g|0)|o[a+172>>2]>=(g|0))){c:{if(!g){b=0;break c}o[6257]=o[6257]+1;b=l[o[4968]](g<<3,16)|0;c=o[a+168>>2];}if((c|0)>=1){i=0;while(1){j=i<<3;q=j+b|0;j=j+o[a+176>>2]|0;n=o[j+4>>2];o[q>>2]=o[j>>2];o[q+4>>2]=n;i=i+1|0;if((i|0)!=(c|0)){continue}break}}c=o[a+176>>2];if(c){if(p[a+180|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+176>>2]=0;}o[a+176>>2]=b;o[a+172>>2]=g;m[a+180|0]=1;}o[a+168>>2]=g;b=0;if((g|0)>=1){i=0;while(1){q=o[a+176>>2];n=(i<<2)+f|0;c=o[n>>2];j=o[c+44>>2];if(j){o[j>>2]=0;o[j+4>>2]=0;o[j+56>>2]=0;o[j+60>>2]=0;o[j+48>>2]=0;o[j+52>>2]=0;o[j+40>>2]=0;o[j+44>>2]=0;o[j+32>>2]=0;o[j+36>>2]=0;o[j+24>>2]=0;o[j+28>>2]=0;o[j+16>>2]=0;o[j+20>>2]=0;o[j+8>>2]=0;o[j+12>>2]=0;c=o[n>>2];}j=q+(i<<3)|0;d:{if(p[c+20|0]){l[o[o[c>>2]+16>>2]](c,j);c=o[j>>2];break d}o[j>>2]=0;o[j+4>>2]=0;c=0;}b=c+b|0;i=i+1|0;if((i|0)!=(g|0)){continue}break}}c=o[a+48>>2];if(!((c|0)>=(b|0)|o[a+52>>2]>=(b|0))){e:{if(!b){q=0;break e}o[6257]=o[6257]+1;q=l[o[4968]](u(b,152),16)|0;c=o[a+48>>2];}if((c|0)>=1){i=0;while(1){j=u(i,152);ra(j+q|0,j+o[a+56>>2]|0,152);i=i+1|0;if((i|0)!=(c|0)){continue}break}}c=o[a+56>>2];if(c){if(p[a+60|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+56>>2]=0;}o[a+56>>2]=q;o[a+52>>2]=b;m[a+60|0]=1;}o[a+48>>2]=b;if((g|0)>=1){i=o[a+176>>2];while(1){U=Q<<3;L=U+i|0;if(o[L>>2]){T=(Q<<2)+f|0;t=o[T>>2];c=o[t+32>>2];b=o[a+56>>2];i=o[t+28>>2];n=Ra(a,i,s[h+12>>2]);A=Ra(a,c,s[h+12>>2]);V=o[a+16>>2];j=o[t+24>>2];x=(j|0)>0?j:o[h+20>>2];if((x|0)>o[a+184>>2]){o[a+184>>2]=x;}q=b+u(W,152)|0;b=0;if(o[L>>2]>=1){while(1){j=$(q+u(b,152)|0,0,152);o[j+120>>2]=-8388609;o[j+124>>2]=2139095039;o[j+148>>2]=A;o[j+144>>2]=n;o[j+96>>2]=0;o[j+100>>2]=0;o[j+136>>2]=x;b=b+1|0;if((b|0)<o[L>>2]){continue}break}}x=V+u(n,244)|0;b=x;o[b+64>>2]=0;o[b+68>>2]=0;o[b+144>>2]=0;o[b+148>>2]=0;o[b+88>>2]=0;o[b+92>>2]=0;o[b+80>>2]=0;o[b+84>>2]=0;o[b+72>>2]=0;o[b+76>>2]=0;o[b+152>>2]=0;o[b+156>>2]=0;o[b+160>>2]=0;o[b+164>>2]=0;o[b+168>>2]=0;o[b+172>>2]=0;A=V+u(A,244)|0;b=A;o[b+88>>2]=0;o[b+92>>2]=0;o[b+80>>2]=0;o[b+84>>2]=0;o[b+72>>2]=0;o[b+76>>2]=0;o[b+64>>2]=0;o[b+68>>2]=0;o[b+144>>2]=0;o[b+148>>2]=0;o[b+152>>2]=0;o[b+156>>2]=0;o[b+160>>2]=0;o[b+164>>2]=0;o[b+168>>2]=0;o[b+172>>2]=0;s[k>>2]=v(1)/s[h+12>>2];b=o[h+32>>2];o[k+28>>2]=q+112;o[k+24>>2]=38;o[k+20>>2]=q+32;o[k+16>>2]=q+48;o[k+12>>2]=q;o[k+8>>2]=q+16;o[k+4>>2]=b;o[q+116>>2]=o[h+40>>2];b=o[h+4>>2];o[k+40>>2]=q+124;o[k+36>>2]=q+120;o[k+32>>2]=q+116;o[k+48>>2]=b;o[k+44>>2]=o[h+20>>2];b=o[T>>2];l[o[o[b>>2]+20>>2]](b,k);if(o[L>>2]>=1){j=0;while(1){b=q+u(j,152)|0;r=s[o[T>>2]+16>>2];if(!!(s[b+124>>2]>=r)){s[b+124>>2]=r;}r=v(-r);if(!!(s[b+120>>2]<=r)){s[b+120>>2]=r;}o[b+132>>2]=t;n=o[t+28>>2];z=s[n+328>>2];B=s[n+332>>2];C=s[n+608>>2];I=s[n+348>>2];G=s[n+340>>2];F=s[n+344>>2];r=s[n+612>>2];D=s[n+364>>2];y=s[n+356>>2];H=s[n+360>>2];M=s[n+604>>2];E=s[n+324>>2];o[b+76>>2]=0;J=r;r=s[b>>2];N=v(y*r);y=s[b+4>>2];O=D;D=s[b+8>>2];s[b+72>>2]=J*v(v(N+v(H*y))+v(O*D));s[b+68>>2]=C*v(v(v(r*G)+v(y*F))+v(D*I));s[b+64>>2]=M*v(v(v(E*r)+v(z*y))+v(B*D));n=o[t+32>>2];I=s[n+328>>2];G=s[n+332>>2];F=s[n+608>>2];H=s[n+348>>2];M=s[n+340>>2];E=s[n+344>>2];z=s[n+612>>2];C=s[n+364>>2];B=s[n+356>>2];N=s[n+360>>2];P=s[n+604>>2];R=s[n+324>>2];o[b+92>>2]=0;J=z;z=s[b+32>>2];S=v(B*z);B=s[b+36>>2];O=C;C=s[b+40>>2];s[b+88>>2]=J*v(v(S+v(N*B))+v(O*C));s[b+84>>2]=F*v(v(v(z*M)+v(B*E))+v(C*H));s[b+80>>2]=P*v(v(v(R*z)+v(I*B))+v(G*C));I=v(0);G=s[b+16>>2];F=s[i+404>>2];H=s[b+20>>2];M=s[b+24>>2];J=v(v(v(v(G*v(G*F))+v(H*v(F*H)))+v(M*v(F*M)))+v(v(v(r*v(v(v(r*s[i+324>>2])+v(y*s[i+328>>2]))+v(D*s[i+332>>2])))+v(y*v(v(v(r*s[i+340>>2])+v(y*s[i+344>>2]))+v(D*s[i+348>>2]))))+v(D*v(v(v(r*s[i+356>>2])+v(y*s[i+360>>2]))+v(D*s[i+364>>2])))));F=s[b+48>>2];E=s[c+404>>2];N=s[b+52>>2];P=s[b+56>>2];E=v(v(J+v(v(v(F*v(F*E))+v(N*v(E*N)))+v(P*v(E*P))))+v(v(v(z*v(v(v(z*s[c+324>>2])+v(B*s[c+328>>2]))+v(C*s[c+332>>2])))+v(B*v(v(v(z*s[c+340>>2])+v(B*s[c+344>>2]))+v(C*s[c+348>>2]))))+v(C*v(v(v(z*s[c+356>>2])+v(B*s[c+360>>2]))+v(C*s[c+364>>2])))));E=v(w(E))>v(1.1920928955078125e-7)?v(v(1)/E):v(0);s[b+108>>2]=E;R=v(0);J=v(0);O=v(0);S=v(0);X=v(0);Y=v(0);if(o[x+240>>2]){Y=s[x+232>>2];X=s[x+228>>2];S=s[x+224>>2];J=s[x+212>>2];O=s[x+208>>2];R=s[x+216>>2];}Z=v(0);_=v(0);aa=v(0);ba=v(0);ca=v(0);if(o[A+240>>2]){ca=s[A+232>>2];ba=s[A+228>>2];aa=s[A+224>>2];Z=s[A+212>>2];_=s[A+208>>2];I=s[A+216>>2];}da=s[i+380>>2];ea=s[i+372>>2];fa=s[i+376>>2];ga=s[i+396>>2];ha=s[i+388>>2];ia=s[i+392>>2];ja=s[c+380>>2];ka=s[c+372>>2];la=s[c+376>>2];ma=s[c+396>>2];na=s[c+388>>2];oa=s[c+392>>2];pa=s[k+48>>2];o[b+100>>2]=0;s[b+112>>2]=v(E*s[b+112>>2])+v(E*v(v(0)-v(pa*v(v(v(v(v(G*v(O+ea))+v(H*v(J+fa)))+v(M*v(R+da)))+v(v(v(r*v(S+ha))+v(y*v(X+ia)))+v(D*v(Y+ga))))+v(v(v(v(F*v(_+ka))+v(N*v(Z+la)))+v(P*v(I+ja)))+v(v(v(z*v(aa+na))+v(B*v(ba+oa)))+v(C*v(ca+ma))))))));j=j+1|0;if((j|0)<o[L>>2]){continue}break}}i=o[a+176>>2];}W=o[i+U>>2]+W|0;Q=Q+1|0;if((Q|0)!=(g|0)){continue}break}}l[o[o[a>>2]+28>>2]](a,d,e,h);d=o[a+68>>2];c=o[a+28>>2];j=o[a+128>>2];e=o[a+48>>2];if(!((j|0)>=(e|0)|o[a+132>>2]>=(e|0))){i=0;b=0;if(e){o[6257]=o[6257]+1;b=l[o[4968]](e<<2,16)|0;j=o[a+128>>2];}f=o[a+136>>2];f:{g:{if((j|0)>=1){while(1){g=i<<2;o[g+b>>2]=o[f+g>>2];i=i+1|0;if((j|0)!=(i|0)){continue}break g}}if(!f){break f}}if(p[a+140|0]){if(f){o[6258]=o[6258]+1;l[o[4969]](f);}}o[a+136>>2]=0;}o[a+136>>2]=b;o[a+132>>2]=e;m[a+140|0]=1;}o[a+128>>2]=e;h:{if(p[h+72|0]&16){j=o[a+108>>2];g=c<<1;if(!((j|0)>=(g|0)|o[a+112>>2]>=(g|0))){i=0;b=0;if(c){o[6257]=o[6257]+1;b=l[o[4968]](c<<3,16)|0;j=o[a+108>>2];}f=o[a+116>>2];i:{j:{if((j|0)>=1){while(1){h=i<<2;o[h+b>>2]=o[f+h>>2];i=i+1|0;if((j|0)!=(i|0)){continue}break j}}if(!f){break i}}if(p[a+120|0]){if(f){o[6258]=o[6258]+1;l[o[4969]](f);}}o[a+116>>2]=0;}o[a+116>>2]=b;o[a+112>>2]=g;m[a+120|0]=1;}o[a+108>>2]=g;break h}j=o[a+108>>2];if(!((j|0)>=(c|0)|o[a+112>>2]>=(c|0))){i=0;b=0;if(c){o[6257]=o[6257]+1;b=l[o[4968]](c<<2,16)|0;j=o[a+108>>2];}f=o[a+116>>2];k:{l:{if((j|0)>=1){while(1){g=i<<2;o[g+b>>2]=o[f+g>>2];i=i+1|0;if((j|0)!=(i|0)){continue}break l}}if(!f){break k}}if(p[a+120|0]){if(f){o[6258]=o[6258]+1;l[o[4969]](f);}}o[a+116>>2]=0;}o[a+116>>2]=b;o[a+112>>2]=c;m[a+120|0]=1;}o[a+108>>2]=c;}j=o[a+148>>2];if(!((j|0)>=(d|0)|o[a+152>>2]>=(d|0))){i=0;b=0;if(d){o[6257]=o[6257]+1;b=l[o[4968]](d<<2,16)|0;j=o[a+148>>2];}f=o[a+156>>2];m:{n:{if((j|0)>=1){while(1){g=i<<2;o[g+b>>2]=o[f+g>>2];i=i+1|0;if((j|0)!=(i|0)){continue}break n}}if(!f){break m}}if(p[a+160|0]){if(f){o[6258]=o[6258]+1;l[o[4969]](f);}}o[a+156>>2]=0;}o[a+156>>2]=b;o[a+152>>2]=d;m[a+160|0]=1;}o[a+148>>2]=d;if((e|0)>=1){b=o[a+136>>2];i=0;while(1){o[b+(i<<2)>>2]=i;i=i+1|0;if((e|0)!=(i|0)){continue}break}}if((c|0)>=1){b=o[a+116>>2];i=0;while(1){o[b+(i<<2)>>2]=i;i=i+1|0;if((c|0)!=(i|0)){continue}break}}if((d|0)>=1){a=o[a+156>>2];i=0;while(1){o[a+(i<<2)>>2]=i;i=i+1|0;if((d|0)!=(i|0)){continue}break}}l[o[4967]]();K=k+256|0;return v(v(0))}function Ug(a,b,c,d,e){var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0,r=0,s=0,t=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0;h=K-48|0;K=h;t=o[e>>2];r=b;C=o[d>>2];if(C){r=o[C+12>>2];}A=o[r+96>>2];l=o[b+96>>2];T=o[c+96>>2]-l|0;f=o[(C?C:t)+12>>2];m=o[b+92>>2];g=o[f+92>>2]-m|0;k=c;N=o[c+92>>2]-m|0;w=o[f+96>>2]-l|0;c=u(T,g)-u(N,w)|0;O=c;P=c>>31;c=T;x=c>>31;n=Qw(O,P,c,x);z=L;j=o[b+88>>2];i=o[f+88>>2]-j|0;U=o[k+88>>2]-j|0;b=u(i,N)-u(g,U)|0;Q=b;R=b>>31;b=U;p=b>>31;f=Qw(Q,R,b,p);H=n-f|0;I=z-(L+(n>>>0<f>>>0)|0)|0;G=o[r+92>>2];n=G;g=Qw(H,I,n,n>>31);z=L;n=N;D=n>>31;f=Qw(Q,R,n,D);F=L;q=g;g=u(b,w)-u(c,i)|0;V=g;S=g>>31;c=Qw(g,S,c,x);J=f-c|0;F=F-(L+(f>>>0<c>>>0)|0)|0;r=o[r+88>>2];c=r;f=Qw(J,F,c,c>>31);c=q+f|0;g=L+z|0;g=c>>>0<f>>>0?g+1|0:g;b=Qw(b,p,V,S);f=L;q=c;c=Qw(n,D,O,P);D=b-c|0;M=f-(L+(b>>>0<c>>>0)|0)|0;c=Qw(D,M,A,A>>31);b=q+c|0;f=L+g|0;n=b;c=b>>>0<c>>>0?f+1|0:f;b=Qw(O,P,j,j>>31);f=L;l=Qw(Q,R,l,l>>31);b=l+b|0;f=L+f|0;f=b>>>0<l>>>0?f+1|0:f;l=Qw(V,S,m,m>>31);b=l+b|0;f=L+f|0;B=b;p=b>>>0<l>>>0?f+1|0:f;k=t?o[t+12>>2]:k;w=o[k+96>>2];x=o[k+92>>2];z=o[k+88>>2];b=t;a:{if(!C){break a}b=t;if(!o[C+12>>2]){break a}b=o[o[C+8>>2]+4>>2];j=o[b+12>>2];f=j;l=o[f+92>>2];m=l;l=l>>31;k=Qw(m,l,V,S);g=L;q=k;f=o[f+88>>2];y=f;v=f>>31;k=Qw(f,v,O,P);f=q+k|0;g=L+g|0;g=f>>>0<k>>>0?g+1|0:g;i=f;f=o[j+96>>2];q=f;s=f>>31;k=Qw(f,s,Q,R);j=i+k|0;f=L+g|0;f=j>>>0<k>>>0?f+1|0:f;b:{if((f|0)<(p|0)?1:(f|0)<=(p|0)?j>>>0>=B>>>0?0:1:0){break b}k=b+12|0;E=o[a+100>>2];while(1){if((E|0)==o[b+20>>2]){break b}f=Qw(m,l,H,I);m=L;j=Qw(y,v,J,F);l=j+f|0;f=L+m|0;f=l>>>0<j>>>0?f+1|0:f;m=Qw(q,s,D,M);l=m+l|0;g=L+f|0;g=l>>>0<m>>>0?g+1|0:g;f=g;if((f|0)<(c|0)?1:(f|0)<=(c|0)?l>>>0>n>>>0?0:1:0){break b}o[d>>2]=b;c=o[k>>2];A=o[c+96>>2];G=o[c+92>>2];r=o[c+88>>2];if(c){b=o[o[b+8>>2]+4>>2];k=b+12|0;n=l;c=f;g=o[b+12>>2];f=g;l=o[f+92>>2];m=l;l=l>>31;j=Qw(m,l,V,S);i=L;f=o[f+88>>2];y=f;v=f>>31;q=Qw(f,v,O,P);j=q+j|0;f=L+i|0;f=j>>>0<q>>>0?f+1|0:f;i=j;j=o[g+96>>2];q=j;s=j>>31;g=Qw(j,s,Q,R);j=i+g|0;i=L+f|0;i=j>>>0<g>>>0?i+1|0:i;if((i|0)<(p|0)?1:(i|0)<=(p|0)?j>>>0>=B>>>0?0:1:0){break b}continue}break}n=l;c=f;}b=o[e>>2];}f=Qw(H,I,x,x>>31);l=L;m=Qw(J,F,z,z>>31);f=m+f|0;g=L+l|0;g=f>>>0<m>>>0?g+1|0:g;m=Qw(D,M,w,w>>31);l=m+f|0;f=L+g|0;f=l>>>0<m>>>0?f+1|0:f;m=l;l=f;c:{if(!b){b=0;break c}if(!o[b+12>>2]){break c}k=o[o[b+8>>2]>>2];j=o[k+12>>2];f=j;g=o[f+92>>2];y=g;v=g>>31;g=Qw(g,v,V,S);i=L;W=g;f=o[f+88>>2];q=f;s=f>>31;g=Qw(f,s,O,P);f=W+g|0;i=L+i|0;i=f>>>0<g>>>0?i+1|0:i;W=f;f=o[j+96>>2];g=f;E=f>>31;X=Qw(f,E,Q,R);j=W+X|0;f=L+i|0;f=j>>>0<X>>>0?f+1|0:f;if((f|0)<(p|0)?1:(f|0)<=(p|0)?j>>>0>=B>>>0?0:1:0){break c}X=k+12|0;Y=o[a+100>>2];while(1){j=k;if((Y|0)==o[j+20>>2]){break c}f=Qw(y,v,H,I);i=L;y=Qw(q,s,J,F);k=y+f|0;f=L+i|0;f=k>>>0<y>>>0?f+1|0:f;g=Qw(D,M,g,E);k=g+k|0;i=L+f|0;i=k>>>0<g>>>0?i+1|0:i;g=k;f=i;if((f|0)<(l|0)?1:(f|0)<=(l|0)?g>>>0>m>>>0?0:1:0){break c}o[e>>2]=j;b=o[X>>2];w=o[b+96>>2];x=o[b+92>>2];z=o[b+88>>2];if(b){k=o[o[j+8>>2]>>2];X=k+12|0;m=g;l=f;b=j;g=o[k+12>>2];f=g;j=o[f+92>>2];y=j;v=j>>31;j=Qw(j,v,V,S);i=L;f=o[f+88>>2];q=f;s=f>>31;E=Qw(f,s,O,P);j=E+j|0;f=L+i|0;f=j>>>0<E>>>0?f+1|0:f;W=j;j=o[g+96>>2];g=j;E=g>>31;i=Qw(g,E,Q,R);j=W+i|0;f=L+f|0;f=j>>>0<i>>>0?f+1|0:f;if((f|0)<(p|0)?1:(f|0)<=(p|0)?j>>>0>=B>>>0?0:1:0){break c}continue}break}b=j;m=g;l=f;}d:{c=l-((m>>>0<n>>>0)+c|0)|0;n=m-n|0;if((c|0)>0?1:(c|0)>=0?n>>>0<1?0:1:0){while(1){p=(u(x-G|0,N)+u(z-r|0,U)|0)+u(w-A|0,T)|0;b=p;l=b;y=b>>31;e:{v=o[d>>2];if(!v|!o[v+12>>2]){break e}q=o[o[v>>2]+8>>2];if(o[q+20>>2]<=o[a+100>>2]){break e}b=o[q+12>>2];m=o[b+92>>2];f=m-G|0;j=o[b+88>>2];g=j-r|0;k=o[b+96>>2];b=k-A|0;t=(u(f,N)+u(g,U)|0)+u(b,T)|0;f=Qw(H,I,f,f>>31);i=L;s=Qw(J,F,g,g>>31);g=s+f|0;f=L+i|0;f=g>>>0<s>>>0?f+1|0:f;i=g;g=Qw(D,M,b,b>>31);b=i+g|0;f=L+f|0;f=b>>>0<g>>>0?f+1|0:f;g=b;i=f;f:{if(!(f|b)){if((t|0)<0){break f}break e}if((i|0)>-1?1:(i|0)>=-1?g>>>0<=4294967295?0:1:0){break e}b=t;s=b>>31;f=h;g:{if((b|0)>=1){o[h+24>>2]=b;o[h+28>>2]=s;o[h+40>>2]=1;b=-1;break g}if((t|0)<=-1){o[h+40>>2]=-1;o[h+24>>2]=0-b;o[h+28>>2]=0-((0<b>>>0)+s|0);b=1;break g}o[h+24>>2]=0;o[h+28>>2]=0;o[h+40>>2]=0;b=0;}o[f+40>>2]=b;o[h+32>>2]=0-g;o[h+36>>2]=0-((0<g>>>0)+i|0);h:{if((p|0)>=1){o[h>>2]=l;o[h+4>>2]=y;o[h+16>>2]=1;g=-1;break h}if((p|0)<=-1){o[h+16>>2]=-1;b=l;o[h>>2]=0-b;o[h+4>>2]=0-((0<b>>>0)+y|0);g=1;break h}o[h>>2]=0;o[h+4>>2]=0;o[h+16>>2]=0;g=0;}t=h;f=c;b=n;i=f;i:{if((f|0)>0?1:(f|0)>=0?b>>>0<=0?0:1:0){break i}b=0;i=0;if((c|0)>-1?1:(c|0)>=-1?n>>>0<=4294967295?0:1:0){break i}o[h+16>>2]=g;f=n;b=0-f|0;i=0-((0<f>>>0)+c|0)|0;}f=i;o[t+8>>2]=b;o[t+12>>2]=f;if((ib(h+24|0,h)|0)<=-1){break e}}o[d>>2]=(v|0)==(C|0)?0:q;b=x-m|0;b=Qw(H,I,b,b>>31);c=L;f=b;b=z-j|0;n=Qw(J,F,b,b>>31);b=f+n|0;f=L+c|0;f=b>>>0<n>>>0?f+1|0:f;g=b;b=w-k|0;c=Qw(D,M,b,b>>31);b=g+c|0;f=L+f|0;n=b;c=b>>>0<c>>>0?f+1|0:f;r=j;G=m;A=k;continue}b=o[e>>2];if(!b|!o[b+12>>2]){break d}v=o[o[b+8>>2]>>2];if(o[v+20>>2]<=o[a+100>>2]){break d}b=o[v+12>>2];m=o[b+92>>2];j=m-x|0;f=j;k=f;t=f>>31;f=Qw(f,t,V,S);g=L;i=f;x=o[b+88>>2];z=x-z|0;f=z;q=f;s=f>>31;B=Qw(f,s,O,P);f=i+B|0;i=L+g|0;i=f>>>0<B>>>0?i+1|0:i;g=f;f=o[b+96>>2];w=f-w|0;b=w;B=b;E=b>>31;b=Qw(Q,R,b,E);if((g|0)!=(0-b|0)|(0-(L+(0<b>>>0)|0)|0)!=(i|0)){break d}b=m-G|0;b=Qw(H,I,b,b>>31);m=L;g=b;b=x-r|0;x=Qw(J,F,b,b>>31);b=g+x|0;g=L+m|0;g=b>>>0<x>>>0?g+1|0:g;i=b;b=f-A|0;m=Qw(D,M,b,b>>31);b=i+m|0;f=L+g|0;f=b>>>0<m>>>0?f+1|0:f;m=b;b=f;if((f|0)<0?1:(f|0)<=0?m>>>0>=1?0:1:0){break d}j=(u(j,N)+u(z,U)|0)+u(w,T)|0;f=Qw(k,t,H,I);t=L;g=Qw(q,s,J,F);k=g+f|0;f=L+t|0;f=k>>>0<g>>>0?f+1|0:f;t=Qw(D,M,B,E);k=t+k|0;f=L+f|0;f=k>>>0<t>>>0?f+1|0:f;t=f;j:{if(!(f|k)){if((j|0)<0){break j}break d}if((t|0)>-1?1:(t|0)>=-1?k>>>0<=4294967295?0:1:0){break d}f=j;w=f>>31;g=h;k:{if((f|0)>=1){o[h+24>>2]=f;o[h+28>>2]=w;o[h+40>>2]=1;f=-1;break k}if((j|0)<=-1){o[h+40>>2]=-1;o[h+24>>2]=0-f;o[h+28>>2]=0-((0<f>>>0)+w|0);f=1;break k}o[h+24>>2]=0;o[h+28>>2]=0;o[h+40>>2]=0;f=0;}o[g+40>>2]=f;o[h+32>>2]=0-k;o[h+36>>2]=0-((0<k>>>0)+t|0);l:{if((p|0)>=1){o[h>>2]=l;o[h+4>>2]=y;o[h+16>>2]=1;k=-1;break l}if((p|0)<=-1){o[h+16>>2]=-1;o[h>>2]=0-l;o[h+4>>2]=0-((0<l>>>0)+y|0);k=1;break l}o[h>>2]=0;o[h+4>>2]=0;o[h+16>>2]=0;k=0;}j=h;q=h;l=c;f=n;g=f;m:{if((c|0)>0?1:(c|0)>=0?f>>>0<=0?0:1:0){break m}l=0;g=0;if((c|0)>-1?1:(c|0)>=-1?n>>>0<=4294967295?0:1:0){break m}o[h+16>>2]=k;l=0-((0<n>>>0)+c|0)|0;g=0-n|0;}o[q+8>>2]=g;o[j+12>>2]=l;if((ib(h+24|0,h)|0)<=0){break d}}o[e>>2]=v;c=o[v+12>>2];w=o[c+96>>2];x=o[c+92>>2];z=o[c+88>>2];n=m;c=b;continue}}if((c|0)>-1?1:(c|0)>=-1?n>>>0<=4294967295?0:1:0){break d}while(1){y=(u(x-G|0,N)+u(z-r|0,U)|0)+u(w-A|0,T)|0;f=y;m=f;v=f>>31;n:{if(!b|!o[b+12>>2]){break n}q=o[o[b+4>>2]+8>>2];if(o[q+20>>2]<=o[a+100>>2]){break n}f=o[q+12>>2];l=o[f+92>>2];i=l-x|0;j=o[f+88>>2];p=j-z|0;k=o[f+96>>2];C=k-w|0;g=(u(i,N)+u(p,U)|0)+u(C,T)|0;f=Qw(H,I,i,i>>31);s=L;p=Qw(J,F,p,p>>31);i=p+f|0;f=L+s|0;f=i>>>0<p>>>0?f+1|0:f;p=Qw(D,M,C,C>>31);i=p+i|0;f=L+f|0;f=i>>>0<p>>>0?f+1|0:f;p=f;o:{if(!(f|i)){if((g|0)>0){break o}break n}if((p|0)>-1?1:(p|0)>=-1?i>>>0<=4294967295?0:1:0){break n}f=g;s=f>>31;B=h;p:{if((f|0)>=1){o[h+24>>2]=f;o[h+28>>2]=s;o[h+40>>2]=1;f=-1;break p}if((g|0)<=-1){o[h+40>>2]=-1;o[h+24>>2]=0-f;o[h+28>>2]=0-((0<f>>>0)+s|0);f=1;break p}o[h+24>>2]=0;o[h+28>>2]=0;o[h+40>>2]=0;f=0;}o[B+40>>2]=f;o[h+32>>2]=0-i;o[h+36>>2]=0-((0<i>>>0)+p|0);q:{if((y|0)>=1){o[h>>2]=m;o[h+4>>2]=v;o[h+16>>2]=1;p=-1;break q}if((y|0)<=-1){o[h+16>>2]=-1;f=m;o[h>>2]=0-f;o[h+4>>2]=0-((0<f>>>0)+v|0);p=1;break q}o[h>>2]=0;o[h+4>>2]=0;o[h+16>>2]=0;p=0;}i=h;f=n;g=c;r:{if((c|0)>0?1:(c|0)>=0?f>>>0<=0?0:1:0){break r}f=0;g=0;if((c|0)>-1?1:(c|0)>=-1?n>>>0<=4294967295?0:1:0){break r}o[h+16>>2]=p;g=n;f=0-g|0;g=0-((0<g>>>0)+c|0)|0;}o[i+8>>2]=f;o[i+12>>2]=g;if((ib(h+24|0,h)|0)>=1){break n}}b=(b|0)==(t|0)?0:q;o[e>>2]=b;c=l-G|0;c=Qw(H,I,c,c>>31);n=L;f=c;c=j-r|0;m=Qw(J,F,c,c>>31);c=f+m|0;f=L+n|0;f=c>>>0<m>>>0?f+1|0:f;g=c;c=k-A|0;n=Qw(D,M,c,c>>31);c=g+n|0;f=L+f|0;f=c>>>0<n>>>0?f+1|0:f;n=c;c=f;z=j;x=l;w=k;continue}b=o[d>>2];if(!b|!o[b+12>>2]){break d}p=o[o[b+8>>2]+4>>2];if(o[p+20>>2]<=o[a+100>>2]){break d}b=o[p+12>>2];l=o[b+92>>2];k=l-G|0;f=k;g=f;G=f>>31;f=Qw(f,G,V,S);j=L;i=f;C=o[b+88>>2];r=C-r|0;f=r;q=f;s=f>>31;B=Qw(f,s,O,P);f=i+B|0;i=L+j|0;i=f>>>0<B>>>0?i+1|0:i;j=o[b+96>>2];A=j-A|0;b=A;B=b;E=b>>31;b=Qw(Q,R,b,E);if((0-b|0)!=(f|0)|(0-(L+(0<b>>>0)|0)|0)!=(i|0)){break d}b=x-l|0;b=Qw(H,I,b,b>>31);f=L;i=b;b=z-C|0;l=Qw(J,F,b,b>>31);b=i+l|0;f=L+f|0;f=b>>>0<l>>>0?f+1|0:f;i=b;b=w-j|0;l=Qw(D,M,b,b>>31);b=i+l|0;f=L+f|0;j=b;f=b>>>0<l>>>0?f+1|0:f;l=f;if((f|0)>-1?1:(f|0)>=-1?b>>>0<=4294967295?0:1:0){break d}r=(u(k,N)+u(r,U)|0)+u(A,T)|0;b=Qw(g,G,H,I);f=L;k=Qw(q,s,J,F);b=k+b|0;g=L+f|0;g=b>>>0<k>>>0?g+1|0:g;k=Qw(D,M,B,E);b=k+b|0;f=L+g|0;f=b>>>0<k>>>0?f+1|0:f;k=b;g=f;s:{if(!(f|b)){if((r|0)<=0){break d}break s}if((g|0)>-1?1:(g|0)>=-1?k>>>0<=4294967295?0:1:0){break d}b=r;A=b>>31;f=h;t:{if((b|0)>=1){o[h+24>>2]=b;o[h+28>>2]=A;o[h+40>>2]=1;b=-1;break t}if((r|0)<=-1){o[h+40>>2]=-1;o[h+24>>2]=0-b;o[h+28>>2]=0-((0<b>>>0)+A|0);b=1;break t}o[h+24>>2]=0;o[h+28>>2]=0;o[h+40>>2]=0;b=0;}o[f+40>>2]=b;o[h+32>>2]=0-k;o[h+36>>2]=0-((0<k>>>0)+g|0);u:{if((y|0)>=1){o[h>>2]=m;o[h+4>>2]=v;o[h+16>>2]=1;r=-1;break u}if((y|0)<=-1){o[h+16>>2]=-1;o[h>>2]=0-m;o[h+4>>2]=0-((0<m>>>0)+v|0);r=1;break u}o[h>>2]=0;o[h+4>>2]=0;o[h+16>>2]=0;r=0;}m=h;k=h;b=n;f=c;g=b;v:{if((f|0)>0?1:(f|0)>=0?b>>>0<=0?0:1:0){break v}f=0;g=0;if((c|0)>-1?1:(c|0)>=-1?n>>>0<=4294967295?0:1:0){break v}o[h+16>>2]=r;f=0-((0<n>>>0)+c|0)|0;g=0-n|0;}o[k+8>>2]=g;o[m+12>>2]=f;if((ib(h+24|0,h)|0)>=0){break d}}o[d>>2]=p;c=o[p+12>>2];A=o[c+96>>2];G=o[c+92>>2];b=o[e>>2];r=o[c+88>>2];n=j;c=l;continue}}K=h+48|0;}function Gl(a,b,c,d){var e=0,f=v(0),g=v(0),h=v(0),i=0,j=v(0),k=v(0),m=v(0),n=v(0),q=v(0),r=v(0),t=v(0),u=0,w=v(0),x=0,y=v(0),z=v(0),A=0,B=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=0,S=0,T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0),Z=v(0),_=v(0),$=v(0),aa=v(0),ba=v(0),ca=v(0),da=v(0),ea=v(0),fa=v(0),ga=v(0),ha=v(0),ia=v(0),ja=v(0),ka=v(0);e=K-272|0;K=e;o[a+56>>2]=0;o[e+264>>2]=0;o[e+268>>2]=0;o[e+256>>2]=0;o[e+260>>2]=0;i=o[b+12>>2];o[e+168>>2]=o[b+8>>2];o[e+172>>2]=i;i=o[b+4>>2];o[e+160>>2]=o[b>>2];o[e+164>>2]=i;i=o[b+28>>2];o[e+184>>2]=o[b+24>>2];o[e+188>>2]=i;i=o[b+20>>2];o[e+176>>2]=o[b+16>>2];o[e+180>>2]=i;i=o[b+44>>2];o[e+200>>2]=o[b+40>>2];o[e+204>>2]=i;i=o[b+36>>2];o[e+192>>2]=o[b+32>>2];o[e+196>>2]=i;i=o[b+60>>2];o[e+216>>2]=o[b+56>>2];o[e+220>>2]=i;i=o[b+52>>2];o[e+208>>2]=o[b+48>>2];o[e+212>>2]=i;i=o[b+76>>2];o[e+104>>2]=o[b+72>>2];o[e+108>>2]=i;i=o[b+68>>2];o[e+96>>2]=o[b+64>>2];o[e+100>>2]=i;i=o[b+92>>2];o[e+120>>2]=o[b+88>>2];o[e+124>>2]=i;i=o[b+84>>2];o[e+112>>2]=o[b+80>>2];o[e+116>>2]=i;i=o[b+108>>2];o[e+136>>2]=o[b+104>>2];o[e+140>>2]=i;i=o[b+100>>2];o[e+128>>2]=o[b+96>>2];o[e+132>>2]=i;i=o[b+124>>2];o[e+152>>2]=o[b+120>>2];o[e+156>>2]=i;i=o[b+116>>2];o[e+144>>2]=o[b+112>>2];o[e+148>>2]=i;f=s[e+212>>2];g=s[e+148>>2];F=v(v(f+g)*v(.5));s[e+212>>2]=f-F;f=s[e+216>>2];h=s[e+152>>2];G=v(v(f+h)*v(.5));s[e+216>>2]=f-G;s[e+148>>2]=g-F;s[e+152>>2]=h-G;f=s[e+208>>2];g=s[e+144>>2];H=v(v(f+g)*v(.5));s[e+208>>2]=f-H;s[e+144>>2]=g-H;A=o[o[a+28>>2]+4>>2]+ -17>>>0<=1?o[o[a+32>>2]+4>>2]+ -17>>>0<2:A;n=s[a+44>>2];f=s[a+48>>2];o[5385]=o[5385]+1;o[a+68>>2]=0;o[a+12>>2]=0;o[a+16>>2]=0;o[a+4>>2]=0;o[a+8>>2]=1065353216;o[a+60>>2]=-1;o[a+64>>2]=0;R=p[a+52|0];Pb(o[a+24>>2]);q=R?v(0):f;i=a+4|0;g=v(0xde0b6b000000000);while(1){m=s[b+32>>2];t=s[b+16>>2];w=s[b>>2];r=s[b+36>>2];z=s[b+20>>2];B=s[b+4>>2];D=s[b+40>>2];f=s[a+12>>2];k=s[b+24>>2];j=s[a+8>>2];E=s[b+8>>2];h=s[a+4>>2];o[e+252>>2]=0;y=k;k=v(-j);s[e+248>>2]=v(v(y*k)-v(h*E))-v(f*D);s[e+244>>2]=v(v(z*k)-v(h*B))-v(f*r);s[e+240>>2]=v(v(t*k)-v(h*w))-v(f*m);k=s[b+96>>2];m=s[b+64>>2];t=s[b+80>>2];w=s[b+100>>2];r=s[b+68>>2];z=s[b+84>>2];B=s[b+104>>2];D=s[b+72>>2];E=s[b+88>>2];o[e+236>>2]=0;s[e+232>>2]=v(v(h*D)+v(j*E))+v(f*B);s[e+228>>2]=v(v(h*r)+v(j*z))+v(f*w);s[e+224>>2]=v(v(h*m)+v(j*t))+v(f*k);Ma(e+80|0,o[a+28>>2],e+240|0);Ma(e- -64|0,o[a+32>>2],e+224|0);o[e+60>>2]=0;f=s[e+80>>2];j=s[e+84>>2];k=s[e+88>>2];h=v(v(v(v(f*s[e+192>>2])+v(j*s[e+196>>2]))+v(k*s[e+200>>2]))+s[e+216>>2]);s[e+56>>2]=h;t=v(v(v(v(f*s[e+176>>2])+v(j*s[e+180>>2]))+v(k*s[e+184>>2]))+s[e+212>>2]);s[e+52>>2]=t;w=v(v(v(v(f*s[e+160>>2])+v(j*s[e+164>>2]))+v(k*s[e+168>>2]))+s[e+208>>2]);s[e+48>>2]=w;o[e+44>>2]=0;f=s[e+64>>2];k=s[e+68>>2];m=s[e+72>>2];j=v(v(v(v(f*s[e+128>>2])+v(k*s[e+132>>2]))+v(m*s[e+136>>2]))+s[e+152>>2]);s[e+40>>2]=j;r=v(v(v(v(f*s[e+112>>2])+v(k*s[e+116>>2]))+v(m*s[e+120>>2]))+s[e+148>>2]);s[e+36>>2]=r;f=v(v(v(v(f*s[e+96>>2])+v(k*s[e+100>>2]))+v(m*s[e+104>>2]))+s[e+144>>2]);s[e+32>>2]=f;if(A){o[e+40>>2]=0;o[e+56>>2]=0;j=v(0);h=v(0);}o[e+28>>2]=0;h=v(h-j);s[e+24>>2]=h;f=v(w-f);s[e+16>>2]=f;j=v(t-r);s[e+20>>2]=j;a:{b:{f=v(v(v(f*s[a+4>>2])+v(j*s[a+8>>2]))+v(h*s[a+12>>2]));if(!(f>v(0)^1|v(f*f)>v(g*s[b+128>>2])^1)){o[a+68>>2]=10;break b}if($e(o[a+24>>2],e+16|0)){x=1;o[a+68>>2]=1;u=2;break a}f=v(g-f);if(!!(f<=v(g*v(9.999999974752427e-7)))){u=2;o[a+68>>2]=f<=v(0)?2:11;x=1;break a}df(o[a+24>>2],e+16|0,e+48|0,e+32|0);if(!af(o[a+24>>2],e)){o[a+68>>2]=3;break b}f=s[e>>2];h=v(f*f);f=s[e+4>>2];h=v(h+v(f*f));f=s[e+8>>2];f=v(h+v(f*f));if(!!(f<v(9.999999974752427e-7))){u=o[e+4>>2];o[i>>2]=o[e>>2];o[i+4>>2]=u;u=o[e+12>>2];o[i+8>>2]=o[e+8>>2];o[i+12>>2]=u;o[a+68>>2]=6;break b}c:{if(!!(v(g-f)<=v(g*v(1.1920928955078125e-7)))){o[a+68>>2]=12;x=1;u=2;break c}u=o[e+4>>2];o[i>>2]=o[e>>2];o[i+4>>2]=u;u=o[e+12>>2];o[i+8>>2]=o[e+8>>2];o[i+12>>2]=u;S=o[a+64>>2];o[a+64>>2]=S+1;u=2;if((S|0)>1e3){break c}if(o[o[a+24>>2]>>2]!=4){u=0;break c}o[a+68>>2]=13;}g=f;break a}x=1;u=2;}if(!u){continue}break}f=v(0);h=R?v(0):n;j=v(h+q);A=0;u=0;if(x&1){_e(o[a+24>>2],e+240|0,e+224|0);x=o[i+12>>2];o[e+264>>2]=o[i+8>>2];o[e+268>>2]=x;x=o[i+4>>2];o[e+256>>2]=o[i>>2];o[e+260>>2]=x;f=s[a+4>>2];k=s[a+8>>2];m=s[a+12>>2];n=v(v(v(f*f)+v(k*k))+v(m*m));if(!!(n<v(9.999999974752427e-7))){o[a+68>>2]=5;}x=1;d:{if(!(n>v(1.4210854715202004e-14))){x=2;f=v(0);break d}n=v(v(1)/v(C(n)));s[e+256>>2]=n*s[e+256>>2];s[e+260>>2]=n*s[e+260>>2];s[e+264>>2]=n*s[e+264>>2];t=v(C(g));g=v(h/t);s[e+240>>2]=s[e+240>>2]-v(g*f);s[e+244>>2]=s[e+244>>2]-v(g*k);s[e+248>>2]=s[e+248>>2]-v(g*m);g=v(q/t);s[e+224>>2]=v(g*f)+s[e+224>>2];s[e+228>>2]=v(g*k)+s[e+228>>2];s[e+232>>2]=v(g*m)+s[e+232>>2];u=1;f=v(v(v(1)/n)-j);}o[a+60>>2]=x;}if(!(!o[a+68>>2]|(!o[a+72>>2]|!o[a+20>>2]))){A=v(j+f)<s[4964];}x=u^1;e:{f:{g:{if(x?0:!A){break g}A=o[a+20>>2];if(!A){break g}o[5384]=o[5384]+1;o[i+8>>2]=0;o[i+12>>2]=0;o[i>>2]=0;o[i+4>>2]=0;if(l[o[o[A>>2]+8>>2]](A,o[a+24>>2],o[a+28>>2],o[a+32>>2],e+160|0,e+96|0,i,e+80|0,e- -64|0,d)){m=v(0);g=s[e+64>>2];n=s[e+80>>2];q=v(g-n);t=s[e+68>>2];w=s[e+84>>2];k=v(t-w);r=s[e+72>>2];z=s[e+88>>2];h=v(r-z);j=v(v(v(q*q)+v(k*k))+v(h*h));if(!!(j<=v(1.4210854715202004e-14))){m=s[a+16>>2];q=s[a+4>>2];k=s[a+8>>2];h=s[a+12>>2];j=v(v(v(q*q)+v(k*k))+v(h*h));}if(!!(j>v(1.4210854715202004e-14))){o[a+60>>2]=3;g=v(n-g);y=v(g*g);g=v(w-t);y=v(y+v(g*g));g=v(z-r);g=v(-v(C(v(y+v(g*g)))));if(!((f>g^-1)&(x^1))){d=o[e+92>>2];o[e+248>>2]=o[e+88>>2];o[e+252>>2]=d;d=o[e+76>>2];o[e+232>>2]=o[e+72>>2];o[e+236>>2]=d;d=o[e+84>>2];o[e+240>>2]=o[e+80>>2];o[e+244>>2]=d;d=o[e+68>>2];o[e+224>>2]=o[e+64>>2];o[e+228>>2]=d;s[e+268>>2]=m;f=v(v(1)/v(C(j)));s[e+264>>2]=h*f;s[e+260>>2]=k*f;s[e+256>>2]=q*f;f=g;break f}o[a+60>>2]=8;if(u){break f}break e}o[a+60>>2]=9;if(u){break f}break e}k=s[a+4>>2];m=s[a+8>>2];n=s[a+12>>2];if(!(v(v(v(k*k)+v(m*m))+v(n*n))>v(0))){break g}g=v(s[e+80>>2]-s[e+64>>2]);r=v(g*g);g=v(s[e+84>>2]-s[e+68>>2]);r=v(r+v(g*g));g=v(s[e+88>>2]-s[e+72>>2]);g=v(v(C(v(r+v(g*g))))-j);if(!((g<f^-1)&(x^1))){d=o[e+92>>2];o[e+248>>2]=o[e+88>>2];o[e+252>>2]=d;d=o[e+76>>2];o[e+232>>2]=o[e+72>>2];o[e+236>>2]=d;s[e+248>>2]=s[e+248>>2]-v(h*n);s[e+232>>2]=v(q*n)+s[e+232>>2];d=o[e+68>>2];o[e+224>>2]=o[e+64>>2];o[e+228>>2]=d;d=o[e+84>>2];o[e+240>>2]=o[e+80>>2];o[e+244>>2]=d;s[e+224>>2]=v(q*k)+s[e+224>>2];s[e+228>>2]=v(q*m)+s[e+228>>2];s[e+240>>2]=s[e+240>>2]-v(h*k);s[e+244>>2]=s[e+244>>2]-v(h*m);d=o[i+12>>2];o[e+264>>2]=o[i+8>>2];o[e+268>>2]=d;d=o[i+4>>2];o[e+256>>2]=o[i>>2];o[e+260>>2]=d;h=s[e+256>>2];j=s[e+260>>2];q=s[e+264>>2];f=v(v(1)/v(C(v(v(v(h*h)+v(j*j))+v(q*q)))));s[e+264>>2]=q*f;s[e+260>>2]=j*f;s[e+256>>2]=h*f;o[a+60>>2]=6;f=g;break f}o[a+60>>2]=5;}if(!u){break e}}if(v(f*f)<s[b+128>>2]^1?!(f<v(0)):0){break e}d=o[e+260>>2];o[i>>2]=o[e+256>>2];o[i+4>>2]=d;d=o[e+268>>2];o[i+8>>2]=o[e+264>>2];o[i+12>>2]=d;s[a+56>>2]=f;q=s[b+32>>2];k=s[b>>2];m=s[b+16>>2];n=s[b+36>>2];t=s[b+4>>2];w=s[b+20>>2];h=s[b+40>>2];g=s[b+8>>2];j=s[b+24>>2];o[e+92>>2]=0;r=g;g=s[e+256>>2];y=j;j=s[e+260>>2];z=h;h=s[e+264>>2];s[e+88>>2]=v(v(r*g)+v(y*j))+v(z*h);s[e+84>>2]=v(v(g*t)+v(j*w))+v(h*n);s[e+80>>2]=v(v(k*g)+v(m*j))+v(q*h);q=s[b+96>>2];k=s[b+80>>2];m=s[b+64>>2];n=s[b+100>>2];t=s[b+84>>2];w=s[b+68>>2];r=s[b+104>>2];z=s[b+88>>2];B=s[b+72>>2];o[e+76>>2]=0;j=v(-j);s[e+72>>2]=v(v(z*j)-v(g*B))-v(h*r);s[e+68>>2]=v(v(t*j)-v(g*w))-v(h*n);s[e+64>>2]=v(v(k*j)-v(g*m))-v(h*q);Ma(e+48|0,o[a+28>>2],e+80|0);Ma(e+32|0,o[a+32>>2],e- -64|0);g=s[e+264>>2];z=s[e+216>>2];B=s[e+200>>2];D=s[e+192>>2];E=s[e+196>>2];T=s[e+152>>2];U=s[e+136>>2];V=s[e+128>>2];W=s[e+132>>2];X=s[e+212>>2];Y=s[e+184>>2];Z=s[e+176>>2];_=s[e+180>>2];$=s[e+148>>2];aa=s[e+120>>2];ba=s[e+112>>2];ca=s[e+116>>2];da=s[e+208>>2];ea=s[e+168>>2];q=s[e+56>>2];fa=s[e+160>>2];k=s[e+48>>2];ga=s[e+164>>2];m=s[e+52>>2];ha=s[e+144>>2];ia=s[e+104>>2];n=s[e+40>>2];ja=s[e+96>>2];t=s[e+32>>2];ka=s[e+100>>2];w=s[e+36>>2];j=s[e+260>>2];h=s[e+256>>2];I=s[b+32>>2];J=s[b+16>>2];L=s[b>>2];M=s[b+36>>2];N=s[b+20>>2];O=s[b+4>>2];P=s[b+40>>2];r=s[b+24>>2];Q=s[b+8>>2];o[e+92>>2]=0;y=r;r=v(-j);s[e+88>>2]=v(v(y*r)-v(h*Q))-v(g*P);s[e+84>>2]=v(v(N*r)-v(h*O))-v(g*M);s[e+80>>2]=v(v(J*r)-v(h*L))-v(g*I);I=s[b+96>>2];J=s[b+64>>2];L=s[b+80>>2];M=s[b+100>>2];N=s[b+68>>2];O=s[b+84>>2];P=s[b+104>>2];Q=s[b+72>>2];y=s[b+88>>2];o[e+76>>2]=0;s[e+72>>2]=v(v(h*Q)+v(j*y))+v(g*P);s[e+68>>2]=v(v(h*N)+v(j*O))+v(g*M);s[e+64>>2]=v(v(h*J)+v(j*L))+v(g*I);Ma(e+48|0,o[a+28>>2],e+80|0);Ma(e+32|0,o[a+32>>2],e- -64|0);r=v(v(v(v(v(X+v(v(v(k*Z)+v(m*_))+v(q*Y)))-v($+v(v(v(t*ba)+v(w*ca))+v(n*aa))))*r)-v(h*v(v(da+v(v(v(k*fa)+v(m*ga))+v(q*ea)))-v(ha+v(v(v(t*ja)+v(w*ka))+v(n*ia))))))-v(g*v(v(z+v(v(v(k*D)+v(m*E))+v(q*B)))-v(T+v(v(v(t*V)+v(w*W))+v(n*U))))));g=s[e+48>>2];h=s[e+52>>2];j=s[e+56>>2];q=s[e+32>>2];k=s[e+36>>2];m=s[e+40>>2];n=s[e+256>>2];t=s[e+260>>2];y=v(v(v(v(v(v(v(g*s[e+160>>2])+v(h*s[e+164>>2]))+v(j*s[e+168>>2]))+s[e+208>>2])-v(v(v(v(q*s[e+96>>2])+v(k*s[e+100>>2]))+v(m*s[e+104>>2]))+s[e+144>>2]))*n)+v(v(v(v(v(v(g*s[e+176>>2])+v(h*s[e+180>>2]))+v(j*s[e+184>>2]))+s[e+212>>2])-v(v(v(v(q*s[e+112>>2])+v(k*s[e+116>>2]))+v(m*s[e+120>>2]))+s[e+148>>2]))*t));h=v(v(v(v(v(g*s[e+192>>2])+v(h*s[e+196>>2]))+v(j*s[e+200>>2]))+s[e+216>>2])-v(v(v(v(q*s[e+128>>2])+v(k*s[e+132>>2]))+v(m*s[e+136>>2]))+s[e+152>>2]));g=s[e+264>>2];if(!!(r>v(y+v(h*g)))){o[a+60>>2]=10;s[e+264>>2]=-g;s[e+260>>2]=-t;s[e+256>>2]=-n;}o[e+92>>2]=0;s[e+88>>2]=G+s[e+232>>2];s[e+84>>2]=F+s[e+228>>2];s[e+80>>2]=H+s[e+224>>2];l[o[o[c>>2]+16>>2]](c,e+256|0,e+80|0,f);}K=e+272|0;}function Qc(a,b,c,d,e,f){var g=0,h=0,i=v(0),j=v(0),k=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),D=v(0),E=v(0),F=v(0),G=0,H=v(0),I=v(0),J=v(0),L=0,M=v(0),N=v(0),O=v(0),P=v(0),Q=0,R=v(0),S=v(0),T=v(0);g=K-688|0;K=g;h=o[d+12>>2];L=o[d+4>>2];G=o[L+4>>2];a:{if((G|0)<=19){s[g+660>>2]=f;o[g+656>>2]=0;o[g+488>>2]=6980;o[g+652>>2]=o[e+4>>2];m[g+460|0]=0;o[g+436>>2]=953267991;o[g+64>>2]=4308;G=g+664|0;o[G+20>>2]=0;o[G+16>>2]=L;o[G+12>>2]=a;o[G+8>>2]=g- -64;o[G+4>>2]=g+128;o[G>>2]=7344;b:{if(!l[o[o[G>>2]+8>>2]](G,b,c,h,h,g+488|0)){break b}f=s[g+620>>2];i=s[g+624>>2];j=s[g+628>>2];k=v(v(v(f*f)+v(i*i))+v(j*j));if(!(k>v(9999999747378752e-20))){break b}n=s[g+652>>2];if(!(n<s[e+4>>2])){break b}q=j;j=v(v(1)/v(C(k)));s[g+628>>2]=q*j;s[g+624>>2]=i*j;s[g+620>>2]=f*j;a=o[d+8>>2];o[g+84>>2]=0;o[g+80>>2]=a;a=o[g+632>>2];o[g+96>>2]=o[g+628>>2];o[g+100>>2]=a;a=o[g+620>>2];b=o[g+624>>2];c=o[g+648>>2];o[g+112>>2]=o[g+644>>2];o[g+116>>2]=c;o[g+88>>2]=a;o[g+92>>2]=b;a=o[g+640>>2];o[g+104>>2]=o[g+636>>2];o[g+108>>2]=a;s[g+120>>2]=n;v(l[o[o[e>>2]+12>>2]](e,g+80|0,1));}break a}Q=G+ -21|0;if(Q>>>0<=8){c:{if(Q>>>0>7){break c}d:{switch(Q-1|0){default:i=s[h+20>>2];j=s[h+36>>2];k=s[h+24>>2];A=s[h+52>>2];w=s[h+56>>2];n=s[h+40>>2];p=s[h+32>>2];q=s[h+16>>2];t=s[h>>2];r=s[h+4>>2];x=s[h+48>>2];z=s[h+8>>2];y=s[b+52>>2];D=s[b+56>>2];E=s[b+48>>2];o[g+92>>2]=0;A=v(-A);F=v(v(v(k*A)-v(z*x))-v(n*w));s[g+88>>2]=F+v(v(v(z*E)+v(k*y))+v(n*D));B=v(v(v(i*A)-v(r*x))-v(j*w));s[g+84>>2]=B+v(v(v(r*E)+v(i*y))+v(j*D));A=v(v(v(q*A)-v(t*x))-v(p*w));s[g+80>>2]=A+v(v(v(t*E)+v(q*y))+v(p*D));w=s[c+52>>2];x=s[c+56>>2];y=s[c+48>>2];o[g+676>>2]=0;s[g+672>>2]=F+v(v(v(z*y)+v(k*w))+v(n*x));s[g+668>>2]=B+v(v(v(r*y)+v(i*w))+v(j*x));s[g+664>>2]=A+v(v(v(t*y)+v(q*w))+v(p*x));w=s[c+20>>2];x=s[c+36>>2];y=s[c+24>>2];D=s[c+40>>2];E=s[c+32>>2];A=s[c>>2];F=s[c+16>>2];B=s[c+4>>2];H=s[c+8>>2];o[g+532>>2]=0;o[g+536>>2]=0;o[g+516>>2]=0;o[g+540>>2]=0;o[g+544>>2]=0;o[g+548>>2]=0;s[g+528>>2]=v(v(z*H)+v(k*y))+v(n*D);s[g+524>>2]=v(v(z*B)+v(k*w))+v(n*x);s[g+512>>2]=v(v(r*H)+v(i*y))+v(j*D);s[g+508>>2]=v(v(r*B)+v(i*w))+v(j*x);o[g+500>>2]=0;s[g+520>>2]=v(v(z*A)+v(k*F))+v(n*E);s[g+504>>2]=v(v(r*A)+v(i*F))+v(j*E);s[g+496>>2]=v(v(t*H)+v(q*y))+v(p*D);s[g+492>>2]=v(v(t*B)+v(q*w))+v(p*x);s[g+488>>2]=v(v(t*A)+v(q*F))+v(p*E);d=o[d+8>>2];Ke(g+128|0,a,b,c,h,v(l[o[o[L>>2]+48>>2]](L)));o[g+348>>2]=L;o[g+344>>2]=d;o[g+128>>2]=8512;o[g+340>>2]=e;b=o[e+4>>2];s[g+336>>2]=f;o[g+328>>2]=b;l[o[o[a>>2]+8>>2]](a,g+488|0,g- -64|0,g+48|0);li(L,g+128|0,g+80|0,g+664|0,g- -64|0,g+48|0);break a;case 0:case 1:case 2:case 3:case 4:case 5:break c;case 6:break d}}s[g+300>>2]=f;o[g+296>>2]=0;o[g+128>>2]=6980;o[g+292>>2]=o[e+4>>2];G=g+80|0;o[G+20>>2]=L;o[G+16>>2]=0;o[G+12>>2]=a;o[G+4>>2]=0;o[G+8>>2]=0;o[G>>2]=7344;e:{if(!l[o[o[G>>2]+8>>2]](G,b,c,h,h,g+128|0)){break e}f=s[g+260>>2];i=s[g+264>>2];j=s[g+268>>2];k=v(v(v(f*f)+v(i*i))+v(j*j));if(!(k>v(9999999747378752e-20))){break e}n=s[g+292>>2];if(!(n<s[e+4>>2])){break e}q=j;j=v(v(1)/v(C(k)));s[g+268>>2]=q*j;s[g+264>>2]=i*j;s[g+260>>2]=f*j;a=o[d+8>>2];o[g+492>>2]=0;o[g+488>>2]=a;a=o[g+272>>2];o[g+504>>2]=o[g+268>>2];o[g+508>>2]=a;a=o[g+260>>2];b=o[g+264>>2];c=o[g+288>>2];o[g+520>>2]=o[g+284>>2];o[g+524>>2]=c;o[g+496>>2]=a;o[g+500>>2]=b;a=o[g+280>>2];o[g+512>>2]=o[g+276>>2];o[g+516>>2]=a;s[g+528>>2]=n;v(l[o[o[e>>2]+12>>2]](e,g+488|0,1));}break a}D=s[c+52>>2];E=s[c+56>>2];T=s[h+52>>2];j=s[h+56>>2];q=s[b+52>>2];A=s[b+56>>2];n=s[h+20>>2];p=s[h+36>>2];r=s[h+24>>2];z=s[h+40>>2];F=s[c+48>>2];B=s[h+48>>2];H=s[b+48>>2];k=s[h+32>>2];t=s[h>>2];w=s[h+16>>2];x=s[h+4>>2];y=s[h+8>>2];i=s[c+20>>2];I=s[c+36>>2];J=s[c+24>>2];M=s[c+40>>2];O=s[c+32>>2];P=s[c>>2];N=s[c+16>>2];R=s[c+4>>2];S=s[c+8>>2];o[g+532>>2]=0;o[g+536>>2]=0;o[g+516>>2]=0;o[g+540>>2]=0;o[g+544>>2]=0;o[g+548>>2]=0;s[g+528>>2]=v(v(y*S)+v(r*J))+v(z*M);s[g+524>>2]=v(v(y*R)+v(r*i))+v(z*I);s[g+512>>2]=v(v(x*S)+v(n*J))+v(p*M);s[g+508>>2]=v(v(x*R)+v(n*i))+v(p*I);o[g+500>>2]=0;s[g+520>>2]=v(v(y*P)+v(r*N))+v(z*O);s[g+504>>2]=v(v(x*P)+v(n*N))+v(p*O);s[g+496>>2]=v(v(t*S)+v(w*J))+v(k*M);s[g+492>>2]=v(v(t*R)+v(w*i))+v(k*I);s[g+488>>2]=v(v(t*P)+v(w*N))+v(k*O);d=o[d+8>>2];Ke(g+128|0,a,b,c,h,v(l[o[o[L>>2]+48>>2]](L)));o[g+348>>2]=L;o[g+344>>2]=d;o[g+128>>2]=8724;o[g+340>>2]=e;b=o[e+4>>2];s[g+336>>2]=f;o[g+328>>2]=b;l[o[o[a>>2]+8>>2]](a,g+488|0,g+80|0,g+664|0);o[g+76>>2]=0;I=v(-T);J=v(v(v(r*I)-v(y*B))-v(z*j));f=v(J+v(v(v(y*H)+v(r*q))+v(z*A)));s[g+72>>2]=f;M=v(v(v(n*I)-v(x*B))-v(p*j));i=v(M+v(v(v(x*H)+v(n*q))+v(p*A)));s[g+68>>2]=i;B=v(v(v(w*I)-v(t*B))-v(k*j));j=v(B+v(v(v(t*H)+v(w*q))+v(k*A)));s[g+64>>2]=j;q=j;k=v(B+v(v(v(t*F)+v(w*D))+v(k*E)));if(!!(k<j)){s[g+64>>2]=k;q=k;}t=i;n=v(M+v(v(v(x*F)+v(n*D))+v(p*E)));if(!!(n<i)){s[g+68>>2]=n;t=n;}p=v(J+v(v(v(y*F)+v(r*D))+v(z*E)));r=f;if(!!(p<r)){s[g+72>>2]=p;r=p;}o[g+60>>2]=0;s[g+56>>2]=f;s[g+52>>2]=i;s[g+48>>2]=j;if(!!(j<k)){s[g+48>>2]=k;j=k;}if(!!(i<n)){s[g+52>>2]=n;i=n;}if(!!(f<p)){s[g+56>>2]=p;f=p;}s[g+64>>2]=s[g+80>>2]+q;s[g+68>>2]=s[g+84>>2]+t;s[g+72>>2]=s[g+88>>2]+r;s[g+48>>2]=s[g+664>>2]+j;s[g+52>>2]=s[g+668>>2]+i;s[g+56>>2]=s[g+672>>2]+f;l[o[o[L>>2]+64>>2]](L,g+128|0,g- -64|0,g+48|0);break a}if((G|0)!=31){break a}l[o[4966]](7881);N=s[h+52>>2];w=s[h+56>>2];x=s[b+52>>2];y=s[b+56>>2];i=s[h+20>>2];j=s[h+36>>2];D=s[b+20>>2];E=s[b+36>>2];A=s[b+24>>2];k=s[h+24>>2];F=s[b+40>>2];n=s[h+40>>2];p=s[h+32>>2];q=s[h>>2];t=s[h+16>>2];B=s[b+32>>2];H=s[b>>2];I=s[b+16>>2];J=s[h+48>>2];M=s[b+48>>2];r=s[h+4>>2];O=s[b+4>>2];P=s[b+8>>2];z=s[h+8>>2];o[g+188>>2]=0;o[g+172>>2]=0;o[g+156>>2]=0;s[g+168>>2]=v(v(z*P)+v(k*A))+v(n*F);s[g+164>>2]=v(v(z*O)+v(k*D))+v(n*E);s[g+152>>2]=v(v(r*P)+v(i*A))+v(j*F);s[g+148>>2]=v(v(r*O)+v(i*D))+v(j*E);N=v(-N);s[g+184>>2]=v(v(v(k*N)-v(z*J))-v(n*w))+v(v(v(z*M)+v(k*x))+v(n*y));s[g+180>>2]=v(v(v(i*N)-v(r*J))-v(j*w))+v(v(v(r*M)+v(i*x))+v(j*y));o[g+140>>2]=0;s[g+160>>2]=v(v(z*H)+v(k*I))+v(n*B);s[g+144>>2]=v(v(r*H)+v(i*I))+v(j*B);s[g+136>>2]=v(v(q*P)+v(t*A))+v(p*F);s[g+132>>2]=v(v(q*O)+v(t*D))+v(p*E);s[g+128>>2]=v(v(q*H)+v(t*I))+v(p*B);s[g+176>>2]=v(v(v(t*N)-v(q*J))-v(p*w))+v(v(v(q*M)+v(t*x))+v(p*y));l[o[o[a>>2]+8>>2]](a,g+128|0,g- -64|0,g+48|0);N=s[h+52>>2];w=s[h+56>>2];x=s[c+52>>2];y=s[c+56>>2];i=s[h+20>>2];j=s[h+36>>2];D=s[c+20>>2];E=s[c+36>>2];A=s[c+24>>2];k=s[h+24>>2];F=s[c+40>>2];n=s[h+40>>2];p=s[h+32>>2];q=s[h>>2];t=s[h+16>>2];B=s[c+32>>2];H=s[c>>2];I=s[c+16>>2];J=s[h+48>>2];M=s[c+48>>2];r=s[h+4>>2];O=s[c+4>>2];P=s[c+8>>2];z=s[h+8>>2];o[g+188>>2]=0;o[g+172>>2]=0;o[g+156>>2]=0;s[g+168>>2]=v(v(z*P)+v(k*A))+v(n*F);s[g+164>>2]=v(v(z*O)+v(k*D))+v(n*E);s[g+152>>2]=v(v(r*P)+v(i*A))+v(j*F);s[g+148>>2]=v(v(r*O)+v(i*D))+v(j*E);N=v(-N);s[g+184>>2]=v(v(v(k*N)-v(z*J))-v(n*w))+v(v(v(z*M)+v(k*x))+v(n*y));s[g+180>>2]=v(v(v(i*N)-v(r*J))-v(j*w))+v(v(v(r*M)+v(i*x))+v(j*y));o[g+140>>2]=0;s[g+160>>2]=v(v(z*H)+v(k*I))+v(n*B);s[g+144>>2]=v(v(r*H)+v(i*I))+v(j*B);s[g+136>>2]=v(v(q*P)+v(t*A))+v(p*F);s[g+132>>2]=v(v(q*O)+v(t*D))+v(p*E);s[g+128>>2]=v(v(q*H)+v(t*I))+v(p*B);s[g+176>>2]=v(v(v(t*N)-v(q*J))-v(p*w))+v(v(v(q*M)+v(t*x))+v(p*y));l[o[o[a>>2]+8>>2]](a,g+128|0,g+24|0,g+8|0);i=s[g+24>>2];if(!!(i<s[g+64>>2])){s[g+64>>2]=i;}i=s[g+28>>2];if(!!(i<s[g+68>>2])){s[g+68>>2]=i;}i=s[g+32>>2];if(!!(i<s[g+72>>2])){s[g+72>>2]=i;}i=s[g+36>>2];if(!!(i<s[g+76>>2])){s[g+76>>2]=i;}i=s[g+8>>2];if(!!(s[g+48>>2]<i)){s[g+48>>2]=i;}i=s[g+12>>2];if(!!(s[g+52>>2]<i)){s[g+52>>2]=i;}i=s[g+16>>2];if(!!(s[g+56>>2]<i)){s[g+56>>2]=i;}i=s[g+20>>2];if(!!(s[g+60>>2]<i)){s[g+60>>2]=i;}o[g+520>>2]=e;o[g+516>>2]=h;s[g+508>>2]=f;o[g+504>>2]=c;o[g+500>>2]=b;o[g+496>>2]=a;o[g+492>>2]=d;o[g+488>>2]=8940;o[g+512>>2]=L;a=o[L+68>>2];f:{if(!a){if(o[L+20>>2]<1){break f}b=0;while(1){a=o[L+28>>2]+u(b,80)|0;c=o[a+64>>2];z=s[a+48>>2];w=s[a+52>>2];x=s[a+56>>2];y=s[a>>2];D=s[a+16>>2];E=s[a+32>>2];A=s[a+4>>2];F=s[a+20>>2];B=s[a+36>>2];H=s[a+8>>2];I=s[a+24>>2];J=s[a+40>>2];M=s[h+52>>2];O=s[h+56>>2];f=s[h+20>>2];i=s[h+24>>2];j=s[h+36>>2];k=s[h+40>>2];P=s[h+48>>2];n=s[h+8>>2];p=s[h>>2];q=s[h+4>>2];t=s[h+16>>2];r=s[h+32>>2];o[g+188>>2]=0;o[g+172>>2]=0;o[g+156>>2]=0;o[g+140>>2]=0;s[g+168>>2]=v(v(H*r)+v(I*j))+v(J*k);s[g+164>>2]=v(v(A*r)+v(F*j))+v(B*k);s[g+160>>2]=v(v(y*r)+v(D*j))+v(E*k);s[g+152>>2]=v(v(H*t)+v(I*f))+v(J*i);s[g+148>>2]=v(v(A*t)+v(F*f))+v(B*i);s[g+144>>2]=v(v(y*t)+v(D*f))+v(E*i);s[g+136>>2]=v(v(H*p)+v(I*q))+v(J*n);s[g+132>>2]=v(v(A*p)+v(F*q))+v(B*n);s[g+128>>2]=v(v(y*p)+v(D*q))+v(E*n);s[g+184>>2]=O+v(v(v(z*r)+v(w*j))+v(x*k));s[g+180>>2]=M+v(v(v(z*t)+v(w*f))+v(x*i));s[g+176>>2]=P+v(v(v(z*p)+v(w*q))+v(x*n));o[g+92>>2]=-1;o[g+84>>2]=1065353216;o[g+88>>2]=1;o[g+100>>2]=b;o[g+80>>2]=9156;a=o[g+520>>2];o[g+96>>2]=a;o[g+84>>2]=o[a+4>>2];a=o[g+492>>2];d=o[a+8>>2];o[g+684>>2]=b;o[g+680>>2]=-1;o[g+672>>2]=d;o[g+668>>2]=c;o[g+664>>2]=a;o[g+676>>2]=g+128;Qc(o[g+496>>2],o[g+500>>2],o[g+504>>2],g+664|0,g+80|0,s[g+508>>2]);b=b+1|0;if((b|0)>=o[L+20>>2]){break f}h=o[g+516>>2];continue}}b=o[g+76>>2];o[g+136>>2]=o[g+72>>2];o[g+140>>2]=b;b=o[g+60>>2];o[g+152>>2]=o[g+56>>2];o[g+156>>2]=b;b=o[g+52>>2];o[g+144>>2]=o[g+48>>2];o[g+148>>2]=b;b=o[g+68>>2];o[g+128>>2]=o[g+64>>2];o[g+132>>2]=b;nb(o[a>>2],g+128|0,g+488|0);}l[o[4967]]();}K=g+688|0;}function Tv(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=v(0),f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=0,m=v(0),n=0,q=0,r=v(0),t=0,u=0,x=0,y=0,z=0,A=0,B=0;f=K-48|0;K=f;m=s[a+44>>2];g=s[a+28>>2];i=v(v(1)/s[a+120>>2]);j=s[a+60>>2];e=v(v(i*s[d+8>>2])+j);e=e<g?g:e;e=m<e?m:e;q=(e<v(0)?-.5:.5)+ +e;a:{if(w(q)<2147483648){t=~~q;break a}t=-2147483648;}e=v(v(i*s[c+8>>2])+j);e=e<g?g:e;e=m<e?m:e;q=(e<v(0)?-.5:.5)+ +e;b:{if(w(q)<2147483648){A=~~q;break b}A=-2147483648;}m=s[a+40>>2];g=s[a+24>>2];i=v(v(1)/s[a+116>>2]);j=s[a+56>>2];e=v(v(i*s[d+4>>2])+j);e=e<g?g:e;e=m<e?m:e;q=(e<v(0)?-.5:.5)+ +e;c:{if(w(q)<2147483648){k=~~q;break c}k=-2147483648;}e=v(v(i*s[c+4>>2])+j);e=e<g?g:e;e=m<e?m:e;q=(e<v(0)?-.5:.5)+ +e;d:{if(w(q)<2147483648){n=~~q;break d}n=-2147483648;}m=s[a+36>>2];g=s[a+20>>2];i=v(v(1)/s[a+112>>2]);j=s[a+52>>2];e=v(v(i*s[d>>2])+j);e=e<g?g:e;e=m<e?m:e;q=(e<v(0)?-.5:.5)+ +e;e:{if(w(q)<2147483648){d=~~q;break e}d=-2147483648;}e=v(v(i*s[c>>2])+j);e=e<g?g:e;e=m<e?m:e;q=(e<v(0)?-.5:.5)+ +e;f:{if(w(q)<2147483648){c=~~q;break f}c=-2147483648;}u=o[a+72>>2]+ -1|0;x=o[a+68>>2]+ -1|0;z=o[a+108>>2];g:{if(z>>>0>2){t=0;n=0;break g}t=t+1|0;A=A+ -1|0;k=k+1|0;n=n+ -1|0;d=d+1|0;c=c+ -1|0;h:{switch(z-1|0){default:u=(t|0)<(u|0)?t:u;x=(k|0)<(x|0)?k:x;t=(n|0)>0?n:0;n=(A|0)>0?A:0;break g;case 0:u=(t|0)<(u|0)?t:u;x=(d|0)<(x|0)?d:x;t=(c|0)>0?c:0;n=(A|0)>0?A:0;break g;case 1:break h}}u=(k|0)<(u|0)?k:u;x=(d|0)<(x|0)?d:x;t=(c|0)>0?c:0;n=(n|0)>0?n:0;}if((n|0)<(u|0)){while(1){A=u;if((t|0)>=(x|0)){n=n+1|0;}else {B=n&1;z=n+1|0;r=v(z|0);m=v(n|0);c=t;while(1){i:{if(!(!p[a+106|0]|B?!(p[a+104|0]|(c+n&1?0:p[a+105|0])):0)){g=v(l[o[o[a>>2]+68>>2]](a,c,n));d=f;j:{k:{l:{m:{n:{k=o[a+108>>2];if(k>>>0<=2){switch(k-1|0){case 1:break l;case 0:break m;default:break n}}h=s[f+8>>2];g=s[f+4>>2];e=s[f>>2];break j}i=s[a+84>>2];j=s[a+88>>2];e=s[a+52>>2];o[f+12>>2]=0;e=v(g-e);s[f>>2]=e;h=v(m-v(j*v(.5)));s[f+8>>2]=h;g=v(v(c|0)-v(i*v(.5)));s[f+4>>2]=g;break j}i=s[a+84>>2];j=s[a+88>>2];e=s[a+56>>2];o[f+12>>2]=0;g=v(g-e);s[f+4>>2]=g;h=v(m-v(j*v(.5)));s[f+8>>2]=h;e=v(v(c|0)-v(i*v(.5)));break k}i=s[a+84>>2];j=s[a+88>>2];e=s[a+60>>2];o[f+12>>2]=0;h=v(g-e);s[f+8>>2]=h;g=v(m-v(j*v(.5)));s[f+4>>2]=g;e=v(v(c|0)-v(i*v(.5)));}s[d>>2]=e;}s[f>>2]=e*s[a+112>>2];s[f+4>>2]=g*s[a+116>>2];s[f+8>>2]=h*s[a+120>>2];g=v(l[o[o[a>>2]+68>>2]](a,c,z));d=f;o:{p:{q:{r:{s:{k=o[a+108>>2];if(k>>>0<=2){switch(k-1|0){case 1:break q;case 0:break r;default:break s}}h=s[f+24>>2];g=s[f+20>>2];e=s[f+16>>2];break o}i=s[a+84>>2];j=s[a+88>>2];e=s[a+52>>2];o[f+28>>2]=0;e=v(g-e);s[f+16>>2]=e;h=v(r-v(j*v(.5)));s[f+24>>2]=h;g=v(v(c|0)-v(i*v(.5)));s[f+20>>2]=g;break o}i=s[a+84>>2];j=s[a+88>>2];e=s[a+56>>2];o[f+28>>2]=0;g=v(g-e);s[f+20>>2]=g;h=v(r-v(j*v(.5)));s[f+24>>2]=h;e=v(v(c|0)-v(i*v(.5)));break p}i=s[a+84>>2];j=s[a+88>>2];e=s[a+60>>2];o[f+28>>2]=0;h=v(g-e);s[f+24>>2]=h;g=v(r-v(j*v(.5)));s[f+20>>2]=g;e=v(v(c|0)-v(i*v(.5)));}s[d+16>>2]=e;}s[f+16>>2]=e*s[a+112>>2];s[f+20>>2]=g*s[a+116>>2];s[f+24>>2]=h*s[a+120>>2];d=c+1|0;g=v(l[o[o[a>>2]+68>>2]](a,d,z));y=f;t:{u:{v:{w:{x:{k=o[a+108>>2];if(k>>>0<=2){switch(k-1|0){case 1:break v;case 0:break w;default:break x}}h=s[f+40>>2];g=s[f+36>>2];e=s[f+32>>2];break t}i=s[a+84>>2];j=s[a+88>>2];e=s[a+52>>2];o[f+44>>2]=0;e=v(g-e);s[f+32>>2]=e;h=v(r-v(j*v(.5)));s[f+40>>2]=h;g=v(v(d|0)-v(i*v(.5)));s[f+36>>2]=g;break t}i=s[a+84>>2];j=s[a+88>>2];e=s[a+56>>2];o[f+44>>2]=0;g=v(g-e);s[f+36>>2]=g;h=v(r-v(j*v(.5)));s[f+40>>2]=h;e=v(v(d|0)-v(i*v(.5)));break u}i=s[a+84>>2];j=s[a+88>>2];e=s[a+60>>2];o[f+44>>2]=0;h=v(g-e);s[f+40>>2]=h;g=v(r-v(j*v(.5)));s[f+36>>2]=g;e=v(v(d|0)-v(i*v(.5)));}s[y+32>>2]=e;}s[f+32>>2]=e*s[a+112>>2];s[f+36>>2]=g*s[a+116>>2];s[f+40>>2]=h*s[a+120>>2];l[o[o[b>>2]+8>>2]](b,f,c,n);g=v(l[o[o[a>>2]+68>>2]](a,d,z));y=f;y:{z:{A:{B:{C:{k=o[a+108>>2];if(k>>>0<=2){switch(k-1|0){case 1:break A;case 0:break B;default:break C}}h=s[f+24>>2];g=s[f+20>>2];e=s[f+16>>2];break y}i=s[a+84>>2];j=s[a+88>>2];e=s[a+52>>2];o[f+28>>2]=0;e=v(g-e);s[f+16>>2]=e;h=v(r-v(j*v(.5)));s[f+24>>2]=h;g=v(v(d|0)-v(i*v(.5)));s[f+20>>2]=g;break y}i=s[a+84>>2];j=s[a+88>>2];e=s[a+56>>2];o[f+28>>2]=0;g=v(g-e);s[f+20>>2]=g;h=v(r-v(j*v(.5)));s[f+24>>2]=h;e=v(v(d|0)-v(i*v(.5)));break z}i=s[a+84>>2];j=s[a+88>>2];e=s[a+60>>2];o[f+28>>2]=0;h=v(g-e);s[f+24>>2]=h;g=v(r-v(j*v(.5)));s[f+20>>2]=g;e=v(v(d|0)-v(i*v(.5)));}s[y+16>>2]=e;}s[f+16>>2]=e*s[a+112>>2];s[f+20>>2]=g*s[a+116>>2];s[f+24>>2]=h*s[a+120>>2];g=v(l[o[o[a>>2]+68>>2]](a,d,n));y=f;D:{E:{F:{G:{H:{k=o[a+108>>2];if(k>>>0<=2){switch(k-1|0){case 1:break F;case 0:break G;default:break H}}h=s[f+40>>2];g=s[f+36>>2];e=s[f+32>>2];break D}i=s[a+84>>2];j=s[a+88>>2];e=s[a+52>>2];o[f+44>>2]=0;e=v(g-e);s[f+32>>2]=e;h=v(m-v(j*v(.5)));s[f+40>>2]=h;g=v(v(d|0)-v(i*v(.5)));s[f+36>>2]=g;break D}i=s[a+84>>2];j=s[a+88>>2];e=s[a+56>>2];o[f+44>>2]=0;g=v(g-e);s[f+36>>2]=g;h=v(m-v(j*v(.5)));s[f+40>>2]=h;e=v(v(d|0)-v(i*v(.5)));break E}i=s[a+84>>2];j=s[a+88>>2];e=s[a+60>>2];o[f+44>>2]=0;h=v(g-e);s[f+40>>2]=h;g=v(m-v(j*v(.5)));s[f+36>>2]=g;e=v(v(d|0)-v(i*v(.5)));}s[y+32>>2]=e;}break i}g=v(l[o[o[a>>2]+68>>2]](a,c,n));d=f;I:{J:{K:{L:{M:{k=o[a+108>>2];if(k>>>0<=2){switch(k-1|0){case 1:break K;case 0:break L;default:break M}}h=s[f+8>>2];g=s[f+4>>2];e=s[f>>2];break I}i=s[a+84>>2];j=s[a+88>>2];e=s[a+52>>2];o[f+12>>2]=0;e=v(g-e);s[f>>2]=e;h=v(m-v(j*v(.5)));s[f+8>>2]=h;g=v(v(c|0)-v(i*v(.5)));s[f+4>>2]=g;break I}i=s[a+84>>2];j=s[a+88>>2];e=s[a+56>>2];o[f+12>>2]=0;g=v(g-e);s[f+4>>2]=g;h=v(m-v(j*v(.5)));s[f+8>>2]=h;e=v(v(c|0)-v(i*v(.5)));break J}i=s[a+84>>2];j=s[a+88>>2];e=s[a+60>>2];o[f+12>>2]=0;h=v(g-e);s[f+8>>2]=h;g=v(m-v(j*v(.5)));s[f+4>>2]=g;e=v(v(c|0)-v(i*v(.5)));}s[d>>2]=e;}s[f>>2]=e*s[a+112>>2];s[f+4>>2]=g*s[a+116>>2];s[f+8>>2]=h*s[a+120>>2];g=v(l[o[o[a>>2]+68>>2]](a,c,z));d=f;N:{O:{P:{Q:{R:{k=o[a+108>>2];if(k>>>0<=2){switch(k-1|0){case 1:break P;case 0:break Q;default:break R}}h=s[f+24>>2];g=s[f+20>>2];e=s[f+16>>2];break N}i=s[a+84>>2];j=s[a+88>>2];e=s[a+52>>2];o[f+28>>2]=0;e=v(g-e);s[f+16>>2]=e;h=v(r-v(j*v(.5)));s[f+24>>2]=h;g=v(v(c|0)-v(i*v(.5)));s[f+20>>2]=g;break N}i=s[a+84>>2];j=s[a+88>>2];e=s[a+56>>2];o[f+28>>2]=0;g=v(g-e);s[f+20>>2]=g;h=v(r-v(j*v(.5)));s[f+24>>2]=h;e=v(v(c|0)-v(i*v(.5)));break O}i=s[a+84>>2];j=s[a+88>>2];e=s[a+60>>2];o[f+28>>2]=0;h=v(g-e);s[f+24>>2]=h;g=v(r-v(j*v(.5)));s[f+20>>2]=g;e=v(v(c|0)-v(i*v(.5)));}s[d+16>>2]=e;}s[f+16>>2]=e*s[a+112>>2];s[f+20>>2]=g*s[a+116>>2];s[f+24>>2]=h*s[a+120>>2];d=c+1|0;g=v(l[o[o[a>>2]+68>>2]](a,d,n));y=f;S:{T:{U:{V:{W:{k=o[a+108>>2];if(k>>>0<=2){switch(k-1|0){case 1:break U;case 0:break V;default:break W}}h=s[f+40>>2];g=s[f+36>>2];e=s[f+32>>2];break S}i=s[a+84>>2];j=s[a+88>>2];e=s[a+52>>2];o[f+44>>2]=0;e=v(g-e);s[f+32>>2]=e;h=v(m-v(j*v(.5)));s[f+40>>2]=h;g=v(v(d|0)-v(i*v(.5)));s[f+36>>2]=g;break S}i=s[a+84>>2];j=s[a+88>>2];e=s[a+56>>2];o[f+44>>2]=0;g=v(g-e);s[f+36>>2]=g;h=v(m-v(j*v(.5)));s[f+40>>2]=h;e=v(v(d|0)-v(i*v(.5)));break T}i=s[a+84>>2];j=s[a+88>>2];e=s[a+60>>2];o[f+44>>2]=0;h=v(g-e);s[f+40>>2]=h;g=v(m-v(j*v(.5)));s[f+36>>2]=g;e=v(v(d|0)-v(i*v(.5)));}s[y+32>>2]=e;}s[f+32>>2]=e*s[a+112>>2];s[f+36>>2]=g*s[a+116>>2];s[f+40>>2]=h*s[a+120>>2];l[o[o[b>>2]+8>>2]](b,f,c,n);g=v(l[o[o[a>>2]+68>>2]](a,d,n));y=f;X:{Y:{Z:{_:{$:{k=o[a+108>>2];if(k>>>0<=2){switch(k-1|0){case 1:break Z;case 0:break _;default:break $}}h=s[f+8>>2];g=s[f+4>>2];e=s[f>>2];break X}i=s[a+84>>2];j=s[a+88>>2];e=s[a+52>>2];o[f+12>>2]=0;e=v(g-e);s[f>>2]=e;h=v(m-v(j*v(.5)));s[f+8>>2]=h;g=v(v(d|0)-v(i*v(.5)));s[f+4>>2]=g;break X}i=s[a+84>>2];j=s[a+88>>2];e=s[a+56>>2];o[f+12>>2]=0;g=v(g-e);s[f+4>>2]=g;h=v(m-v(j*v(.5)));s[f+8>>2]=h;e=v(v(d|0)-v(i*v(.5)));break Y}i=s[a+84>>2];j=s[a+88>>2];e=s[a+60>>2];o[f+12>>2]=0;h=v(g-e);s[f+8>>2]=h;g=v(m-v(j*v(.5)));s[f+4>>2]=g;e=v(v(d|0)-v(i*v(.5)));}s[y>>2]=e;}s[f>>2]=e*s[a+112>>2];s[f+4>>2]=g*s[a+116>>2];s[f+8>>2]=h*s[a+120>>2];g=v(l[o[o[a>>2]+68>>2]](a,d,z));y=f;aa:{ba:{ca:{da:{ea:{k=o[a+108>>2];if(k>>>0<=2){switch(k-1|0){case 1:break ca;case 0:break da;default:break ea}}h=s[f+40>>2];g=s[f+36>>2];e=s[f+32>>2];break aa}i=s[a+84>>2];j=s[a+88>>2];e=s[a+52>>2];o[f+44>>2]=0;e=v(g-e);s[f+32>>2]=e;h=v(r-v(j*v(.5)));s[f+40>>2]=h;g=v(v(d|0)-v(i*v(.5)));s[f+36>>2]=g;break aa}i=s[a+84>>2];j=s[a+88>>2];e=s[a+56>>2];o[f+44>>2]=0;g=v(g-e);s[f+36>>2]=g;h=v(r-v(j*v(.5)));s[f+40>>2]=h;e=v(v(d|0)-v(i*v(.5)));break ba}i=s[a+84>>2];j=s[a+88>>2];e=s[a+60>>2];o[f+44>>2]=0;h=v(g-e);s[f+40>>2]=h;g=v(r-v(j*v(.5)));s[f+36>>2]=g;e=v(v(d|0)-v(i*v(.5)));}s[y+32>>2]=e;}}s[f+32>>2]=e*s[a+112>>2];s[f+36>>2]=g*s[a+116>>2];s[f+40>>2]=h*s[a+120>>2];l[o[o[b>>2]+8>>2]](b,f,c,n);c=d;if((d|0)!=(x|0)){continue}break}n=z;}if((A|0)!=(n|0)){continue}break}}K=f+48|0;}function gj(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,n=v(0),q=v(0),r=v(0),t=v(0),x=v(0),y=v(0),z=0,A=v(0),B=0,C=v(0),D=v(0),E=v(0),F=0,G=v(0),H=v(0),I=v(0),J=0,L=0,M=0,N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0),Z=0,_=v(0),$=v(0),aa=0,ba=0,ca=0,ea=v(0),fa=v(0),ga=v(0),ha=v(0),ia=v(0);f=K-3584|0;K=f;a:{b:{aa=o[b+4>>2];L=o[aa+68>>2];if(L){ba=o[c+4>>2];z=o[ba+68>>2];if(z){break b}}xe(a,b,c,d,e);break a}if(!(o[ba+72>>2]==o[a+112>>2]?o[aa+72>>2]==o[a+108>>2]:0)){j=o[a+84>>2];i=o[j+8>>2];if((i|0)>=1){while(1){k=o[(o[j+16>>2]+u(h,12)|0)+8>>2];if(k){l[o[o[k>>2]>>2]](k)|0;g=o[a+4>>2];l[o[o[g>>2]+60>>2]](g,k);}h=h+1|0;if((i|0)!=(h|0)){continue}break}j=o[a+84>>2];}te(j);o[a+108>>2]=o[aa+72>>2];o[a+112>>2]=o[ba+72>>2];}o[f+84>>2]=0;m[f+88|0]=1;o[f+76>>2]=0;o[f+80>>2]=0;sb(f+112|0);sb(f+980|0);sb(f+1848|0);sb(f+2716|0);j=o[f+84>>2];if(j){if(p[f+88|0]){if(j){o[6258]=o[6258]+1;l[o[4969]](j);}}o[f+84>>2]=0;}o[f+76>>2]=0;o[f+80>>2]=4;o[f+84>>2]=f+112;m[f+88|0]=0;i=o[a+84>>2];k=o[i+8>>2];c:{d:{if((k|0)<=0){h=f+112|0;break d}while(1){j=o[(o[i+16>>2]+u(F,12)|0)+8>>2];if(j){l[o[o[j>>2]+16>>2]](j,f+72|0);k=0;h=o[f+76>>2];if((h|0)>0){while(1){M=o[o[f+84>>2]+(k<<2)>>2];if(o[M+844>>2]){o[e+4>>2]=M;j=o[M+836>>2];h=o[o[e+8>>2]+8>>2];g=(j|0)==(h|0);B=j;j=o[o[e+12>>2]+8>>2];da(M,(g?B:j)+4|0,(g?j:h)+4|0);o[e+4>>2]=0;h=o[f+76>>2];}k=k+1|0;if((k|0)<(h|0)){continue}break}}if((h|0)<=-1){if(o[f+80>>2]<=-1){j=o[f+84>>2];if(j){if(p[f+88|0]){if(j){o[6258]=o[6258]+1;l[o[4969]](j);}}o[f+84>>2]=0;}m[f+88|0]=1;o[f+80>>2]=0;o[f+84>>2]=0;}while(1){o[o[f+84>>2]+(h<<2)>>2]=0;j=h+1|0;g=j>>>0>=h>>>0;h=j;if(g){continue}break}}o[f+76>>2]=0;k=o[i+8>>2];}F=F+1|0;if((F|0)<(k|0)){continue}break}h=o[f+84>>2];if(!h){break c}}if(p[f+88|0]){if(h){o[6258]=o[6258]+1;l[o[4969]](h);}}o[f+84>>2]=0;}h=o[a+4>>2];j=o[a+84>>2];o[f+104>>2]=o[a+72>>2];o[f+100>>2]=j;o[f+92>>2]=d;o[f+88>>2]=h;o[f+76>>2]=0;o[f+72>>2]=10696;o[f+96>>2]=e;o[f+80>>2]=b;o[f+84>>2]=c;j=o[L>>2];e:{if(!j){break e}d=o[z>>2];if(!d){break e}g=o[b+12>>2];D=s[g+24>>2];n=v(-s[g+52>>2]);C=s[g+8>>2];r=s[g+48>>2];E=s[g+40>>2];x=s[g+56>>2];h=o[c+12>>2];y=s[h+48>>2];t=s[h+52>>2];q=s[h+56>>2];ga=v(v(v(v(D*n)-v(C*r))-v(E*x))+v(v(v(C*y)+v(D*t))+v(E*q)));G=s[g+20>>2];I=s[g+4>>2];H=s[g+36>>2];ha=v(v(v(v(G*n)-v(I*r))-v(H*x))+v(v(v(I*y)+v(G*t))+v(H*q)));Q=s[h+40>>2];N=s[h+24>>2];R=s[h+8>>2];O=s[h+36>>2];S=s[h+20>>2];P=s[h+4>>2];_=s[g+16>>2];A=v(_*n);n=s[g>>2];A=v(A-v(n*r));r=s[g+32>>2];ia=v(v(A-v(r*x))+v(v(v(n*y)+v(_*t))+v(r*q)));y=s[h+16>>2];t=s[h>>2];q=s[h+32>>2];$=s[e+32>>2];o[f+116>>2]=d;o[f+112>>2]=j;A=v(v(v(C*R)+v(D*N))+v(E*Q));W=v(w(A));T=v(v(v(C*P)+v(D*S))+v(E*O));X=v(w(T));U=v(v(v(C*t)+v(D*y))+v(E*q));Y=v(w(U));V=v(v(v(I*R)+v(G*N))+v(H*Q));D=v(w(V));C=v(v(v(I*P)+v(G*S))+v(H*O));E=v(w(C));G=v(v(v(I*t)+v(G*y))+v(H*q));I=v(w(G));H=v(v(v(n*R)+v(_*N))+v(r*Q));Q=v(w(H));N=v(v(v(n*P)+v(_*S))+v(r*O));R=v(w(N));O=v(v(v(n*t)+v(_*y))+v(r*q));S=v(w(O));Z=124;g=0;d=128;z=f+112|0;L=128;k=1;while(1){f:{g:{h:{M=k+ -1|0;ca=M<<3;j=ca+z|0;J=o[j>>2];B=o[j+4>>2];P=s[B+16>>2];n=s[B>>2];ea=v(v(v(P-n)*v(.5))+v(0));r=s[B+20>>2];x=s[B+4>>2];fa=v(v(v(r-x)*v(.5))+v(0));y=s[B+24>>2];q=s[B+8>>2];_=v(v(v(y-q)*v(.5))+v(0));t=v(v(v(S*ea)+v(R*fa))+v(Q*_));n=v(v(P+n)*v(.5));x=v(v(r+x)*v(.5));y=v(v(y+q)*v(.5));q=v(ia+v(v(v(O*n)+v(N*x))+v(H*y)));i:{if(s[J>>2]<=v($+v(t+q))^1|s[J+16>>2]>=v(v(q-t)-$)^1){break i}t=v(v(v(I*ea)+v(E*fa))+v(D*_));q=v(ha+v(v(v(G*n)+v(C*x))+v(V*y)));if(s[J+4>>2]<=v($+v(t+q))^1|s[J+20>>2]>=v(v(q-t)-$)^1){break i}t=v(v(v(Y*ea)+v(X*fa))+v(W*_));q=v(ga+v(v(v(U*n)+v(T*x))+v(A*y)));if(s[J+8>>2]<=v($+v(t+q))^1|s[J+24>>2]>=v(v(q-t)-$)^1){break i}j:{if((M|0)<=(Z|0)){j=d;i=z;h=g;break j}j=d<<1;k:{if(!((d|0)>=(j|0)|(L|0)>=(j|0))){l:{m:{n:{if(!d){i=0;break n}Z=0;o[6257]=o[6257]+1;i=l[o[4968]](d<<4,16)|0;if((d|0)<1){break n}while(1){h=Z<<3;F=h+i|0;L=h+z|0;h=o[L+4>>2];o[F>>2]=o[L>>2];o[F+4>>2]=h;Z=Z+1|0;if((Z|0)!=(d|0)){continue}break}if(!(g&255)){break l}break m}h=1;if(!z){break l}L=j;if(!(g&255)){break k}}if(z){o[6258]=o[6258]+1;l[o[4969]](z);}}h=1;L=j;break k}i=z;h=g;}Z=j+ -4|0;}d=o[B+40>>2];if(o[J+40>>2]){g=o[J+36>>2];if(d){d=i+ca|0;o[d+4>>2]=o[B+36>>2];o[d>>2]=g;d=o[J+40>>2];g=(k<<3)+i|0;o[g+4>>2]=o[B+36>>2];o[g>>2]=d;d=o[J+36>>2];o[g+12>>2]=o[B+40>>2];o[g+8>>2]=d;d=o[J+40>>2];o[g+20>>2]=o[B+40>>2];o[g+16>>2]=d;k=k+3|0;break g}d=i+ca|0;o[d+4>>2]=B;o[d>>2]=g;g=o[J+40>>2];d=(k<<3)+i|0;o[d+4>>2]=B;o[d>>2]=g;break h}if(d){d=i+ca|0;o[d+4>>2]=o[B+36>>2];o[d>>2]=J;d=(k<<3)+i|0;o[d+4>>2]=o[B+40>>2];o[d>>2]=J;break h}l[o[o[f+72>>2]+8>>2]](f+72|0,J,B);d=j;z=i;g=h;}k=M;break f}k=k+1|0;}d=j;z=i;g=h;}if(k){continue}break}if(!z|!(g&255)){break e}if(z){o[6258]=o[6258]+1;l[o[4969]](z);}}M=o[a+84>>2];if(o[M+8>>2]>=1){L=0;while(1){j=u(L,12);d=j+o[M+16>>2]|0;h=o[d+8>>2];o:{if(!h){break o}i=o[aa+28>>2]+u(o[d>>2],80)|0;d=o[i+64>>2];g=o[b+12>>2];y=s[g+52>>2];t=s[g+56>>2];G=s[i+48>>2];I=s[i+52>>2];H=s[i+56>>2];Q=s[i+4>>2];N=s[i+20>>2];R=s[i+36>>2];O=s[i+8>>2];S=s[i+24>>2];P=s[i+40>>2];W=s[g+20>>2];T=s[g+24>>2];n=s[i>>2];X=s[g+36>>2];r=s[i+16>>2];U=s[g+40>>2];x=s[i+32>>2];q=s[g+48>>2];Y=s[g+8>>2];V=s[g>>2];D=s[g+4>>2];C=s[g+16>>2];E=s[g+32>>2];o[f+172>>2]=0;o[f+156>>2]=0;o[f+140>>2]=0;o[f+124>>2]=0;s[f+144>>2]=v(v(E*n)+v(X*r))+v(U*x);s[f+128>>2]=v(v(C*n)+v(W*r))+v(T*x);s[f+112>>2]=v(v(V*n)+v(D*r))+v(Y*x);s[f+152>>2]=v(v(E*O)+v(X*S))+v(U*P);s[f+148>>2]=v(v(E*Q)+v(X*N))+v(U*R);s[f+136>>2]=v(v(C*O)+v(W*S))+v(T*P);s[f+132>>2]=v(v(C*Q)+v(W*N))+v(T*R);s[f+120>>2]=v(v(V*O)+v(D*S))+v(Y*P);s[f+116>>2]=v(v(V*Q)+v(D*N))+v(Y*R);s[f+168>>2]=t+v(v(v(E*G)+v(X*I))+v(U*H));s[f+164>>2]=y+v(v(v(C*G)+v(W*I))+v(T*H));s[f+160>>2]=q+v(v(v(V*G)+v(D*I))+v(Y*H));l[o[o[d>>2]+8>>2]](d,f+112|0,f+56|0,f+40|0);A=s[e+32>>2];s[f+56>>2]=s[f+56>>2]-A;s[f+60>>2]=s[f+60>>2]-A;s[f+64>>2]=s[f+64>>2]-A;s[f+40>>2]=A+s[f+40>>2];s[f+44>>2]=A+s[f+44>>2];s[f+48>>2]=A+s[f+48>>2];i=o[ba+28>>2]+u(o[(j+o[M+16>>2]|0)+4>>2],80)|0;d=o[i+64>>2];g=o[c+12>>2];y=s[g+52>>2];t=s[g+56>>2];G=s[i+48>>2];I=s[i+52>>2];H=s[i+56>>2];Q=s[i+4>>2];N=s[i+20>>2];R=s[i+36>>2];O=s[i+8>>2];S=s[i+24>>2];P=s[i+40>>2];W=s[g+20>>2];T=s[g+24>>2];n=s[i>>2];X=s[g+36>>2];r=s[i+16>>2];U=s[g+40>>2];x=s[i+32>>2];q=s[g+48>>2];Y=s[g+8>>2];V=s[g>>2];D=s[g+4>>2];C=s[g+16>>2];E=s[g+32>>2];o[f+172>>2]=0;o[f+156>>2]=0;o[f+140>>2]=0;o[f+124>>2]=0;s[f+144>>2]=v(v(E*n)+v(X*r))+v(U*x);s[f+128>>2]=v(v(C*n)+v(W*r))+v(T*x);s[f+112>>2]=v(v(V*n)+v(D*r))+v(Y*x);s[f+152>>2]=v(v(E*O)+v(X*S))+v(U*P);s[f+148>>2]=v(v(E*Q)+v(X*N))+v(U*R);s[f+136>>2]=v(v(C*O)+v(W*S))+v(T*P);s[f+132>>2]=v(v(C*Q)+v(W*N))+v(T*R);s[f+120>>2]=v(v(V*O)+v(D*S))+v(Y*P);s[f+116>>2]=v(v(V*Q)+v(D*N))+v(Y*R);s[f+168>>2]=t+v(v(v(E*G)+v(X*I))+v(U*H));s[f+164>>2]=y+v(v(v(C*G)+v(W*I))+v(T*H));s[f+160>>2]=q+v(v(v(V*G)+v(D*I))+v(Y*H));l[o[o[d>>2]+8>>2]](d,f+112|0,f+24|0,f+8|0);n=v(s[f+24>>2]-A);s[f+24>>2]=n;r=v(s[f+28>>2]-A);s[f+28>>2]=r;x=v(s[f+32>>2]-A);s[f+32>>2]=x;y=v(A+s[f+8>>2]);s[f+8>>2]=y;t=v(A+s[f+16>>2]);s[f+16>>2]=t;q=v(A+s[f+12>>2]);s[f+12>>2]=q;p:{if(s[f+44>>2]<r|s[f+60>>2]>q|(s[f+40>>2]<n|s[f+56>>2]>y)){break p}if(s[f+64>>2]>t){break p}if(!(s[f+48>>2]<x)){break o}}l[o[o[h>>2]>>2]](h)|0;d=o[a+4>>2];l[o[o[d>>2]+60>>2]](d,h);d=j+o[M+16>>2]|0;g=o[d+4>>2];j=o[d>>2];F=o[a+92>>2];q:{if((F|0)!=o[a+96>>2]){break q}k=F?F<<1:1;if((F|0)>=(k|0)){break q}h=0;Z=0;if(k){o[6257]=o[6257]+1;Z=l[o[4968]](u(k,12),16)|0;F=o[a+92>>2];}if((F|0)>=1){while(1){d=u(h,12);z=d+Z|0;i=d+o[a+100>>2]|0;d=o[i+4>>2];o[z>>2]=o[i>>2];o[z+4>>2]=d;o[z+8>>2]=o[i+8>>2];h=h+1|0;if((F|0)!=(h|0)){continue}break}}d=o[a+100>>2];if(d){if(p[a+104|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+100>>2]=0;}o[a+100>>2]=Z;m[a+104|0]=1;o[a+96>>2]=k;F=o[a+92>>2];}d=o[a+100>>2]+u(F,12)|0;o[d+8>>2]=0;o[d+4>>2]=g;o[d>>2]=j;o[a+92>>2]=o[a+92>>2]+1;}L=L+1|0;if((L|0)<o[M+8>>2]){continue}break}}if(o[a+92>>2]>=1){h=0;while(1){c=o[a+84>>2];b=o[a+100>>2]+u(h,12)|0;l[o[o[c>>2]+8>>2]](c,o[b>>2],o[b+4>>2])|0;h=h+1|0;if((h|0)<o[a+92>>2]){continue}break}}b=o[a+100>>2];if(b){if(p[a+104|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+100>>2]=0;}o[a+100>>2]=0;o[a+92>>2]=0;o[a+96>>2]=0;m[a+104|0]=1;}K=f+3584|0;}function fk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=v(0),h=v(0),i=0,j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),w=v(0),x=0,y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=0,H=0,I=v(0),J=v(0),L=0,M=0,N=0,O=0,P=0,Q=v(0),R=v(0),S=v(0);e=K-144|0;K=e;a:{if(!l[o[o[a>>2]+20>>2]](a)){break a}f=l[o[o[a>>2]+20>>2]](a)|0;if(!(l[o[o[f>>2]+56>>2]](f)&32768)){break a}f=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[f>>2]+64>>2]](f,b,v(.10000000149011612));}b:{c:{f=o[c+4>>2];if(f>>>0>31){break c}d:{switch(f-1|0){case 30:x=o[c+20>>2];if((x|0)<1){break b}while(1){f=x+ -1|0;i=o[c+28>>2]+u(f,80)|0;G=o[i+64>>2];r=s[i+56>>2];t=s[i+48>>2];B=s[i+52>>2];y=s[i+32>>2];C=s[i>>2];D=s[i+16>>2];F=s[i+36>>2];k=s[i+4>>2];w=s[i+20>>2];E=s[i+40>>2];I=s[i+8>>2];J=s[i+24>>2];Q=s[b+48>>2];R=s[b+52>>2];S=s[b+56>>2];g=s[b+8>>2];h=s[b>>2];j=s[b+4>>2];m=s[b+24>>2];n=s[b+16>>2];p=s[b+20>>2];z=s[b+40>>2];A=s[b+32>>2];q=s[b+36>>2];o[e+60>>2]=0;o[e+44>>2]=0;o[e+28>>2]=0;o[e+12>>2]=0;s[e+40>>2]=v(v(I*A)+v(J*q))+v(E*z);s[e+36>>2]=v(v(k*A)+v(w*q))+v(F*z);s[e+32>>2]=v(v(C*A)+v(D*q))+v(y*z);s[e+24>>2]=v(v(I*n)+v(J*p))+v(E*m);s[e+20>>2]=v(v(k*n)+v(w*p))+v(F*m);s[e+16>>2]=v(v(C*n)+v(D*p))+v(y*m);s[e+8>>2]=v(v(I*h)+v(J*j))+v(E*g);s[e+4>>2]=v(v(k*h)+v(w*j))+v(F*g);s[e>>2]=v(v(C*h)+v(D*j))+v(y*g);s[e+56>>2]=S+v(v(v(t*A)+v(B*q))+v(r*z));s[e+52>>2]=R+v(v(v(t*n)+v(B*p))+v(r*m));s[e+48>>2]=Q+v(v(v(t*h)+v(B*j))+v(r*g));l[o[o[a>>2]+28>>2]](a,e,G,d);i=(x|0)>1;x=f;if(i){continue}break}break b;default:f=o[c+44>>2];o[e+8>>2]=o[c+40>>2];o[e+12>>2]=f;f=o[c+36>>2];o[e>>2]=o[c+32>>2];o[e+4>>2]=f;g=v(l[o[o[c>>2]+48>>2]](c));h=v(l[o[o[c>>2]+48>>2]](c));j=v(v(l[o[o[c>>2]+48>>2]](c))+s[e+8>>2]);s[e+8>>2]=j;g=v(g+s[e>>2]);s[e>>2]=g;h=v(h+s[e+4>>2]);s[e+4>>2]=h;a=l[o[o[a>>2]+20>>2]](a)|0;o[e+140>>2]=0;s[e+136>>2]=-j;s[e+132>>2]=-h;s[e+128>>2]=-g;l[o[o[a>>2]+80>>2]](a,e+128|0,e,b,d);break b;case 7:g=v(l[o[o[c>>2]+48>>2]](c));a=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[a>>2]+24>>2]](a,g,b,d);break b;case 8:f=o[c+96>>2];if((f|0)<1){break b}while(1){i=f+ -1|0;x=o[c+104>>2]+(i<<4)|0;g=s[x+8>>2];h=s[x>>2];j=s[x+4>>2];x=l[o[o[a>>2]+20>>2]](a)|0;y=s[o[c+124>>2]+(i<<2)>>2];C=s[b+48>>2];D=s[b+52>>2];F=s[b+56>>2];m=s[b+8>>2];n=s[b>>2];p=s[b+4>>2];z=s[b+24>>2];A=s[b+16>>2];q=s[b+20>>2];r=s[b+40>>2];t=s[b+32>>2];B=s[b+36>>2];o[e+60>>2]=0;o[e+44>>2]=0;o[e+28>>2]=0;o[e+12>>2]=0;k=v(t*v(0));w=v(B*v(0));s[e+40>>2]=r+v(k+w);E=v(k+B);k=v(r*v(0));s[e+36>>2]=E+k;s[e+32>>2]=v(t+w)+k;k=v(A*v(0));w=v(q*v(0));s[e+24>>2]=z+v(k+w);E=v(k+q);k=v(z*v(0));s[e+20>>2]=E+k;s[e+16>>2]=v(A+w)+k;k=v(n*v(0));w=v(p*v(0));s[e+8>>2]=m+v(k+w);E=v(k+p);k=v(m*v(0));s[e+4>>2]=E+k;s[e>>2]=v(n+w)+k;s[e+56>>2]=F+v(v(v(h*t)+v(j*B))+v(g*r));s[e+52>>2]=D+v(v(v(h*A)+v(j*q))+v(g*z));s[e+48>>2]=C+v(v(v(h*n)+v(j*p))+v(g*m));l[o[o[x>>2]+24>>2]](x,y,e,d);x=(f|0)>1;f=i;if(x){continue}break}break b;case 9:f=o[c+56>>2];c=c+32|0;g=s[(f<<2)+c>>2];h=s[c+((f+2|0)%3<<2)>>2];a=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[a>>2]+84>>2]](a,h,g,f,b,d);break b;case 10:f=o[c+72>>2];g=s[c+60>>2];h=s[c+64>>2];a=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[a>>2]+92>>2]](a,g,h,f,b,d);break b;case 12:f=o[c+56>>2];g=v(l[o[o[c>>2]+92>>2]](c));i=o[c+44>>2];o[e+8>>2]=o[c+40>>2];o[e+12>>2]=i;i=o[c+36>>2];o[e>>2]=o[c+32>>2];o[e+4>>2]=i;h=v(l[o[o[c>>2]+48>>2]](c));j=v(l[o[o[c>>2]+48>>2]](c));s[e+8>>2]=v(l[o[o[c>>2]+48>>2]](c))+s[e+8>>2];s[e>>2]=h+s[e>>2];s[e+4>>2]=j+s[e+4>>2];h=s[(f<<2)+e>>2];a=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[a>>2]+88>>2]](a,g,h,f,b,d);break b;case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 11:case 13:case 14:case 15:case 16:case 17:case 18:case 19:case 20:case 21:case 22:case 23:case 24:case 25:case 26:case 28:case 29:break c;case 27:break d}}g=s[c+68>>2];a=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[a>>2]+96>>2]](a,c+52|0,g,b,d);break b}e:{if((f|0)>6){break e}G=o[c+56>>2];if(G){if(o[G+28>>2]<1){break e}while(1){j=v(0);f:{N=u(M,36);f=N+o[G+36>>2]|0;L=o[f+4>>2];if(!L){g=v(0);h=v(0);break f}g=v(0);h=v(0);if((L|0)<1){break f}H=o[f+12>>2];f=o[(H+(L<<2)|0)+ -4>>2];x=0;while(1){i=o[(x<<2)+H>>2];O=i<<4;H=O+o[G+16>>2]|0;E=s[H>>2];I=s[H+4>>2];J=s[H+8>>2];H=l[o[o[a>>2]+20>>2]](a)|0;P=o[G+16>>2];f=P+(f<<4)|0;m=s[f+8>>2];n=s[f>>2];p=s[f+4>>2];z=s[b+48>>2];A=s[b+8>>2];q=s[b>>2];r=s[b+4>>2];t=s[b+52>>2];B=s[b+24>>2];y=s[b+16>>2];C=s[b+20>>2];D=s[b+56>>2];F=s[b+40>>2];k=s[b+32>>2];w=s[b+36>>2];o[e+12>>2]=0;s[e+8>>2]=D+v(v(v(n*k)+v(p*w))+v(m*F));s[e+4>>2]=t+v(v(v(n*y)+v(p*C))+v(m*B));s[e>>2]=z+v(v(v(n*q)+v(p*r))+v(m*A));f=O+P|0;m=s[f+8>>2];n=s[f>>2];p=s[f+4>>2];o[e+140>>2]=0;s[e+136>>2]=D+v(v(v(k*n)+v(w*p))+v(F*m));s[e+132>>2]=t+v(v(v(y*n)+v(C*p))+v(B*m));s[e+128>>2]=z+v(v(v(q*n)+v(r*p))+v(A*m));l[o[o[H>>2]+16>>2]](H,e,e+128|0,d);h=v(h+J);g=v(g+I);j=v(j+E);x=x+1|0;f=o[G+36>>2]+N|0;if((x|0)>=o[f+4>>2]){break f}H=o[f+12>>2];f=i;continue}}f=l[o[o[a>>2]+20>>2]](a)|0;if(l[o[o[f>>2]+56>>2]](f)&16384){o[e+8>>2]=0;o[e+12>>2]=0;o[e>>2]=1065353216;o[e+4>>2]=1065353216;f=o[G+36>>2]+N|0;k=s[f+28>>2];w=s[f+20>>2];E=s[f+24>>2];f=l[o[o[a>>2]+20>>2]](a)|0;m=s[b+48>>2];n=s[b+8>>2];p=s[b>>2];z=s[b+4>>2];A=s[b+52>>2];q=s[b+24>>2];r=s[b+16>>2];t=s[b+20>>2];B=s[b+56>>2];y=s[b+40>>2];C=s[b+32>>2];D=s[b+36>>2];o[e+140>>2]=0;F=v(v(1)/v(L|0));j=v(F*j);g=v(F*g);h=v(F*h);s[e+136>>2]=B+v(v(v(C*j)+v(D*g))+v(y*h));s[e+132>>2]=A+v(v(v(j*r)+v(g*t))+v(h*q));s[e+128>>2]=m+v(v(v(j*p)+v(g*z))+v(h*n));o[e+124>>2]=0;j=v(j+w);g=v(g+E);h=v(h+k);s[e+120>>2]=B+v(v(v(C*j)+v(D*g))+v(y*h));s[e+116>>2]=A+v(v(v(j*r)+v(g*t))+v(h*q));s[e+112>>2]=m+v(v(v(j*p)+v(g*z))+v(h*n));l[o[o[f>>2]+16>>2]](f,e+128|0,e+112|0,e);}M=M+1|0;if((M|0)<o[G+28>>2]){continue}break}break e}if((l[o[o[c>>2]+100>>2]](c)|0)<1){break e}f=0;while(1){l[o[o[c>>2]+104>>2]](c,f,e,e+128|0);g=s[b+48>>2];h=s[b+8>>2];j=s[b>>2];m=s[b+4>>2];n=s[b+52>>2];p=s[b+24>>2];z=s[b+16>>2];A=s[b+20>>2];q=s[b+56>>2];r=s[b+40>>2];t=s[b+32>>2];B=s[b+36>>2];o[e+124>>2]=0;y=s[e>>2];C=s[e+4>>2];D=s[e+8>>2];s[e+120>>2]=q+v(v(v(t*y)+v(B*C))+v(r*D));s[e+116>>2]=n+v(v(v(y*z)+v(C*A))+v(D*p));s[e+112>>2]=g+v(v(v(y*j)+v(C*m))+v(D*h));o[e+108>>2]=0;k=q;q=s[e+128>>2];y=v(t*q);t=s[e+132>>2];w=r;r=s[e+136>>2];s[e+104>>2]=k+v(v(y+v(B*t))+v(w*r));s[e+100>>2]=n+v(v(v(z*q)+v(A*t))+v(p*r));s[e+96>>2]=g+v(v(v(j*q)+v(m*t))+v(h*r));i=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[i>>2]+16>>2]](i,e+112|0,e+96|0,d);f=f+1|0;if((f|0)<(l[o[o[c>>2]+100>>2]](c)|0)){continue}break}}f=o[c+4>>2];if(f+ -21>>>0<=8){o[e+136>>2]=1566444395;o[e+140>>2]=0;o[e+128>>2]=1566444395;o[e+132>>2]=1566444395;o[e+120>>2]=-581039253;o[e+124>>2]=0;o[e+112>>2]=-581039253;o[e+116>>2]=-581039253;o[e+8>>2]=l[o[o[a>>2]+20>>2]](a);o[e+4>>2]=9624;o[e>>2]=9600;f=o[d+12>>2];o[e+20>>2]=o[d+8>>2];o[e+24>>2]=f;f=o[d+4>>2];o[e+12>>2]=o[d>>2];o[e+16>>2]=f;f=o[b+12>>2];o[e+36>>2]=o[b+8>>2];o[e+40>>2]=f;f=o[b+4>>2];o[e+28>>2]=o[b>>2];o[e+32>>2]=f;f=o[b+20>>2];o[e+44>>2]=o[b+16>>2];o[e+48>>2]=f;f=o[b+28>>2];o[e+52>>2]=o[b+24>>2];o[e+56>>2]=f;f=o[b+44>>2];o[e+68>>2]=o[b+40>>2];o[e+72>>2]=f;f=o[b+36>>2];o[e+60>>2]=o[b+32>>2];o[e+64>>2]=f;f=o[b+52>>2];o[e+76>>2]=o[b+48>>2];o[e+80>>2]=f;f=o[b+60>>2];o[e+84>>2]=o[b+56>>2];o[e+88>>2]=f;l[o[o[c>>2]+64>>2]](c,e,e+112|0,e+128|0);f=o[c+4>>2];}if((f|0)!=3){break b}o[e+136>>2]=1566444395;o[e+140>>2]=0;o[e+128>>2]=1566444395;o[e+132>>2]=1566444395;o[e+120>>2]=-581039253;o[e+124>>2]=0;o[e+112>>2]=-581039253;o[e+116>>2]=-581039253;o[e+8>>2]=l[o[o[a>>2]+20>>2]](a);o[e+4>>2]=9624;o[e>>2]=9600;a=o[d+12>>2];o[e+20>>2]=o[d+8>>2];o[e+24>>2]=a;a=o[d+4>>2];o[e+12>>2]=o[d>>2];o[e+16>>2]=a;a=o[b+12>>2];o[e+36>>2]=o[b+8>>2];o[e+40>>2]=a;a=o[b+4>>2];o[e+28>>2]=o[b>>2];o[e+32>>2]=a;a=o[b+20>>2];o[e+44>>2]=o[b+16>>2];o[e+48>>2]=a;a=o[b+28>>2];o[e+52>>2]=o[b+24>>2];o[e+56>>2]=a;a=o[b+44>>2];o[e+68>>2]=o[b+40>>2];o[e+72>>2]=a;a=o[b+36>>2];o[e+60>>2]=o[b+32>>2];o[e+64>>2]=a;a=o[b+52>>2];o[e+76>>2]=o[b+48>>2];o[e+80>>2]=a;a=o[b+60>>2];o[e+84>>2]=o[b+56>>2];o[e+88>>2]=a;a=o[c+96>>2];l[o[o[a>>2]+8>>2]](a,e|4,e+112|0,e+128|0);}K=e+144|0;}function xu(){var a=0;a=qa(8);o[5678]=a;G(a|0,0)|0;o[5681]=0;o[5682]=0;o[5680]=16468;o[5683]=0;o[5684]=0;o[5685]=0;o[5686]=0;o[5687]=0;o[5688]=0;W(22720);o[5690]=0;o[5691]=0;o[5689]=16468;o[5692]=0;o[5693]=0;o[5694]=0;o[5695]=0;o[5696]=0;o[5697]=0;W(22756);o[5699]=0;o[5700]=0;o[5698]=16468;o[5701]=0;o[5702]=0;o[5703]=0;o[5704]=0;o[5705]=0;o[5706]=0;W(22792);o[5708]=0;o[5709]=0;o[5707]=16468;o[5710]=0;o[5711]=0;o[5712]=0;o[5713]=0;o[5714]=0;o[5715]=0;W(22828);o[5717]=0;o[5718]=0;o[5716]=16468;o[5719]=0;o[5720]=0;o[5721]=0;o[5722]=0;o[5723]=0;o[5724]=0;W(22864);o[5726]=0;o[5727]=0;o[5725]=16468;o[5728]=0;o[5729]=0;o[5730]=0;o[5731]=0;o[5732]=0;o[5733]=0;W(22900);o[5735]=0;o[5736]=0;o[5734]=16468;o[5737]=0;o[5738]=0;o[5739]=0;o[5740]=0;o[5741]=0;o[5742]=0;W(22936);o[5744]=0;o[5745]=0;o[5743]=16468;o[5746]=0;o[5747]=0;o[5748]=0;o[5749]=0;o[5750]=0;o[5751]=0;W(22972);o[5753]=0;o[5754]=0;o[5752]=16468;o[5755]=0;o[5756]=0;o[5757]=0;o[5758]=0;o[5759]=0;o[5760]=0;W(23008);o[5762]=0;o[5763]=0;o[5761]=16468;o[5764]=0;o[5765]=0;o[5766]=0;o[5767]=0;o[5768]=0;o[5769]=0;W(23044);o[5771]=0;o[5772]=0;o[5770]=16468;o[5773]=0;o[5774]=0;o[5775]=0;o[5776]=0;o[5777]=0;o[5778]=0;W(23080);o[5780]=0;o[5781]=0;o[5779]=16468;o[5782]=0;o[5783]=0;o[5784]=0;o[5785]=0;o[5786]=0;o[5787]=0;W(23116);o[5789]=0;o[5790]=0;o[5788]=16468;o[5791]=0;o[5792]=0;o[5793]=0;o[5794]=0;o[5795]=0;o[5796]=0;W(23152);o[5798]=0;o[5799]=0;o[5797]=16468;o[5800]=0;o[5801]=0;o[5802]=0;o[5803]=0;o[5804]=0;o[5805]=0;W(23188);o[5807]=0;o[5808]=0;o[5806]=16468;o[5809]=0;o[5810]=0;o[5811]=0;o[5812]=0;o[5813]=0;o[5814]=0;W(23224);o[5816]=0;o[5817]=0;o[5815]=16468;o[5818]=0;o[5819]=0;o[5820]=0;o[5821]=0;o[5822]=0;o[5823]=0;W(23260);o[5825]=0;o[5826]=0;o[5824]=16468;o[5827]=0;o[5828]=0;o[5829]=0;o[5830]=0;o[5831]=0;o[5832]=0;W(23296);o[5834]=0;o[5835]=0;o[5833]=16468;o[5836]=0;o[5837]=0;o[5838]=0;o[5839]=0;o[5840]=0;o[5841]=0;W(23332);o[5843]=0;o[5844]=0;o[5842]=16468;o[5845]=0;o[5846]=0;o[5847]=0;o[5848]=0;o[5849]=0;o[5850]=0;W(23368);o[5852]=0;o[5853]=0;o[5851]=16468;o[5854]=0;o[5855]=0;o[5856]=0;o[5857]=0;o[5858]=0;o[5859]=0;W(23404);o[5861]=0;o[5862]=0;o[5860]=16468;o[5863]=0;o[5864]=0;o[5865]=0;o[5866]=0;o[5867]=0;o[5868]=0;W(23440);o[5870]=0;o[5871]=0;o[5869]=16468;o[5872]=0;o[5873]=0;o[5874]=0;o[5875]=0;o[5876]=0;o[5877]=0;W(23476);o[5879]=0;o[5880]=0;o[5878]=16468;o[5881]=0;o[5882]=0;o[5883]=0;o[5884]=0;o[5885]=0;o[5886]=0;W(23512);o[5888]=0;o[5889]=0;o[5887]=16468;o[5890]=0;o[5891]=0;o[5892]=0;o[5893]=0;o[5894]=0;o[5895]=0;W(23548);o[5897]=0;o[5898]=0;o[5896]=16468;o[5899]=0;o[5900]=0;o[5901]=0;o[5902]=0;o[5903]=0;o[5904]=0;W(23584);o[5906]=0;o[5907]=0;o[5905]=16468;o[5908]=0;o[5909]=0;o[5910]=0;o[5911]=0;o[5912]=0;o[5913]=0;W(23620);o[5915]=0;o[5916]=0;o[5914]=16468;o[5917]=0;o[5918]=0;o[5919]=0;o[5920]=0;o[5921]=0;o[5922]=0;W(23656);o[5924]=0;o[5925]=0;o[5923]=16468;o[5926]=0;o[5927]=0;o[5928]=0;o[5929]=0;o[5930]=0;o[5931]=0;W(23692);o[5933]=0;o[5934]=0;o[5932]=16468;o[5935]=0;o[5936]=0;o[5937]=0;o[5938]=0;o[5939]=0;o[5940]=0;W(23728);o[5942]=0;o[5943]=0;o[5941]=16468;o[5944]=0;o[5945]=0;o[5946]=0;o[5947]=0;o[5948]=0;o[5949]=0;W(23764);o[5951]=0;o[5952]=0;o[5950]=16468;o[5953]=0;o[5954]=0;o[5955]=0;o[5956]=0;o[5957]=0;o[5958]=0;W(23800);o[5960]=0;o[5961]=0;o[5959]=16468;o[5962]=0;o[5963]=0;o[5964]=0;o[5965]=0;o[5966]=0;o[5967]=0;W(23836);o[5969]=0;o[5970]=0;o[5968]=16468;o[5971]=0;o[5972]=0;o[5973]=0;o[5974]=0;o[5975]=0;o[5976]=0;W(23872);o[5978]=0;o[5979]=0;o[5977]=16468;o[5980]=0;o[5981]=0;o[5982]=0;o[5983]=0;o[5984]=0;o[5985]=0;W(23908);o[5987]=0;o[5988]=0;o[5986]=16468;o[5989]=0;o[5990]=0;o[5991]=0;o[5992]=0;o[5993]=0;o[5994]=0;W(23944);o[5996]=0;o[5997]=0;o[5995]=16468;o[5998]=0;o[5999]=0;o[6e3]=0;o[6001]=0;o[6002]=0;o[6003]=0;W(23980);o[6005]=0;o[6006]=0;o[6004]=16468;o[6007]=0;o[6008]=0;o[6009]=0;o[6010]=0;o[6011]=0;o[6012]=0;W(24016);o[6014]=0;o[6015]=0;o[6013]=16468;o[6016]=0;o[6017]=0;o[6018]=0;o[6019]=0;o[6020]=0;o[6021]=0;W(24052);o[6023]=0;o[6024]=0;o[6022]=16468;o[6025]=0;o[6026]=0;o[6027]=0;o[6028]=0;o[6029]=0;o[6030]=0;W(24088);o[6032]=0;o[6033]=0;o[6031]=16468;o[6034]=0;o[6035]=0;o[6036]=0;o[6037]=0;o[6038]=0;o[6039]=0;W(24124);o[6041]=0;o[6042]=0;o[6040]=16468;o[6043]=0;o[6044]=0;o[6045]=0;o[6046]=0;o[6047]=0;o[6048]=0;W(24160);o[6050]=0;o[6051]=0;o[6049]=16468;o[6052]=0;o[6053]=0;o[6054]=0;o[6055]=0;o[6056]=0;o[6057]=0;W(24196);o[6059]=0;o[6060]=0;o[6058]=16468;o[6061]=0;o[6062]=0;o[6063]=0;o[6064]=0;o[6065]=0;o[6066]=0;W(24232);o[6068]=0;o[6069]=0;o[6067]=16468;o[6070]=0;o[6071]=0;o[6072]=0;o[6073]=0;o[6074]=0;o[6075]=0;W(24268);o[6077]=0;o[6078]=0;o[6076]=16468;o[6079]=0;o[6080]=0;o[6081]=0;o[6082]=0;o[6083]=0;o[6084]=0;W(24304);o[6086]=0;o[6087]=0;o[6085]=16468;o[6088]=0;o[6089]=0;o[6090]=0;o[6091]=0;o[6092]=0;o[6093]=0;W(24340);o[6095]=0;o[6096]=0;o[6094]=16468;o[6097]=0;o[6098]=0;o[6099]=0;o[6100]=0;o[6101]=0;o[6102]=0;W(24376);o[6104]=0;o[6105]=0;o[6103]=16468;o[6106]=0;o[6107]=0;o[6108]=0;o[6109]=0;o[6110]=0;o[6111]=0;W(24412);o[6113]=0;o[6114]=0;o[6112]=16468;o[6115]=0;o[6116]=0;o[6117]=0;o[6118]=0;o[6119]=0;o[6120]=0;W(24448);o[6122]=0;o[6123]=0;o[6121]=16468;o[6124]=0;o[6125]=0;o[6126]=0;o[6127]=0;o[6128]=0;o[6129]=0;W(24484);o[6131]=0;o[6132]=0;o[6130]=16468;o[6133]=0;o[6134]=0;o[6135]=0;o[6136]=0;o[6137]=0;o[6138]=0;W(24520);o[6140]=0;o[6141]=0;o[6139]=16468;o[6142]=0;o[6143]=0;o[6144]=0;o[6145]=0;o[6146]=0;o[6147]=0;W(24556);o[6149]=0;o[6150]=0;o[6148]=16468;o[6151]=0;o[6152]=0;o[6153]=0;o[6154]=0;o[6155]=0;o[6156]=0;W(24592);o[6158]=0;o[6159]=0;o[6157]=16468;o[6160]=0;o[6161]=0;o[6162]=0;o[6163]=0;o[6164]=0;o[6165]=0;W(24628);o[6167]=0;o[6168]=0;o[6166]=16468;o[6169]=0;o[6170]=0;o[6171]=0;o[6172]=0;o[6173]=0;o[6174]=0;W(24664);o[6176]=0;o[6177]=0;o[6175]=16468;o[6178]=0;o[6179]=0;o[6180]=0;o[6181]=0;o[6182]=0;o[6183]=0;W(24700);o[6185]=0;o[6186]=0;o[6184]=16468;o[6187]=0;o[6188]=0;o[6189]=0;o[6190]=0;o[6191]=0;o[6192]=0;W(24736);o[6194]=0;o[6195]=0;o[6193]=16468;o[6196]=0;o[6197]=0;o[6198]=0;o[6199]=0;o[6200]=0;o[6201]=0;W(24772);o[6203]=0;o[6204]=0;o[6202]=16468;o[6205]=0;o[6206]=0;o[6207]=0;o[6208]=0;o[6209]=0;o[6210]=0;W(24808);o[6212]=0;o[6213]=0;o[6211]=16468;o[6214]=0;o[6215]=0;o[6216]=0;o[6217]=0;o[6218]=0;o[6219]=0;W(24844);o[6221]=0;o[6222]=0;o[6220]=16468;o[6223]=0;o[6224]=0;o[6225]=0;o[6226]=0;o[6227]=0;o[6228]=0;W(24880);o[6230]=0;o[6231]=0;o[6229]=16468;o[6232]=0;o[6233]=0;o[6234]=0;o[6235]=0;o[6236]=0;o[6237]=0;W(24916);o[6239]=0;o[6240]=0;o[6238]=16468;o[6241]=0;o[6242]=0;o[6243]=0;o[6244]=0;o[6245]=0;o[6246]=0;W(24952);o[6248]=0;o[6249]=0;o[6247]=16468;o[6250]=0;o[6251]=0;o[6252]=0;o[6253]=0;o[6254]=0;o[6255]=0;W(24988);}function pu(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0,r=0,s=0,t=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,M=0;d=K-128|0;K=d;a:{if(!o[c+4>>2]){break a}if(!o[b+4>>2]){a=o[c+4>>2];o[b>>2]=o[c>>2];o[b+4>>2]=a;a=o[c+12>>2];o[b+8>>2]=o[c+8>>2];o[b+12>>2]=a;break a}o[a+100>>2]=o[a+100>>2]+ -1;o[d+124>>2]=0;o[d+120>>2]=0;b:{if(qu(b,c,d+124|0,d+120|0)){y=o[d+124>>2];k=o[y+92>>2];s=o[d+120>>2];l=o[s+92>>2];t=o[y+96>>2];q=o[s+96>>2];r=o[y+88>>2];D=o[s+88>>2];o[d+92>>2]=-1;c=q-t|0;o[d+88>>2]=c;g=l-k|0;o[d+84>>2]=g;i=D-r|0;o[d+80>>2]=i;b=o[y+8>>2];o[d+32>>2]=0;e=c;B=c>>31;h=g;n=g>>31;w=Qw(c,B,g,n);G=L;c=0-i|0;f=c;j=c>>31;c=Qw(c,j,i,i>>31);g=L;C=Qw(h,n,h,n);i=c-C|0;C=g-(L+(c>>>0<C>>>0)|0)|0;c=Qw(e,B,f,j);B=0-c|0;H=0-(L+(0<c>>>0)|0)|0;if(b){c=b;while(1){e=o[c+12>>2];g=o[e+92>>2]-k|0;v=g;g=g>>31;p=Qw(v,g,f,j);z=L;I=p;p=o[e+88>>2]-r|0;J=p;p=p>>31;M=Qw(h,n,J,p);c:{if((I|0)!=(0-M|0)|(0-(L+(0<M>>>0)|0)|0)!=(z|0)){break c}g=Qw(w,G,v,g);z=L;p=Qw(J,p,B,H);v=p+g|0;g=L+z|0;g=v>>>0<p>>>0?g+1|0:g;e=o[e+96>>2]-t|0;p=Qw(i,C,e,e>>31);v=p+v|0;e=L+g|0;e=v>>>0<p>>>0?e+1|0:e;if((e|0)<0?1:(e|0)<=0?v>>>0>=1?0:1:0){break c}if(m){o[d+64>>2]=-1;o[d+68>>2]=-1;o[d+56>>2]=0;o[d+60>>2]=0;if((Gd(m,c,d+80|0,d+56|0)|0)!=1){break c}}m=c;}c=o[c>>2];if((b|0)!=(c|0)){continue}break}o[d+32>>2]=m;}g=o[s+8>>2];b=0;o[d+8>>2]=0;if(g){c=g;while(1){k=o[c+12>>2];e=o[k+92>>2]-l|0;t=e;e=e>>31;r=Qw(t,e,f,j);v=L;I=r;r=o[k+88>>2]-D|0;p=r;r=p>>31;z=Qw(h,n,p,r);d:{if((I|0)!=(0-z|0)|(0-(L+(0<z>>>0)|0)|0)!=(v|0)){break d}e=Qw(w,G,t,e);v=L;r=Qw(p,r,B,H);t=r+e|0;e=L+v|0;e=t>>>0<r>>>0?e+1|0:e;p=t;k=o[k+96>>2]-q|0;t=Qw(i,C,k,k>>31);k=p+t|0;e=L+e|0;e=k>>>0<t>>>0?e+1|0:e;if((e|0)<0?1:(e|0)<=0?k>>>0>=1?0:1:0){break d}if(b){o[d+64>>2]=-1;o[d+68>>2]=-1;o[d+56>>2]=0;o[d+60>>2]=0;if((Gd(b,c,d+80|0,d+56|0)|0)!=2){break d}}b=c;}c=o[c>>2];if((g|0)!=(c|0)){continue}break}o[d+8>>2]=b;}e:{if(!(b|m)){break e}Ug(a,y,s,d+32|0,d+8|0);b=o[d+32>>2];if(b){y=o[b+12>>2];o[d+124>>2]=y;}b=o[d+8>>2];if(!b){break e}s=o[b+12>>2];o[d+120>>2]=s;}r=o[s+96>>2]+1|0;D=o[s+88>>2];t=o[s+92>>2];break b}s=o[d+120>>2];D=o[s+88>>2]+1|0;r=o[s+96>>2];y=o[d+124>>2];t=o[s+92>>2];}c=s;b=y;n=0;m=0;G=1;j=0;g=0;while(1){e=o[c+96>>2];f=o[b+96>>2];k=o[b+92>>2];h=o[c+92>>2];q=o[b+88>>2];i=o[c+88>>2];o[d+116>>2]=-1;h=h-k|0;o[d+108>>2]=h;e=e-f|0;o[d+112>>2]=e;i=i-q|0;o[d+104>>2]=i;k=t-k|0;f=r-f|0;w=u(k,e)-u(f,h)|0;l=w>>31;C=w;o[d+80>>2]=w;o[d+84>>2]=l;p=u(f,i);f=D-q|0;w=p-u(f,e)|0;q=w>>31;B=w;o[d+88>>2]=w;o[d+92>>2]=q;f=u(f,h)-u(i,k)|0;w=f>>31;H=f;o[d+96>>2]=f;o[d+100>>2]=w;f=i;v=f>>31;i=Qw(B,q,f,v);p=L;k=h;z=h>>31;h=Qw(C,l,h,z);o[d+72>>2]=i-h;o[d+76>>2]=p-(L+(i>>>0<h>>>0)|0);h=e;i=e>>31;e=Qw(C,l,e,i);l=L;f=Qw(H,w,f,v);o[d+64>>2]=e-f;o[d+68>>2]=l-(L+(e>>>0<f>>>0)|0);e=Qw(H,w,k,z);f=L;h=Qw(h,i,B,q);o[d+56>>2]=e-h;o[d+60>>2]=f-(L+(e>>>0<h>>>0)|0);o[d+48>>2]=0;o[d+40>>2]=0;o[d+44>>2]=0;o[d+32>>2]=0;o[d+36>>2]=0;q=Tg(a,0,b,d+104|0,d+80|0,d+56|0,d+32|0);o[d+24>>2]=0;o[d+16>>2]=0;o[d+20>>2]=0;o[d+8>>2]=0;o[d+12>>2]=0;l=Tg(a,1,c,d+104|0,d+80|0,d+56|0,d+8|0);f:{if(!(l|q)){h=Id(a,b,c);o[h+4>>2]=h;o[h>>2]=h;o[b+8>>2]=h;b=o[h+8>>2];o[b+4>>2]=b;o[b>>2]=b;o[c+8>>2]=b;c=0;break f}k=q?-1:1;if(!(!q|!l)){k=ib(d+32|0,d+8|0);}g:{h:{if(G){break h}i:{if((k|0)>=0){if(o[d+24>>2]>-1){break h}if(!(o[d+16>>2]|o[d+20>>2])){break i}break h}if(o[d+40>>2]|o[d+44>>2]|o[d+48>>2]>-1){break h}}f=n;h=m;i=j;e=g;break g}i=Id(a,b,c);e=i;if(j){o[j+4>>2]=i;e=g;}o[i>>2]=j;f=o[i+8>>2];h=f;if(n){o[n>>2]=f;h=m;}o[f+4>>2]=n;}o[d+4>>2]=q;o[d>>2]=l;n=l;if(!k){Ug(a,o[d+124>>2],o[d+120>>2],d+4|0,d);n=o[d>>2];}b=f;j:{if((k|0)<0){break j}b=f;if(!n){break j}k:{l:{m:{if(x){c=o[x>>2];if((l|0)!=(c|0)){while(1){j=o[c+8>>2];g=0;b=0;m=o[c>>2];if((m|0)!=(c|0)){o[m+4>>2]=o[c+4>>2];o[o[c+4>>2]>>2]=m;b=m;}o[o[j+12>>2]+8>>2]=b;b=o[j>>2];if((b|0)!=(j|0)){o[b+4>>2]=o[j+4>>2];o[o[j+4>>2]>>2]=b;g=b;}o[o[c+12>>2]+8>>2]=g;o[c+12>>2]=0;o[c+16>>2]=0;o[c+4>>2]=0;o[c+8>>2]=0;o[c>>2]=o[a+56>>2];o[a+56>>2]=c;o[j+12>>2]=0;o[j+16>>2]=0;o[j+4>>2]=0;o[j+8>>2]=0;o[j>>2]=o[a+56>>2];o[a+56>>2]=j;o[a+116>>2]=o[a+116>>2]+ -1;c=m;if((l|0)!=(c|0)){continue}break}}if(f){break m}break l}if(!f){break l}x=o[l+4>>2];E=h;}o[x>>2]=h;o[h+4>>2]=x;o[f>>2]=l;o[l+4>>2]=f;h=0;n=o[d>>2];break k}E=x?E:l;}b=o[d+120>>2];r=o[b+96>>2];t=o[b+92>>2];D=o[b+88>>2];o[d+120>>2]=o[n+12>>2];x=o[n+8>>2];b=0;}n=b;n:{o:{if((k|0)<=0){f=o[d+4>>2];if(f){break o}}b=o[d+124>>2];break n}p:{q:{r:{s:{if(A){b=o[A+4>>2];if((q|0)!=(b|0)){while(1){m=b+4|0;l=o[b+8>>2];j=o[b+4>>2];c=0;k=0;g=o[b>>2];if((g|0)!=(b|0)){o[g+4>>2]=j;o[o[m>>2]>>2]=g;k=g;}o[o[l+12>>2]+8>>2]=k;g=o[l>>2];if((g|0)!=(l|0)){o[g+4>>2]=o[l+4>>2];o[o[l+4>>2]>>2]=g;c=g;}o[o[b+12>>2]+8>>2]=c;c=m;o[c+8>>2]=0;o[c+12>>2]=0;o[c>>2]=0;o[c+4>>2]=0;o[b>>2]=o[a+56>>2];o[a+56>>2]=b;o[l+12>>2]=0;o[l+16>>2]=0;o[l+4>>2]=0;o[l+8>>2]=0;o[l>>2]=o[a+56>>2];o[a+56>>2]=l;o[a+116>>2]=o[a+116>>2]+ -1;b=j;if((q|0)!=(b|0)){continue}break}}if(!i){break s}o[e>>2]=A;b=A+4|0;break q}if(i){break r}}F=A?F:q;break p}b=o[q>>2];o[e>>2]=b;F=e;b=b+4|0;}o[b>>2]=e;o[q>>2]=i;o[i+4>>2]=q;e=0;f=o[d+4>>2];}b=o[d+124>>2];r=o[b+96>>2];t=o[b+92>>2];D=o[b+88>>2];b=o[f+12>>2];o[d+124>>2]=b;A=o[f+8>>2];i=0;}c=1;t:{if(!((b|0)!=(y|0)|o[d+120>>2]!=(s|0))){u:{if(!A){o[e>>2]=i;o[i+4>>2]=e;o[o[d+124>>2]+8>>2]=i;break u}b=o[A+4>>2];if((F|0)!=(b|0)){while(1){m=b+4|0;j=o[b+8>>2];f=o[b+4>>2];c=0;k=0;g=o[b>>2];if((g|0)!=(b|0)){o[g+4>>2]=f;o[o[m>>2]>>2]=g;k=g;}o[o[j+12>>2]+8>>2]=k;g=o[j>>2];if((g|0)!=(j|0)){o[g+4>>2]=o[j+4>>2];o[o[j+4>>2]>>2]=g;c=g;}o[o[b+12>>2]+8>>2]=c;c=m;o[c+8>>2]=0;o[c+12>>2]=0;o[c>>2]=0;o[c+4>>2]=0;o[b>>2]=o[a+56>>2];o[a+56>>2]=b;o[j+12>>2]=0;o[j+16>>2]=0;o[j+4>>2]=0;o[j+8>>2]=0;o[j>>2]=o[a+56>>2];o[a+56>>2]=j;o[a+116>>2]=o[a+116>>2]+ -1;b=f;if((F|0)!=(b|0)){continue}break}}if(!i){break u}o[e>>2]=A;o[A+4>>2]=e;o[F>>2]=i;o[i+4>>2]=F;}if(!x){o[n>>2]=h;o[h+4>>2]=n;o[o[d+120>>2]+8>>2]=n;x=0;m=h;j=i;g=e;c=0;break f}c=o[x>>2];if((E|0)!=(c|0)){while(1){f=o[c+8>>2];g=0;b=0;m=o[c>>2];if((m|0)!=(c|0)){o[m+4>>2]=o[c+4>>2];o[o[c+4>>2]>>2]=m;b=m;}o[o[f+12>>2]+8>>2]=b;b=o[f>>2];if((b|0)!=(f|0)){o[b+4>>2]=o[f+4>>2];o[o[f+4>>2]>>2]=b;g=b;}o[o[c+12>>2]+8>>2]=g;o[c+12>>2]=0;o[c+16>>2]=0;o[c+4>>2]=0;o[c+8>>2]=0;o[c>>2]=o[a+56>>2];o[a+56>>2]=c;o[f+12>>2]=0;o[f+16>>2]=0;o[f+4>>2]=0;o[f+8>>2]=0;o[f>>2]=o[a+56>>2];o[a+56>>2]=f;o[a+116>>2]=o[a+116>>2]+ -1;c=m;if((E|0)!=(c|0)){continue}break}}c=0;v:{if(!n){n=0;break v}o[x>>2]=h;o[h+4>>2]=x;o[n>>2]=E;o[E+4>>2]=n;}break t}G=0;}m=h;j=i;g=e;}if(!c){break a}b=o[d+124>>2];c=o[d+120>>2];continue}}K=d+128|0;}function tm(a,b,c){var d=v(0),e=0,f=v(0),g=v(0),h=0,i=v(0),j=0,k=0,n=0,q=v(0),r=v(0),t=0,x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),D=0,E=v(0),F=v(0),G=v(0),H=0,I=v(0),J=0,L=0,M=0,N=0,O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=0,V=0,W=0,X=v(0),Y=0,Z=v(0),_=v(0),$=v(0),aa=v(0),ba=v(0),ca=v(0),da=0,ea=0;e=K-80|0;K=e;j=o[b+840>>2];k=o[b+836>>2];J=Ra(a,k,s[c+12>>2]);L=Ra(a,j,s[c+12>>2]);n=o[a+16>>2];t=n+u(J,244)|0;d=s[t+128>>2];g=v(d*d);d=s[t+132>>2];g=v(g+v(d*d));d=s[t+136>>2];a:{if(!!(v(g+v(d*d))<v(1.4210854715202004e-14))){t=n+u(L,244)|0;d=s[t+128>>2];g=v(d*d);d=s[t+132>>2];g=v(g+v(d*d));d=s[t+136>>2];if(v(g+v(d*d))<v(1.4210854715202004e-14)){break a}}D=o[b+844>>2];if((D|0)<1){break a}M=n+u(L,244)|0;da=M;N=n+u(J,244)|0;ea=N;while(1){h=u(Y,208)+b|0;if(!!(s[h+84>>2]<=s[b+852>>2])){V=h+4|0;t=o[a+28>>2];D=t;b:{if((t|0)!=o[a+32>>2]){break b}D=t;H=t?t<<1:1;if((t|0)>=(H|0)){break b}D=0;n=t;U=0;if(H){o[6257]=o[6257]+1;U=l[o[4968]](u(H,152),16)|0;n=o[a+28>>2];}if((n|0)>=1){while(1){W=u(D,152);ra(W+U|0,o[a+36>>2]+W|0,152);D=D+1|0;if((n|0)!=(D|0)){continue}break}}n=o[a+36>>2];if(n){if(p[a+40|0]){if(n){o[6258]=o[6258]+1;l[o[4969]](n);}}o[a+36>>2]=0;}o[a+36>>2]=U;m[a+40|0]=1;o[a+32>>2]=H;D=o[a+28>>2];}o[a+28>>2]=D+1;U=o[a+36>>2]+u(t,152)|0;o[U+148>>2]=L;o[U+144>>2]=J;o[U+132>>2]=V;O=s[h+52>>2];B=s[h+56>>2];q=s[h+60>>2];i=s[k+52>>2];f=s[k+56>>2];d=s[k+60>>2];o[e+76>>2]=0;I=v(q-d);s[e+72>>2]=I;y=v(B-f);s[e+68>>2]=y;r=v(O-i);s[e+64>>2]=r;O=s[h+36>>2];B=s[h+40>>2];q=s[h+44>>2];i=s[j+52>>2];f=s[j+56>>2];d=s[j+60>>2];o[e+60>>2]=0;g=v(q-d);s[e+56>>2]=g;B=v(B-f);s[e+52>>2]=B;q=v(O-i);s[e+48>>2]=q;Z=v(0);_=v(0);$=v(0);aa=v(0);if(o[N+240>>2]){i=v(s[N+192>>2]+s[N+224>>2]);f=v(s[N+196>>2]+s[N+228>>2]);aa=v(v(s[N+184>>2]+s[N+216>>2])+v(v(y*i)-v(r*f)));d=v(s[N+200>>2]+s[ea+232>>2]);$=v(v(s[N+180>>2]+s[N+212>>2])+v(v(r*d)-v(I*i)));_=v(v(s[N+176>>2]+s[N+208>>2])+v(v(I*f)-v(y*d)));}ba=v(0);ca=v(0);if(o[M+240>>2]){i=v(s[M+192>>2]+s[M+224>>2]);f=v(s[M+196>>2]+s[M+228>>2]);ca=v(v(s[M+184>>2]+s[M+216>>2])+v(v(B*i)-v(q*f)));d=v(s[M+200>>2]+s[da+232>>2]);ba=v(v(s[M+180>>2]+s[M+212>>2])+v(v(q*d)-v(g*i)));Z=v(v(s[M+176>>2]+s[M+208>>2])+v(v(g*f)-v(B*d)));}O=s[h+76>>2];W=h+68|0;B=s[W>>2];q=s[h+72>>2];vm(a,U,J,L,V,c,e+44|0,e- -64|0,e+48|0);o[U+140>>2]=o[a+68>>2];c:{if(!(s[h+92>>2]>v(0))){break c}ad(a,W,J,L,t,s[h+96>>2]);g=s[h+76>>2];d:{if(!!(v(w(g))>v(.7071067690849304))){d=s[h+72>>2];o[e+24>>2]=0;A=d;d=v(v(g*g)+v(d*d));f=v(v(1)/v(C(d)));E=v(A*f);s[e+32>>2]=E;x=v(f*v(-g));s[e+28>>2]=x;F=v(d*f);s[e+8>>2]=F;d=s[W>>2];G=v(E*v(-d));s[e+12>>2]=G;z=v(0);A=v(d*x);break d}d=s[W>>2];i=s[h+72>>2];o[e+32>>2]=0;A=d;d=v(v(d*d)+v(i*i));f=v(v(1)/v(C(d)));x=v(A*f);s[e+28>>2]=x;z=v(f*v(-i));s[e+24>>2]=z;G=v(g*z);s[e+12>>2]=G;F=v(x*v(-g));s[e+8>>2]=F;E=v(0);A=v(d*f);}d=v(v(1)/v(C(v(v(v(z*z)+v(x*x))+v(E*E)))));E=v(E*d);s[e+32>>2]=E;x=v(x*d);s[e+28>>2]=x;z=v(z*d);s[e+24>>2]=z;d=v(v(1)/v(C(v(v(A*A)+v(v(F*F)+v(G*G))))));A=v(A*d);s[e+16>>2]=A;G=v(G*d);s[e+12>>2]=G;F=v(F*d);s[e+8>>2]=F;D=o[k+180>>2]&2;if(D){i=s[k+172>>2];P=s[k+44>>2];Q=s[k+12>>2];R=s[k+28>>2];f=s[k+164>>2];g=s[k+36>>2];S=s[k+4>>2];T=s[k+20>>2];d=s[k+168>>2];I=s[k+40>>2];y=s[k+8>>2];r=s[k+24>>2];o[e+36>>2]=0;X=g;g=v(f*v(v(v(z*S)+v(x*T))+v(E*g)));f=v(d*v(v(v(z*y)+v(x*r))+v(E*I)));d=v(i*v(v(v(z*Q)+v(x*R))+v(E*P)));E=v(v(v(X*g)+v(I*f))+v(P*d));s[e+32>>2]=E;x=v(v(v(T*g)+v(r*f))+v(R*d));s[e+28>>2]=x;z=v(v(v(S*g)+v(y*f))+v(Q*d));s[e+24>>2]=z;}n=o[j+180>>2]&2;if(n){i=s[j+172>>2];P=s[j+44>>2];Q=s[j+12>>2];R=s[j+28>>2];f=s[j+164>>2];g=s[j+36>>2];S=s[j+4>>2];T=s[j+20>>2];d=s[j+168>>2];I=s[j+40>>2];y=s[j+8>>2];r=s[j+24>>2];o[e+36>>2]=0;X=g;g=v(f*v(v(v(S*z)+v(T*x))+v(g*E)));f=v(d*v(v(v(z*y)+v(x*r))+v(E*I)));d=v(i*v(v(v(z*Q)+v(x*R))+v(E*P)));E=v(v(v(X*g)+v(I*f))+v(P*d));s[e+32>>2]=E;x=v(v(v(T*g)+v(r*f))+v(R*d));s[e+28>>2]=x;z=v(v(v(S*g)+v(y*f))+v(Q*d));s[e+24>>2]=z;}if(D){i=s[k+172>>2];P=s[k+44>>2];Q=s[k+12>>2];R=s[k+28>>2];f=s[k+164>>2];g=s[k+36>>2];S=s[k+4>>2];T=s[k+20>>2];d=s[k+168>>2];I=s[k+40>>2];y=s[k+8>>2];r=s[k+24>>2];o[e+20>>2]=0;X=g;g=v(f*v(v(v(F*S)+v(G*T))+v(A*g)));f=v(d*v(v(v(F*y)+v(G*r))+v(A*I)));d=v(i*v(v(v(F*Q)+v(G*R))+v(A*P)));A=v(v(v(X*g)+v(I*f))+v(P*d));s[e+16>>2]=A;G=v(v(v(T*g)+v(r*f))+v(R*d));s[e+12>>2]=G;F=v(v(v(S*g)+v(y*f))+v(Q*d));s[e+8>>2]=F;}if(n){i=s[j+172>>2];P=s[j+44>>2];Q=s[j+12>>2];R=s[j+28>>2];f=s[j+164>>2];g=s[j+36>>2];S=s[j+4>>2];T=s[j+20>>2];d=s[j+168>>2];I=s[j+40>>2];y=s[j+8>>2];r=s[j+24>>2];o[e+20>>2]=0;X=g;g=v(f*v(v(v(S*F)+v(T*G))+v(g*A)));f=v(d*v(v(v(F*y)+v(G*r))+v(A*I)));d=v(i*v(v(v(F*Q)+v(G*R))+v(A*P)));A=v(v(v(X*g)+v(I*f))+v(P*d));s[e+16>>2]=A;G=v(v(v(T*g)+v(r*f))+v(R*d));s[e+12>>2]=G;F=v(v(v(S*g)+v(y*f))+v(Q*d));s[e+8>>2]=F;}if(!!(+v(C(v(v(v(z*z)+v(x*x))+v(E*E))))>.001)){ad(a,e+24|0,J,L,t,s[h+92>>2]);}if(!(+v(C(v(v(v(F*F)+v(G*G))+v(A*A))))>.001)){break c}ad(a,e+8|0,J,L,t,s[h+92>>2]);}e:{if(!(m[h+132|0]&1?p[c+72|0]&32:0)){g=s[W>>2];y=s[h+72>>2];r=s[h+76>>2];o[h+184>>2]=0;i=v(_-Z);f=v($-ba);d=v(aa-ca);O=v(v(v(i*B)+v(f*q))+v(d*O));B=v(d-v(r*O));s[h+180>>2]=B;q=v(f-v(O*y));s[h+176>>2]=q;H=h+172|0;f=v(i-v(O*g));s[H>>2]=f;f:{if(p[c+72|0]&64){break f}d=v(v(v(f*f)+v(q*q))+v(B*B));if(!(d>v(1.1920928955078125e-7))){break f}d=v(v(1)/v(C(d)));s[H>>2]=f*d;s[h+176>>2]=q*d;s[h+180>>2]=B*d;La(k,H);La(j,H);d=s[e+44>>2];Xa(a,H,J,L,t,V,e- -64|0,e+48|0,d,c,v(0),v(0));if(!(p[c+72|0]&16)){break e}r=s[h+176>>2];g=s[h+72>>2];O=s[W>>2];i=s[h+180>>2];B=s[H>>2];f=s[h+76>>2];o[h+200>>2]=0;q=v(v(r*f)-v(i*g));i=v(v(i*O)-v(f*B));f=v(v(g*B)-v(r*O));B=v(v(1)/v(C(v(v(v(q*q)+v(i*i))+v(f*f)))));s[h+196>>2]=f*B;s[h+192>>2]=i*B;n=h+188|0;s[n>>2]=q*B;La(k,n);La(j,n);Xa(a,n,J,L,t,V,e- -64|0,e+48|0,d,c,v(0),v(0));break e}D=h+188|0;n=D;g:{if(!!(v(w(r))>v(.7071067690849304))){o[H>>2]=0;i=v(v(y*y)+v(r*r));q=v(v(1)/v(C(i)));f=v(q*v(-r));s[h+176>>2]=f;d=v(y*q);s[h+180>>2]=d;x=v(g*f);z=v(d*v(-g));g=v(i*q);break g}i=v(v(g*g)+v(y*y));q=v(v(1)/v(C(i)));f=v(q*v(-y));s[H>>2]=f;d=v(g*q);s[h+176>>2]=d;o[h+180>>2]=0;x=v(i*q);z=v(r*f);g=v(d*v(-r));}s[n>>2]=g;s[h+196>>2]=x;s[h+192>>2]=z;La(k,H);La(j,H);d=s[e+44>>2];Xa(a,H,J,L,t,V,e- -64|0,e+48|0,d,c,v(0),v(0));n=o[c+72>>2];if(n&16){La(k,D);La(j,D);Xa(a,D,J,L,t,V,e- -64|0,e+48|0,d,c,v(0),v(0));n=o[c+72>>2];}if((n&80)!=80){break e}o[h+132>>2]=o[h+132>>2]|1;break e}d=s[e+44>>2];Xa(a,h+172|0,J,L,t,V,e- -64|0,e+48|0,d,c,s[h+148>>2],s[h+164>>2]);if(!(p[c+72|0]&16)){break e}Xa(a,h+188|0,J,L,t,V,e- -64|0,e+48|0,d,c,s[h+152>>2],s[h+164>>2]);}um(a,U,J,L,V,c);D=o[b+844>>2];}Y=Y+1|0;if((Y|0)<(D|0)){continue}break}}K=e+80|0;}function Om(a){a=a|0;var b=0,c=v(0),d=0,e=v(0),f=v(0),g=v(0),h=0,i=v(0),j=v(0),k=v(0),l=v(0),m=0,n=v(0),q=v(0),r=v(0),t=v(0),x=v(0),y=v(0),z=v(0),A=0,B=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0);d=K-176|0;K=d;if(p[a+738|0]){o[a+744>>2]=0;o[a+36>>2]=0;a:{if(p[a+736|0]){break a}B=s[a+664>>2];m=o[a+32>>2];j=s[a+668>>2];i=s[a+672>>2];q=v(v(v(v(B*s[m+4>>2])+v(j*s[m+8>>2]))+v(i*s[m+12>>2]))+s[m+52>>2]);f=s[a+600>>2];b=o[a+28>>2];g=s[a+604>>2];c=s[a+608>>2];r=v(v(v(v(f*s[b+4>>2])+v(g*s[b+8>>2]))+v(c*s[b+12>>2]))+s[b+52>>2]);l=v(q-r);n=v(v(v(v(B*s[m+20>>2])+v(j*s[m+24>>2]))+v(i*s[m+28>>2]))+s[m+56>>2]);k=v(v(v(v(f*s[b+20>>2])+v(g*s[b+24>>2]))+v(c*s[b+28>>2]))+s[b+56>>2]);e=v(n-k);i=v(v(v(v(B*s[m+36>>2])+v(j*s[m+40>>2]))+v(i*s[m+44>>2]))+s[m+60>>2]);f=v(v(v(v(f*s[b+36>>2])+v(g*s[b+40>>2]))+v(c*s[b+44>>2]))+s[b+60>>2]);g=v(i-f);c=v(v(v(l*l)+v(e*e))+v(g*g));b:{if(!!(c>v(1.1920928955078125e-7))){o[d+140>>2]=0;c=v(v(1)/v(C(c)));j=v(g*c);s[d+136>>2]=j;g=v(e*c);s[d+132>>2]=g;c=v(l*c);s[d+128>>2]=c;break b}o[d+136>>2]=0;o[d+140>>2]=0;o[d+128>>2]=1065353216;o[d+132>>2]=0;c=v(1);g=v(0);j=v(0);}c:{if(!!(v(w(j))>v(.7071067690849304))){e=v(v(j*j)+v(g*g));l=v(v(1)/v(C(e)));x=v(e*l);t=v(l*v(-j));z=v(c*t);j=v(g*l);g=v(j*v(-c));e=v(0);break c}e=v(v(c*c)+v(g*g));l=v(v(1)/v(C(e)));z=v(e*l);e=v(l*v(-g));g=v(j*e);t=v(c*l);x=v(t*v(-j));j=v(0);}s[d+168>>2]=z;s[d+164>>2]=g;s[d+152>>2]=j;s[d+148>>2]=t;s[d+160>>2]=x;s[d+144>>2]=e;while(1){A=o[a+28>>2];o[d+80>>2]=o[A+4>>2];o[d+84>>2]=o[A+20>>2];b=o[A+36>>2];o[d+92>>2]=0;o[d+88>>2]=b;o[d+96>>2]=o[A+8>>2];o[d+100>>2]=o[A+24>>2];b=o[A+40>>2];o[d+108>>2]=0;o[d+104>>2]=b;o[d+112>>2]=o[A+12>>2];o[d+116>>2]=o[A+28>>2];b=o[A+44>>2];o[d+124>>2]=0;o[d+120>>2]=b;o[d+32>>2]=o[m+4>>2];o[d+36>>2]=o[m+20>>2];b=o[m+36>>2];o[d+44>>2]=0;o[d+40>>2]=b;o[d+48>>2]=o[m+8>>2];o[d+52>>2]=o[m+24>>2];b=o[m+40>>2];o[d+60>>2]=0;o[d+56>>2]=b;o[d+64>>2]=o[m+12>>2];o[d+68>>2]=o[m+28>>2];b=o[m+44>>2];o[d+76>>2]=0;o[d+72>>2]=b;e=s[A+52>>2];g=s[A+56>>2];c=s[A+60>>2];o[d+28>>2]=0;s[d+24>>2]=f-c;s[d+20>>2]=k-g;s[d+16>>2]=r-e;e=s[m+52>>2];g=s[m+56>>2];c=s[m+60>>2];o[d+12>>2]=0;s[d+8>>2]=i-c;s[d+4>>2]=n-g;s[d>>2]=q-e;tf((u(h,84)+a|0)+48|0,d+80|0,d+32|0,d+16|0,d,(d+128|0)+(h<<4)|0,A+456|0,s[A+404>>2],m+456|0,s[m+404>>2]);h=h+1|0;if((h|0)==3){break a}m=o[a+32>>2];continue}}g=s[a+576>>2];c=s[a+560>>2];H=s[a+592>>2];d:{if(!!(v(w(H))>v(.7071067690849304))){e=v(v(H*H)+v(g*g));f=v(v(1)/v(C(e)));t=v(e*f);x=v(f*v(-H));z=v(x*c);D=v(f*g);e=v(D*v(-c));break d}e=v(v(c*c)+v(g*g));f=v(v(1)/v(C(e)));z=v(e*f);x=v(f*c);t=v(x*v(-H));E=v(f*v(-g));e=v(H*E);}h=o[a+32>>2];B=s[h+36>>2];j=s[h+20>>2];l=s[h+40>>2];q=s[h+24>>2];r=s[h+8>>2];n=s[h+44>>2];k=s[h+28>>2];i=s[h+12>>2];b=o[a+28>>2];M=s[b+44>>2];N=s[b+36>>2];O=s[b+40>>2];P=s[b+12>>2];Q=s[b+8>>2];R=s[b+28>>2];S=s[b+20>>2];T=s[b+24>>2];f=s[h+4>>2];U=s[b+4>>2];o[a+344>>2]=0;o[a+328>>2]=0;o[a+308>>2]=0;o[a+312>>2]=0;o[a+300>>2]=0;o[a+304>>2]=0;F=v(v(v(E*U)+v(x*Q))+v(D*P));y=v(v(v(E*S)+v(x*T))+v(D*R));G=v(v(v(E*N)+v(x*O))+v(D*M));I=v(v(v(P*F)+v(R*y))+v(M*G));s[a+324>>2]=I;x=v(v(v(F*Q)+v(y*T))+v(G*O));s[a+320>>2]=x;E=v(v(v(F*U)+v(y*S))+v(G*N));s[a+316>>2]=E;J=k;k=v(-y);D=v(v(v(J*k)-v(F*i))-v(G*n));s[a+340>>2]=D;y=v(v(v(q*k)-v(F*r))-v(G*l));s[a+336>>2]=y;j=v(v(v(j*k)-v(F*f))-v(G*B));s[a+332>>2]=j;k=s[b+460>>2];i=s[b+464>>2];f=s[b+456>>2];o[a+360>>2]=0;l=v(I*i);s[a+356>>2]=l;q=v(x*k);s[a+352>>2]=q;r=v(E*f);s[a+348>>2]=r;n=s[h+460>>2];i=s[h+464>>2];f=s[h+456>>2];o[a+376>>2]=0;k=v(D*i);s[a+372>>2]=k;i=v(y*n);s[a+368>>2]=i;f=v(j*f);s[a+364>>2]=f;s[a+380>>2]=v(v(v(E*r)+v(x*q))+v(I*l))+v(v(v(j*f)+v(y*i))+v(D*k));L=s[b+36>>2];W=s[b+20>>2];F=s[b+40>>2];G=s[b+8>>2];I=s[b+24>>2];x=s[b+44>>2];E=s[b+12>>2];D=s[b+28>>2];y=s[h+36>>2];B=s[h+20>>2];j=s[h+40>>2];l=s[h+24>>2];q=s[h+8>>2];r=s[h+44>>2];n=s[h+28>>2];k=s[h+12>>2];i=s[b+4>>2];f=s[h+4>>2];o[a+428>>2]=0;o[a+412>>2]=0;o[a+392>>2]=0;o[a+396>>2]=0;o[a+384>>2]=0;o[a+388>>2]=0;J=n;V=v(v(v(t*S)+v(e*T))+v(z*R));n=v(-V);X=k;k=v(v(v(t*U)+v(e*Q))+v(z*P));e=v(v(v(t*N)+v(e*O))+v(z*M));t=v(v(v(J*n)-v(X*k))-v(r*e));s[a+424>>2]=t;z=v(v(v(l*n)-v(k*q))-v(e*j));s[a+420>>2]=z;y=v(v(v(B*n)-v(k*f))-v(e*y));s[a+416>>2]=y;B=v(v(v(k*E)+v(V*D))+v(e*x));s[a+408>>2]=B;j=v(v(v(k*G)+v(V*I))+v(e*F));s[a+404>>2]=j;l=v(v(v(k*i)+v(V*W))+v(e*L));s[a+400>>2]=l;i=s[b+460>>2];f=s[b+464>>2];e=s[b+456>>2];o[a+444>>2]=0;q=v(B*f);s[a+440>>2]=q;r=v(j*i);s[a+436>>2]=r;n=v(l*e);s[a+432>>2]=n;k=s[h+460>>2];f=s[h+464>>2];e=s[h+456>>2];o[a+460>>2]=0;i=v(t*f);s[a+456>>2]=i;f=v(z*k);s[a+452>>2]=f;e=v(y*e);s[a+448>>2]=e;s[a+464>>2]=v(v(v(l*n)+v(j*r))+v(B*q))+v(v(v(y*e)+v(z*f))+v(t*i));W=s[b+36>>2];F=s[b+20>>2];G=s[b+40>>2];I=s[b+8>>2];x=s[b+24>>2];E=s[b+44>>2];D=s[b+12>>2];y=s[b+28>>2];B=s[h+36>>2];j=s[h+20>>2];l=s[h+40>>2];q=s[h+24>>2];r=s[h+8>>2];n=s[h+44>>2];k=s[h+28>>2];i=s[h+12>>2];f=s[b+4>>2];e=s[h+4>>2];o[a+512>>2]=0;o[a+496>>2]=0;o[a+476>>2]=0;o[a+480>>2]=0;o[a+468>>2]=0;o[a+472>>2]=0;J=k;t=v(v(v(S*c)+v(T*g))+v(H*R));k=v(-t);X=i;i=v(v(v(U*c)+v(Q*g))+v(H*P));c=v(v(v(N*c)+v(O*g))+v(H*M));z=v(v(v(J*k)-v(X*i))-v(n*c));s[a+508>>2]=z;L=v(v(v(q*k)-v(i*r))-v(c*l));s[a+504>>2]=L;j=v(v(v(j*k)-v(i*e))-v(c*B));s[a+500>>2]=j;l=v(v(v(i*D)+v(t*y))+v(c*E));s[a+492>>2]=l;q=v(v(v(i*I)+v(t*x))+v(c*G));s[a+488>>2]=q;r=v(v(v(i*f)+v(t*F))+v(c*W));s[a+484>>2]=r;e=s[b+460>>2];g=s[b+464>>2];c=s[b+456>>2];o[a+528>>2]=0;n=v(l*g);s[a+524>>2]=n;k=v(q*e);s[a+520>>2]=k;i=v(r*c);s[a+516>>2]=i;f=s[h+460>>2];g=s[h+464>>2];c=s[h+456>>2];o[a+724>>2]=0;o[a+544>>2]=0;e=v(z*g);s[a+540>>2]=e;g=v(L*f);s[a+536>>2]=g;c=v(j*c);s[a+532>>2]=c;s[a+548>>2]=v(v(v(r*i)+v(q*k))+v(l*n))+v(v(v(j*c)+v(L*g))+v(z*e));c=bd(a,b+4|0,h+4|0);s[a+728>>2]=c;pf(a+688|0,c);h=a;e=s[a+560>>2];b=o[a+28>>2];g=s[a+576>>2];c=s[a+592>>2];i=v(v(v(e*s[b+4>>2])+v(g*s[b+8>>2]))+v(c*s[b+12>>2]));f=v(v(v(e*s[b+20>>2])+v(g*s[b+24>>2]))+v(c*s[b+28>>2]));c=v(v(v(e*s[b+36>>2])+v(g*s[b+40>>2]))+v(c*s[b+44>>2]));a=o[a+32>>2];s[h+720>>2]=v(1)/v(v(v(v(i*v(v(v(i*s[b+324>>2])+v(f*s[b+340>>2]))+v(c*s[b+356>>2])))+v(f*v(v(v(i*s[b+328>>2])+v(f*s[b+344>>2]))+v(c*s[b+360>>2]))))+v(c*v(v(v(i*s[b+332>>2])+v(f*s[b+348>>2]))+v(c*s[b+364>>2]))))+v(v(v(i*v(v(v(i*s[a+324>>2])+v(f*s[a+340>>2]))+v(c*s[a+356>>2])))+v(f*v(v(v(i*s[a+328>>2])+v(f*s[a+344>>2]))+v(c*s[a+360>>2]))))+v(c*v(v(v(i*s[a+332>>2])+v(f*s[a+348>>2]))+v(c*s[a+364>>2])))));}K=d+176|0;}function Gj(a,b,c,d,e,f){var g=0,h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),q=v(0),r=v(0),t=0,x=v(0),y=0,z=v(0),A=v(0),B=0,D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=0,M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0),Z=0,_=v(0),$=v(0),aa=v(0),ba=v(0),ca=v(0),da=v(0),ea=v(0);g=K-112|0;K=g;o[5641]=o[5641]+1;N=s[c+52>>2];j=s[c+20>>2];r=s[c+24>>2];O=s[d+52>>2];x=s[d+20>>2];z=s[d+24>>2];P=s[c+56>>2];i=s[c+36>>2];h=s[a+68>>2];n=s[c+40>>2];A=s[a+72>>2];G=s[d+56>>2];k=s[d+36>>2];H=s[b+68>>2];q=s[d+40>>2];I=s[b+72>>2];Q=s[c+48>>2];J=s[c+8>>2];R=s[c>>2];S=s[c+4>>2];X=s[d+48>>2];Y=s[d+8>>2];T=s[d>>2];U=s[d+4>>2];D=s[c+16>>2];V=s[d+16>>2];E=s[c+32>>2];F=s[a+64>>2];W=s[d+32>>2];m=s[b+64>>2];o[g+28>>2]=0;P=v(v(P+v(v(v(F*E)+v(h*i))+v(A*n)))-v(G+v(v(v(m*W)+v(H*k))+v(I*q))));s[g+24>>2]=P;N=v(v(N+v(v(v(F*D)+v(h*j))+v(A*r)))-v(O+v(v(v(m*V)+v(H*x))+v(I*z))));s[g+20>>2]=N;O=v(v(Q+v(v(v(F*R)+v(h*S))+v(A*J)))-v(X+v(v(v(m*T)+v(H*U))+v(I*Y))));s[g+16>>2]=O;h=v(3.4028234663852886e+38);a:{b:{c:{d:{e:{f:{L=o[a+28>>2];if((L|0)<1){break f}while(1){y=o[a+36>>2]+u(t,36)|0;A=s[y+28>>2];H=s[y+24>>2];I=s[y+20>>2];F=s[c>>2];m=s[c+4>>2];o[g+12>>2]=0;i=v(v(v(I*E)+v(H*i))+v(A*n));s[g+8>>2]=i;j=v(v(v(I*D)+v(H*j))+v(A*r));s[g+4>>2]=j;r=v(v(v(I*F)+v(H*m))+v(A*J));s[g>>2]=r;if(!!(v(v(v(r*O)+v(j*N))+v(i*P))<v(0))){s[g+8>>2]=-i;s[g+4>>2]=-j;s[g>>2]=-r;}o[5639]=o[5639]+1;g:{if(p[19860]){if(!Oc(c,d,g+16|0,g,a,b,h)){break g}}B=0;o[5640]=o[5640]+1;Wa(a,c,g,g+108|0,g+104|0,g+80|0,g- -64|0);Wa(b,d,g,g+100|0,g+96|0,g+48|0,g+32|0);j=s[g+104>>2];r=s[g+100>>2];h:{if(j<r){break h}i=s[g+96>>2];n=s[g+108>>2];if(i<n){break h}x=v(j-r);j=v(i-n);x=x<j?x:j;B=1;}if(!B){break e}if(!(x<h)){break g}y=o[g+4>>2];o[e>>2]=o[g>>2];o[e+4>>2]=y;y=o[g+12>>2];o[e+8>>2]=o[g+8>>2];o[e+12>>2]=y;h=x;}t=t+1|0;if((L|0)==(t|0)){break f}n=s[c+40>>2];i=s[c+36>>2];E=s[c+32>>2];r=s[c+24>>2];j=s[c+20>>2];D=s[c+16>>2];J=s[c+8>>2];continue}}L=o[b+28>>2];if((L|0)>=1){t=0;while(1){y=o[b+36>>2]+u(t,36)|0;j=s[y+28>>2];r=s[y+20>>2];i=s[y+24>>2];H=s[d+8>>2];I=s[d>>2];J=s[d+4>>2];A=s[d+24>>2];D=s[d+16>>2];E=s[d+20>>2];n=s[d+40>>2];F=s[d+32>>2];m=s[d+36>>2];o[g+12>>2]=0;n=v(v(v(r*F)+v(i*m))+v(j*n));s[g+8>>2]=n;A=v(v(v(r*D)+v(i*E))+v(j*A));s[g+4>>2]=A;j=v(v(v(r*I)+v(i*J))+v(j*H));s[g>>2]=j;if(!!(v(v(v(j*O)+v(A*N))+v(n*P))<v(0))){s[g+8>>2]=-n;s[g+4>>2]=-A;s[g>>2]=-j;}o[5639]=o[5639]+1;i:{if(p[19860]){if(!Oc(c,d,g+16|0,g,a,b,h)){break i}}B=0;o[5640]=o[5640]+1;Wa(a,c,g,g+108|0,g+104|0,g+80|0,g- -64|0);Wa(b,d,g,g+100|0,g+96|0,g+48|0,g+32|0);j=s[g+104>>2];r=s[g+100>>2];j:{if(j<r){break j}i=s[g+96>>2];n=s[g+108>>2];if(i<n){break j}x=v(j-r);j=v(i-n);x=x<j?x:j;B=1;}if(!B){break e}if(!(x<h)){break i}y=o[g+4>>2];o[e>>2]=o[g>>2];o[e+4>>2]=y;y=o[g+12>>2];o[e+8>>2]=o[g+8>>2];o[e+12>>2]=y;h=x;}t=t+1|0;if((L|0)!=(t|0)){continue}break}}t=o[a+48>>2];if((t|0)>=1){break d}L=-1;x=v(0);j=v(0);r=v(0);i=v(0);n=v(0);A=v(0);Z=-1;break c}d=0;break a}B=o[b+48>>2];Z=-1;y=0;L=-1;A=v(0);n=v(0);i=v(0);r=v(0);j=v(0);x=v(0);while(1){if((B|0)>=1){t=o[a+56>>2]+(y<<4)|0;J=s[t>>2];D=s[t+4>>2];E=s[t+8>>2];H=v(v(v(J*s[c+32>>2])+v(D*s[c+36>>2]))+v(E*s[c+40>>2]));I=v(v(v(J*s[c+16>>2])+v(D*s[c+20>>2]))+v(E*s[c+24>>2]));J=v(v(v(J*s[c>>2])+v(D*s[c+4>>2]))+v(E*s[c+8>>2]));t=0;while(1){B=o[b+56>>2]+(t<<4)|0;F=s[B+8>>2];z=s[B>>2];G=s[B+4>>2];M=s[d+40>>2];aa=s[d+32>>2];ba=s[d+36>>2];D=s[d+24>>2];E=s[d+16>>2];m=s[d+20>>2];ca=s[d+8>>2];da=s[d>>2];ea=s[d+4>>2];o[g+12>>2]=0;D=v(v(v(z*E)+v(G*m))+v(F*D));E=v(v(v(z*da)+v(G*ea))+v(F*ca));m=v(v(J*D)-v(I*E));s[g+8>>2]=m;F=v(v(v(z*aa)+v(G*ba))+v(F*M));z=v(v(H*E)-v(J*F));s[g+4>>2]=z;G=v(v(I*F)-v(H*D));s[g>>2]=G;k:{if(+v(w(m))>1e-6^1?!(+v(w(G))>1e-6|+v(w(z))>1e-6):0){break k}M=m;m=v(v(1)/v(C(v(v(m*m)+v(v(G*G)+v(z*z))))));M=v(M*m);s[g+8>>2]=M;z=v(z*m);s[g+4>>2]=z;m=v(G*m);s[g>>2]=m;if(!!(v(v(v(m*O)+v(z*N))+v(P*M))<v(0))){s[g+8>>2]=-M;s[g+4>>2]=-z;s[g>>2]=-m;}o[5639]=o[5639]+1;if(p[19860]){if(!Oc(c,d,g+16|0,g,a,b,h)){break k}}B=0;o[5640]=o[5640]+1;Wa(a,c,g,g+108|0,g+104|0,g+80|0,g- -64|0);Wa(b,d,g,g+100|0,g+96|0,g+48|0,g+32|0);m=s[g+104>>2];z=s[g+100>>2];l:{if(m<z){break l}G=s[g+96>>2];M=s[g+108>>2];if(G<M){break l}k=v(m-z);m=v(G-M);if(!!(k<m)){B=1;S=s[g+56>>2];X=s[g+52>>2];Y=s[g+48>>2];q=s[g+72>>2];Q=s[g+68>>2];R=s[g+64>>2];break l}B=1;S=s[g+40>>2];X=s[g+36>>2];Y=s[g+32>>2];q=s[g+88>>2];Q=s[g+84>>2];R=s[g+80>>2];k=m;}if(!B){break b}if(!(k<h)){break k}L=o[g+4>>2];o[e>>2]=o[g>>2];o[e+4>>2]=L;L=o[g+12>>2];o[e+8>>2]=o[g+8>>2];o[e+12>>2]=L;x=Y;j=X;r=S;i=R;n=Q;A=q;T=E;U=D;V=F;W=J;_=I;$=H;L=y;Z=t;h=k;}t=t+1|0;B=o[b+48>>2];if((t|0)<(B|0)){continue}break}t=o[a+48>>2];}y=y+1|0;if((y|0)<(t|0)){continue}break}}m:{if((L|Z)<0){break m}Q=v(x-i);R=v(j-n);S=v(r-A);q=v(v(v(Q*T)+v(R*U))+v(S*V));n=v(v(v(Q*W)+v(R*_))+v(S*$));h=v(0);i=v(v(v(T*W)+v(U*_))+v(V*$));k=v(v(1)-v(i*i));n:{if(k==v(0)){break n}h=v(-1.0000000150474662e+30);k=v(v(n-v(q*i))/k);if(k<v(-1.0000000150474662e+30)){break n}h=k;if(!(h>v(1.0000000150474662e+30))){break n}h=v(1.0000000150474662e+30);}q=v(v(i*h)-q);o:{if(!!(q<v(-1.0000000150474662e+30))){k=v(n+v(i*v(-1.0000000150474662e+30)));if(k<v(-1.0000000150474662e+30)){q=v(-1.0000000150474662e+30);h=v(-1.0000000150474662e+30);break o}h=v(1.0000000150474662e+30);if(!(k>v(1.0000000150474662e+30))){q=v(-1.0000000150474662e+30);h=k;break o}q=v(-1.0000000150474662e+30);break o}if(!(q>v(1.0000000150474662e+30))){break o}h=v(-1.0000000150474662e+30);q=v(1.0000000150474662e+30);k=v(n+v(i*v(1.0000000150474662e+30)));if(k<v(-1.0000000150474662e+30)){break o}h=k;if(!(h>v(1.0000000150474662e+30))){break o}h=v(1.0000000150474662e+30);}o[g+92>>2]=0;n=v(V*q);k=v(n+v(S-v($*h)));s[g+88>>2]=k;U=v(U*q);i=v(U+v(R-v(_*h)));s[g+84>>2]=i;T=v(T*q);h=v(T+v(Q-v(W*h)));s[g+80>>2]=h;q=v(v(k*k)+v(v(h*h)+v(i*i)));if(!(q>v(1.1920928955078125e-7))){break m}m=k;V=v(C(q));k=v(v(1)/V);q=v(m*k);s[g+88>>2]=q;i=v(i*k);s[g+84>>2]=i;h=v(h*k);s[g+80>>2]=h;if(!!(v(v(v(h*O)+v(i*N))+v(q*P))<v(0))){s[g+88>>2]=-q;s[g+84>>2]=-i;s[g+80>>2]=-h;}o[g+76>>2]=0;s[g+72>>2]=r+n;s[g+68>>2]=j+U;s[g+64>>2]=x+T;l[o[o[f>>2]+16>>2]](f,g+80|0,g- -64|0,v(-V));}d=1;h=s[e>>2];x=s[e+4>>2];k=s[e+8>>2];if(!(v(v(v(O*h)+v(N*x))+v(P*k))<v(0))){break a}o[e+12>>2]=0;s[e+8>>2]=-k;s[e+4>>2]=-x;s[e>>2]=-h;break a}d=0;}K=g+112|0;return d}function Lm(a,b,c,d,e,f){var g=0,h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),n=v(0),q=v(0),r=v(0),t=0,w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=0,D=v(0),E=v(0),F=0,G=0,H=v(0),I=v(0),J=v(0),L=v(0),M=0,N=0,O=v(0),P=0,Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0),Z=v(0),_=v(0),$=v(0),aa=v(0),ba=v(0),ca=v(0),da=v(0),ea=v(0),fa=v(0),ga=v(0),ha=v(0),ia=v(0),ja=v(0),ka=v(0),la=v(0),ma=v(0),na=v(0),oa=v(0),pa=v(0),qa=v(0),ra=v(0),sa=v(0);g=K+ -64|0;K=g;h=s[a+588>>2];H=s[a+572>>2];I=s[a+556>>2];W=s[d+56>>2];X=s[d+52>>2];w=s[a+664>>2];x=s[a+668>>2];z=s[a+672>>2];Y=s[c+56>>2];Z=s[c+52>>2];A=s[a+600>>2];E=s[a+604>>2];y=s[a+608>>2];_=s[d+36>>2];$=s[d+40>>2];J=s[c+36>>2];Q=s[c+40>>2];i=s[a+624>>2];O=s[d+20>>2];q=s[a+640>>2];aa=s[d+24>>2];D=s[a+656>>2];n=s[a+560>>2];R=s[c+20>>2];r=s[a+576>>2];S=s[c+24>>2];k=s[a+592>>2];F=o[b+24>>2];ba=s[d+48>>2];ca=s[c+48>>2];da=s[d+32>>2];T=s[c+32>>2];ea=s[d+8>>2];L=s[d>>2];qa=s[d+4>>2];U=s[c+8>>2];fa=s[c>>2];ga=s[c+4>>2];ra=s[d+16>>2];V=s[o[a+32>>2]+404>>2];sa=s[o[a+28>>2]+404>>2];ha=s[c+16>>2];o[g+60>>2]=0;l=v(sa+V);l=l>v(0)?v(V/l):v(.5);j=v(v(1)-l);ia=v(v(v(n*T)+v(r*J))+v(k*Q));ja=v(v(v(i*da)+v(q*_))+v(D*$));ka=v(v(ia*l)+v(ja*j));la=v(v(v(fa*n)+v(ga*r))+v(U*k));ma=v(v(v(L*i)+v(qa*q))+v(ea*D));na=v(v(la*l)+v(ma*j));oa=v(v(v(n*ha)+v(r*R))+v(k*S));pa=v(v(v(i*ra)+v(q*O))+v(D*aa));q=v(v(oa*l)+v(pa*j));D=v(v(1)/v(C(v(v(ka*ka)+v(v(na*na)+v(q*q))))));i=v(ka*D);s[g+56>>2]=i;q=v(q*D);s[g+52>>2]=q;D=v(na*D);s[g+48>>2]=D;o[g+28>>2]=0;_=v(W+v(v(v(da*w)+v(_*x))+v($*z)));r=v(_-W);W=v(ba+v(v(v(L*w)+v(qa*x))+v(ea*z)));k=v(W-ba);$=v(X+v(v(v(ra*w)+v(O*x))+v(aa*z)));x=v($-X);z=v(v(r*i)+v(v(k*D)+v(x*q)));n=v(i*z);X=v(Y+v(v(v(T*A)+v(J*E))+v(Q*y)));w=v(X-Y);Y=v(ca+v(v(v(fa*A)+v(ga*E))+v(U*y)));O=v(Y-ca);aa=v(Z+v(v(v(ha*A)+v(R*E))+v(S*y)));y=v(aa-Z);A=v(v(w*i)+v(v(O*D)+v(y*q)));E=v(i*A);r=v(r-n);Z=v(w-E);w=v(v(l*r)+v(j*Z));s[g+24>>2]=w;ba=v(q*z);ca=v(x-ba);L=y;y=v(q*A);da=v(L-y);x=v(v(l*ca)+v(j*da));s[g+20>>2]=x;L=k;k=v(D*z);ea=v(L-k);L=O;O=v(D*A);L=v(L-O);z=v(v(l*ea)+v(j*L));s[g+16>>2]=z;n=v(E-n);A=v(r-v(j*n));r=v(y-ba);E=v(ca-v(j*r));k=v(O-k);y=v(ea-v(j*k));n=v(Z+v(l*n));r=v(da+v(l*r));k=v(L+v(l*k));d=sa<v(1.1920928955078125e-7)|V<v(1.1920928955078125e-7);c=g;V=v(v(w*w)+v(v(z*z)+v(x*x)));a:{if(!!(V>v(1.1920928955078125e-7))){h=v(v(1)/v(C(V)));w=v(w*h);s[g+24>>2]=w;x=v(x*h);s[g+20>>2]=x;h=v(z*h);break a}o[g+28>>2]=0;w=v(v(v(I*T)+v(H*J))+v(h*Q));s[g+24>>2]=w;x=v(v(v(I*ha)+v(H*R))+v(h*S));s[g+20>>2]=x;h=v(v(v(fa*I)+v(ga*H))+v(U*h));}s[c+16>>2]=h;o[g+12>>2]=0;H=v(v(D*x)-v(q*h));s[g+8>>2]=H;I=v(v(i*h)-v(D*w));s[g+4>>2]=I;z=v(v(q*w)-v(i*x));s[g>>2]=z;s[g+40>>2]=v(k*x)-v(r*h);s[g+36>>2]=v(n*h)-v(k*w);s[g+32>>2]=v(r*w)-v(n*x);B=o[g+36>>2];c=o[b+12>>2];o[c>>2]=o[g+32>>2];o[c+4>>2]=B;o[c+8>>2]=o[g+40>>2];c=o[b+20>>2];s[c+8>>2]=-v(v(y*x)-v(E*h));s[c+4>>2]=-v(v(A*h)-v(y*w));s[c>>2]=-v(v(E*w)-v(A*x));o[g+44>>2]=0;S=v(v(k*I)-v(r*z));s[g+40>>2]=S;T=v(v(n*z)-v(k*H));s[g+36>>2]=T;U=v(v(r*H)-v(n*I));s[g+32>>2]=U;J=v(v(y*I)-v(E*z));Q=v(v(A*z)-v(y*H));R=v(v(E*H)-v(A*I));if(!(!d|!p[a+716|0])){s[g+40>>2]=l*S;s[g+36>>2]=l*T;s[g+32>>2]=l*U;Q=v(j*Q);R=v(j*R);J=v(j*J);}t=o[g+36>>2];B=F<<2;c=B+o[b+12>>2]|0;o[c>>2]=o[g+32>>2];o[c+4>>2]=t;o[c+8>>2]=o[g+40>>2];c=o[b+20>>2];s[c+B>>2]=-R;B=F+1|0;s[c+(B<<2)>>2]=-Q;M=F+2|0;s[c+(M<<2)>>2]=-J;J=v(v(k*q)-v(r*D));s[g+40>>2]=J;o[g+44>>2]=0;k=v(v(n*D)-v(k*i));s[g+36>>2]=k;r=v(v(r*i)-v(n*q));s[g+32>>2]=r;n=v(v(y*q)-v(E*D));y=v(v(A*D)-v(y*i));A=v(v(E*i)-v(A*q));if(d){s[g+40>>2]=l*J;s[g+36>>2]=l*k;s[g+32>>2]=l*r;n=v(j*n);y=v(j*y);A=v(j*A);}G=o[g+36>>2];d=F<<1;t=d<<2;c=t+o[b+12>>2]|0;o[c>>2]=o[g+32>>2];o[c+4>>2]=G;o[c+8>>2]=o[g+40>>2];c=o[b+20>>2];s[t+c>>2]=-A;G=d|1;s[(G<<2)+c>>2]=-y;P=d+2|0;s[(P<<2)+c>>2]=-n;E=s[(p[a+748|0]&8?a+756|0:b+4|0)>>2];b:{if(p[a+736|0]){n=v(-H);A=v(-I);l=v(-z);y=v(-h);B=o[b+28>>2];break b}j=s[b>>2];t=o[g+20>>2];c=o[b+8>>2];o[c>>2]=o[g+16>>2];o[c+4>>2]=t;o[c+8>>2]=o[g+24>>2];N=o[g+4>>2];t=F<<2;c=t+o[b+8>>2]|0;o[c>>2]=o[g>>2];o[c+4>>2]=N;o[c+8>>2]=o[g+8>>2];N=o[g+52>>2];d=d<<2;c=d+o[b+8>>2]|0;o[c>>2]=o[g+48>>2];o[c+4>>2]=N;o[c+8>>2]=o[g+56>>2];c=o[b+16>>2];y=v(-h);s[c>>2]=y;s[c+4>>2]=-x;s[c+8>>2]=-w;l=v(-z);s[c+t>>2]=l;A=v(-I);s[c+(B<<2)>>2]=A;n=v(-H);s[c+(M<<2)>>2]=n;s[c+d>>2]=-D;s[c+(G<<2)>>2]=-q;s[c+(P<<2)>>2]=-i;B=o[b+28>>2];j=v(E*j);r=v(W-Y);k=v($-aa);J=v(_-X);s[B>>2]=j*v(v(v(r*h)+v(k*x))+v(J*w));s[t+B>>2]=j*v(v(v(r*z)+v(k*I))+v(J*H));s[d+B>>2]=j*v(v(v(r*D)+v(k*q))+v(J*i));c=o[b+20>>2];}d=o[b+12>>2];t=u(F,12);s[d+t>>2]=h;M=t+8|0;s[M+d>>2]=w;G=t+4|0;s[G+d>>2]=x;F=F<<4;s[F+d>>2]=z;P=F|4;s[P+d>>2]=I;N=F|8;s[N+d>>2]=H;s[c+t>>2]=y;j=s[g+20>>2];s[c+G>>2]=-j;i=s[g+24>>2];s[c+M>>2]=-i;s[c+F>>2]=l;s[c+P>>2]=A;s[c+N>>2]=n;l=v(E*s[b>>2]);q=v(v(oa*ja)-v(ia*pa));k=v(q*h);h=v(v(ia*ma)-v(la*ja));k=v(k+v(j*h));j=v(v(la*pa)-v(oa*ma));s[t+B>>2]=l*v(k+v(i*j));s[B+F>>2]=l*v(v(v(q*z)+v(h*I))+v(j*H));c:{d:{if(p[a+716|0]){n=v(s[a+708>>2]*s[a+732>>2]);M=n>v(0)?1:2;G=p[a+737|0]!=0;F=1;break d}if(!p[a+737|0]){break c}n=v(0);G=1;M=0;F=0;}l=s[g+48>>2];B=u(o[b+24>>2],5);t=B<<2;o[t+d>>2]=o[g+48>>2];h=s[g+52>>2];P=t+4|0;o[P+d>>2]=o[g+52>>2];j=s[g+56>>2];N=t+8|0;o[d+N>>2]=o[g+56>>2];s[c+P>>2]=-h;s[c+t>>2]=-l;s[c+N>>2]=-j;c=a+688|0;i=Tb(c);q=Ub(c);d=o[b+28>>2];o[t+d>>2]=0;t=i!=q;c=(t|F^1)&G;G=o[a+748>>2];if(G&2){E=s[a+764>>2];}if(c){if(G&4){o[o[b+32>>2]+(B<<2)>>2]=o[a+752>>2];}i=Wb(s[a+728>>2],i,q,s[a+680>>2],v(E*s[b>>2]));d=o[b+28>>2];c=B<<2;G=d+c|0;s[G>>2]=v(v(i*s[a+680>>2])*s[a+732>>2])+s[G>>2];s[c+o[b+36>>2]>>2]=-s[a+684>>2];o[c+o[b+40>>2]>>2]=o[a+684>>2];}if(!F){break c}c=d;d=B<<2;c=c+d|0;s[c>>2]=s[c>>2]+v(n*v(E*s[b>>2]));if(m[a+748|0]&1){o[d+o[b+32>>2]>>2]=o[a+760>>2];}e:{if(!t){o[o[b+36>>2]+(B<<2)>>2]=-8388609;i=v(3.4028234663852886e+38);break e}d=o[b+36>>2]+(B<<2)|0;if((M|0)==1){o[d>>2]=0;i=v(3.4028234663852886e+38);break e}o[d>>2]=-8388609;i=v(0);}s[o[b+40>>2]+(B<<2)>>2]=i;i=s[a+704>>2];f:{if(!(i>v(0))){break f}h=v(v(v(v(s[e>>2]*l)+v(s[e+4>>2]*h))+v(s[e+8>>2]*j))-v(v(v(s[f>>2]*l)+v(s[f+4>>2]*h))+v(s[f+8>>2]*j)));if((M|0)==1){if(!(h<v(0))){break f}h=v(h*v(-i));if(!(h>s[c>>2])){break f}s[c>>2]=h;break f}if(!(h>v(0))){break f}h=v(h*v(-i));if(!(h<s[c>>2])){break f}s[c>>2]=h;}s[c>>2]=s[a+700>>2]*s[c>>2];}K=g- -64|0;}function Yg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,r=0;o[a+168>>2]=o[a+152>>2];m[b+80|0]=1;m[b+60|0]=0;o[b+52>>2]=287;o[b>>2]=16296;o[b+76>>2]=0;m[b+100|0]=1;o[b+68>>2]=0;o[b+72>>2]=0;o[b+96>>2]=0;m[b+120|0]=1;o[b+88>>2]=0;o[b+92>>2]=0;o[b+116>>2]=0;m[b+140|0]=1;o[b+108>>2]=0;o[b+112>>2]=0;o[b+136>>2]=0;m[b+164|0]=1;o[b+144>>2]=0;o[b+128>>2]=0;o[b+132>>2]=0;o[b+160>>2]=0;o[b+152>>2]=0;o[b+156>>2]=0;o[b+168>>2]=0;o[b+28>>2]=2139095039;o[b+32>>2]=0;o[b+20>>2]=2139095039;o[b+24>>2]=2139095039;o[b+12>>2]=-8388609;o[b+16>>2]=0;o[b+4>>2]=-8388609;o[b+8>>2]=-8388609;g=o[a+56>>2];c=b;a:{if(d){o[b+56>>2]=g<<8&16711680|g<<24|(g>>>8&65280|g>>>24);m[b+4|0]=p[a+7|0];m[b+5|0]=p[a+6|0];m[b+6|0]=p[a+5|0];m[b+7|0]=p[a+4|0];m[b+8|0]=p[a+11|0];m[b+9|0]=p[a+10|0];m[b+10|0]=p[a+9|0];m[b+11|0]=p[a+8|0];m[b+12|0]=p[a+15|0];m[b+13|0]=p[a+14|0];m[b+14|0]=p[a+13|0];m[b+15|0]=p[a+12|0];m[b+16|0]=p[a+19|0];m[b+17|0]=p[a+18|0];m[b+18|0]=p[a+17|0];m[b+19|0]=p[a+16|0];m[b+20|0]=p[a+23|0];m[b+21|0]=p[a+22|0];m[b+22|0]=p[a+21|0];m[b+23|0]=p[a+20|0];m[b+24|0]=p[a+27|0];m[b+25|0]=p[a+26|0];m[b+26|0]=p[a+25|0];m[b+27|0]=p[a+24|0];m[b+28|0]=p[a+31|0];m[b+29|0]=p[a+30|0];m[b+30|0]=p[a+29|0];m[b+31|0]=p[a+28|0];m[b+32|0]=p[a+35|0];m[b+33|0]=p[a+34|0];m[b+34|0]=p[a+33|0];m[b+35|0]=p[a+32|0];m[b+36|0]=p[a+39|0];m[b+37|0]=p[a+38|0];m[b+38|0]=p[a+37|0];m[b+39|0]=p[a+36|0];m[b+40|0]=p[a+43|0];m[b+41|0]=p[a+42|0];m[b+42|0]=p[a+41|0];m[b+43|0]=p[a+40|0];m[b+44|0]=p[a+47|0];m[b+45|0]=p[a+46|0];m[b+46|0]=p[a+45|0];m[b+47|0]=p[a+44|0];m[b+48|0]=p[a+51|0];m[b+49|0]=p[a+50|0];m[b+50|0]=p[a+49|0];m[b+51|0]=p[a+48|0];g=o[a+144>>2];o[b+144>>2]=g<<24|g<<8&16711680|(g>>>8&65280|g>>>24);g=o[a+168>>2];g=g<<24|g<<8&16711680|(g>>>8&65280|g>>>24);break a}o[b+56>>2]=g;g=o[a+16>>2];o[b+12>>2]=o[a+12>>2];o[b+16>>2]=g;g=o[a+8>>2];o[b+4>>2]=o[a+4>>2];o[b+8>>2]=g;g=o[a+32>>2];o[b+28>>2]=o[a+28>>2];o[b+32>>2]=g;g=o[a+24>>2];o[b+20>>2]=o[a+20>>2];o[b+24>>2]=g;g=o[a+48>>2];o[b+44>>2]=o[a+44>>2];o[b+48>>2]=g;g=o[a+40>>2];o[b+36>>2]=o[a+36>>2];o[b+40>>2]=g;o[b+144>>2]=o[a+144>>2];g=o[a+168>>2];}o[c+168>>2]=g;m[b+60|0]=p[a+60|0];g=b+172|0;j=o[a+56>>2];b:{if(p[a+60|0]){c=o[b+136>>2];if(c){if(p[b+140|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[b+136>>2]=0;}o[b+136>>2]=g;m[b+140|0]=0;o[b+132>>2]=j;o[b+128>>2]=j;c:{if(!d){if((j|0)<1){break c}h=o[a+136>>2];while(1){c=i<<4;f=c+g|0;c=c+h|0;n[f>>1]=q[c>>1];n[f+2>>1]=q[c+2>>1];n[f+4>>1]=q[c+4>>1];n[f+6>>1]=q[c+6>>1];n[f+8>>1]=q[c+8>>1];n[f+10>>1]=q[c+10>>1];o[f+12>>2]=o[c+12>>2];i=i+1|0;if((j|0)!=(i|0)){continue}break}break c}if((j|0)<1){break c}h=o[a+136>>2];while(1){c=i<<4;e=c+g|0;f=c+h|0;c=q[f>>1];n[e>>1]=(c<<24|c<<8&16711680)>>>16;c=q[f+2>>1];n[e+2>>1]=(c<<24|c<<8&16711680)>>>16;c=q[f+4>>1];n[e+4>>1]=(c<<24|c<<8&16711680)>>>16;c=q[f+6>>1];n[e+6>>1]=(c<<24|c<<8&16711680)>>>16;c=q[f+8>>1];n[e+8>>1]=(c<<24|c<<8&16711680)>>>16;c=q[f+10>>1];n[e+10>>1]=(c<<24|c<<8&16711680)>>>16;c=o[f+12>>2];o[e+12>>2]=c<<24|c<<8&16711680|(c>>>8&65280|c>>>24);i=i+1|0;if((j|0)!=(i|0)){continue}break}}f=b+128|0;e=j<<4;break b}c=o[b+96>>2];if(c){if(p[b+100|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[b+96>>2]=0;}f=b+88|0;o[b+96>>2]=g;m[b+100|0]=0;o[b+92>>2]=j;o[b+88>>2]=j;d:{e:{f:{if(!d){if((j|0)<1){break e}r=o[a+96>>2];c=g;while(1){k=i<<6;e=k+c|0;h=k+r|0;c=o[h+4>>2];o[e>>2]=o[h>>2];o[e+4>>2]=c;c=o[h+12>>2];o[e+8>>2]=o[h+8>>2];o[e+12>>2]=c;h=k+o[a+96>>2]|0;c=o[h+20>>2];e=k+o[b+96>>2]|0;o[e+16>>2]=o[h+16>>2];o[e+20>>2]=c;c=o[h+28>>2];o[e+24>>2]=o[h+24>>2];o[e+28>>2]=c;c=o[b+96>>2];e=k+c|0;r=o[a+96>>2];h=k+r|0;o[e+32>>2]=o[h+32>>2];o[e+36>>2]=o[h+36>>2];o[e+40>>2]=o[h+40>>2];i=i+1|0;if((j|0)!=(i|0)){continue}break}break f}if((j|0)<1){break e}k=o[a+96>>2];c=g;while(1){h=r<<6;e=h+c|0;c=h+k|0;m[e|0]=p[c+3|0];m[e+1|0]=p[c+2|0];m[e+2|0]=p[c+1|0];m[e+3|0]=p[c|0];m[e+4|0]=p[c+7|0];m[e+5|0]=p[c+6|0];m[e+6|0]=p[c+5|0];m[e+7|0]=p[c+4|0];m[e+8|0]=p[c+11|0];m[e+9|0]=p[c+10|0];m[e+10|0]=p[c+9|0];m[e+11|0]=p[c+8|0];m[e+12|0]=p[c+15|0];m[e+13|0]=p[c+14|0];m[e+14|0]=p[c+13|0];m[e+15|0]=p[c+12|0];e=h+o[b+96>>2]|0;c=h+o[a+96>>2]|0;m[e+16|0]=p[c+19|0];m[e+17|0]=p[c+18|0];m[e+18|0]=p[c+17|0];m[e+19|0]=p[c+16|0];m[e+20|0]=p[c+23|0];m[e+21|0]=p[c+22|0];m[e+22|0]=p[c+21|0];m[e+23|0]=p[c+20|0];m[e+24|0]=p[c+27|0];m[e+25|0]=p[c+26|0];m[e+26|0]=p[c+25|0];m[e+27|0]=p[c+24|0];m[e+28|0]=p[c+31|0];m[e+29|0]=p[c+30|0];m[e+30|0]=p[c+29|0];m[e+31|0]=p[c+28|0];c=o[b+96>>2];e=h+c|0;k=o[a+96>>2];h=h+k|0;i=o[h+32>>2];o[e+32>>2]=i<<24|i<<8&16711680|(i>>>8&65280|i>>>24);i=o[h+36>>2];o[e+36>>2]=i<<24|i<<8&16711680|(i>>>8&65280|i>>>24);h=o[h+40>>2];o[e+40>>2]=h<<24|h<<8&16711680|(h>>>8&65280|h>>>24);r=r+1|0;if((j|0)!=(r|0)){continue}break}}e=j<<6;h=e;if(c){break d}break b}c=g;h=j<<6;}e=h;if(p[b+100|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[b+96>>2]=0;}o[f>>2]=0;o[f+4>>2]=0;m[f+5|0]=0;m[f+6|0]=0;m[f+7|0]=0;m[f+8|0]=0;m[f+9|0]=0;m[f+10|0]=0;m[f+11|0]=0;m[f+12|0]=0;f=o[a+168>>2];c=o[b+160>>2];if(c){if(p[b+164|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[b+160>>2]=0;}h=e+g|0;o[b+160>>2]=h;m[b+164|0]=0;o[b+156>>2]=f;o[b+152>>2]=f;g=o[a+168>>2];g:{if(!d){if((g|0)<1){break g}g=o[a+160>>2];d=0;while(1){c=d<<5;f=c+h|0;c=c+g|0;n[f>>1]=q[c>>1];n[f+2>>1]=q[c+2>>1];n[f+4>>1]=q[c+4>>1];n[f+6>>1]=q[c+6>>1];n[f+8>>1]=q[c+8>>1];n[f+10>>1]=q[c+10>>1];o[f+12>>2]=o[c+12>>2];c=o[c+16>>2];o[f+28>>2]=0;o[f+20>>2]=0;o[f+24>>2]=0;o[f+16>>2]=c;d=d+1|0;if((d|0)<o[a+168>>2]){continue}break}break g}if((g|0)<1){break g}c=o[a+160>>2];d=0;while(1){a=d<<5;e=a+h|0;f=a+c|0;a=q[f>>1];n[e>>1]=(a<<24|a<<8&16711680)>>>16;a=q[f+2>>1];n[e+2>>1]=(a<<24|a<<8&16711680)>>>16;a=q[f+4>>1];n[e+4>>1]=(a<<24|a<<8&16711680)>>>16;a=q[f+6>>1];n[e+6>>1]=(a<<24|a<<8&16711680)>>>16;a=q[f+8>>1];n[e+8>>1]=(a<<24|a<<8&16711680)>>>16;a=q[f+10>>1];n[e+10>>1]=(a<<24|a<<8&16711680)>>>16;a=o[f+12>>2];o[e+12>>2]=a<<24|a<<8&16711680|(a>>>8&65280|a>>>24);a=o[f+16>>2];o[e+16>>2]=a<<24|a<<8&16711680|(a>>>8&65280|a>>>24);d=d+1|0;if((g|0)!=(d|0)){continue}break}}o[b>>2]=0;m[b+157|0]=0;m[b+158|0]=0;m[b+159|0]=0;m[b+160|0]=0;m[b+161|0]=0;m[b+162|0]=0;m[b+163|0]=0;m[b+164|0]=0;o[b+152>>2]=0;o[b+156>>2]=0;return 1}function Db(a,b,c,d){var e=0,f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),n=v(0),p=v(0),q=v(0),r=0,t=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=0,B=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=0,M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0);e=K-704|0;K=e;sa(e+624|0);o[e+652>>2]=0;o[e+656>>2]=0;o[e+648>>2]=1065353216;o[e+660>>2]=0;o[e+664>>2]=0;o[e+668>>2]=0;o[e+672>>2]=0;o[e+676>>2]=0;o[e+640>>2]=1065353216;o[e+644>>2]=1065353216;o[e+628>>2]=8;o[e+624>>2]=11388;f=o[c+12>>2];a:{r=o[c+4>>2];A=o[r+4>>2];if((A|0)<=19){o[e+616>>2]=0;o[e+620>>2]=0;o[e+448>>2]=6980;o[e+612>>2]=o[d+4>>2];m[e+420|0]=0;o[e+396>>2]=953267991;A=e+680|0;o[A+12>>2]=r;o[A+8>>2]=e+624;o[A+4>>2]=e+88;o[A>>2]=6276;L=e+72|0;o[L+12>>2]=r;o[L+8>>2]=e+624;o[L+4>>2]=e+88;o[L>>2]=7232;r=o[d+16>>2]&8?L:A;b:{if(!l[o[o[r>>2]+8>>2]](r,a,b,f,f,e+448|0)){break b}h=s[e+580>>2];j=s[e+584>>2];g=s[e+588>>2];i=v(v(v(h*h)+v(j*j))+v(g*g));if(!(i>v(9999999747378752e-20))){break b}t=s[e+612>>2];if(!(t<s[d+4>>2])){break b}k=g;g=v(v(1)/v(C(i)));s[e+588>>2]=k*g;s[e+584>>2]=j*g;s[e+580>>2]=h*g;a=o[c+8>>2];o[e+44>>2]=0;o[e+40>>2]=a;a=o[e+592>>2];o[e+56>>2]=o[e+588>>2];o[e+60>>2]=a;a=o[e+584>>2];o[e+48>>2]=o[e+580>>2];o[e+52>>2]=a;s[e+64>>2]=t;v(l[o[o[d>>2]+12>>2]](d,e+40|0,1));}break a}if(A+ -21>>>0<=8){p=s[f+20>>2];k=s[f+36>>2];n=s[f+24>>2];g=s[f+52>>2];i=s[f+56>>2];q=s[f+40>>2];w=s[f+32>>2];x=s[f+16>>2];y=s[f>>2];F=s[f+4>>2];h=s[f+48>>2];G=s[f+8>>2];t=s[a+52>>2];B=s[a+56>>2];j=s[a+48>>2];o[e+460>>2]=0;H=v(-g);I=v(n*H);J=v(q*i);z=v(v(I-v(G*h))-J);N=v(n*t);O=v(q*B);s[e+456>>2]=z+v(v(v(G*j)+N)+O);P=v(p*H);R=v(k*i);M=v(v(P-v(F*h))-R);S=v(p*t);T=v(k*B);s[e+452>>2]=M+v(v(v(F*j)+S)+T);U=v(v(v(x*H)-v(y*h))-v(w*i));s[e+448>>2]=U+v(v(v(y*j)+v(x*t))+v(w*B));D=s[b+52>>2];E=s[b+56>>2];g=s[b+48>>2];o[e+52>>2]=0;Q=z;V=v(G*g);G=v(n*D);z=v(q*E);s[e+48>>2]=Q+v(v(V+G)+z);Q=M;n=v(F*g);F=v(p*D);M=v(k*E);s[e+44>>2]=Q+v(v(n+F)+M);s[e+40>>2]=U+v(v(v(y*g)+v(x*D))+v(w*E));a=f;if(o[r+4>>2]==21){b=o[c+8>>2];Le(e+88|0,e+448|0,e+40|0,o[d+16>>2]);o[e+140>>2]=r;o[e+136>>2]=b;o[e+132>>2]=d;o[e+88>>2]=7952;b=o[a+12>>2];o[e+152>>2]=o[a+8>>2];o[e+156>>2]=b;b=o[a+4>>2];o[e+144>>2]=o[a>>2];o[e+148>>2]=b;b=o[a+28>>2];o[e+168>>2]=o[a+24>>2];o[e+172>>2]=b;b=o[a+20>>2];o[e+160>>2]=o[a+16>>2];o[e+164>>2]=b;b=o[f+44>>2];o[e+184>>2]=o[f+40>>2];o[e+188>>2]=b;b=o[f+36>>2];o[e+176>>2]=o[f+32>>2];o[e+180>>2]=b;b=o[f+60>>2];o[e+200>>2]=o[f+56>>2];o[e+204>>2]=b;b=o[a+52>>2];o[e+192>>2]=o[a+48>>2];o[e+196>>2]=b;o[e+128>>2]=o[d+4>>2];mi(r,e+88|0,e+448|0,e+40|0);break a}p=s[a+32>>2];k=s[a+16>>2];n=s[a>>2];q=s[a+4>>2];w=s[a+8>>2];o[e+692>>2]=0;x=v(v(I-v(w*h))-J);s[e+688>>2]=v(v(v(j*w)+N)+O)+x;y=v(v(P-v(q*h))-R);s[e+684>>2]=v(v(v(j*q)+S)+T)+y;h=v(v(v(k*H)-v(n*h))-v(p*i));s[e+680>>2]=v(v(v(j*n)+v(t*k))+v(B*p))+h;o[e+84>>2]=0;s[e+80>>2]=v(v(v(g*w)+G)+z)+x;s[e+76>>2]=v(v(v(g*q)+F)+M)+y;s[e+72>>2]=v(v(v(g*n)+v(D*k))+v(E*p))+h;b=o[c+8>>2];Le(e+88|0,e+680|0,e+72|0,o[d+16>>2]);o[e+140>>2]=r;o[e+136>>2]=b;o[e+132>>2]=d;o[e+88>>2]=7952;b=o[a+12>>2];o[e+152>>2]=o[a+8>>2];o[e+156>>2]=b;b=o[a+4>>2];o[e+144>>2]=o[a>>2];o[e+148>>2]=b;b=o[a+28>>2];o[e+168>>2]=o[a+24>>2];o[e+172>>2]=b;b=o[a+20>>2];o[e+160>>2]=o[a+16>>2];o[e+164>>2]=b;b=o[f+44>>2];o[e+184>>2]=o[f+40>>2];o[e+188>>2]=b;b=o[f+36>>2];o[e+176>>2]=o[f+32>>2];o[e+180>>2]=b;b=o[f+60>>2];o[e+200>>2]=o[f+56>>2];o[e+204>>2]=b;b=o[a+52>>2];o[e+192>>2]=o[a+48>>2];o[e+196>>2]=b;o[e+128>>2]=o[d+4>>2];a=o[e+692>>2];o[e+32>>2]=o[e+688>>2];o[e+36>>2]=a;a=o[e+684>>2];o[e+24>>2]=o[e+680>>2];o[e+28>>2]=a;h=s[e+72>>2];if(!!(h<s[e+24>>2])){s[e+24>>2]=h;}j=s[e+76>>2];if(!!(j<s[e+28>>2])){s[e+28>>2]=j;}g=s[e+80>>2];if(!!(g<s[e+32>>2])){s[e+32>>2]=g;}i=s[e+84>>2];if(!!(i<s[e+36>>2])){s[e+36>>2]=i;}a=o[e+692>>2];o[e+16>>2]=o[e+688>>2];o[e+20>>2]=a;a=o[e+684>>2];o[e+8>>2]=o[e+680>>2];o[e+12>>2]=a;if(!!(s[e+8>>2]<h)){s[e+8>>2]=h;}if(!!(s[e+12>>2]<j)){s[e+12>>2]=j;}if(!!(s[e+16>>2]<g)){s[e+16>>2]=g;}if(!!(s[e+20>>2]<i)){s[e+20>>2]=i;}l[o[o[r>>2]+64>>2]](r,e+88|0,e+24|0,e+8|0);break a}if((A|0)!=31){break a}A=o[r+68>>2];c=o[c+8>>2];o[e+64>>2]=d;o[e+60>>2]=b;o[e+56>>2]=a;o[e+52>>2]=f;o[e+48>>2]=r;o[e+44>>2]=c;o[e+40>>2]=8136;if(A){h=s[f+20>>2];j=s[f+36>>2];g=s[f+24>>2];i=s[f+52>>2];n=s[a+52>>2];t=s[f+40>>2];B=s[f+56>>2];q=s[a+56>>2];w=s[f>>2];D=s[f+16>>2];E=s[f+32>>2];x=s[f+4>>2];k=s[f+8>>2];p=s[f+48>>2];y=s[a+48>>2];o[e+100>>2]=0;z=k;k=v(y-p);n=v(n-i);q=v(q-B);s[e+96>>2]=v(v(z*k)+v(g*n))+v(t*q);s[e+92>>2]=v(v(k*x)+v(n*h))+v(q*j);s[e+88>>2]=v(v(k*w)+v(n*D))+v(q*E);k=s[b+52>>2];n=s[b+56>>2];q=s[f>>2];w=s[f+4>>2];x=s[f+8>>2];y=s[b+48>>2];o[e+460>>2]=0;p=v(y-p);z=g;g=v(k-i);i=v(n-B);s[e+456>>2]=v(v(x*p)+v(z*g))+v(t*i);s[e+452>>2]=v(v(p*w)+v(g*h))+v(i*j);s[e+448>>2]=v(v(p*q)+v(g*D))+v(i*E);ik(o[A>>2],e+88|0,e+448|0,e+40|0);break a}b=o[r+20>>2];if((b|0)<1){break a}c=0;while(1){a=o[r+28>>2]+u(c,80)|0;d=o[a+64>>2];k=s[a+56>>2];n=s[a+48>>2];q=s[a+52>>2];w=s[a+32>>2];x=s[a>>2];y=s[a+16>>2];F=s[a+36>>2];G=s[a+4>>2];H=s[a+20>>2];I=s[a+40>>2];J=s[a+8>>2];z=s[a+24>>2];N=s[f+52>>2];O=s[f+56>>2];h=s[f+24>>2];j=s[f+20>>2];g=s[f+40>>2];i=s[f+36>>2];P=s[f+48>>2];t=s[f+8>>2];B=s[f>>2];D=s[f+4>>2];E=s[f+16>>2];p=s[f+32>>2];o[e+148>>2]=0;o[e+132>>2]=0;o[e+116>>2]=0;o[e+100>>2]=0;s[e+128>>2]=v(v(J*p)+v(z*i))+v(I*g);s[e+124>>2]=v(v(G*p)+v(H*i))+v(F*g);s[e+120>>2]=v(v(x*p)+v(y*i))+v(w*g);s[e+112>>2]=v(v(J*E)+v(z*j))+v(I*h);s[e+108>>2]=v(v(G*E)+v(H*j))+v(F*h);s[e+104>>2]=v(v(x*E)+v(y*j))+v(w*h);s[e+96>>2]=v(v(B*J)+v(D*z))+v(t*I);s[e+92>>2]=v(v(B*G)+v(D*H))+v(t*F);s[e+88>>2]=v(v(x*B)+v(y*D))+v(w*t);s[e+144>>2]=O+v(v(v(p*n)+v(i*q))+v(g*k));s[e+140>>2]=N+v(v(v(E*n)+v(j*q))+v(h*k));s[e+136>>2]=P+v(v(v(B*n)+v(D*q))+v(t*k));o[e+700>>2]=c;o[e+696>>2]=-1;o[e+688>>2]=o[e+44>>2];o[e+684>>2]=d;o[e+680>>2]=0;o[e+692>>2]=e+88;o[e+460>>2]=-65535;o[e+464>>2]=0;o[e+452>>2]=1065353216;o[e+456>>2]=0;o[e+472>>2]=c;o[e+448>>2]=8340;a=o[e+64>>2];o[e+468>>2]=a;o[e+452>>2]=o[a+4>>2];o[e+464>>2]=o[a+16>>2];Db(o[e+56>>2],o[e+60>>2],e+680|0,e+448|0);c=c+1|0;if((b|0)==(c|0)){break a}f=o[e+52>>2];r=o[e+48>>2];continue}}K=e+704|0;}function Lh(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=v(0),n=v(0),q=v(0),r=0,t=0,x=v(0),y=0,z=v(0),A=v(0),B=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0);r=K-32|0;K=r;x=s[c+8>>2];a:{if(!!(v(w(x))>v(.7071067690849304))){k=s[c+4>>2];n=v(v(x*x)+v(k*k));q=v(v(1)/v(C(n)));F=v(n*q);n=s[c>>2];A=v(q*v(-x));G=v(n*A);H=v(k*q);n=v(H*v(-n));break a}q=s[c>>2];k=s[c+4>>2];n=v(v(q*q)+v(k*k));z=v(v(1)/v(C(n)));G=v(n*z);A=v(q*z);F=v(A*v(-x));D=v(z*v(-k));n=v(x*D);}h=o[a+4>>2];b:{if((h|0)>=2){d=o[a+12>>2];while(1){f=u(j,24);e=f+d|0;if(!!(v(v(v(D*s[e>>2])+v(A*s[e+4>>2]))+v(H*s[e+8>>2]))<v(v(v(D*s[d>>2])+v(A*s[d+4>>2]))+v(H*s[d+8>>2])))){g=o[d+20>>2];o[r+24>>2]=o[d+16>>2];o[r+28>>2]=g;g=o[d+12>>2];o[r+16>>2]=o[d+8>>2];o[r+20>>2]=g;g=o[d+4>>2];o[r+8>>2]=o[d>>2];o[r+12>>2]=g;g=o[e+4>>2];o[d>>2]=o[e>>2];o[d+4>>2]=g;g=o[e+12>>2];o[d+8>>2]=o[e+8>>2];o[d+12>>2]=g;g=o[e+20>>2];o[d+16>>2]=o[e+16>>2];o[d+20>>2]=g;e=o[r+12>>2];g=f+o[a+12>>2]|0;d=g;o[d>>2]=o[r+8>>2];o[d+4>>2]=e;e=o[r+28>>2];o[d+16>>2]=o[r+24>>2];o[d+20>>2]=e;e=o[r+20>>2];o[d+8>>2]=o[r+16>>2];o[d+12>>2]=e;h=o[a+4>>2];d=o[a+12>>2];}j=j+1|0;if((j|0)<(h|0)){continue}break}o[d+16>>2]=-246811958;if((h|0)>=2){I=s[d+8>>2];J=s[d>>2];x=s[d+4>>2];j=1;while(1){B=v(0);e=u(j,24)+d|0;z=v(s[e>>2]-J);q=v(s[e+4>>2]-x);k=v(s[e+8>>2]-I);E=v(v(v(F*z)+v(n*q))+v(G*k));q=v(v(v(D*z)+v(A*q))+v(H*k));if(!(v(v(E*E)+v(q*q))<v(1.1920928955078125e-7))){k=v(w(E));c:{if(!!(q>=v(0))){B=v(.7853981852531433);k=v(v(q-k)/v(q+k));break c}B=v(2.356194496154785);k=v(v(q+k)/v(k-q));}k=v(B+v(k*v(-.7853981852531433)));B=E<v(0)?v(-k):k;}s[e+16>>2]=B;j=j+1|0;if((j|0)!=(h|0)){continue}break}}e=o[d+12>>2];o[r+16>>2]=o[d+8>>2];o[r+20>>2]=e;e=o[d+4>>2];o[r+8>>2]=o[d>>2];o[r+12>>2]=e;Gc(a,r+8|0,1,h+ -1|0);e=o[a+12>>2];h=o[b+4>>2];d:{if((h|0)!=o[b+8>>2]){break d}j=h?h<<1:1;if((h|0)>=(j|0)){break d}d=0;if(j){o[6257]=o[6257]+1;t=l[o[4968]](u(j,24),16)|0;h=o[b+4>>2];}if((h|0)>=1){while(1){g=u(d,24);y=g+t|0;f=y;i=g+o[b+12>>2]|0;g=o[i+4>>2];o[f>>2]=o[i>>2];o[f+4>>2]=g;g=o[i+20>>2];o[f+16>>2]=o[i+16>>2];o[f+20>>2]=g;g=o[i+12>>2];o[f+8>>2]=o[i+8>>2];o[f+12>>2]=g;d=d+1|0;if((h|0)!=(d|0)){continue}break}}d=o[b+12>>2];if(d){if(p[b+16|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[b+12>>2]=0;}o[b+12>>2]=t;m[b+16|0]=1;o[b+8>>2]=j;h=o[b+4>>2];}d=o[e+4>>2];f=o[b+12>>2]+u(h,24)|0;o[f>>2]=o[e>>2];o[f+4>>2]=d;d=o[e+20>>2];o[f+16>>2]=o[e+16>>2];o[f+20>>2]=d;d=o[e+12>>2];o[f+8>>2]=o[e+8>>2];o[f+12>>2]=d;h=o[b+4>>2]+1|0;o[b+4>>2]=h;e=o[a+12>>2];e:{if(o[b+8>>2]!=(h|0)){break e}j=h?h<<1:1;if((h|0)>=(j|0)){break e}d=0;t=0;if(j){o[6257]=o[6257]+1;t=l[o[4968]](u(j,24),16)|0;h=o[b+4>>2];}if((h|0)>=1){while(1){g=u(d,24);y=g+t|0;f=y;i=g+o[b+12>>2]|0;g=o[i+4>>2];o[f>>2]=o[i>>2];o[f+4>>2]=g;g=o[i+20>>2];o[f+16>>2]=o[i+16>>2];o[f+20>>2]=g;g=o[i+12>>2];o[f+8>>2]=o[i+8>>2];o[f+12>>2]=g;d=d+1|0;if((h|0)!=(d|0)){continue}break}}d=o[b+12>>2];if(d){if(p[b+16|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[b+12>>2]=0;}o[b+12>>2]=t;m[b+16|0]=1;o[b+8>>2]=j;h=o[b+4>>2];}d=o[e+28>>2];f=o[b+12>>2]+u(h,24)|0;o[f>>2]=o[e+24>>2];o[f+4>>2]=d;d=o[e+44>>2];o[f+16>>2]=o[e+40>>2];o[f+20>>2]=d;d=o[e+36>>2];o[f+8>>2]=o[e+32>>2];o[f+12>>2]=d;e=o[b+4>>2]+1|0;o[b+4>>2]=e;if(o[a+4>>2]==2){break b}t=2;while(1){f:{if((e|0)<2){break f}g=o[a+12>>2]+u(t,24)|0;D=s[g+8>>2];E=s[g+4>>2];F=s[g>>2];G=s[c+8>>2];I=s[c+4>>2];J=s[c>>2];h=o[b+12>>2];d=e;while(1){e=u(d,24)+h|0;f=e+ -48|0;k=s[f>>2];e=e+ -24|0;x=v(k-s[e>>2]);n=s[f+4>>2];z=v(n-E);n=v(n-s[e+4>>2]);q=v(k-F);B=v(v(v(x*z)-v(n*q))*G);A=n;n=s[f+8>>2];k=v(n-D);n=v(n-s[e+8>>2]);if(!(v(B+v(v(J*v(v(A*k)-v(n*z)))+v(I*v(v(n*q)-v(x*k)))))>v(0))){e=d+ -1|0;o[b+4>>2]=e;f=(d|0)>2;d=e;if(f){continue}break f}break}g:{if(o[b+8>>2]!=(d|0)){break g}y=d<<1;if((d|0)>=(y|0)){break g}o[6257]=o[6257]+1;h=l[o[4968]](u(d,48),16)|0;d=0;j=o[b+4>>2];if((j|0)>=1){while(1){e=u(d,24);i=e+h|0;f=i;i=e+o[b+12>>2]|0;e=o[i+4>>2];o[f>>2]=o[i>>2];o[f+4>>2]=e;e=o[i+20>>2];o[f+16>>2]=o[i+16>>2];o[f+20>>2]=e;e=o[i+12>>2];o[f+8>>2]=o[i+8>>2];o[f+12>>2]=e;d=d+1|0;if((j|0)!=(d|0)){continue}break}}e=o[b+12>>2];if(e){if(p[b+16|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[b+12>>2]=0;}o[b+12>>2]=h;m[b+16|0]=1;o[b+8>>2]=y;d=o[b+4>>2];}e=o[g+4>>2];f=u(d,24)+h|0;d=f;o[d>>2]=o[g>>2];o[d+4>>2]=e;e=o[g+20>>2];o[d+16>>2]=o[g+16>>2];o[d+20>>2]=e;e=o[g+12>>2];o[d+8>>2]=o[g+8>>2];o[d+12>>2]=e;e=o[b+4>>2]+1|0;o[b+4>>2]=e;}if((e|0)==1){e=o[a+12>>2]+u(t,24)|0;d=1;if(o[b+8>>2]==1){o[6257]=o[6257]+1;y=l[o[4968]](48,16)|0;d=0;j=o[b+4>>2];if((j|0)>=1){while(1){g=u(d,24);i=g+y|0;f=i;i=g+o[b+12>>2]|0;g=o[i+4>>2];o[f>>2]=o[i>>2];o[f+4>>2]=g;g=o[i+20>>2];o[f+16>>2]=o[i+16>>2];o[f+20>>2]=g;g=o[i+12>>2];o[f+8>>2]=o[i+8>>2];o[f+12>>2]=g;d=d+1|0;if((j|0)!=(d|0)){continue}break}}d=o[b+12>>2];if(d){if(p[b+16|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[b+12>>2]=0;}o[b+12>>2]=y;m[b+16|0]=1;o[b+8>>2]=2;d=o[b+4>>2];}f=o[b+12>>2]+u(d,24)|0;d=o[e+4>>2];o[f>>2]=o[e>>2];o[f+4>>2]=d;d=o[e+20>>2];o[f+16>>2]=o[e+16>>2];o[f+20>>2]=d;d=o[e+12>>2];o[f+8>>2]=o[e+8>>2];o[f+12>>2]=d;e=o[b+4>>2]+1|0;o[b+4>>2]=e;}t=t+1|0;if((t|0)!=o[a+4>>2]){continue}break}break b}if((h|0)!=1){break b}h=o[b+4>>2];while(1){c=o[a+12>>2];h:{if(o[b+8>>2]!=(h|0)){break h}j=h?h<<1:1;if((h|0)>=(j|0)){break h}d=0;t=0;if(j){o[6257]=o[6257]+1;t=l[o[4968]](u(j,24),16)|0;h=o[b+4>>2];}if((h|0)>=1){while(1){g=u(d,24);y=g+t|0;f=y;i=g+o[b+12>>2]|0;g=o[i+4>>2];o[f>>2]=o[i>>2];o[f+4>>2]=g;g=o[i+20>>2];o[f+16>>2]=o[i+16>>2];o[f+20>>2]=g;g=o[i+12>>2];o[f+8>>2]=o[i+8>>2];o[f+12>>2]=g;d=d+1|0;if((h|0)!=(d|0)){continue}break}}d=o[b+12>>2];if(d){if(p[b+16|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[b+12>>2]=0;}o[b+12>>2]=t;m[b+16|0]=1;o[b+8>>2]=j;h=o[b+4>>2];}d=o[c+4>>2];f=o[b+12>>2]+u(h,24)|0;o[f>>2]=o[c>>2];o[f+4>>2]=d;d=o[c+20>>2];o[f+16>>2]=o[c+16>>2];o[f+20>>2]=d;d=o[c+12>>2];o[f+8>>2]=o[c+8>>2];o[f+12>>2]=d;h=o[b+4>>2]+1|0;o[b+4>>2]=h;e=e+1|0;if((e|0)<o[a+4>>2]){continue}break}}K=r+32|0;}function Sg(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0,q=0,r=0,s=0,t=0,v=0,w=0;d=K-144|0;K=d;a:{if((c|0)<=0){b=o[a+12>>2];if(b){if(p[a+16|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+12>>2]=0;}o[a+12>>2]=0;m[a+16|0]=1;o[a+4>>2]=0;o[a+8>>2]=0;b=o[a+32>>2];if(b){if(p[a+36|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+32>>2]=0;}o[a+32>>2]=0;o[a+24>>2]=0;o[a+28>>2]=0;m[a+36|0]=1;b=o[a+52>>2];if(b){if(p[a+56|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+52>>2]=0;}o[a+52>>2]=0;o[a+44>>2]=0;o[a+48>>2]=0;m[a+56|0]=1;break a}m[d+112|0]=1;o[d+88>>2]=0;o[d+92>>2]=256;o[d+72>>2]=0;o[d+76>>2]=256;o[d+56>>2]=0;o[d+60>>2]=256;o[d+108>>2]=0;o[d+100>>2]=0;o[d+104>>2]=0;o[d+80>>2]=0;o[d+84>>2]=0;o[d+64>>2]=0;o[d+68>>2]=0;o[d+48>>2]=0;o[d+52>>2]=0;nu(d+16|0,b,c);c=o[a+4>>2];if((c|0)<=-1){if(o[a+8>>2]<=-1){b=o[a+12>>2];if(b){if(p[a+16|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+12>>2]=0;}m[a+16|0]=1;o[a+8>>2]=0;o[a+12>>2]=0;}while(1){b=o[d+4>>2];e=o[a+12>>2]+(c<<4)|0;o[e>>2]=o[d>>2];o[e+4>>2]=b;b=o[d+12>>2];o[e+8>>2]=o[d+8>>2];o[e+12>>2]=b;b=c+1|0;e=b>>>0>=c>>>0;c=b;if(e){continue}break}}o[a+4>>2]=0;o[d+8>>2]=0;o[d>>2]=0;o[d+4>>2]=0;c=o[a+24>>2];if((c|0)<=-1){if(o[a+28>>2]<=-1){b=o[a+32>>2];if(b){if(p[a+36|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+32>>2]=0;}o[a+28>>2]=0;o[a+32>>2]=0;m[a+36|0]=1;}while(1){b=o[d+4>>2];e=o[a+32>>2]+u(c,12)|0;o[e>>2]=o[d>>2];o[e+4>>2]=b;o[e+8>>2]=o[d+8>>2];b=c+1|0;e=b>>>0>=c>>>0;c=b;if(e){continue}break}}o[a+24>>2]=0;c=o[a+44>>2];if((c|0)<=-1){b=o[a+52>>2];if(o[a+48>>2]<=-1){if(!(!b|!p[a+56|0])){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}m[a+56|0]=1;o[a+48>>2]=0;o[a+52>>2]=0;b=0;}e=b;b=c<<2;$(e+b|0,0,0-b|0);}o[a+44>>2]=0;b=o[d+140>>2];b:{if(o[b+104>>2]>-1){break b}o[b+104>>2]=0;o[6257]=o[6257]+1;k=l[o[4968]](4,16)|0;o[k>>2]=b;c=0;j=1;q=1;while(1){w=c;g=o[(c<<2)+k>>2];mu(d,d+16|0,g);f=o[a+4>>2];c:{if((f|0)!=o[a+8>>2]){break c}v=f?f<<1:1;if((f|0)>=(v|0)){break c}c=0;e=0;if(v){o[6257]=o[6257]+1;e=l[o[4968]](v<<4,16)|0;f=o[a+4>>2];}if((f|0)>=1){while(1){b=c<<4;i=b+e|0;h=b+o[a+12>>2]|0;b=o[h+4>>2];o[i>>2]=o[h>>2];o[i+4>>2]=b;b=o[h+12>>2];o[i+8>>2]=o[h+8>>2];o[i+12>>2]=b;c=c+1|0;if((f|0)!=(c|0)){continue}break}}b=o[a+12>>2];if(b){if(p[a+16|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+12>>2]=0;}o[a+12>>2]=e;m[a+16|0]=1;o[a+8>>2]=v;f=o[a+4>>2];}b=o[d+4>>2];c=o[a+12>>2]+(f<<4)|0;o[c>>2]=o[d>>2];o[c+4>>2]=b;b=o[d+12>>2];o[c+8>>2]=o[d+8>>2];o[c+12>>2]=b;o[a+4>>2]=o[a+4>>2]+1;i=-1;t=-1;v=o[g+8>>2];b=v;if(b){while(1){c=o[b+20>>2];if((c|0)<=-1){f=o[a+24>>2];o[d+8>>2]=0;o[d>>2]=0;o[d+4>>2]=0;c=f;d:{if((c|0)!=o[a+28>>2]){break d}n=c?c<<1:1;if((f|0)>=(n|0)){break d}c=0;e=f;g=0;if(n){o[6257]=o[6257]+1;g=l[o[4968]](u(n,12),16)|0;e=o[a+24>>2];}if((e|0)>=1){while(1){h=u(c,12);r=h+o[a+32>>2]|0;s=g+h|0;h=o[r+4>>2];o[s>>2]=o[r>>2];o[s+4>>2]=h;o[s+8>>2]=o[r+8>>2];c=c+1|0;if((e|0)!=(c|0)){continue}break}}c=o[a+32>>2];if(c){if(p[a+36|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+32>>2]=0;}o[a+32>>2]=g;m[a+36|0]=1;o[a+28>>2]=n;c=o[a+24>>2];}e=o[a+32>>2]+u(c,12)|0;c=o[d+4>>2];o[e>>2]=o[d>>2];o[e+4>>2]=c;o[e+8>>2]=o[d+8>>2];e=o[a+24>>2]+1|0;o[a+24>>2]=e;o[d+8>>2]=0;o[d>>2]=0;o[d+4>>2]=0;e:{if(o[a+28>>2]!=(e|0)){break e}n=e?e<<1:1;if((e|0)>=(n|0)){break e}c=0;g=0;if(n){o[6257]=o[6257]+1;g=l[o[4968]](u(n,12),16)|0;e=o[a+24>>2];}if((e|0)>=1){while(1){h=u(c,12);r=h+o[a+32>>2]|0;s=g+h|0;h=o[r+4>>2];o[s>>2]=o[r>>2];o[s+4>>2]=h;o[s+8>>2]=o[r+8>>2];c=c+1|0;if((e|0)!=(c|0)){continue}break}}c=o[a+32>>2];if(c){if(p[a+36|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+32>>2]=0;}o[a+32>>2]=g;m[a+36|0]=1;o[a+28>>2]=n;e=o[a+24>>2];}c=o[d+4>>2];e=o[a+32>>2]+u(e,12)|0;o[e>>2]=o[d>>2];o[e+4>>2]=c;o[e+8>>2]=o[d+8>>2];o[a+24>>2]=o[a+24>>2]+1;n=o[a+32>>2];o[b+20>>2]=f;h=f+1|0;o[o[b+8>>2]+20>>2]=h;r=u(f,12)+n|0;o[r+16>>2]=-1;o[r+4>>2]=1;s=o[b+12>>2];c=o[s+104>>2];f:{if((c|0)>-1){e=j;j=c;break f}o[s+104>>2]=j;g:{h:{if((j|0)!=(q|0)){break h}g=q?q<<1:1;if((q|0)>=(g|0)){break h}c=0;f=0;if(g){o[6257]=o[6257]+1;f=l[o[4968]](g<<2,16)|0;}i:{if((q|0)>=1){while(1){e=c<<2;o[e+f>>2]=o[e+k>>2];c=c+1|0;if((q|0)!=(c|0)){continue}break i}}if(!k){break g}}if(k){o[6258]=o[6258]+1;l[o[4969]](k);}break g}f=k;g=q;}o[(j<<2)+f>>2]=s;e=j+1|0;k=f;q=g;}o[r+8>>2]=j;o[(u(h,12)+n|0)+8>>2]=w;j=e;c=o[b+20>>2];}e=c;if((i|0)>=0){o[o[a+32>>2]+u(c,12)>>2]=i-c;e=t;}i=c;t=e;b=o[b>>2];if((v|0)!=(b|0)){continue}break}o[o[a+32>>2]+u(t,12)>>2]=i-t;}c=w+1|0;if((c|0)<(j|0)){continue}break}j=0;while(1){g=o[o[(j<<2)+k>>2]+8>>2];b=g;if(b){while(1){c=o[b+20>>2];if((c|0)>=0){f=o[a+44>>2];j:{if((f|0)!=o[a+48>>2]){break j}i=f?f<<1:1;if((f|0)>=(i|0)){break j}c=0;e=0;if(i){o[6257]=o[6257]+1;e=l[o[4968]](i<<2,16)|0;f=o[a+44>>2];}t=o[a+52>>2];k:{l:{if((f|0)>=1){while(1){q=c<<2;o[q+e>>2]=o[q+t>>2];c=c+1|0;if((f|0)!=(c|0)){continue}break l}}if(!t){break k}}if(p[a+56|0]){c=t;if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+52>>2]=0;f=o[a+44>>2];}o[a+52>>2]=e;m[a+56|0]=1;o[a+48>>2]=i;c=o[b+20>>2];}o[o[a+52>>2]+(f<<2)>>2]=c;o[a+44>>2]=o[a+44>>2]+1;c=b;while(1){o[c+20>>2]=-1;c=o[o[c+8>>2]+4>>2];if((c|0)!=(b|0)){continue}break}}b=o[b>>2];if((g|0)!=(b|0)){continue}break}}b=(j|0)==(w|0);j=j+1|0;if(!b){continue}break}if(!k){break b}if(k){o[6258]=o[6258]+1;l[o[4969]](k);}}a=o[d+108>>2];if(a){if(p[d+112|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[d+108>>2]=0;}o[d+108>>2]=0;m[d+112|0]=1;o[d+100>>2]=0;o[d+104>>2]=0;while(1){b=o[d+80>>2];if(b){o[d+80>>2]=o[b+8>>2];a=o[b>>2];if(a){o[6258]=o[6258]+1;l[o[4969]](a);}if(b){o[6258]=o[6258]+1;l[o[4969]](b);}continue}break}while(1){b=o[d+64>>2];if(b){o[d+64>>2]=o[b+8>>2];a=o[b>>2];if(a){o[6258]=o[6258]+1;l[o[4969]](a);}if(b){o[6258]=o[6258]+1;l[o[4969]](b);}continue}break}while(1){b=o[d+48>>2];if(!b){break a}o[d+48>>2]=o[b+8>>2];a=o[b>>2];if(a){o[6258]=o[6258]+1;l[o[4969]](a);}if(b){o[6258]=o[6258]+1;l[o[4969]](b);}continue}}K=d+144|0;}function ff(a,b,c){var d=0,e=v(0),f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=0,l=0,m=0,n=0,p=v(0),q=v(0),r=0,t=0,w=0,x=v(0),y=v(0),z=v(0),A=v(0),B=0,D=0,E=0,F=0,G=0;d=K-96|0;K=d;o[a+376>>2]=0;o[a+364>>2]=4;o[a+368>>2]=0;k=a+316|0;o[a+360>>2]=k;o[a+356>>2]=a+284;o[a+352>>2]=a+252;o[a+348>>2]=a+220;f=o[b+4>>2];o[a>>2]=o[b>>2];o[a+4>>2]=f;f=o[b+20>>2];o[a+16>>2]=o[b+16>>2];o[a+20>>2]=f;f=o[b+12>>2];o[a+8>>2]=o[b+8>>2];o[a+12>>2]=f;f=o[b+36>>2];o[a+32>>2]=o[b+32>>2];o[a+36>>2]=f;f=o[b+28>>2];o[a+24>>2]=o[b+24>>2];o[a+28>>2]=f;f=o[b+52>>2];o[a+48>>2]=o[b+48>>2];o[a+52>>2]=f;f=o[b+44>>2];o[a+40>>2]=o[b+40>>2];o[a+44>>2]=f;m=b- -64|0;n=o[m+4>>2];f=a- -64|0;o[f>>2]=o[m>>2];o[f+4>>2]=n;f=o[b+60>>2];o[a+56>>2]=o[b+56>>2];o[a+60>>2]=f;f=o[b+84>>2];o[a+80>>2]=o[b+80>>2];o[a+84>>2]=f;f=o[b+76>>2];o[a+72>>2]=o[b+72>>2];o[a+76>>2]=f;f=o[b+100>>2];o[a+96>>2]=o[b+96>>2];o[a+100>>2]=f;f=o[b+92>>2];o[a+88>>2]=o[b+88>>2];o[a+92>>2]=f;f=o[b+108>>2];o[a+104>>2]=o[b+104>>2];o[a+108>>2]=f;f=o[b+116>>2];o[a+112>>2]=o[b+112>>2];o[a+116>>2]=f;f=o[b+124>>2];b=o[b+120>>2];o[a+180>>2]=0;o[a+144>>2]=0;o[a+120>>2]=b;o[a+124>>2]=f;b=o[c+12>>2];o[a+136>>2]=o[c+8>>2];o[a+140>>2]=b;b=o[c+4>>2];o[a+128>>2]=o[c>>2];o[a+132>>2]=b;f=a+128|0;e=s[a+128>>2];i=s[a+132>>2];h=s[a+136>>2];p=v(v(v(e*e)+v(i*i))+v(h*h));a:{if(!!(p>v(0))){s[d+40>>2]=-h;s[d+36>>2]=-i;s[d+32>>2]=-e;break a}o[d+40>>2]=0;o[d+32>>2]=1065353216;o[d+36>>2]=0;}o[d+44>>2]=0;o[a+364>>2]=3;o[a+164>>2]=0;o[a+180>>2]=1;o[a+148>>2]=k;Ia(a,d+32|0,k);o[a+164>>2]=1065353216;b=o[a+148>>2];c=o[b+20>>2];o[f>>2]=o[b+16>>2];o[f+4>>2]=c;c=o[b+28>>2];o[f+8>>2]=o[b+24>>2];o[f+12>>2]=c;c=o[b+28>>2];o[d+88>>2]=o[b+24>>2];o[d+92>>2]=c;c=o[b+20>>2];o[d+80>>2]=o[b+16>>2];o[d+84>>2]=c;c=o[b+28>>2];o[d+72>>2]=o[b+24>>2];o[d+76>>2]=c;c=o[b+20>>2];o[d+64>>2]=o[b+16>>2];o[d+68>>2]=c;c=o[b+28>>2];o[d+56>>2]=o[b+24>>2];o[d+60>>2]=c;c=o[b+20>>2];o[d+48>>2]=o[b+16>>2];o[d+52>>2]=c;c=o[b+28>>2];o[d+40>>2]=o[b+24>>2];o[d+44>>2]=c;c=o[b+20>>2];o[d+32>>2]=o[b+16>>2];o[d+36>>2]=c;e=s[a+136>>2];i=s[a+132>>2];h=s[a+128>>2];k=o[a+368>>2];b:{c:{d:{while(1){q=v(C(v(v(v(h*h)+v(i*i))+v(e*e))));if(!!(q<v(9999999747378752e-20))){o[a+376>>2]=1;break d}o[d+28>>2]=0;s[d+24>>2]=-e;s[d+20>>2]=-i;s[d+16>>2]=-h;c=u(k,36)+a|0;m=c+148|0;b=o[c+180>>2];n=m+(b<<2)|0;o[n+16>>2]=0;l=o[a+364>>2]+ -1|0;o[a+364>>2]=l;r=n;n=o[((l<<2)+a|0)+348>>2];o[r>>2]=n;o[c+180>>2]=b+1;Ia(a,d+16|0,n);e:{l=o[c+180>>2];b=o[(m+(l<<2)|0)+ -4>>2];e=s[b+16>>2];i=v(e-s[d+32>>2]);g=v(i*i);i=s[b+20>>2];h=v(i-s[d+36>>2]);j=v(g+v(h*h));h=s[b+24>>2];g=v(h-s[d+40>>2]);if(v(j+v(g*g))<v(9999999747378752e-20)){break e}g=v(e-s[d+48>>2]);j=v(g*g);g=v(i-s[d+52>>2]);j=v(j+v(g*g));g=v(h-s[d+56>>2]);if(!!(v(j+v(g*g))<v(9999999747378752e-20))){break e}g=v(e-s[d+64>>2]);j=v(g*g);g=v(i-s[d+68>>2]);j=v(j+v(g*g));g=v(h-s[d+72>>2]);if(v(j+v(g*g))<v(9999999747378752e-20)){break e}g=v(e-s[d+80>>2]);j=v(g*g);g=v(i-s[d+84>>2]);j=v(j+v(g*g));g=v(h-s[d+88>>2]);if(v(j+v(g*g))<v(9999999747378752e-20)){break e}w=o[b+28>>2];B=B+1&3;n=(d+32|0)+(B<<4)|0;o[n+8>>2]=o[b+24>>2];o[n+12>>2]=w;r=o[b+20>>2];o[n>>2]=o[b+16>>2];o[n+4>>2]=r;e=v(v(v(v(s[a+128>>2]*e)+v(s[a+132>>2]*i))+v(s[a+136>>2]*h))/q);x=e>x?e:x;if(!!(v(v(q-x)+v(q*v(-9999999747378752e-20)))<=v(0))){k=o[a+368>>2];c=u(k,36)+a|0;b=o[c+180>>2]+ -1|0;o[c+180>>2]=b;b=o[(c+(b<<2)|0)+148>>2];c=o[a+364>>2];o[a+364>>2]=c+1;o[((c<<2)+a|0)+348>>2]=b;break d}o[d+12>>2]=0;f:{g:{b=l+ -2|0;h:{if(b>>>0>2){break h}i:{switch(b-1|0){default:b=o[c+152>>2];y=s[b+16>>2];m=o[m>>2];p=s[m+16>>2];q=v(y-p);z=s[b+20>>2];i=s[m+20>>2];g=v(z-i);A=s[b+24>>2];h=s[m+24>>2];j=v(A-h);e=v(v(v(q*q)+v(g*g))+v(j*j));if(!(e>v(0))){break g}e=v(v(-v(v(v(p*q)+v(i*g))+v(h*j)))/e);if(!!(e>=v(1))){o[d+16>>2]=0;o[d+20>>2]=1065353216;o[d+12>>2]=2;p=v(v(v(y*y)+v(z*z))+v(A*A));break h}if(!!(e<=v(0))){o[d+16>>2]=1065353216;o[d+20>>2]=0;o[d+12>>2]=1;p=v(v(v(p*p)+v(i*i))+v(h*h));break h}o[d+12>>2]=3;s[d+20>>2]=e;s[d+16>>2]=v(1)-e;h=v(h+v(j*e));p=v(p+v(q*e));e=v(i+v(g*e));p=v(v(h*h)+v(v(p*p)+v(e*e)));break h;case 0:p=ef(o[m>>2]+16|0,o[c+152>>2]+16|0,o[c+156>>2]+16|0,d+16|0,d+12|0);break h;case 1:break i}}p=Nl(o[m>>2]+16|0,o[c+152>>2]+16|0,o[c+156>>2]+16|0,o[c+160>>2]+16|0,d+16|0,d+12|0);}if(!(p>=v(0))){break g}b=0;k=1-k|0;r=u(k,36)+a|0;m=r;o[m+180>>2]=0;o[f+8>>2]=0;o[f+12>>2]=0;o[f>>2]=0;o[f+4>>2]=0;o[a+368>>2]=k;e=v(0);n=o[d+12>>2];i=v(0);h=v(0);w=o[c+180>>2];if(!w){break f}while(1){t=b<<2;D=t+c|0;l=o[D+148>>2];j:{if(n>>>b&1){E=o[m+180>>2];F=(E<<2)+r|0;o[F+148>>2]=l;l=t+(d+16|0)|0;e=s[l>>2];l=o[l>>2];o[m+180>>2]=E+1;o[F+164>>2]=l;l=o[D+148>>2];q=s[l+24>>2];i=s[l+20>>2];h=v(v(s[l+16>>2]*e)+s[a+128>>2]);s[a+128>>2]=h;i=v(v(i*e)+s[a+132>>2]);s[a+132>>2]=i;e=v(v(q*e)+s[a+136>>2]);s[a+136>>2]=e;break j}t=o[a+364>>2];o[a+364>>2]=t+1;o[((t<<2)+a|0)+348>>2]=l;}b=b+1|0;if((w|0)!=(b|0)){continue}break}break f}k=o[a+368>>2];c=u(k,36)+a|0;b=o[c+180>>2]+ -1|0;o[c+180>>2]=b;b=o[(c+(b<<2)|0)+148>>2];c=o[a+364>>2];o[a+364>>2]=c+1;o[((c<<2)+a|0)+348>>2]=b;break d}if((n|0)==15){o[a+376>>2]=1;}if((G|0)==127){b=2;o[a+376>>2]=2;o[a+372>>2]=(u(k,36)+a|0)+148;break b}G=G+1|0;b=o[a+376>>2];if(!b){continue}break c}break}k=o[a+368>>2];c=u(k,36)+a|0;b=o[c+180>>2]+ -1|0;o[c+180>>2]=b;b=o[(c+(b<<2)|0)+148>>2];c=o[a+364>>2];o[a+364>>2]=c+1;o[((c<<2)+a|0)+348>>2]=b;}b=o[a+376>>2];}o[a+372>>2]=(u(k,36)+a|0)+148;if(b>>>0>1){break b}if(b-1){e=s[a+128>>2];g=v(e*e);e=s[a+132>>2];g=v(g+v(e*e));e=s[a+136>>2];s[a+144>>2]=C(v(g+v(e*e)));b=0;break b}o[a+144>>2]=0;b=1;}K=d+96|0;return b}function Fl(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;var k=v(0),n=v(0),q=v(0),r=v(0),t=0,u=0,w=v(0),x=v(0),y=v(0),z=v(0),A=0,B=v(0),C=0,D=v(0),E=v(0),F=v(0),G=v(0),H=0,I=0,J=0,L=v(0);a=K-4240|0;K=a;J=o[c+4>>2]+ -17>>>0<=1?o[d+4>>2]+ -17>>>0<2:J;while(1){Nb();x=s[e+32>>2];y=s[e+16>>2];z=s[e>>2];w=s[e+36>>2];D=s[e+20>>2];B=s[e+4>>2];k=s[e+40>>2];n=s[e+24>>2];E=s[e+8>>2];A=C<<4;t=A+(a+1264|0)|0;o[t+12>>2]=0;r=s[A+21556>>2];q=v(-r);G=v(n*q);n=s[A+21552>>2];F=k;k=s[A+21560>>2];s[t+8>>2]=v(G-v(E*n))-v(F*k);s[t+4>>2]=v(v(D*q)-v(n*B))-v(k*w);s[t>>2]=v(v(y*q)-v(n*z))-v(k*x);q=s[f+40>>2];x=s[f+8>>2];y=s[f+24>>2];z=s[f+36>>2];w=s[f+4>>2];D=s[f+20>>2];B=s[f+32>>2];E=s[f>>2];F=s[f+16>>2];A=A+(a+272|0)|0;o[A+12>>2]=0;s[A>>2]=v(v(n*E)+v(r*F))+v(k*B);s[A+4>>2]=v(v(n*w)+v(r*D))+v(k*z);s[A+8>>2]=v(v(n*x)+v(r*y))+v(k*q);C=C+1|0;if((C|0)!=42){continue}break}A=42;I=l[o[o[c>>2]+84>>2]](c)|0;if((I|0)>=1){C=0;while(1){l[o[o[c>>2]+88>>2]](c,C,a+3248|0);q=s[e+8>>2];x=s[e>>2];y=s[e+4>>2];z=s[e+24>>2];w=s[e+16>>2];D=s[e+20>>2];r=s[e+40>>2];n=s[e+32>>2];k=s[e+36>>2];o[a+3260>>2]=0;F=n;n=s[a+3248>>2];B=k;k=s[a+3252>>2];E=r;r=s[a+3256>>2];s[a+3256>>2]=v(v(F*n)+v(B*k))+v(E*r);s[a+3252>>2]=v(v(n*w)+v(k*D))+v(r*z);s[a+3248>>2]=v(v(x*n)+v(y*k))+v(q*r);Nb();H=o[a+3260>>2];t=A<<4;u=t+21560|0;o[u>>2]=o[a+3256>>2];o[u+4>>2]=H;H=o[a+3252>>2];u=t+21552|0;o[u>>2]=o[a+3248>>2];o[u+4>>2]=H;x=s[e+40>>2];y=s[e+24>>2];z=s[e+8>>2];w=s[e+36>>2];D=s[e+20>>2];B=s[e+4>>2];k=s[e+32>>2];n=s[e+16>>2];E=s[e>>2];u=t+(a+1264|0)|0;o[u+12>>2]=0;r=s[a+3252>>2];q=v(-r);G=v(n*q);n=s[a+3248>>2];F=k;k=s[a+3256>>2];s[u>>2]=v(G-v(E*n))-v(F*k);s[u+4>>2]=v(v(D*q)-v(n*B))-v(k*w);s[u+8>>2]=v(v(y*q)-v(n*z))-v(k*x);q=s[f+32>>2];x=s[f>>2];y=s[f+16>>2];z=s[f+36>>2];w=s[f+4>>2];D=s[f+20>>2];B=s[f+40>>2];E=s[f+8>>2];F=s[f+24>>2];t=t+(a+272|0)|0;o[t+12>>2]=0;s[t+8>>2]=v(v(n*E)+v(r*F))+v(k*B);s[t+4>>2]=v(v(n*w)+v(r*D))+v(k*z);s[t>>2]=v(v(n*x)+v(r*y))+v(k*q);A=A+1|0;C=C+1|0;if((I|0)!=(C|0)){continue}break}}I=l[o[o[d>>2]+84>>2]](d)|0;if((I|0)>=1){C=0;while(1){l[o[o[d>>2]+88>>2]](d,C,a+3248|0);q=s[f+8>>2];x=s[f>>2];y=s[f+4>>2];z=s[f+24>>2];w=s[f+16>>2];D=s[f+20>>2];r=s[f+40>>2];n=s[f+32>>2];k=s[f+36>>2];o[a+3260>>2]=0;F=n;n=s[a+3248>>2];B=k;k=s[a+3252>>2];E=r;r=s[a+3256>>2];s[a+3256>>2]=v(v(F*n)+v(B*k))+v(E*r);s[a+3252>>2]=v(v(n*w)+v(k*D))+v(r*z);s[a+3248>>2]=v(v(x*n)+v(y*k))+v(q*r);Nb();H=o[a+3260>>2];t=A<<4;u=t+21560|0;o[u>>2]=o[a+3256>>2];o[u+4>>2]=H;H=o[a+3252>>2];u=t+21552|0;o[u>>2]=o[a+3248>>2];o[u+4>>2]=H;x=s[e+40>>2];y=s[e+24>>2];z=s[e+8>>2];w=s[e+36>>2];D=s[e+20>>2];B=s[e+4>>2];k=s[e+32>>2];n=s[e+16>>2];E=s[e>>2];u=t+(a+1264|0)|0;o[u+12>>2]=0;r=s[a+3252>>2];q=v(-r);G=v(n*q);n=s[a+3248>>2];F=k;k=s[a+3256>>2];s[u>>2]=v(G-v(E*n))-v(F*k);s[u+4>>2]=v(v(D*q)-v(n*B))-v(k*w);s[u+8>>2]=v(v(y*q)-v(n*z))-v(k*x);q=s[f+32>>2];x=s[f>>2];y=s[f+16>>2];z=s[f+36>>2];w=s[f+4>>2];D=s[f+20>>2];B=s[f+40>>2];E=s[f+8>>2];F=s[f+24>>2];t=t+(a+272|0)|0;o[t+12>>2]=0;s[t+8>>2]=v(v(n*E)+v(r*F))+v(k*B);s[t+4>>2]=v(v(n*w)+v(r*D))+v(k*z);s[t>>2]=v(v(n*x)+v(r*y))+v(k*q);A=A+1|0;C=C+1|0;if((I|0)!=(C|0)){continue}break}}l[o[o[c>>2]+76>>2]](c,a+1264|0,a+3248|0,A);l[o[o[d>>2]+76>>2]](d,a+272|0,a+2256|0,A);a:{if((A|0)<1){q=v(0xde0b6b000000000);n=v(0);k=v(0);r=v(0);D=v(0);break a}C=0;q=v(0xde0b6b000000000);D=v(0);r=v(0);k=v(0);n=v(0);while(1){Nb();t=C<<4;x=s[t+21552>>2];y=s[t+21556>>2];z=J?v(0):s[t+21560>>2];b:{if(!(+v(v(v(x*x)+v(y*y))+v(z*z))>.01)){break b}u=t+(a+2256|0)|0;w=s[u>>2];B=s[u+4>>2];E=s[u+8>>2];u=t+(a+3248|0)|0;F=s[u>>2];G=s[u+4>>2];L=s[u+8>>2];w=v(v(v(x*v(v(v(v(v(w*s[f>>2])+v(B*s[f+4>>2]))+v(E*s[f+8>>2]))+s[f+48>>2])-v(v(v(v(F*s[e>>2])+v(G*s[e+4>>2]))+v(L*s[e+8>>2]))+s[e+48>>2])))+v(y*v(v(v(v(v(w*s[f+16>>2])+v(B*s[f+20>>2]))+v(E*s[f+24>>2]))+s[f+52>>2])-v(v(v(v(F*s[e+16>>2])+v(G*s[e+20>>2]))+v(L*s[e+24>>2]))+s[e+52>>2]))))+v(z*(J?v(0):v(v(v(v(v(w*s[f+32>>2])+v(B*s[f+36>>2]))+v(E*s[f+40>>2]))+s[f+56>>2])-v(v(v(v(F*s[e+32>>2])+v(G*s[e+36>>2]))+v(L*s[e+40>>2]))+s[e+56>>2])))));if(!(w<q)){break b}D=s[t+21564>>2];n=x;k=y;r=z;q=w;}C=C+1|0;if((C|0)!=(A|0)){continue}break}}Fc(c);Fc(d);A=0;if(!(q<v(0))){x=Fc(c);y=Fc(d);b=Wc(a+192|0,c,d,b,0);z=s[e+52>>2];w=s[e+56>>2];B=s[e+48>>2];d=o[e+12>>2];c=a- -64|0;o[c>>2]=o[e+8>>2];o[c+4>>2]=d;c=o[e+4>>2];o[a+56>>2]=o[e>>2];o[a+60>>2]=c;c=o[e+28>>2];o[a+80>>2]=o[e+24>>2];o[a+84>>2]=c;c=o[e+20>>2];o[a+72>>2]=o[e+16>>2];o[a+76>>2]=c;c=o[e+40>>2];d=o[e+44>>2];C=o[e+32>>2];e=o[e+36>>2];o[a+116>>2]=0;q=v(q+v(v(x+y)+v(.5)));s[a+112>>2]=w+v(r*q);s[a+108>>2]=z+v(k*q);o[a+96>>2]=c;o[a+100>>2]=d;s[a+104>>2]=B+v(n*q);o[a+88>>2]=C;o[a+92>>2]=e;c=o[f+12>>2];o[a+128>>2]=o[f+8>>2];o[a+132>>2]=c;c=o[f+4>>2];o[a+120>>2]=o[f>>2];o[a+124>>2]=c;c=o[f+28>>2];o[a+144>>2]=o[f+24>>2];o[a+148>>2]=c;c=o[f+20>>2];o[a+136>>2]=o[f+16>>2];o[a+140>>2]=c;c=o[f+44>>2];o[a+160>>2]=o[f+40>>2];o[a+164>>2]=c;c=o[f+36>>2];o[a+152>>2]=o[f+32>>2];o[a+156>>2]=c;c=o[f+60>>2];o[a+176>>2]=o[f+56>>2];o[a+180>>2]=c;c=o[f+52>>2];o[a+168>>2]=o[f+48>>2];o[a+172>>2]=c;o[a+184>>2]=1566444395;m[a+48|0]=0;o[a+8>>2]=4584;o[b+16>>2]=0;s[b+12>>2]=-r;s[b+8>>2]=-k;s[b+4>>2]=-n;Ha(b,a+56|0,a+8|0,j);b=p[a+48|0];if(b){x=s[a+44>>2];y=s[a+32>>2];z=s[a+36>>2];w=s[a+28>>2];o[h+12>>2]=0;q=v(q-x);s[h>>2]=w-v(n*q);s[h+8>>2]=z-v(r*q);s[h+4>>2]=y-v(k*q);c=o[a+40>>2];o[i+8>>2]=o[a+36>>2];o[i+12>>2]=c;c=o[a+32>>2];o[i>>2]=o[a+28>>2];o[i+4>>2]=c;s[g+12>>2]=D;s[g+8>>2]=r;s[g+4>>2]=k;s[g>>2]=n;}A=(b|0)!=0;}K=a+4240|0;return A|0}function fe(a){var b=0,c=0,d=0,e=0,f=v(0),i=v(0),j=0,k=v(0),t=v(0),x=v(0),y=0,z=v(0),A=0,B=v(0),D=v(0),E=v(0),F=0,G=0,H=0,I=0,J=v(0),L=v(0),M=0,N=0,O=0,P=0,Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0);c=K-96|0;K=c;m[c+52|0]=1;o[c+48>>2]=0;m[c+72|0]=1;o[c+40>>2]=0;o[c+44>>2]=0;o[c+68>>2]=0;m[c+92|0]=1;o[c+60>>2]=0;o[c+64>>2]=0;o[c+88>>2]=0;o[c+80>>2]=0;o[c+84>>2]=0;o[c+28>>2]=0;m[c+32|0]=1;o[c+20>>2]=0;o[c+24>>2]=0;o[a+72>>2]=0;o[a+76>>2]=0;o[a+64>>2]=0;o[a+68>>2]=0;d=o[a+28>>2];a:{if((d|0)<1){break a}while(1){b=o[a+36>>2];M=u(y,36);N=o[(b+M|0)+4>>2];if((N|0)>=1){F=0;while(1){d=o[(b+M|0)+12>>2];b=o[d+(F<<2)>>2];F=F+1|0;I=(N|0)==(F|0);j=o[d+((I?0:F)<<2)>>2];n[c+10>>1]=j;n[c+8>>1]=b;H=0;e=j<<16>>16;d=b<<16>>16;if((e|0)>(d|0)){n[c+10>>1]=b;n[c+8>>1]=j;e=b;d=j;}j=e<<16;A=d<<16>>16;b=j+A&o[c+64>>2]+ -1;b:{if(b>>>0>=r[c+20>>2]){break b}b=o[o[c+28>>2]+(b<<2)>>2];if((b|0)==-1){break b}G=o[c+48>>2];P=o[c+88>>2];while(1){b=b<<2;O=b+P|0;if(!(q[O+2>>1]==(e&65535)?q[O>>1]==(d&65535):0)){b=o[b+G>>2];if((b|0)!=-1){continue}break b}break}H=b+o[c+68>>2]|0;}e=o[a+16>>2];d=e+(j>>16<<4)|0;e=e+(A<<4)|0;f=v(s[d+8>>2]-s[e+8>>2]);i=v(s[d>>2]-s[e>>2]);k=v(s[d+4>>2]-s[e+4>>2]);x=v(v(1)/v(C(v(v(v(i*i)+v(k*k))+v(f*f)))));f=v(f*x);k=v(k*x);i=v(i*x);d=o[a+48>>2];c:{if((d|0)>=1){j=o[a+56>>2];b=0;while(1){e=j+(b<<4)|0;x=s[e+8>>2];B=s[e>>2];z=s[e+4>>2];if((+v(w(v(x-f)))>1e-6^1?!(+v(w(v(B-i)))>1e-6|+v(w(v(z-k)))>1e-6):0)|(+v(w(v(f+x)))>1e-6^1?!(+v(w(v(i+B)))>1e-6|+v(w(v(k+z)))>1e-6):0)){break c}b=b+1|0;if((b|0)<(d|0)){continue}break}}d:{if(o[a+52>>2]!=(d|0)){break d}e=d?d<<1:1;if((d|0)>=(e|0)){break d}b=0;j=0;if(e){o[6257]=o[6257]+1;j=l[o[4968]](e<<4,16)|0;d=o[a+48>>2];}if((d|0)>=1){while(1){A=b<<4;G=A+j|0;A=A+o[a+56>>2]|0;O=o[A+4>>2];o[G>>2]=o[A>>2];o[G+4>>2]=O;P=o[A+12>>2];o[G+8>>2]=o[A+8>>2];o[G+12>>2]=P;b=b+1|0;if((d|0)!=(b|0)){continue}break}}d=o[a+56>>2];if(d){if(p[a+60|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+56>>2]=0;}o[a+56>>2]=j;m[a+60|0]=1;o[a+52>>2]=e;d=o[a+48>>2];}d=o[a+56>>2]+(d<<4)|0;o[d+12>>2]=0;s[d+8>>2]=f;s[d+4>>2]=k;s[d>>2]=i;o[a+48>>2]=o[a+48>>2]+1;}e:{if(H){n[H+2>>1]=y;break e}n[c>>1]=y;n[c+2>>1]=65535;xi(c+16|0,c+8|0,c);}if(!I){b=o[a+36>>2];continue}break}d=o[a+28>>2];}y=y+1|0;if((y|0)<(d|0)){continue}break}if((d|0)<1){b=0;break a}e=o[a+16>>2];G=o[a+36>>2];y=0;while(1){b=G+u(y,36)|0;j=o[b+4>>2];if((j|0)>=3){M=j+ -1|0;F=o[b+12>>2];H=e+(o[F>>2]<<4)|0;N=H;i=s[a+72>>2];x=s[a+68>>2];z=s[a+64>>2];b=1;while(1){A=e+(o[F+(b<<2)>>2]<<4)|0;f=s[A+8>>2];b=b+1|0;I=e+(o[F+((b|0)%(j|0)<<2)>>2]<<4)|0;k=s[I+8>>2];B=s[H>>2];Q=s[A>>2];R=v(B-Q);t=s[H+4>>2];S=s[I+4>>2];L=v(t-S);T=s[A+4>>2];E=v(t-T);U=s[I>>2];V=v(B-U);J=v(v(R*L)-v(E*V));Y=E;E=s[N+8>>2];W=v(E-k);X=v(E-f);L=v(v(Y*W)-v(X*L));k=v(v(v(E+f)+k)*v(.3333333432674408));f=v(v(X*V)-v(R*W));f=v(v(C(v(v(J*J)+v(v(L*L)+v(f*f)))))*v(.5));i=v(i+v(k*f));s[a+72>>2]=i;x=v(x+v(v(v(S+v(t+T))*v(.3333333432674408))*f));s[a+68>>2]=x;z=v(z+v(v(v(U+v(B+Q))*v(.3333333432674408))*f));s[a+64>>2]=z;D=v(D+f);if((b|0)!=(M|0)){continue}break}}b=1;y=y+1|0;if((y|0)!=(d|0)){continue}break}}o[a+96>>2]=2139095039;f=v(v(1)/D);x=v(f*s[a+64>>2]);s[a+64>>2]=x;z=v(f*s[a+68>>2]);s[a+68>>2]=z;D=v(f*s[a+72>>2]);s[a+72>>2]=D;f=v(3.4028234663852886e+38);k=v(3.4028234663852886e+38);if(b){j=o[a+36>>2];e=0;while(1){b=j+u(e,36)|0;i=v(w(v(s[b+32>>2]+v(v(v(x*s[b+20>>2])+v(z*s[b+24>>2]))+v(D*s[b+28>>2])))));if(!!(i<k)){s[a+96>>2]=i;k=i;}e=e+1|0;if((e|0)!=(d|0)){continue}break}}e=o[a+8>>2];f:{if((e|0)<1){B=v(-3.4028234663852886e+38);i=v(3.4028234663852886e+38);x=v(-3.4028234663852886e+38);z=v(-3.4028234663852886e+38);D=v(3.4028234663852886e+38);break f}j=o[a+16>>2];z=v(-3.4028234663852886e+38);b=0;D=v(3.4028234663852886e+38);x=v(-3.4028234663852886e+38);B=v(-3.4028234663852886e+38);i=v(3.4028234663852886e+38);while(1){d=j+(b<<4)|0;t=s[d+8>>2];z=t>z?t:z;i=t<i?t:i;t=s[d+4>>2];x=t>x?t:x;f=t<f?t:f;t=s[d>>2];B=t>B?t:B;D=t<D?t:D;b=b+1|0;if((e|0)!=(b|0)){continue}break}}b=0;o[a+128>>2]=0;t=v(z-i);s[a+124>>2]=t;J=v(x-f);s[a+120>>2]=J;E=v(B-D);s[a+116>>2]=E;o[a+112>>2]=0;s[a+108>>2]=i+z;s[a+104>>2]=f+x;s[a+100>>2]=B+D;d=E<J?J<t?2:1:(E<t)<<1;e=d<<2;j=e+(a+116|0)|0;i=s[j>>2];f=v(k/v(1.7320507764816284));s[a+84>>2]=f;s[a+88>>2]=f;s[a+80>>2]=f;e=e+(a+80|0)|0;k=v(s[j>>2]*v(.5));s[e>>2]=k;i=v(v(v(i*v(.5))-f)*v(.0009765625));g:{h:{while(1){if(Hc(a)){break h}k=v(k-i);s[e>>2]=k;b=b+1|0;if((b|0)!=1024){continue}break}s[a+84>>2]=f;s[a+88>>2]=f;s[a+80>>2]=f;break g}e=a+80|0;d=1<<d&3;b=e+((1<<d&3)<<2)|0;j=o[b>>2];y=e+(d<<2)|0;d=y;e=o[d>>2];i=v(v(s[a+96>>2]-f)*v(.0009765625));s[d>>2]=i+s[d>>2];f=v(i+s[b>>2]);s[b>>2]=f;if(Hc(a)){d=0;while(1){k=f;d=d+1|0;if((d|0)==1024){break g}e=o[y>>2];s[y>>2]=i+s[y>>2];f=v(i+s[b>>2]);s[b>>2]=f;if(Hc(a)){continue}break}j=(g(k),h(0));}o[y>>2]=e;o[b>>2]=j;}a=o[c+88>>2];if(a){if(p[c+92|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+88>>2]=0;}o[c+88>>2]=0;m[c+92|0]=1;o[c+80>>2]=0;o[c+84>>2]=0;a=o[c+68>>2];if(a){if(p[c+72|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+68>>2]=0;}o[c+68>>2]=0;m[c+72|0]=1;o[c+60>>2]=0;o[c+64>>2]=0;a=o[c+48>>2];if(a){if(p[c+52|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+48>>2]=0;}o[c+48>>2]=0;m[c+52|0]=1;o[c+40>>2]=0;o[c+44>>2]=0;a=o[c+28>>2];if(a){if(p[c+32|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+28>>2]=0;}K=c+96|0;}function vm(a,b,c,d,e,f,g,h,i){var j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),q=0,r=0,t=v(0),x=v(0),y=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=0,F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),K=0,L=0,M=v(0),N=v(0);E=o[a+16>>2];K=E+u(d,244)|0;q=o[K+240>>2];L=u(c,244)+E|0;r=o[L+240>>2];o[g>>2]=o[f+28>>2];F=s[f+12>>2];M=s[f+36>>2];t=s[f+40>>2];a=o[e+128>>2];a:{if(a&6){t=a&2?s[e+152>>2]:t;if(!(a&4)){break a}M=s[e+156>>2];break a}if(!(a&8)){break a}k=v(F*s[e+152>>2]);j=v(z(v(k+s[e+156>>2]),v(1.1920928955078125e-7)));M=v(k/j);t=v(v(1)/j);}j=s[e+68>>2];k=s[h>>2];m=s[h+4>>2];n=s[e+64>>2];x=v(v(j*k)-v(m*n));l=s[h+8>>2];C=v(l*n);n=s[e+72>>2];B=v(C-v(n*k));G=v(v(m*n)-v(l*j));k=v(0);m=v(0);if(r){D=v(v(v(v(G*s[r+356>>2])+v(B*s[r+360>>2]))+v(x*s[r+364>>2]))*s[r+612>>2]);m=v(v(v(v(G*s[r+340>>2])+v(B*s[r+344>>2]))+v(x*s[r+348>>2]))*s[r+608>>2]);k=v(v(v(v(G*s[r+324>>2])+v(B*s[r+328>>2]))+v(x*s[r+332>>2]))*s[r+604>>2]);}s[b+64>>2]=k;o[b+76>>2]=0;s[b+72>>2]=D;s[b+68>>2]=m;j=s[e+68>>2];n=s[i>>2];l=s[i+4>>2];y=s[e+64>>2];H=v(v(j*n)-v(l*y));C=s[i+8>>2];I=v(C*y);y=s[e+72>>2];J=v(I-v(y*n));y=v(v(l*y)-v(C*j));n=v(0);l=v(0);if(q){j=v(-J);l=v(v(v(v(s[q+360>>2]*j)-v(y*s[q+356>>2]))-v(H*s[q+364>>2]))*s[q+612>>2]);A=v(v(v(v(s[q+328>>2]*j)-v(y*s[q+324>>2]))-v(H*s[q+332>>2]))*s[q+604>>2]);n=v(v(v(v(s[q+344>>2]*j)-v(y*s[q+340>>2]))-v(H*s[q+348>>2]))*s[q+608>>2]);}s[b+80>>2]=A;o[b+92>>2]=0;s[b+88>>2]=l;s[b+84>>2]=n;j=v(0);if(r){j=s[h+8>>2];C=s[h+4>>2];N=v(v(v(m*j)-v(D*C))*s[e+64>>2]);I=D;D=s[h>>2];j=v(s[r+404>>2]+v(v(N+v(v(v(I*D)-v(j*k))*s[e+68>>2]))+v(v(v(C*k)-v(m*D))*s[e+72>>2])));}a=b;N=s[g>>2];D=v(v(1)/F);C=v(D*t);m=C;if(q){k=s[i+4>>2];F=s[i+8>>2];t=v(v(v(l*k)-v(n*F))*s[e+64>>2]);I=l;l=s[i>>2];l=v(s[q+404>>2]+v(v(t+v(v(v(A*F)-v(I*l))*s[e+68>>2]))+v(v(v(n*l)-v(A*k))*s[e+72>>2])));}else {l=v(0);}s[a+108>>2]=N/v(m+v(j+l));b:{if(r){a=e- -64|0;g=o[a+4>>2];o[b+16>>2]=o[a>>2];o[b+20>>2]=g;g=o[a+12>>2];o[b+24>>2]=o[a+8>>2];o[b+28>>2]=g;o[b+12>>2]=0;s[b+8>>2]=x;s[b+4>>2]=B;s[b>>2]=G;break b}o[b>>2]=0;o[b+4>>2]=0;o[b+24>>2]=0;o[b+28>>2]=0;o[b+16>>2]=0;o[b+20>>2]=0;o[b+8>>2]=0;o[b+12>>2]=0;}c:{if(q){j=s[e+64>>2];k=s[e+68>>2];m=s[e+72>>2];o[b+60>>2]=0;o[b+44>>2]=0;s[b+40>>2]=-H;s[b+36>>2]=-J;s[b+32>>2]=-y;s[b+56>>2]=-m;s[b+52>>2]=-k;s[b+48>>2]=-j;break c}o[b+32>>2]=0;o[b+36>>2]=0;o[b+56>>2]=0;o[b+60>>2]=0;o[b+48>>2]=0;o[b+52>>2]=0;o[b+40>>2]=0;o[b+44>>2]=0;}J=s[f+64>>2];I=s[e+80>>2];A=v(0);k=v(0);m=v(0);n=v(0);if(r){j=s[h+4>>2];k=s[r+388>>2];l=s[r+392>>2];m=s[h>>2];n=v(v(v(j*k)-v(l*m))+s[r+380>>2]);t=s[r+396>>2];x=s[h+8>>2];m=v(s[r+376>>2]+v(v(t*m)-v(x*k)));k=v(v(v(l*x)-v(t*j))+s[r+372>>2]);}l=v(0);x=v(0);if(q){j=s[i+4>>2];l=s[q+388>>2];t=s[q+392>>2];A=s[i>>2];x=v(v(v(j*l)-v(t*A))+s[q+380>>2]);B=s[q+396>>2];y=v(B*A);A=s[i+8>>2];l=v(s[q+376>>2]+v(y-v(A*l)));A=v(v(v(t*A)-v(B*j))+s[q+372>>2]);}j=s[e+72>>2];t=s[e+64>>2];B=s[e+68>>2];o[b+104>>2]=o[e+84>>2];j=v(v(v(t*v(k-A))+v(B*v(m-l)))+v(j*v(n-x)));A=v(w(j))<s[f+96>>2]?v(0):v(s[e+96>>2]*v(-j));d:{if(p[f+72|0]&4){j=v(s[e+132>>2]*s[f+68>>2]);s[b+100>>2]=j;if(!(!r|!o[L+240>>2])){k=s[r+416>>2];m=s[b+24>>2];n=s[r+412>>2];l=s[b+20>>2];a=u(c,244)+E|0;s[a+64>>2]=v(s[a+112>>2]*v(j*v(v(s[b+16>>2]*s[a+128>>2])*s[r+408>>2])))+s[a+64>>2];s[a+68>>2]=v(v(j*v(n*v(l*s[a+132>>2])))*s[a+116>>2])+s[a+68>>2];s[a+72>>2]=v(v(j*v(k*v(m*s[a+136>>2])))*s[a+120>>2])+s[a+72>>2];k=s[b+72>>2];m=s[b+68>>2];s[a+80>>2]=v(v(j*s[a+96>>2])*s[b+64>>2])+s[a+80>>2];n=s[a+104>>2];s[a+84>>2]=v(m*v(j*s[a+100>>2]))+s[a+84>>2];s[a+88>>2]=v(k*v(j*n))+s[a+88>>2];}if(!q|!o[K+240>>2]){break d}k=s[q+416>>2];m=s[b+56>>2];n=s[q+412>>2];l=s[b+52>>2];t=s[b+88>>2];x=s[b+84>>2];B=s[b+80>>2];a=u(d,244)+E|0;j=v(-s[b+100>>2]);s[a+64>>2]=s[a+64>>2]-v(s[a+112>>2]*v(v(v(s[a+128>>2]*s[b+48>>2])*s[q+408>>2])*j));s[a+68>>2]=s[a+68>>2]-v(v(v(n*v(l*s[a+132>>2]))*j)*s[a+116>>2]);s[a+72>>2]=s[a+72>>2]-v(v(v(k*v(m*s[a+136>>2]))*j)*s[a+120>>2]);s[a+80>>2]=s[a+80>>2]-v(B*v(s[a+96>>2]*j));k=s[a+104>>2];s[a+84>>2]=s[a+84>>2]-v(x*v(s[a+100>>2]*j));s[a+88>>2]=s[a+88>>2]-v(t*v(k*j));break d}o[b+100>>2]=0;}o[b+96>>2]=0;m=v(0);n=v(0);l=v(0);x=v(0);B=v(0);G=v(0);H=v(0);if(o[L+240>>2]){a=u(c,244)+E|0;H=s[a+224>>2];x=s[a+208>>2];B=s[a+232>>2];G=s[a+228>>2];l=s[a+212>>2];n=s[a+216>>2];}k=v(0);y=v(0);t=v(0);F=v(0);j=v(0);if(o[K+240>>2]){a=u(d,244)+E|0;j=s[a+224>>2];m=s[a+208>>2];t=s[a+232>>2];F=s[a+228>>2];y=s[a+216>>2];k=s[a+212>>2];}a=u(c,244)+E|0;l=v(v(v(v(v(x+s[a+176>>2])*s[b+16>>2])+v(v(l+s[a+180>>2])*s[b+20>>2]))+v(v(n+s[a+184>>2])*s[b+24>>2]))+v(v(v(v(H+s[a+192>>2])*s[b>>2])+v(v(G+s[a+196>>2])*s[b+4>>2]))+v(v(B+s[a+200>>2])*s[b+8>>2])));a=u(d,244)+E|0;k=v((A<=v(0)?v(0):A)-v(l+v(v(v(v(v(m+s[a+176>>2])*s[b+48>>2])+v(v(k+s[a+180>>2])*s[b+52>>2]))+v(v(y+s[a+184>>2])*s[b+56>>2]))+v(v(v(v(j+s[a+192>>2])*s[b+32>>2])+v(v(F+s[a+196>>2])*s[b+36>>2]))+v(v(t+s[a+200>>2])*s[b+40>>2])))));m=v(0);j=v(I+J);e:{if(!!(j>v(0))){k=v(k-v(D*j));break e}m=v(D*v(M*v(-j)));}n=s[b+108>>2];k=v(k*n);m=v(m*n);a=b;if(!(j>s[f+56>>2]^1?o[f+52>>2]:0)){k=v(m+k);m=v(0);}s[a+128>>2]=m;s[b+112>>2]=k;o[b+120>>2]=0;o[b+124>>2]=1343554297;s[b+116>>2]=C*n;}function wk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=v(d);var e=0,f=0,g=v(0),h=0,i=v(0),j=v(0),k=v(0),m=v(0),n=0,q=v(0),r=0,t=v(0),x=0,A=0,B=v(0),D=0,E=0,F=0,G=v(0),H=v(0),I=v(0),J=0,L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0);e=K-208|0;K=e;a:{if(s[o[a+4>>2]+848>>2]<d){break a}B=s[c+8>>2];j=v(v(s[b+8>>2]*d)+B);G=s[c+4>>2];q=v(v(s[b+4>>2]*d)+G);H=s[c>>2];t=v(v(s[b>>2]*d)+H);h=o[a+4>>2];J=o[h+844>>2];x=o[h+836>>2];F=o[o[a+8>>2]+8>>2];n=(x|0)==(F|0);b:{if(!n){f=o[o[a+12>>2]+8>>2];g=v(t-s[f+52>>2]);i=v(q-s[f+56>>2]);k=v(j-s[f+60>>2]);m=v(v(v(g*s[f+12>>2])+v(i*s[f+28>>2]))+v(k*s[f+44>>2]));I=v(v(v(g*s[f+8>>2])+v(i*s[f+24>>2]))+v(k*s[f+40>>2]));g=v(v(v(g*s[f+4>>2])+v(i*s[f+20>>2]))+v(k*s[f+36>>2]));f=F;break b}g=v(t-s[x+52>>2]);i=v(q-s[x+56>>2]);k=v(j-s[x+60>>2]);m=v(v(v(g*s[x+12>>2])+v(i*s[x+28>>2]))+v(k*s[x+44>>2]));I=v(v(v(g*s[x+8>>2])+v(i*s[x+24>>2]))+v(k*s[x+40>>2]));g=v(v(v(g*s[x+4>>2])+v(i*s[x+20>>2]))+v(k*s[x+36>>2]));f=o[o[a+12>>2]+8>>2];}L=s[f+20>>2];M=s[f+36>>2];N=s[f+40>>2];O=s[f+8>>2];P=s[f+24>>2];Q=s[f+44>>2];R=s[f+60>>2];i=s[f+12>>2];k=s[f+52>>2];S=s[f+28>>2];T=s[f+56>>2];U=s[f+4>>2];o[e+28>>2]=0;V=i;i=v(H-k);k=v(G-T);B=v(B-R);s[e+24>>2]=v(v(V*i)+v(S*k))+v(Q*B);s[e+20>>2]=v(v(i*O)+v(k*P))+v(B*N);o[e+12>>2]=0;s[e+8>>2]=m;s[e+4>>2]=I;s[e>>2]=g;s[e+16>>2]=v(v(i*U)+v(k*L))+v(B*M);f=o[b+12>>2];o[e+72>>2]=o[b+8>>2];o[e+76>>2]=f;f=o[b>>2];b=o[b+4>>2];o[e+92>>2]=0;o[e+96>>2]=0;o[e+124>>2]=0;o[e+128>>2]=0;o[e+132>>2]=0;o[e+136>>2]=0;o[e+140>>2]=0;o[e+144>>2]=0;o[e+148>>2]=0;o[e+152>>2]=0;o[e+156>>2]=0;o[e+160>>2]=0;o[e+164>>2]=0;s[e+52>>2]=q;s[e+56>>2]=j;o[e+60>>2]=0;o[e+64>>2]=f;o[e+68>>2]=b;o[e+84>>2]=0;o[e+88>>2]=0;s[e+80>>2]=d;o[e+116>>2]=0;o[e+120>>2]=0;s[e+48>>2]=t;b=o[c+12>>2];o[e+40>>2]=o[c+8>>2];o[e+44>>2]=b;b=o[c+4>>2];o[e+32>>2]=o[c>>2];o[e+36>>2]=b;c=im(h,e);b=o[a+12>>2];f=o[b+8>>2];r=o[a+8>>2];h=o[r+8>>2];c:{if(!n){o[e+100>>2]=o[a+20>>2];o[e+104>>2]=o[a+16>>2];D=o[a+28>>2];o[e+108>>2]=D;E=o[a+24>>2];o[e+112>>2]=E;n=o[b>>2];n=o[(n?n:b)+4>>2];o[e+200>>2]=n;b=o[r>>2];r=o[(b?b:r)+4>>2];A=r;b=h;h=e+204|0;break c}o[e+100>>2]=o[a+16>>2];o[e+104>>2]=o[a+20>>2];D=o[a+24>>2];o[e+108>>2]=D;E=o[a+28>>2];o[e+112>>2]=E;n=o[b>>2];A=o[(n?n:b)+4>>2];o[e+204>>2]=A;b=o[r>>2];r=o[(b?b:r)+4>>2];n=r;b=f;f=h;h=e+200|0;}o[h>>2]=r;r=o[f+260>>2];d=s[f+240>>2];j=s[f+236>>2];q=s[f+232>>2];t=s[f+228>>2];h=o[n+4>>2]+ -21|0;d:{if(h>>>0>10){break d}e:{switch(h-1|0){case 9:if(!p[n+180|0]){break d}f=D<<2;r=o[f+o[n+172>>2]>>2];d=s[f+o[n+152>>2]>>2];q=s[f+o[n+132>>2]>>2];t=s[f+o[n+92>>2]>>2];j=s[f+o[n+112>>2]>>2];break d;case 0:case 1:case 3:case 5:case 6:case 7:case 8:break d;default:break e}}f=o[f+192>>2];if(o[f+4>>2]!=31|!p[f+180|0]){break d}h=o[n+12>>2]<<2;r=o[h+o[f+172>>2]>>2];d=s[h+o[f+152>>2]>>2];q=s[h+o[f+132>>2]>>2];t=s[h+o[f+92>>2]>>2];j=s[h+o[f+112>>2]>>2];}f=o[b+260>>2];g=s[b+240>>2];i=s[b+236>>2];k=s[b+232>>2];m=s[b+228>>2];h=o[A+4>>2]+ -21|0;f:{if(h>>>0>10){break f}g:{switch(h-1|0){case 9:if(!p[A+180|0]){break f}b=E<<2;f=o[b+o[A+172>>2]>>2];g=s[b+o[A+152>>2]>>2];k=s[b+o[A+132>>2]>>2];m=s[b+o[A+92>>2]>>2];i=s[b+o[A+112>>2]>>2];break f;case 0:case 1:case 3:case 5:case 6:case 7:case 8:break f;default:break g}}b=o[b+192>>2];if(o[b+4>>2]!=31|!p[b+180|0]){break f}h=o[A+12>>2]<<2;f=o[h+o[b+172>>2]>>2];g=s[h+o[b+152>>2]>>2];k=s[h+o[b+132>>2]>>2];m=s[h+o[b+92>>2]>>2];i=s[h+o[b+112>>2]>>2];}h=a+4|0;b=e;f=(r|0)>(f|0)?r:f;h:{if(f>>>0<=2){i:{switch(f-1|0){default:s[e+96>>2]=v(q+k)*v(.5);s[e+84>>2]=v(t+m)*v(.5);s[e+88>>2]=y(v(z(v(v(j+i)*v(.5)),v(-10))),v(10));d=v(v(d+g)*v(.5));break h;case 0:s[e+96>>2]=q<k?q:k;s[e+84>>2]=t<m?t:m;s[e+88>>2]=y(v(z(j<i?j:i,v(-10))),v(10));d=d<g?d:g;break h;case 1:break i}}s[e+96>>2]=q*k;s[e+84>>2]=t*m;s[e+88>>2]=y(v(z(v(j*i),v(-10))),v(10));d=v(d*g);break h}s[e+96>>2]=q>k?q:k;s[e+84>>2]=t>m?t:m;s[e+88>>2]=y(v(z(j>i?j:i,v(-10))),v(10));d=d>g?d:g;}s[b+92>>2]=y(v(z(d,v(-10))),v(10));d=s[e+72>>2];j:{if(!!(v(w(d))>v(.7071067690849304))){m=s[e+68>>2];j=v(v(d*d)+v(m*m));g=v(v(1)/v(C(j)));j=v(j*g);i=s[e+64>>2];q=v(g*v(-d));t=v(i*q);d=v(m*g);g=v(d*v(-i));i=v(0);break j}j=s[e+64>>2];g=s[e+68>>2];q=v(v(j*j)+v(g*g));m=v(v(1)/v(C(q)));t=v(q*m);i=v(m*v(-g));g=v(d*i);q=v(j*m);j=v(q*v(-d));d=v(0);}s[e+192>>2]=t;s[e+188>>2]=g;s[e+176>>2]=d;s[e+172>>2]=q;s[e+184>>2]=j;s[e+168>>2]=i;b=o[h>>2];k:{if((c|0)>=0){b=b+u(c,208)|0;f=b;d=s[b+144>>2];g=s[b+140>>2];m=s[b+136>>2];n=o[b+168>>2];l:{if(p[e+128|0]&16){j=v(v(m*s[b+88>>2])+v(0));if(!(v(v(g*g)+v(d*d))>v(j*j))){break l}}A=o[b+120>>2];ra(b+4|0,e,208);o[b+120>>2]=A;s[b+136>>2]=m;s[b+140>>2]=g;s[f+144>>2]=d;}o[b+168>>2]=n;break k}c=$c(b,e);}f=o[5637];m:{if(!f){break m}b=a+12|0;a=a+8|0;if(p[o[o[b>>2]+8>>2]+204|0]&8?0:!(p[o[o[a>>2]+8>>2]+204|0]&8)){break m}r=(o[h>>2]+u(c,208)|0)+4|0;c=(x|0)!=(F|0);l[f](r,o[(c?b:a)>>2],o[e+100>>2],o[e+108>>2],o[(c?a:b)>>2],o[e+104>>2],o[e+112>>2])|0;}if(J){break a}a=o[5381];if(!a){break a}l[a](h);}K=e+208|0;}function xe(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=v(0),j=v(0),k=v(0),n=v(0),q=v(0),r=v(0),t=v(0),w=v(0),x=v(0),y=0,z=0,A=0,B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=0,Q=v(0),R=v(0),S=0,T=0,U=0;f=K-176|0;K=f;z=p[a+68|0];S=z?c:b;P=o[S+4>>2];if(o[P+72>>2]!=o[a+80>>2]){y=o[a+52>>2];if((y|0)>=1){while(1){A=g<<2;h=o[A+o[a+60>>2]>>2];if(h){l[o[o[h>>2]>>2]](h)|0;h=o[a+4>>2];l[o[o[h>>2]+60>>2]](h,o[A+o[a+60>>2]>>2]);}g=g+1|0;if((y|0)!=(g|0)){continue}break}}ye(a,b,c);o[a+80>>2]=o[P+72>>2];}h=o[a+52>>2];a:{if(!h){break a}y=o[P+68>>2];g=o[a+60>>2];A=o[a+4>>2];o[f+172>>2]=o[a+72>>2];o[f+168>>2]=g;o[f+164>>2]=e;o[f+160>>2]=d;o[f+156>>2]=A;d=z?b:c;o[f+152>>2]=d;o[f+148>>2]=S;o[f+144>>2]=10476;g=o[a+32>>2];if((g|0)<=-1){if(o[a+36>>2]<=-1){b=o[a+40>>2];if(b){if(p[a+44|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+40>>2]=0;}o[a+36>>2]=0;o[a+40>>2]=0;m[a+44|0]=1;}while(1){o[o[a+40>>2]+(g<<2)>>2]=0;b=g+1|0;c=b>>>0>=g>>>0;g=b;if(c){continue}break}h=o[a+52>>2];}o[a+32>>2]=0;if((h|0)>=1){z=a+28|0;c=0;while(1){b=o[o[a+60>>2]+(c<<2)>>2];if(b){l[o[o[b>>2]+16>>2]](b,z);h=0;g=o[a+32>>2];if((g|0)>0){while(1){b=o[o[a+40>>2]+(h<<2)>>2];if(o[b+844>>2]){o[e+4>>2]=b;A=o[b+836>>2];T=o[o[e+8>>2]+8>>2];g=(A|0)==(T|0);U=b;b=o[o[e+12>>2]+8>>2];da(U,(g?A:b)+4|0,(g?b:T)+4|0);o[e+4>>2]=0;g=o[a+32>>2];}h=h+1|0;if((h|0)<(g|0)){continue}break}}if((g|0)<=-1){if(o[a+36>>2]<=-1){b=o[a+40>>2];if(b){if(p[a+44|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+40>>2]=0;}m[a+44|0]=1;o[a+36>>2]=0;o[a+40>>2]=0;}while(1){o[o[a+40>>2]+(g<<2)>>2]=0;b=g+1|0;h=b>>>0>=g>>>0;g=b;if(h){continue}break}}o[a+32>>2]=0;h=o[a+52>>2];}c=c+1|0;if((c|0)<(h|0)){continue}break}}b:{if(!y){if((h|0)<1){break b}g=0;while(1){we(f+144|0,o[(o[P+28>>2]+u(g,80)|0)+64>>2],g);g=g+1|0;if((h|0)!=(g|0)){continue}break}break b}b=o[S+12>>2];B=s[b+52>>2];C=s[b+56>>2];c=o[d+12>>2];D=s[c+52>>2];E=s[c+56>>2];i=s[b+20>>2];j=s[b+36>>2];F=s[c+20>>2];G=s[c+36>>2];H=s[c+24>>2];k=s[b+24>>2];I=s[c+40>>2];n=s[b+40>>2];J=s[c+32>>2];q=s[b+32>>2];L=s[c>>2];r=s[b>>2];M=s[c+16>>2];t=s[b+16>>2];N=s[b+48>>2];O=s[c+48>>2];w=s[b+4>>2];Q=s[c+4>>2];R=s[c+8>>2];x=s[b+8>>2];o[f+108>>2]=0;o[f+92>>2]=0;o[f+76>>2]=0;s[f+88>>2]=v(v(x*R)+v(k*H))+v(n*I);s[f+84>>2]=v(v(x*Q)+v(k*F))+v(n*G);s[f+72>>2]=v(v(w*R)+v(i*H))+v(j*I);s[f+68>>2]=v(v(w*Q)+v(i*F))+v(j*G);B=v(-B);s[f+104>>2]=v(v(v(k*B)-v(x*N))-v(n*C))+v(v(v(x*O)+v(k*D))+v(n*E));s[f+100>>2]=v(v(v(i*B)-v(w*N))-v(j*C))+v(v(v(w*O)+v(i*D))+v(j*E));o[f+60>>2]=0;s[f+48>>2]=v(v(r*L)+v(t*M))+v(q*J);s[f+80>>2]=v(v(x*L)+v(k*M))+v(n*J);s[f+64>>2]=v(v(w*L)+v(i*M))+v(j*J);s[f+56>>2]=v(v(r*R)+v(t*H))+v(q*I);s[f+52>>2]=v(v(r*Q)+v(t*F))+v(q*G);s[f+96>>2]=v(v(v(t*B)-v(r*N))-v(q*C))+v(v(v(r*O)+v(t*D))+v(q*E));b=o[d+4>>2];l[o[o[b>>2]+8>>2]](b,f+48|0,f+128|0,f+112|0);i=s[e+32>>2];s[f+128>>2]=s[f+128>>2]-i;s[f+132>>2]=s[f+132>>2]-i;s[f+136>>2]=s[f+136>>2]-i;s[f+112>>2]=i+s[f+112>>2];s[f+116>>2]=i+s[f+116>>2];s[f+120>>2]=i+s[f+120>>2];b=o[f+140>>2];o[f+24>>2]=o[f+136>>2];o[f+28>>2]=b;b=o[f+124>>2];o[f+40>>2]=o[f+120>>2];o[f+44>>2]=b;b=o[f+116>>2];o[f+32>>2]=o[f+112>>2];o[f+36>>2]=b;b=o[f+132>>2];o[f+16>>2]=o[f+128>>2];o[f+20>>2]=b;tj(o[y>>2],f+16|0,a+8|0,f+144|0);}y=o[a+52>>2];g=o[a+32>>2];if((g|0)<=-1){if(o[a+36>>2]<=-1){b=o[a+40>>2];if(b){if(p[a+44|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+40>>2]=0;}o[a+36>>2]=0;o[a+40>>2]=0;m[a+44|0]=1;}while(1){o[o[a+40>>2]+(g<<2)>>2]=0;b=g+1|0;c=b>>>0>=g>>>0;g=b;if(c){continue}break}}o[a+32>>2]=0;if((y|0)<1){break a}e=0;while(1){g=e<<2;c:{if(!o[g+o[a+60>>2]>>2]){break c}b=o[P+28>>2]+u(e,80)|0;z=o[b+64>>2];c=o[S+12>>2];Q=s[c+52>>2];R=s[c+56>>2];C=s[b+48>>2];D=s[b+52>>2];E=s[b+56>>2];F=s[b+4>>2];G=s[b+20>>2];H=s[b+36>>2];I=s[b+8>>2];J=s[b+24>>2];L=s[b+40>>2];i=s[c+20>>2];j=s[c+24>>2];M=s[b>>2];N=s[b+16>>2];k=s[c+36>>2];O=s[b+32>>2];n=s[c+40>>2];B=s[c+48>>2];q=s[c+8>>2];r=s[c>>2];t=s[c+4>>2];w=s[c+16>>2];x=s[c+32>>2];h=0;o[f+108>>2]=0;o[f+92>>2]=0;o[f+76>>2]=0;o[f+60>>2]=0;s[f+80>>2]=v(v(x*M)+v(k*N))+v(n*O);s[f+64>>2]=v(v(w*M)+v(i*N))+v(j*O);s[f+48>>2]=v(v(r*M)+v(t*N))+v(q*O);s[f+88>>2]=v(v(x*I)+v(k*J))+v(n*L);s[f+84>>2]=v(v(x*F)+v(k*G))+v(n*H);s[f+72>>2]=v(v(w*I)+v(i*J))+v(j*L);s[f+68>>2]=v(v(w*F)+v(i*G))+v(j*H);s[f+56>>2]=v(v(r*I)+v(t*J))+v(q*L);s[f+52>>2]=v(v(r*F)+v(t*G))+v(q*H);s[f+104>>2]=R+v(v(v(x*C)+v(k*D))+v(n*E));s[f+100>>2]=Q+v(v(v(w*C)+v(i*D))+v(j*E));s[f+96>>2]=B+v(v(v(r*C)+v(t*D))+v(q*E));l[o[o[z>>2]+8>>2]](z,f+48|0,f+16|0,f+128|0);b=o[d+4>>2];l[o[o[b>>2]+8>>2]](b,o[d+12>>2],f+112|0,f);b=0;d:{if(s[f+16>>2]>s[f>>2]){break d}b=0;if(s[f+128>>2]<s[f+112>>2]){break d}b=1;}h=s[f+136>>2]<s[f+120>>2]|s[f+24>>2]>s[f+8>>2]?h:b;if(h^1?0:!(s[f+132>>2]<s[f+116>>2]|s[f+20>>2]>s[f+4>>2])){break c}b=o[g+o[a+60>>2]>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+4>>2];l[o[o[b>>2]+60>>2]](b,o[g+o[a+60>>2]>>2]);o[g+o[a+60>>2]>>2]=0;}e=e+1|0;if((y|0)!=(e|0)){continue}break}}K=f+176|0;}function ln(a){var b=v(0),c=v(0),d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=0,n=v(0),p=v(0),q=0,r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),D=v(0),E=v(0),F=0;m=K-48|0;K=m;l=s[a+1332>>2];r=s[a+1316>>2];t=s[a+1336>>2];u=s[a+1304>>2];w=s[a+1320>>2];x=s[a+1340>>2];y=s[a+1308>>2];z=s[a+1324>>2];h=s[a+1244>>2];i=s[a+1256>>2];g=s[a+1272>>2];e=s[a+1240>>2];d=s[a+1268>>2];j=s[a+1260>>2];f=s[a+1252>>2];k=s[a+1276>>2];A=s[a+1300>>2];b=s[a+1236>>2];o[m+44>>2]=0;o[m+28>>2]=0;E=v(v(i*k)-v(j*g));n=v(v(j*d)-v(k*f));p=v(v(g*f)-v(i*d));c=v(v(1)/v(v(v(b*E)+v(e*n))+v(p*h)));p=v(p*c);B=v(v(v(d*e)-v(g*b))*c);D=v(v(v(i*b)-v(f*e))*c);s[m+40>>2]=v(v(y*p)+v(z*B))+v(x*D);s[m+36>>2]=v(v(u*p)+v(B*w))+v(D*t);n=v(n*c);d=v(v(v(k*b)-v(d*h))*c);b=v(v(v(f*h)-v(j*b))*c);s[m+24>>2]=v(v(y*n)+v(z*d))+v(x*b);s[m+20>>2]=v(v(u*n)+v(d*w))+v(b*t);o[m+12>>2]=0;s[m+32>>2]=v(l*D)+v(v(A*p)+v(r*B));s[m+16>>2]=v(l*b)+v(v(A*n)+v(r*d));b=v(E*c);g=v(v(v(g*h)-v(k*e))*c);c=v(v(v(j*e)-v(i*h))*c);s[m+8>>2]=v(v(y*b)+v(z*g))+v(x*c);s[m+4>>2]=v(v(b*u)+v(g*w))+v(c*t);s[m>>2]=v(l*c)+v(v(A*b)+v(r*g));F=a;a:{b:{c:{d:{e:{f:{g:{h:{q=o[a+1232>>2];if(q>>>0<=5){i:{j:{switch(q-1|0){default:rn(m,a+1364|0);break i;case 0:qn(m,a+1364|0);break i;case 1:pn(m,a+1364|0);break i;case 2:on(m,a+1364|0);break i;case 3:nn(m,a+1364|0);break i;case 4:break j}}mn(m,a+1364|0);}q=o[a+1232>>2];}if(q>>>0<=5){switch(q-1|0){case 4:break c;case 3:break d;case 2:break e;case 1:break f;case 0:break g;default:break h}}h=s[a+1420>>2];e=s[a+1416>>2];b=s[a+1412>>2];i=s[a+1404>>2];g=s[a+1400>>2];d=s[a+1396>>2];j=s[a+1388>>2];f=s[a+1384>>2];c=s[a+1380>>2];break a}o[a+1408>>2]=0;o[a+1424>>2]=0;o[a+1392>>2]=0;c=s[a+1316>>2];f=s[a+1244>>2];e=s[a+1300>>2];k=s[a+1260>>2];i=v(v(c*f)-v(e*k));s[a+1404>>2]=i;l=s[a+1276>>2];b=s[a+1332>>2];g=v(v(e*l)-v(f*b));s[a+1400>>2]=g;d=v(v(b*k)-v(c*l));s[a+1396>>2]=d;h=v(v(e*g)-v(c*d));s[a+1420>>2]=h;e=v(v(b*d)-v(e*i));s[a+1416>>2]=e;b=v(v(c*i)-v(b*g));s[a+1412>>2]=b;j=v(v(k*d)-v(f*g));s[a+1388>>2]=j;f=v(v(f*i)-v(l*d));s[a+1384>>2]=f;c=v(v(l*g)-v(k*i));break b}o[a+1424>>2]=0;o[a+1408>>2]=0;o[a+1392>>2]=0;c=s[a+1300>>2];k=s[a+1256>>2];d=s[a+1316>>2];f=s[a+1240>>2];h=v(v(c*k)-v(d*f));s[a+1420>>2]=h;j=s[a+1332>>2];l=s[a+1272>>2];e=v(v(f*j)-v(c*l));s[a+1416>>2]=e;b=v(v(d*l)-v(j*k));s[a+1412>>2]=b;i=v(v(d*b)-v(c*e));s[a+1404>>2]=i;g=v(v(c*h)-v(j*b));s[a+1400>>2]=g;d=v(v(j*e)-v(d*h));s[a+1396>>2]=d;j=v(v(f*e)-v(k*b));s[a+1388>>2]=j;f=v(v(l*b)-v(f*h));s[a+1384>>2]=f;c=v(v(k*h)-v(l*e));break b}o[a+1424>>2]=0;o[a+1408>>2]=0;o[a+1392>>2]=0;e=s[a+1304>>2];d=s[a+1260>>2];b=s[a+1320>>2];g=s[a+1244>>2];j=v(v(e*d)-v(b*g));s[a+1388>>2]=j;i=s[a+1336>>2];k=s[a+1276>>2];f=v(v(g*i)-v(e*k));s[a+1384>>2]=f;c=v(v(b*k)-v(i*d));s[a+1380>>2]=c;h=v(v(b*c)-v(e*f));s[a+1420>>2]=h;e=v(v(e*j)-v(i*c));s[a+1416>>2]=e;b=v(v(i*f)-v(b*j));s[a+1412>>2]=b;i=v(v(g*f)-v(d*c));s[a+1404>>2]=i;g=v(v(k*c)-v(g*j));s[a+1400>>2]=g;d=v(v(d*j)-v(k*f));s[a+1396>>2]=d;break a}o[a+1424>>2]=0;o[a+1408>>2]=0;o[a+1392>>2]=0;c=s[a+1236>>2];k=s[a+1320>>2];d=s[a+1252>>2];f=s[a+1304>>2];h=v(v(c*k)-v(d*f));s[a+1420>>2]=h;j=s[a+1268>>2];l=s[a+1336>>2];e=v(v(f*j)-v(c*l));s[a+1416>>2]=e;b=v(v(d*l)-v(j*k));s[a+1412>>2]=b;i=v(v(d*b)-v(c*e));s[a+1404>>2]=i;g=v(v(c*h)-v(j*b));s[a+1400>>2]=g;d=v(v(j*e)-v(d*h));s[a+1396>>2]=d;j=v(v(f*e)-v(k*b));s[a+1388>>2]=j;f=v(v(l*b)-v(f*h));s[a+1384>>2]=f;c=v(v(k*h)-v(l*e));break b}o[a+1424>>2]=0;o[a+1408>>2]=0;o[a+1392>>2]=0;e=s[a+1240>>2];d=s[a+1324>>2];b=s[a+1256>>2];g=s[a+1308>>2];j=v(v(e*d)-v(b*g));s[a+1388>>2]=j;i=s[a+1272>>2];k=s[a+1340>>2];f=v(v(g*i)-v(e*k));s[a+1384>>2]=f;c=v(v(b*k)-v(i*d));s[a+1380>>2]=c;h=v(v(b*c)-v(e*f));s[a+1420>>2]=h;e=v(v(e*j)-v(i*c));s[a+1416>>2]=e;b=v(v(i*f)-v(b*j));s[a+1412>>2]=b;i=v(v(g*f)-v(d*c));s[a+1404>>2]=i;g=v(v(k*c)-v(g*j));s[a+1400>>2]=g;d=v(v(d*j)-v(k*f));s[a+1396>>2]=d;break a}o[a+1408>>2]=0;o[a+1424>>2]=0;o[a+1392>>2]=0;c=s[a+1252>>2];f=s[a+1308>>2];e=s[a+1236>>2];k=s[a+1324>>2];i=v(v(c*f)-v(e*k));s[a+1404>>2]=i;l=s[a+1340>>2];b=s[a+1268>>2];g=v(v(e*l)-v(f*b));s[a+1400>>2]=g;d=v(v(b*k)-v(c*l));s[a+1396>>2]=d;h=v(v(e*g)-v(c*d));s[a+1420>>2]=h;e=v(v(b*d)-v(e*i));s[a+1416>>2]=e;b=v(v(c*i)-v(b*g));s[a+1412>>2]=b;j=v(v(k*d)-v(f*g));s[a+1388>>2]=j;f=v(v(f*i)-v(l*d));s[a+1384>>2]=f;c=v(v(l*g)-v(k*i));}s[F+1380>>2]=c;}k=h;h=v(v(1)/v(C(v(v(v(b*b)+v(e*e))+v(h*h)))));s[a+1420>>2]=k*h;s[a+1416>>2]=e*h;s[a+1412>>2]=b*h;h=v(v(1)/v(C(v(v(v(d*d)+v(g*g))+v(i*i)))));s[a+1404>>2]=i*h;s[a+1400>>2]=g*h;s[a+1396>>2]=d*h;h=v(v(1)/v(C(v(v(v(c*c)+v(f*f))+v(j*j)))));s[a+1388>>2]=j*h;s[a+1384>>2]=f*h;s[a+1380>>2]=c*h;K=m+48|0;}function Te(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=0,u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=0,N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0),Z=v(0),_=v(0),$=v(0),aa=v(0),ba=v(0),ca=v(0),da=0,ea=0;g=K-96|0;K=g;Pb(o[a+4>>2]);W=s[d+40>>2];X=s[d+36>>2];Y=s[d+24>>2];Z=s[d+20>>2];N=s[b+20>>2];O=s[b+36>>2];P=s[b+24>>2];B=s[b+52>>2];i=s[c+52>>2];D=s[d+52>>2];m=s[e+52>>2];Q=s[b+40>>2];E=s[b+56>>2];n=s[c+56>>2];F=s[d+56>>2];h=s[e+56>>2];_=s[d+32>>2];$=s[d+16>>2];aa=s[d+8>>2];ba=s[d+4>>2];ca=s[d>>2];R=s[b>>2];S=s[b+16>>2];T=s[b+32>>2];U=s[b+4>>2];V=s[b+8>>2];G=s[b+48>>2];j=s[c+48>>2];H=s[d+48>>2];k=s[e+48>>2];t=o[a+8>>2];o[g+60>>2]=0;z=v(v(i-B)-v(m-D));i=v(-z);u=v(v(j-G)-v(k-H));w=v(v(n-E)-v(h-F));s[g+56>>2]=v(v(P*i)-v(V*u))-v(Q*w);s[g+52>>2]=v(v(N*i)-v(u*U))-v(w*O);s[g+48>>2]=v(v(S*i)-v(u*R))-v(w*T);l[o[o[t>>2]+64>>2]](g+80|0,t,g+48|0);h=s[b+52>>2];j=s[b+24>>2];k=s[b+20>>2];i=s[b+56>>2];n=s[b+40>>2];m=s[b+36>>2];p=s[b+48>>2];q=s[b+8>>2];r=s[b>>2];y=s[b+4>>2];A=s[b+16>>2];x=s[b+32>>2];o[g+76>>2]=0;I=i;i=s[g+80>>2];J=m;m=s[g+84>>2];L=n;n=s[g+88>>2];s[g+72>>2]=I+v(v(v(x*i)+v(J*m))+v(L*n));s[g+68>>2]=h+v(v(v(i*A)+v(m*k))+v(n*j));s[g+64>>2]=p+v(v(v(i*r)+v(m*y))+v(n*q));t=o[a+12>>2];i=s[d+20>>2];m=s[d+36>>2];n=s[d+24>>2];h=s[d+40>>2];j=s[d>>2];k=s[d+16>>2];p=s[d+32>>2];q=s[d+4>>2];r=s[d+8>>2];o[g+28>>2]=0;s[g+24>>2]=v(v(u*r)+v(z*n))+v(w*h);s[g+20>>2]=v(v(u*q)+v(z*i))+v(w*m);s[g+16>>2]=v(v(u*j)+v(z*k))+v(w*p);l[o[o[t>>2]+64>>2]](g+32|0,t,g+16|0);h=s[d+52>>2];j=s[d+24>>2];k=s[d+20>>2];i=s[d+56>>2];n=s[d+40>>2];m=s[d+36>>2];p=s[d+16>>2];q=s[d+48>>2];r=s[d+8>>2];y=s[d>>2];A=s[d+4>>2];x=s[d+32>>2];o[g+60>>2]=0;o[g+92>>2]=0;I=i;i=s[g+32>>2];J=m;m=s[g+36>>2];L=n;n=s[g+40>>2];x=v(I+v(v(v(x*i)+v(J*m))+v(L*n)));s[g+56>>2]=x;q=v(q+v(v(v(i*y)+v(m*A))+v(n*r)));s[g+48>>2]=q;i=v(h+v(v(v(i*p)+v(m*k))+v(n*j)));s[g+52>>2]=i;h=v(s[g+68>>2]-i);s[g+84>>2]=h;j=v(s[g+64>>2]-q);s[g+80>>2]=j;k=v(s[g+72>>2]-x);s[g+88>>2]=k;i=v(0);m=v(0);n=v(0);p=v(0);a:{b:{if(!(v(v(v(j*j)+v(h*h))+v(k*k))>v(9999999747378752e-20))){break b}t=32;while(1){if(!t){break b}M=o[a+8>>2];o[g+12>>2]=0;h=v(-s[g+84>>2]);j=s[g+80>>2];k=s[g+88>>2];s[g+8>>2]=v(v(P*h)-v(V*j))-v(Q*k);s[g+4>>2]=v(v(N*h)-v(U*j))-v(O*k);s[g>>2]=v(v(S*h)-v(R*j))-v(T*k);l[o[o[M>>2]+64>>2]](g+16|0,M,g);o[g+76>>2]=0;h=s[g+16>>2];j=s[g+20>>2];k=s[g+24>>2];s[g+72>>2]=E+v(v(v(T*h)+v(O*j))+v(Q*k));s[g+68>>2]=B+v(v(v(S*h)+v(N*j))+v(P*k));s[g+64>>2]=G+v(v(v(R*h)+v(U*j))+v(V*k));M=o[a+12>>2];o[g+12>>2]=0;h=s[g+80>>2];j=s[g+84>>2];k=s[g+88>>2];s[g+8>>2]=v(v(aa*h)+v(Y*j))+v(W*k);s[g+4>>2]=v(v(ba*h)+v(Z*j))+v(X*k);s[g>>2]=v(v(ca*h)+v($*j))+v(_*k);l[o[o[M>>2]+64>>2]](g+16|0,M,g);o[g+60>>2]=0;o[g+44>>2]=0;h=s[g+16>>2];j=s[g+20>>2];k=s[g+24>>2];q=v(F+v(v(v(_*h)+v(X*j))+v(W*k)));s[g+56>>2]=q;q=v(s[g+72>>2]-q);s[g+40>>2]=q;r=v(D+v(v(v($*h)+v(Z*j))+v(Y*k)));s[g+52>>2]=r;r=v(s[g+68>>2]-r);s[g+36>>2]=r;h=v(H+v(v(v(ca*h)+v(ba*j))+v(aa*k)));s[g+48>>2]=h;y=v(s[g+64>>2]-h);s[g+32>>2]=y;if(p>v(1)){break a}h=s[g+80>>2];j=s[g+84>>2];k=s[g+88>>2];A=v(v(v(y*h)+v(r*j))+v(q*k));if(!!(A>v(0))){i=v(v(v(u*h)+v(z*j))+v(w*k));if(i>=v(-1.4210854715202004e-14)){break a}m=s[b+48>>2];n=s[c+48>>2];B=s[b+52>>2];G=s[c+52>>2];E=s[b+56>>2];x=s[c+56>>2];H=s[d+48>>2];I=s[e+48>>2];D=s[d+52>>2];J=s[e+52>>2];F=s[d+56>>2];L=s[e+56>>2];o[g+44>>2]=0;s[g+40>>2]=q;s[g+36>>2]=r;s[g+32>>2]=y;p=v(p-v(A/i));i=v(v(1)-p);F=v(v(F*i)+v(p*L));D=v(v(i*D)+v(p*J));H=v(v(i*H)+v(p*I));E=v(v(i*E)+v(p*x));B=v(v(i*B)+v(p*G));G=v(v(i*m)+v(p*n));da=o[g+92>>2];m=j;n=k;i=h;}if(!$e(o[a+4>>2],g+32|0)){df(o[a+4>>2],g+32|0,g- -64|0,g+48|0);}if(!af(o[a+4>>2],g+80|0)){break b}t=t+ -1|0;h=s[g+80>>2];j=v(h*h);h=s[g+84>>2];j=v(j+v(h*h));h=s[g+88>>2];if(v(j+v(h*h))>v(9999999747378752e-20)){continue}break}}s[f+164>>2]=p;h=v(v(v(i*i)+v(m*m))+v(n*n));c:{if(!!(h>=v(1.4210854715202004e-14))){o[f+144>>2]=da;j=n;n=v(v(1)/v(C(h)));p=v(j*n);s[f+140>>2]=p;m=v(m*n);s[f+136>>2]=m;i=v(i*n);s[f+132>>2]=i;break c}o[f+132>>2]=0;o[f+136>>2]=0;o[f+140>>2]=0;o[f+144>>2]=0;p=v(0);m=v(0);i=v(0);}if(v(v(v(u*i)+v(z*m))+v(w*p))>=v(-s[f+172>>2])){break a}_e(o[a+4>>2],g+16|0,g);a=o[g+12>>2];o[f+156>>2]=o[g+8>>2];o[f+160>>2]=a;a=o[g+4>>2];o[f+148>>2]=o[g>>2];o[f+152>>2]=a;ea=1;}K=g+96|0;return ea|0}function Du(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;j=K+ -64|0;K=j;s[a+20>>2]=t[b+32>>3];s[a+24>>2]=t[b+40>>3];s[a+28>>2]=t[b+48>>3];s[a+32>>2]=t[b+56>>3];s[a+4>>2]=t[b>>3];s[a+8>>2]=t[b+8>>3];s[a+12>>2]=t[b+16>>3];s[a+16>>2]=t[b+24>>3];s[a+36>>2]=t[b+64>>3];s[a+40>>2]=t[b+72>>3];s[a+44>>2]=t[b+80>>3];s[a+48>>2]=t[b+88>>3];o[a+56>>2]=o[b+96>>2];m[a+60|0]=o[b+100>>2]!=0;i=o[b+104>>2];d=j;o[d+56>>2]=0;o[d+60>>2]=0;o[d+48>>2]=0;o[d+52>>2]=0;o[d+40>>2]=0;o[d+44>>2]=0;o[d+32>>2]=0;o[d+36>>2]=0;o[d+24>>2]=0;o[d+28>>2]=0;o[d+16>>2]=0;o[d+20>>2]=0;o[d+8>>2]=0;o[d+12>>2]=0;o[d>>2]=0;o[d+4>>2]=0;h=o[a+88>>2];if((h|0)<(i|0)){if(o[a+92>>2]<(i|0)){if(i){o[6257]=o[6257]+1;k=l[o[4968]](i<<6,16)|0;d=o[a+88>>2];}else {d=h;}if((d|0)>=1){while(1){c=e<<6;g=c+k|0;f=c+o[a+96>>2]|0;c=o[f+4>>2];o[g>>2]=o[f>>2];o[g+4>>2]=c;c=o[f+60>>2];o[g+56>>2]=o[f+56>>2];o[g+60>>2]=c;c=o[f+52>>2];o[g+48>>2]=o[f+48>>2];o[g+52>>2]=c;c=o[f+44>>2];o[g+40>>2]=o[f+40>>2];o[g+44>>2]=c;c=o[f+36>>2];o[g+32>>2]=o[f+32>>2];o[g+36>>2]=c;c=o[f+28>>2];o[g+24>>2]=o[f+24>>2];o[g+28>>2]=c;c=o[f+20>>2];o[g+16>>2]=o[f+16>>2];o[g+20>>2]=c;c=o[f+12>>2];o[g+8>>2]=o[f+8>>2];o[g+12>>2]=c;e=e+1|0;if((d|0)!=(e|0)){continue}break}}d=o[a+96>>2];if(d){if(p[a+100|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+96>>2]=0;}o[a+96>>2]=k;o[a+92>>2]=i;m[a+100|0]=1;}while(1){d=j;e=o[d+4>>2];c=o[a+96>>2]+(h<<6)|0;o[c>>2]=o[d>>2];o[c+4>>2]=e;e=o[d+60>>2];o[c+56>>2]=o[d+56>>2];o[c+60>>2]=e;e=o[d+52>>2];o[c+48>>2]=o[d+48>>2];o[c+52>>2]=e;e=o[d+44>>2];o[c+40>>2]=o[d+40>>2];o[c+44>>2]=e;e=o[d+36>>2];o[c+32>>2]=o[d+32>>2];o[c+36>>2]=e;e=o[d+28>>2];o[c+24>>2]=o[d+24>>2];o[c+28>>2]=e;e=o[d+20>>2];o[c+16>>2]=o[d+16>>2];o[c+20>>2]=e;e=o[d+12>>2];o[c+8>>2]=o[d+8>>2];o[c+12>>2]=e;h=h+1|0;if((i|0)!=(h|0)){continue}break}}o[a+88>>2]=i;if((i|0)>=1){d=o[a+96>>2];e=o[b+112>>2];h=0;while(1){c=d+(h<<6)|0;s[c+16>>2]=t[e+32>>3];s[c+20>>2]=t[e+40>>3];s[c+24>>2]=t[e+48>>3];s[c+28>>2]=t[e+56>>3];s[c>>2]=t[e>>3];s[c+4>>2]=t[e+8>>3];s[c+8>>2]=t[e+16>>3];s[c+12>>2]=t[e+24>>3];o[c+32>>2]=o[e+64>>2];o[c+36>>2]=o[e+68>>2];o[c+40>>2]=o[e+72>>2];e=e+80|0;h=h+1|0;if((i|0)!=(h|0)){continue}break}}f=o[b+108>>2];o[j+8>>2]=0;o[j+12>>2]=0;o[j>>2]=0;o[j+4>>2]=0;e=o[a+128>>2];if((e|0)<(f|0)){if(o[a+132>>2]<(f|0)){a:{if(!f){k=0;d=e;break a}o[6257]=o[6257]+1;k=l[o[4968]](f<<4,16)|0;d=o[a+128>>2];}if((d|0)>=1){h=0;while(1){c=h<<4;i=c+k|0;g=c+o[a+136>>2]|0;c=o[g+4>>2];o[i>>2]=o[g>>2];o[i+4>>2]=c;c=o[g+12>>2];o[i+8>>2]=o[g+8>>2];o[i+12>>2]=c;h=h+1|0;if((d|0)!=(h|0)){continue}break}}d=o[a+136>>2];if(d){if(p[a+140|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+136>>2]=0;}o[a+136>>2]=k;o[a+132>>2]=f;m[a+140|0]=1;}while(1){d=o[j+4>>2];c=o[a+136>>2]+(e<<4)|0;o[c>>2]=o[j>>2];o[c+4>>2]=d;d=o[j+12>>2];o[c+8>>2]=o[j+8>>2];o[c+12>>2]=d;e=e+1|0;if((f|0)!=(e|0)){continue}break}}o[a+128>>2]=f;if((f|0)>=1){d=o[a+136>>2];e=o[b+116>>2];h=0;while(1){c=d+(h<<4)|0;o[c+12>>2]=o[e+12>>2];n[c+6>>1]=q[e+6>>1];n[c+8>>1]=q[e+8>>1];n[c+10>>1]=q[e+10>>1];n[c>>1]=q[e>>1];n[c+2>>1]=q[e+2>>1];n[c+4>>1]=q[e+4>>1];e=e+16|0;h=h+1|0;if((f|0)!=(h|0)){continue}break}}o[a+144>>2]=o[b+120>>2];h=o[a+152>>2];f=o[b+124>>2];if((h|0)<(f|0)){if(o[a+156>>2]<(f|0)){b:{if(!f){k=0;d=h;break b}o[6257]=o[6257]+1;k=l[o[4968]](f<<5,16)|0;d=o[a+152>>2];}if((d|0)>=1){e=0;while(1){c=e<<5;i=c+k|0;g=c+o[a+160>>2]|0;c=o[g+4>>2];o[i>>2]=o[g>>2];o[i+4>>2]=c;c=o[g+28>>2];o[i+24>>2]=o[g+24>>2];o[i+28>>2]=c;c=o[g+20>>2];o[i+16>>2]=o[g+16>>2];o[i+20>>2]=c;c=o[g+12>>2];o[i+8>>2]=o[g+8>>2];o[i+12>>2]=c;e=e+1|0;if((d|0)!=(e|0)){continue}break}}d=o[a+160>>2];if(d){if(p[a+164|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+160>>2]=0;}o[a+160>>2]=k;o[a+156>>2]=f;m[a+164|0]=1;}while(1){d=o[j+4>>2];c=o[a+160>>2]+(h<<5)|0;o[c>>2]=o[j>>2];o[c+4>>2]=d;d=o[j+28>>2];o[c+24>>2]=o[j+24>>2];o[c+28>>2]=d;d=o[j+20>>2];o[c+16>>2]=o[j+16>>2];o[c+20>>2]=d;d=o[j+12>>2];o[c+8>>2]=o[j+8>>2];o[c+12>>2]=d;h=h+1|0;if((f|0)!=(h|0)){continue}break}}o[a+152>>2]=f;if((f|0)>=1){d=o[a+160>>2];e=o[b+128>>2];a=0;while(1){b=d+(a<<5)|0;n[b+6>>1]=q[e+14>>1];n[b+8>>1]=q[e+16>>1];n[b+10>>1]=q[e+18>>1];n[b>>1]=q[e+8>>1];n[b+2>>1]=q[e+10>>1];n[b+4>>1]=q[e+12>>1];o[b+12>>2]=o[e>>2];o[b+16>>2]=o[e+4>>2];e=e+20|0;a=a+1|0;if((f|0)!=(a|0)){continue}break}}K=j- -64|0;}function Eu(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;j=K+ -64|0;K=j;o[a+20>>2]=o[b+16>>2];o[a+24>>2]=o[b+20>>2];o[a+28>>2]=o[b+24>>2];o[a+32>>2]=o[b+28>>2];o[a+4>>2]=o[b>>2];o[a+8>>2]=o[b+4>>2];o[a+12>>2]=o[b+8>>2];o[a+16>>2]=o[b+12>>2];o[a+36>>2]=o[b+32>>2];o[a+40>>2]=o[b+36>>2];o[a+44>>2]=o[b+40>>2];o[a+48>>2]=o[b+44>>2];o[a+56>>2]=o[b+48>>2];m[a+60|0]=o[b+52>>2]!=0;i=o[b+56>>2];d=j;o[d+56>>2]=0;o[d+60>>2]=0;o[d+48>>2]=0;o[d+52>>2]=0;o[d+40>>2]=0;o[d+44>>2]=0;o[d+32>>2]=0;o[d+36>>2]=0;o[d+24>>2]=0;o[d+28>>2]=0;o[d+16>>2]=0;o[d+20>>2]=0;o[d+8>>2]=0;o[d+12>>2]=0;o[d>>2]=0;o[d+4>>2]=0;h=o[a+88>>2];if((h|0)<(i|0)){if(o[a+92>>2]<(i|0)){if(i){o[6257]=o[6257]+1;k=l[o[4968]](i<<6,16)|0;d=o[a+88>>2];}else {d=h;}if((d|0)>=1){while(1){c=e<<6;g=c+k|0;f=c+o[a+96>>2]|0;c=o[f+4>>2];o[g>>2]=o[f>>2];o[g+4>>2]=c;c=o[f+60>>2];o[g+56>>2]=o[f+56>>2];o[g+60>>2]=c;c=o[f+52>>2];o[g+48>>2]=o[f+48>>2];o[g+52>>2]=c;c=o[f+44>>2];o[g+40>>2]=o[f+40>>2];o[g+44>>2]=c;c=o[f+36>>2];o[g+32>>2]=o[f+32>>2];o[g+36>>2]=c;c=o[f+28>>2];o[g+24>>2]=o[f+24>>2];o[g+28>>2]=c;c=o[f+20>>2];o[g+16>>2]=o[f+16>>2];o[g+20>>2]=c;c=o[f+12>>2];o[g+8>>2]=o[f+8>>2];o[g+12>>2]=c;e=e+1|0;if((d|0)!=(e|0)){continue}break}}d=o[a+96>>2];if(d){if(p[a+100|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+96>>2]=0;}o[a+96>>2]=k;o[a+92>>2]=i;m[a+100|0]=1;}while(1){d=j;e=o[d+4>>2];c=o[a+96>>2]+(h<<6)|0;o[c>>2]=o[d>>2];o[c+4>>2]=e;e=o[d+60>>2];o[c+56>>2]=o[d+56>>2];o[c+60>>2]=e;e=o[d+52>>2];o[c+48>>2]=o[d+48>>2];o[c+52>>2]=e;e=o[d+44>>2];o[c+40>>2]=o[d+40>>2];o[c+44>>2]=e;e=o[d+36>>2];o[c+32>>2]=o[d+32>>2];o[c+36>>2]=e;e=o[d+28>>2];o[c+24>>2]=o[d+24>>2];o[c+28>>2]=e;e=o[d+20>>2];o[c+16>>2]=o[d+16>>2];o[c+20>>2]=e;e=o[d+12>>2];o[c+8>>2]=o[d+8>>2];o[c+12>>2]=e;h=h+1|0;if((i|0)!=(h|0)){continue}break}}o[a+88>>2]=i;if((i|0)>=1){d=o[a+96>>2];e=o[b+64>>2];h=0;while(1){c=d+(h<<6)|0;o[c+16>>2]=o[e+16>>2];o[c+20>>2]=o[e+20>>2];o[c+24>>2]=o[e+24>>2];o[c+28>>2]=o[e+28>>2];o[c>>2]=o[e>>2];o[c+4>>2]=o[e+4>>2];o[c+8>>2]=o[e+8>>2];o[c+12>>2]=o[e+12>>2];o[c+32>>2]=o[e+32>>2];o[c+36>>2]=o[e+36>>2];o[c+40>>2]=o[e+40>>2];e=e+48|0;h=h+1|0;if((i|0)!=(h|0)){continue}break}}f=o[b+60>>2];o[j+8>>2]=0;o[j+12>>2]=0;o[j>>2]=0;o[j+4>>2]=0;e=o[a+128>>2];if((e|0)<(f|0)){if(o[a+132>>2]<(f|0)){a:{if(!f){k=0;d=e;break a}o[6257]=o[6257]+1;k=l[o[4968]](f<<4,16)|0;d=o[a+128>>2];}if((d|0)>=1){h=0;while(1){c=h<<4;i=c+k|0;g=c+o[a+136>>2]|0;c=o[g+4>>2];o[i>>2]=o[g>>2];o[i+4>>2]=c;c=o[g+12>>2];o[i+8>>2]=o[g+8>>2];o[i+12>>2]=c;h=h+1|0;if((d|0)!=(h|0)){continue}break}}d=o[a+136>>2];if(d){if(p[a+140|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+136>>2]=0;}o[a+136>>2]=k;o[a+132>>2]=f;m[a+140|0]=1;}while(1){d=o[j+4>>2];c=o[a+136>>2]+(e<<4)|0;o[c>>2]=o[j>>2];o[c+4>>2]=d;d=o[j+12>>2];o[c+8>>2]=o[j+8>>2];o[c+12>>2]=d;e=e+1|0;if((f|0)!=(e|0)){continue}break}}o[a+128>>2]=f;if((f|0)>=1){d=o[a+136>>2];e=o[b+68>>2];h=0;while(1){c=d+(h<<4)|0;o[c+12>>2]=o[e+12>>2];n[c+6>>1]=q[e+6>>1];n[c+8>>1]=q[e+8>>1];n[c+10>>1]=q[e+10>>1];n[c>>1]=q[e>>1];n[c+2>>1]=q[e+2>>1];n[c+4>>1]=q[e+4>>1];e=e+16|0;h=h+1|0;if((f|0)!=(h|0)){continue}break}}o[a+144>>2]=o[b+76>>2];h=o[a+152>>2];f=o[b+80>>2];if((h|0)<(f|0)){if(o[a+156>>2]<(f|0)){b:{if(!f){k=0;d=h;break b}o[6257]=o[6257]+1;k=l[o[4968]](f<<5,16)|0;d=o[a+152>>2];}if((d|0)>=1){e=0;while(1){c=e<<5;i=c+k|0;g=c+o[a+160>>2]|0;c=o[g+4>>2];o[i>>2]=o[g>>2];o[i+4>>2]=c;c=o[g+28>>2];o[i+24>>2]=o[g+24>>2];o[i+28>>2]=c;c=o[g+20>>2];o[i+16>>2]=o[g+16>>2];o[i+20>>2]=c;c=o[g+12>>2];o[i+8>>2]=o[g+8>>2];o[i+12>>2]=c;e=e+1|0;if((d|0)!=(e|0)){continue}break}}d=o[a+160>>2];if(d){if(p[a+164|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+160>>2]=0;}o[a+160>>2]=k;o[a+156>>2]=f;m[a+164|0]=1;}while(1){d=o[j+4>>2];c=o[a+160>>2]+(h<<5)|0;o[c>>2]=o[j>>2];o[c+4>>2]=d;d=o[j+28>>2];o[c+24>>2]=o[j+24>>2];o[c+28>>2]=d;d=o[j+20>>2];o[c+16>>2]=o[j+16>>2];o[c+20>>2]=d;d=o[j+12>>2];o[c+8>>2]=o[j+8>>2];o[c+12>>2]=d;h=h+1|0;if((f|0)!=(h|0)){continue}break}}o[a+152>>2]=f;if((f|0)>=1){d=o[a+160>>2];e=o[b+72>>2];a=0;while(1){b=d+(a<<5)|0;n[b+6>>1]=q[e+14>>1];n[b+8>>1]=q[e+16>>1];n[b+10>>1]=q[e+18>>1];n[b>>1]=q[e+8>>1];n[b+2>>1]=q[e+10>>1];n[b+4>>1]=q[e+12>>1];o[b+12>>2]=o[e>>2];o[b+16>>2]=o[e+4>>2];e=e+20|0;a=a+1|0;if((f|0)!=(a|0)){continue}break}}K=j- -64|0;}function qm(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;var k=0,n=v(0),q=v(0),r=0,t=0,w=0,x=v(0),y=0,z=0;a:{if(!(m[i+72|0]&1)){break a}j=o[a+68>>2];t=o[a+28>>2];r=o[a+48>>2];if((r|0)>=1){f=u(o[a+232>>2],1664525)+1013904223|0;b:{if((r|0)==1){break b}c=2;e=o[a+136>>2];d=o[e+4>>2];f=u(f,1664525)+1013904223|0;k=f^f>>>16;k=k>>>8^k;k=k>>>4^k;k=k>>>2^k;k=e+(((k>>>1^k)&1)<<2)|0;o[e+4>>2]=o[k>>2];o[k>>2]=d;if((r|0)==2){break b}while(1){d=c;c=d+1|0;k=e+(d<<2)|0;z=o[k>>2];y=k;f=u(f,1664525)+1013904223|0;k=f;c:{if(d>>>0>65535){break c}w=f>>>16^f;k=w;if(d>>>0>255){break c}w=w^w>>>8;k=w;if(d>>>0>15){break c}w=w^w>>>4;k=w;if(d>>>0>3){break c}k=w^w>>>2;}d=((k>>>0)%(c>>>0)<<2)+e|0;o[y>>2]=o[d>>2];o[d>>2]=z;if((c|0)!=(r|0)){continue}break}}o[a+232>>2]=f;}if(o[i+20>>2]<=(b|0)){break a}if((t|0)>=1){f=u(o[a+232>>2],1664525)+1013904223|0;d:{if((t|0)==1){break d}c=2;e=o[a+116>>2];d=o[e+4>>2];f=u(f,1664525)+1013904223|0;k=f^f>>>16;k=k>>>8^k;k=k>>>4^k;k=k>>>2^k;k=e+(((k>>>1^k)&1)<<2)|0;o[e+4>>2]=o[k>>2];o[k>>2]=d;if((t|0)==2){break d}while(1){d=c;c=d+1|0;k=e+(d<<2)|0;w=o[k>>2];y=k;f=u(f,1664525)+1013904223|0;k=f;e:{if(d>>>0>65535){break e}r=f>>>16^f;k=r;if(d>>>0>255){break e}r=r^r>>>8;k=r;if(d>>>0>15){break e}r=r^r>>>4;k=r;if(d>>>0>3){break e}k=r^r>>>2;}d=((k>>>0)%(c>>>0)<<2)+e|0;o[y>>2]=o[d>>2];o[d>>2]=w;if((c|0)!=(t|0)){continue}break}}o[a+232>>2]=f;}if((j|0)<1){break a}f=u(o[a+232>>2],1664525)+1013904223|0;f:{if((j|0)==1){break f}c=2;e=o[a+156>>2];d=o[e+4>>2];f=u(f,1664525)+1013904223|0;k=f^f>>>16;k=k>>>8^k;k=k>>>4^k;k=k>>>2^k;k=e+(((k>>>1^k)&1)<<2)|0;o[e+4>>2]=o[k>>2];o[k>>2]=d;if((j|0)==2){break f}while(1){d=c;c=d+1|0;k=e+(d<<2)|0;r=o[k>>2];w=k;f=u(f,1664525)+1013904223|0;k=f;g:{if(d>>>0>65535){break g}t=f>>>16^f;k=t;if(d>>>0>255){break g}t=t^t>>>8;k=t;if(d>>>0>15){break g}t=t^t>>>4;k=t;if(d>>>0>3){break g}k=t^t>>>2;}d=((k>>>0)%(c>>>0)<<2)+e|0;o[w>>2]=o[d>>2];o[d>>2]=r;if((c|0)!=(j|0)){continue}break}}o[a+232>>2]=f;}e=o[a+48>>2];if((e|0)>=1){c=0;while(1){d=o[a+56>>2]+u(o[o[a+136>>2]+(c<<2)>>2],152)|0;if(o[d+136>>2]>(b|0)){q=n;e=o[a+16>>2];n=v(l[o[a+212>>2]](e+u(o[d+144>>2],244)|0,e+u(o[d+148>>2],244)|0,d));n=v(q+v(n*n));e=o[a+48>>2];}c=c+1|0;if((c|0)<(e|0)){continue}break}}h:{if(o[i+20>>2]<=(b|0)){break h}if((h|0)>=1){c=0;while(1){b=(c<<2)+g|0;d=o[b>>2];if(p[d+20|0]){d=Ra(a,o[d+28>>2],s[i+12>>2]);e=Ra(a,o[o[b>>2]+32>>2],s[i+12>>2]);b=o[b>>2];f=u(d,244);d=o[a+16>>2];l[o[o[b>>2]+24>>2]](b,f+d|0,d+u(e,244)|0,s[i+12>>2]);}c=c+1|0;if((h|0)!=(c|0)){continue}break}}d=o[a+28>>2];b=o[i+72>>2];i:{if(!(b&512)){if((d|0)>=1){c=0;while(1){q=n;e=o[a+16>>2];b=o[a+36>>2]+u(o[o[a+116>>2]+(c<<2)>>2],152)|0;n=v(l[o[a+216>>2]](e+u(o[b+144>>2],244)|0,e+u(o[b+148>>2],244)|0,b));n=v(q+v(n*n));c=c+1|0;if((d|0)!=(c|0)){continue}break}}d=o[a+68>>2];if((d|0)<1){break i}b=0;while(1){c=o[a+76>>2]+u(o[o[a+156>>2]+(b<<2)>>2],152)|0;q=s[(o[a+36>>2]+u(o[c+140>>2],152)|0)+100>>2];if(!!(q>v(0))){x=s[c+104>>2];s[c+124>>2]=q*x;s[c+120>>2]=q*v(-x);q=n;e=o[a+16>>2];n=v(l[o[a+212>>2]](e+u(o[c+144>>2],244)|0,e+u(o[c+148>>2],244)|0,c));n=v(q+v(n*n));}b=b+1|0;if((d|0)!=(b|0)){continue}break}break i}if((d|0)<1){break i}f=b&16?2:1;c=0;while(1){q=n;e=o[a+16>>2];b=o[a+36>>2]+u(o[o[a+116>>2]+(c<<2)>>2],152)|0;n=v(l[o[a+216>>2]](e+u(o[b+144>>2],244)|0,e+u(o[b+148>>2],244)|0,b));n=v(q+v(n*n));e=u(c,f)<<2;q=s[b+100>>2];g=q>v(0)^1;if(!g){b=o[a+76>>2]+u(o[e+o[a+156>>2]>>2],152)|0;x=s[b+104>>2];s[b+124>>2]=q*x;s[b+120>>2]=q*v(-x);x=n;h=o[a+16>>2];n=v(l[o[a+212>>2]](h+u(o[b+144>>2],244)|0,h+u(o[b+148>>2],244)|0,b));n=v(x+v(n*n));}if(!(g|!(p[i+72|0]&16))){b=o[a+76>>2]+u(o[(e+o[a+156>>2]|0)+4>>2],152)|0;x=s[b+104>>2];s[b+124>>2]=q*x;s[b+120>>2]=q*v(-x);q=n;e=o[a+16>>2];n=v(l[o[a+212>>2]](e+u(o[b+144>>2],244)|0,e+u(o[b+148>>2],244)|0,b));n=v(q+v(n*n));}c=c+1|0;if((d|0)!=(c|0)){continue}break}}d=o[a+88>>2];if((d|0)<1){break h}b=0;while(1){c=o[a+96>>2]+u(b,152)|0;q=s[(o[a+36>>2]+u(o[c+140>>2],152)|0)+100>>2];if(!!(q>v(0))){x=q;q=s[c+104>>2];x=v(x*q);q=x>q?q:x;s[c+124>>2]=q;s[c+120>>2]=-q;q=n;e=o[a+16>>2];n=v(l[o[a+212>>2]](e+u(o[c+144>>2],244)|0,e+u(o[c+148>>2],244)|0,c));n=v(q+v(n*n));}b=b+1|0;if((d|0)!=(b|0)){continue}break}}return v(n)}function Ll(a,b,c){var d=0,e=v(0),f=0,g=v(0),h=0,i=0,j=0,k=v(0),l=v(0),n=v(0),q=v(0),t=v(0),u=0,w=v(0),x=v(0),y=0,z=0,A=0,B=v(0),D=v(0);z=K-16|0;K=z;a:{b:{i=o[b+372>>2];if(r[i+32>>2]<2){break b}if(!Qa(b)){break b}f=o[a+18496>>2];if(f){d=o[a+18508>>2];j=o[a+18500>>2];while(1){h=o[f+48>>2];if(h){o[h+44>>2]=o[f+44>>2];}h=o[f+44>>2];if(h){o[h+48>>2]=o[f+48>>2];}if(o[a+18496>>2]==(f|0)){o[a+18496>>2]=o[f+48>>2];}o[f+44>>2]=0;o[f+48>>2]=o[a+18504>>2];h=o[a+18504>>2];if(h){o[h+44>>2]=f;}j=j+ -1|0;o[a+18504>>2]=f;d=d+1|0;f=o[a+18496>>2];if(f){continue}break}o[a+18508>>2]=d;o[a+18500>>2]=j;}o[a+18492>>2]=0;o[a>>2]=0;d=o[i>>2];j=o[i+12>>2];e=s[j+16>>2];t=v(s[d+16>>2]-e);f=o[i+4>>2];g=s[j+20>>2];l=v(s[f+20>>2]-g);h=o[i+8>>2];k=s[j+24>>2];n=v(s[h+24>>2]-k);q=v(s[d+20>>2]-g);w=v(s[f+24>>2]-k);x=v(s[h+16>>2]-e);k=v(s[d+24>>2]-k);e=v(s[f+16>>2]-e);g=v(s[h+20>>2]-g);c:{if(!(v(v(v(v(t*l)*n)+v(v(v(v(v(q*w)*x)+v(v(k*e)*g))-v(v(t*w)*g))-v(v(q*e)*n)))-v(v(k*l)*x))<v(0))){j=f;f=d;break c}o[i+4>>2]=d;o[i>>2]=f;j=o[i+16>>2];o[i+16>>2]=o[i+20>>2];o[i+20>>2]=j;j=d;}j=rb(a,f,j,h,1);h=rb(a,o[i+4>>2],o[i>>2],o[i+12>>2],1);u=rb(a,o[i+8>>2],o[i+4>>2],o[i+12>>2],1);y=rb(a,o[i>>2],o[i+8>>2],o[i+12>>2],1);if(o[a+18500>>2]!=4){break b}d=o[a+18496>>2];e=s[d+16>>2];f=o[d+48>>2];if(f){e=v(e*e);while(1){g=s[f+16>>2];g=v(g*g);c=g<e;d=c?f:d;e=c?g:e;f=o[f+48>>2];if(f){continue}break}e=s[d+16>>2];}c=o[d+28>>2];i=o[d+24>>2];A=o[d+20>>2];l=s[d+12>>2];t=s[d+8>>2];k=s[d+4>>2];g=s[d>>2];o[j+32>>2]=h;m[j+52|0]=0;o[h+32>>2]=j;m[h+52|0]=0;o[j+36>>2]=u;m[j+53|0]=0;o[u+32>>2]=j;m[u+52|0]=1;o[j+40>>2]=y;m[j+54|0]=0;o[y+32>>2]=j;m[y+52|0]=2;o[h+36>>2]=y;m[h+53|0]=2;o[y+40>>2]=h;m[y+54|0]=1;o[h+40>>2]=u;m[h+54|0]=1;o[u+36>>2]=h;m[u+53|0]=258;m[u+54|0]=1;o[u+40>>2]=y;o[y+36>>2]=u;m[y+53|0]=2;o[a>>2]=0;j=0;while(1){d:{e:{h=o[a+18492>>2];if(h>>>0<=127){f=0;o[z+8>>2]=0;o[z>>2]=0;o[z+4>>2]=0;o[a+18492>>2]=h+1;j=j+1|0;m[d+55|0]=j;h=(h<<5)+a|0;u=h+60|0;Ia(b,d,u);if(!(v(v(v(v(s[d>>2]*s[h+76>>2])+v(s[d+4>>2]*s[h+80>>2]))+v(s[d+8>>2]*s[h+84>>2]))-s[d+16>>2])>v(9999999747378752e-20))){o[a>>2]=7;break d}while(1){h=Zc(a,j,u,o[((f<<2)+d|0)+32>>2],p[(d+f|0)+52|0],z);if(!h){break e}y=f>>>0<2;f=f+1|0;if(y){continue}break}break e}o[a>>2]=6;break d}if(!(h&r[z+8>>2]>2)){o[a>>2]=4;break d}c=o[z>>2];f=o[z+4>>2];o[c+36>>2]=f;m[c+53|0]=2;o[f+40>>2]=c;m[f+54|0]=1;c=o[d+48>>2];if(c){o[c+44>>2]=o[d+44>>2];}c=o[d+44>>2];if(c){o[c+48>>2]=o[d+48>>2];}if(o[a+18496>>2]==(d|0)){o[a+18496>>2]=o[d+48>>2];}o[a+18500>>2]=o[a+18500>>2]+ -1;o[d+44>>2]=0;o[d+48>>2]=o[a+18504>>2];c=o[a+18504>>2];if(c){o[c+44>>2]=d;}o[a+18504>>2]=d;o[a+18508>>2]=o[a+18508>>2]+1;d=o[a+18496>>2];e=s[d+16>>2];f=o[d+48>>2];if(f){e=v(e*e);while(1){g=s[f+16>>2];g=v(g*g);c=g<e;d=c?f:d;e=c?g:e;f=o[f+48>>2];if(f){continue}break}e=s[d+16>>2];}c=o[d+28>>2];i=o[d+24>>2];A=o[d+20>>2];l=s[d+12>>2];t=s[d+8>>2];k=s[d+4>>2];g=s[d>>2];if((j|0)!=255){continue}}break}s[a+56>>2]=e;s[a+40>>2]=g;o[a+4>>2]=A;s[a+52>>2]=l;s[a+48>>2]=t;s[a+44>>2]=k;o[a+36>>2]=3;o[a+12>>2]=c;o[a+8>>2]=i;g=v(g*e);l=v(s[i+16>>2]-g);k=v(k*e);n=v(s[c+20>>2]-k);q=v(s[i+20>>2]-k);w=v(s[c+16>>2]-g);x=v(v(l*n)-v(q*w));e=v(t*e);t=v(s[c+24>>2]-e);B=v(q*t);q=v(s[i+24>>2]-e);n=v(B-v(q*n));t=v(v(q*w)-v(l*t));t=v(C(v(v(x*x)+v(v(n*n)+v(t*t)))));s[a+20>>2]=t;l=v(s[c+16>>2]-g);n=v(s[A+20>>2]-k);q=v(s[c+20>>2]-k);w=v(s[A+16>>2]-g);x=v(v(l*n)-v(q*w));D=v(x*x);B=q;q=v(s[A+24>>2]-e);x=v(s[c+24>>2]-e);n=v(v(B*q)-v(x*n));l=v(v(x*w)-v(l*q));l=v(C(v(D+v(v(n*n)+v(l*l)))));s[a+24>>2]=l;n=v(s[A+16>>2]-g);q=v(s[i+20>>2]-k);k=v(s[A+20>>2]-k);g=v(s[i+16>>2]-g);w=v(v(n*q)-v(k*g));B=k;k=v(s[i+24>>2]-e);e=v(s[A+24>>2]-e);q=v(v(B*k)-v(e*q));e=v(v(e*g)-v(n*k));g=v(C(v(v(w*w)+v(v(q*q)+v(e*e)))));e=v(g+v(t+l));s[a+28>>2]=g/e;s[a+24>>2]=l/e;s[a+20>>2]=t/e;a=o[a>>2];break a}o[a>>2]=8;e=s[c>>2];g=s[c+4>>2];k=s[c+8>>2];o[a+52>>2]=0;t=v(-k);s[a+48>>2]=t;l=v(-g);s[a+44>>2]=l;n=v(-e);s[a+40>>2]=n;e=v(C(v(v(v(e*e)+v(g*g))+v(k*k))));f:{if(!!(e>v(0))){e=v(v(1)/e);s[a+48>>2]=e*t;s[a+44>>2]=e*l;s[a+40>>2]=e*n;break f}o[a+48>>2]=0;o[a+40>>2]=1065353216;o[a+44>>2]=0;}o[a+52>>2]=0;o[a+56>>2]=0;o[a+36>>2]=1;b=o[i>>2];o[a+20>>2]=1065353216;o[a+4>>2]=b;a=8;}K=z+16|0;return a}function tn(a,b,c){a=a|0;b=b|0;c=c|0;Vb(a,b,c);o[b+52>>2]=o[a+48>>2];o[b+56>>2]=o[a+52>>2];o[b+60>>2]=o[a+56>>2];o[b+64>>2]=o[a+60>>2];o[b+68>>2]=o[a- -64>>2];o[b+72>>2]=o[a+68>>2];o[b+76>>2]=o[a+72>>2];o[b+80>>2]=o[a+76>>2];o[b+84>>2]=o[a+80>>2];o[b+88>>2]=o[a+84>>2];o[b+92>>2]=o[a+88>>2];o[b+96>>2]=o[a+92>>2];o[b+100>>2]=o[a+96>>2];o[b+104>>2]=o[a+100>>2];o[b+108>>2]=o[a+104>>2];o[b+112>>2]=o[a+108>>2];o[b+116>>2]=o[a+112>>2];o[b+120>>2]=o[a+116>>2];o[b+124>>2]=o[a+120>>2];o[b+128>>2]=o[a+124>>2];o[b+132>>2]=o[a+128>>2];o[b+136>>2]=o[a+132>>2];o[b+140>>2]=o[a+136>>2];o[b+144>>2]=o[a+140>>2];o[b+148>>2]=o[a+144>>2];o[b+152>>2]=o[a+148>>2];o[b+156>>2]=o[a+152>>2];o[b+160>>2]=o[a+156>>2];o[b+164>>2]=o[a+160>>2];o[b+168>>2]=o[a+164>>2];o[b+172>>2]=o[a+168>>2];o[b+176>>2]=o[a+172>>2];o[b+428>>2]=o[a+968>>2];o[b+412>>2]=o[a+972>>2];o[b+444>>2]=o[a+976>>2];o[b+460>>2]=o[a+980>>2];o[b+476>>2]=o[a+984>>2];o[b+492>>2]=o[a+988>>2];o[b+508>>2]=o[a+992>>2];o[b+524>>2]=o[a+1e3>>2];o[b+540>>2]=o[a+1004>>2];o[b+556>>2]=o[a+1012>>2];o[b+572>>2]=o[a+1020>>2];o[b+588>>2]=o[a+1028>>2];o[b+604>>2]=o[a+1036>>2];o[b+432>>2]=o[a+1056>>2];o[b+416>>2]=o[a+1060>>2];o[b+448>>2]=o[a+1064>>2];o[b+464>>2]=o[a+1068>>2];o[b+480>>2]=o[a+1072>>2];o[b+496>>2]=o[a+1076>>2];o[b+512>>2]=o[a+1080>>2];o[b+528>>2]=o[a+1088>>2];o[b+544>>2]=o[a+1092>>2];o[b+560>>2]=o[a+1100>>2];o[b+576>>2]=o[a+1108>>2];o[b+592>>2]=o[a+1116>>2];o[b+608>>2]=o[a+1124>>2];o[b+436>>2]=o[a+1144>>2];o[b+420>>2]=o[a+1148>>2];o[b+452>>2]=o[a+1152>>2];o[b+468>>2]=o[a+1156>>2];o[b+484>>2]=o[a+1160>>2];o[b+500>>2]=o[a+1164>>2];o[b+516>>2]=o[a+1168>>2];o[b+532>>2]=o[a+1176>>2];o[b+548>>2]=o[a+1180>>2];o[b+564>>2]=o[a+1188>>2];o[b+580>>2]=o[a+1196>>2];o[b+596>>2]=o[a+1204>>2];c=o[a+1212>>2];o[b+440>>2]=0;o[b+612>>2]=c;o[b+616>>2]=0;o[b+600>>2]=0;o[b+584>>2]=0;o[b+568>>2]=0;o[b+552>>2]=0;o[b+536>>2]=0;o[b+520>>2]=0;o[b+504>>2]=0;o[b+488>>2]=0;o[b+472>>2]=0;o[b+456>>2]=0;o[b+424>>2]=0;m[b+620|0]=p[a+996|0];m[b+624|0]=p[a+1008|0];m[b+628|0]=p[a+1016|0];m[b+632|0]=p[a+1024|0];m[b+636|0]=p[a+1032|0];m[b+621|0]=p[a+1084|0];m[b+625|0]=p[a+1096|0];m[b+629|0]=p[a+1104|0];m[b+633|0]=p[a+1112|0];m[b+637|0]=p[a+1120|0];m[b+622|0]=p[a+1172|0];m[b+626|0]=p[a+1184|0];m[b+630|0]=p[a+1192|0];m[b+634|0]=p[a+1200|0];c=p[a+1208|0];m[b+639|0]=0;m[b+635|0]=0;m[b+631|0]=0;m[b+627|0]=0;m[b+623|0]=0;m[b+638|0]=c;o[b+196>>2]=o[a+680>>2];o[b+200>>2]=o[a+684>>2];o[b+204>>2]=o[a+688>>2];o[b+208>>2]=o[a+692>>2];o[b+180>>2]=o[a+696>>2];o[b+184>>2]=o[a+700>>2];o[b+188>>2]=o[a+704>>2];o[b+192>>2]=o[a+708>>2];o[b+212>>2]=o[a+712>>2];o[b+216>>2]=o[a+716>>2];o[b+220>>2]=o[a+720>>2];o[b+224>>2]=o[a+724>>2];o[b+228>>2]=o[a+728>>2];o[b+232>>2]=o[a+732>>2];o[b+236>>2]=o[a+736>>2];o[b+240>>2]=o[a+740>>2];o[b+244>>2]=o[a+744>>2];o[b+248>>2]=o[a+748>>2];o[b+252>>2]=o[a+752>>2];o[b+256>>2]=o[a+756>>2];o[b+260>>2]=o[a+760>>2];o[b+264>>2]=o[a+764>>2];o[b+268>>2]=o[a+768>>2];o[b+272>>2]=o[a+772>>2];o[b+276>>2]=o[a+776>>2];o[b+280>>2]=o[a+780>>2];o[b+284>>2]=o[a+784>>2];o[b+288>>2]=o[a+788>>2];o[b+292>>2]=o[a+876>>2];o[b+296>>2]=o[a+880>>2];o[b+300>>2]=o[a+884>>2];o[b+304>>2]=o[a+888>>2];o[b+308>>2]=o[a+892>>2];o[b+312>>2]=o[a+896>>2];o[b+316>>2]=o[a+900>>2];o[b+320>>2]=o[a+904>>2];o[b+324>>2]=o[a+804>>2];o[b+328>>2]=o[a+808>>2];o[b+332>>2]=o[a+812>>2];o[b+336>>2]=o[a+816>>2];o[b+340>>2]=o[a+820>>2];o[b+344>>2]=o[a+824>>2];o[b+348>>2]=o[a+828>>2];o[b+352>>2]=o[a+832>>2];o[b+356>>2]=o[a+840>>2];o[b+360>>2]=o[a+844>>2];o[b+364>>2]=o[a+848>>2];o[b+368>>2]=o[a+852>>2];o[b+372>>2]=o[a+860>>2];o[b+376>>2]=o[a+864>>2];o[b+380>>2]=o[a+868>>2];o[b+384>>2]=o[a+872>>2];m[b+388|0]=p[a+792|0];m[b+392|0]=p[a+795|0];m[b+396|0]=p[a+798|0];m[b+400|0]=p[a+836|0];m[b+404|0]=p[a+856|0];m[b+389|0]=p[a+793|0];m[b+393|0]=p[a+796|0];m[b+397|0]=p[a+799|0];m[b+401|0]=p[a+837|0];m[b+405|0]=p[a+857|0];m[b+390|0]=p[a+794|0];m[b+394|0]=p[a+797|0];m[b+398|0]=p[a+800|0];m[b+402|0]=p[a+838|0];c=p[a+858|0];m[b+407|0]=0;m[b+403|0]=0;m[b+399|0]=0;m[b+395|0]=0;m[b+391|0]=0;m[b+406|0]=c;a=o[a+1232>>2];o[b+408>>2]=0;o[b+640>>2]=a;return 3204}function On(a,b,c,d){var e=0,f=0,g=0,h=v(0),i=0,j=0,k=v(0),n=0,q=v(0),r=v(0),t=v(0),w=v(0),x=0,A=0,B=v(0),C=v(0),D=0,E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0);e=K-512|0;K=e;if((c|0)>=1){while(1){g=o[(x<<2)+b>>2];o[g+268>>2]=1065353216;a:{b:{f=o[g+220>>2]+ -2|0;if(f>>>0>3){break b}switch(f-1|0){case 0:case 1:break b;default:break a}}if(p[g+204|0]&3){break a}ub(g,d,e+448|0);if(!p[a+44|0]){break a}h=s[g+276>>2];h=v(h*h);if(h==v(0)){break a}k=h;h=v(s[e+496>>2]-s[g+52>>2]);q=v(h*h);h=v(s[e+500>>2]-s[g+56>>2]);q=v(q+v(h*h));h=v(s[e+504>>2]-s[g+60>>2]);if(!(k<v(q+v(h*h)))){break a}l[o[4966]](2640);if(o[o[g+192>>2]+4>>2]<=19){o[5207]=o[5207]+1;f=o[a+68>>2];f=l[o[o[f>>2]+36>>2]](f)|0;i=o[a+24>>2];o[e+348>>2]=-1;o[e+340>>2]=1065353216;o[e+344>>2]=1;j=o[g+64>>2];o[e+360>>2]=o[g+60>>2];o[e+364>>2]=j;j=o[g+56>>2];o[e+352>>2]=o[g+52>>2];o[e+356>>2]=j;j=o[e+508>>2];o[e+376>>2]=o[e+504>>2];o[e+380>>2]=j;j=o[e+500>>2];o[e+368>>2]=o[e+496>>2];o[e+372>>2]=j;o[e+416>>2]=0;o[e+336>>2]=3052;o[e+428>>2]=f;o[e+432>>2]=i;o[e+424>>2]=0;o[e+420>>2]=g;f=o[g+272>>2];sa(e+280|0);o[e+304>>2]=1065353216;o[e+296>>2]=1065353216;o[e+300>>2]=1065353216;o[e+284>>2]=8;o[e+280>>2]=11388;o[e+316>>2]=0;o[e+320>>2]=0;o[e+324>>2]=0;o[e+308>>2]=0;o[e+312>>2]=0;o[e+332>>2]=0;o[e+328>>2]=f;o[e+312>>2]=f;o[e+424>>2]=o[a+56>>2];f=o[g+188>>2];o[e+344>>2]=o[f+4>>2];o[e+348>>2]=o[f+8>>2];f=o[e+460>>2];o[e+224>>2]=o[e+456>>2];o[e+228>>2]=f;f=o[e+452>>2];o[e+216>>2]=o[e+448>>2];o[e+220>>2]=f;f=o[e+476>>2];o[e+240>>2]=o[e+472>>2];o[e+244>>2]=f;f=o[e+468>>2];o[e+232>>2]=o[e+464>>2];o[e+236>>2]=f;f=o[e+492>>2];o[e+256>>2]=o[e+488>>2];o[e+260>>2]=f;f=o[e+484>>2];o[e+248>>2]=o[e+480>>2];o[e+252>>2]=f;f=o[e+508>>2];o[e+272>>2]=o[e+504>>2];o[e+276>>2]=f;f=o[e+500>>2];o[e+264>>2]=o[e+496>>2];o[e+268>>2]=f;f=g+4|0;i=o[f+12>>2];o[e+224>>2]=o[f+8>>2];o[e+228>>2]=i;i=o[f+4>>2];o[e+216>>2]=o[f>>2];o[e+220>>2]=i;i=o[g+32>>2];o[e+240>>2]=o[g+28>>2];o[e+244>>2]=i;i=o[g+24>>2];o[e+232>>2]=o[g+20>>2];o[e+236>>2]=i;i=o[g+48>>2];o[e+256>>2]=o[g+44>>2];o[e+260>>2]=i;i=o[g+40>>2];o[e+248>>2]=o[g+36>>2];o[e+252>>2]=i;Pc(a,e+280|0,f,e+216|0,e+336|0);h=s[e+340>>2];if(!!(h<v(1))){r=v(h*v(s[e+500>>2]-s[g+56>>2]));t=v(h*v(s[e+496>>2]-s[g+52>>2]));w=v(h*v(s[e+504>>2]-s[g+60>>2]));N=v(v(v(r*v(-s[e+388>>2]))-v(t*s[e+384>>2]))-v(w*s[e+392>>2]));f=o[a+24>>2];i=l[o[o[f>>2]+12>>2]](f,g,o[e+416>>2])|0;f=o[a+324>>2];c:{if((f|0)!=o[a+328>>2]){break c}j=f?f<<1:1;if((f|0)>=(j|0)){break c}n=0;A=0;if(j){o[6257]=o[6257]+1;A=l[o[4968]](j<<2,16)|0;f=o[a+324>>2];}if((f|0)>=1){while(1){D=n<<2;o[D+A>>2]=o[o[a+332>>2]+D>>2];n=n+1|0;if((f|0)!=(n|0)){continue}break}}n=o[a+332>>2];if(n){if(p[a+336|0]){if(n){o[6258]=o[6258]+1;l[o[4969]](n);}f=o[a+324>>2];}o[a+332>>2]=0;}o[a+332>>2]=A;m[a+336|0]=1;o[a+328>>2]=j;}o[o[a+332>>2]+(f<<2)>>2]=i;o[a+324>>2]=f+1;f=o[e+416>>2];E=s[f+20>>2];F=s[f+36>>2];G=s[f+40>>2];H=s[f+8>>2];I=s[f+24>>2];h=s[f+60>>2];O=s[f+56>>2];B=s[f+52>>2];J=s[f+44>>2];L=s[f+12>>2];k=s[f+28>>2];M=s[f+4>>2];q=s[g+60>>2];C=s[g+52>>2];P=s[g+56>>2];o[e+16>>2]=0;o[e+20>>2]=0;o[e+36>>2]=0;o[e+8>>2]=0;o[e+12>>2]=0;t=v(t+C);r=v(r+P);w=v(w+q);C=v(v(v(L*t)+v(k*r))+v(J*w));q=k;k=v(-O);s[e+32>>2]=C+v(v(v(q*k)-v(L*B))-v(J*h));s[e+28>>2]=v(v(v(t*H)+v(r*I))+v(w*G))+v(v(v(I*k)-v(H*B))-v(G*h));s[e+24>>2]=v(v(v(t*M)+v(r*E))+v(w*F))+v(v(v(E*k)-v(M*B))-v(F*h));f=o[e+388>>2];o[e+72>>2]=o[e+384>>2];o[e+76>>2]=f;f=o[e+396>>2];o[e+80>>2]=o[e+392>>2];o[e+84>>2]=f;s[e+88>>2]=N;o[e+100>>2]=0;o[e+104>>2]=0;o[e+92>>2]=0;o[e+96>>2]=0;o[e+172>>2]=0;o[e+164>>2]=0;o[e+168>>2]=0;o[e+156>>2]=0;o[e+160>>2]=0;o[e+148>>2]=0;o[e+152>>2]=0;o[e+140>>2]=0;o[e+144>>2]=0;o[e+132>>2]=0;o[e+136>>2]=0;o[e+124>>2]=0;o[e+128>>2]=0;f=u($c(i,e+8|0),208)+i|0;o[f+100>>2]=0;s[f+88>>2]=y(v(z(v(s[g+228>>2]*s[o[e+416>>2]+228>>2]),v(-10))),v(10));i=o[g+56>>2];o[f+52>>2]=o[g+52>>2];o[f+56>>2]=i;i=o[g+64>>2];o[f+60>>2]=o[g+60>>2];o[f+64>>2]=i;o[f+48>>2]=0;s[f+44>>2]=w;s[f+40>>2]=r;s[f+36>>2]=t;}}l[o[4967]]();}x=x+1|0;if((x|0)!=(c|0)){continue}break}}K=e+512|0;}function Km(a,b,c,d,e,f){var g=v(0),h=0,i=v(0),j=0,k=v(0),l=0,n=0,q=v(0),r=0,t=v(0),w=0,x=0,y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=0,F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),K=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0),Z=v(0),_=v(0),$=v(0),aa=v(0),ba=v(0),ca=v(0),da=v(0),ea=v(0),fa=v(0),ga=v(0),ha=v(0),ia=v(0),ja=v(0);B=s[a+656>>2];t=s[d+40>>2];ba=v(B*t);K=s[a+624>>2];y=s[d+32>>2];L=s[a+640>>2];z=s[d+36>>2];ca=v(v(K*y)+v(L*z));k=s[d+24>>2];da=v(B*k);i=s[d+16>>2];g=s[d+20>>2];ea=v(v(K*i)+v(L*g));R=s[a+592>>2];J=s[c+40>>2];fa=v(R*J);F=s[a+560>>2];A=s[c+32>>2];G=s[a+576>>2];q=s[c+36>>2];ga=v(v(F*A)+v(G*q));S=s[a+588>>2];ha=v(S*J);T=s[a+556>>2];U=s[a+572>>2];H=v(v(T*A)+v(U*q));V=s[a+584>>2];M=v(V*J);W=s[a+552>>2];X=s[a+568>>2];N=v(v(W*A)+v(X*q));O=s[c+24>>2];ia=v(R*O);P=s[c+16>>2];Q=s[c+20>>2];ja=v(v(F*P)+v(G*Q));Y=s[a+664>>2];Z=s[a+668>>2];C=s[a+672>>2];$=v(v(v(v(y*Y)+v(z*Z))+v(t*C))+s[d+56>>2]);aa=v(v(v(v(i*Y)+v(g*Z))+v(k*C))+s[d+52>>2]);_=s[a+600>>2];D=s[a+604>>2];g=v(v(A*_)+v(q*D));q=s[a+608>>2];I=s[c+56>>2];J=v(v(g+v(J*q))+I);z=s[c+52>>2];A=v(v(v(v(P*_)+v(Q*D))+v(O*q))+z);k=s[d>>2];i=s[d+4>>2];K=v(v(k*K)+v(i*L));g=s[d+8>>2];L=v(g*B);B=s[c>>2];t=v(B*F);F=s[c+4>>2];t=v(t+v(F*G));G=s[c+8>>2];y=v(G*R);C=v(s[d+48>>2]+v(v(v(k*Y)+v(i*Z))+v(g*C)));q=v(s[c+48>>2]+v(v(v(B*_)+v(F*D))+v(G*q)));E=o[b+24>>2];l=p[a+736|0];j=E<<1;a:{if(l){break a}h=o[b+8>>2];o[h>>2]=1065353216;j=(E<<2)+4|0;o[j+h>>2]=1065353216;n=h;h=(E<<3)+8|0;o[n+h>>2]=1065353216;w=o[b+16>>2];o[w>>2]=-1082130432;o[j+w>>2]=-1082130432;o[h+w>>2]=-1082130432;I=s[c+56>>2];z=s[c+52>>2];j=E<<1;}g=s[c+48>>2];n=o[b+12>>2];o[n+12>>2]=0;k=v(J-I);s[n+4>>2]=k;o[n>>2]=0;i=v(A-z);s[n+8>>2]=-i;h=E<<2;c=h+n|0;o[c+12>>2]=0;g=v(q-g);s[c+8>>2]=g;o[c+4>>2]=0;s[c>>2]=-k;c=j<<2;j=c+n|0;o[j+8>>2]=0;o[j+12>>2]=0;s[j+4>>2]=-g;s[j>>2]=i;z=s[d+48>>2];i=s[d+56>>2];g=s[d+52>>2];r=o[b+20>>2];o[r+12>>2]=0;o[r>>2]=0;k=v(aa-g);s[r+8>>2]=k;i=v($-i);s[r+4>>2]=-i;d=h+r|0;o[d+12>>2]=0;g=v(C-z);s[d+8>>2]=-g;o[d+4>>2]=0;s[d>>2]=i;c=c+r|0;o[c+8>>2]=0;o[c+12>>2]=0;s[c+4>>2]=g;s[c>>2]=-k;I=s[(p[a+748|0]&8?a+756|0:b+4|0)>>2];D=v(I*s[b>>2]);x=o[b+28>>2];if(!l){s[x>>2]=D*v(C-q);s[h+x>>2]=D*v(aa-A);s[x+(E<<3)>>2]=D*v($-J);}w=u(E,12);A=v(v(v(W*B)+v(X*F))+v(V*G));s[w+n>>2]=A;j=w+8|0;g=v(N+M);s[j+n>>2]=g;h=w+4|0;C=v(v(v(W*P)+v(X*Q))+v(V*O));s[h+n>>2]=C;l=E<<4;q=v(v(v(B*T)+v(F*U))+v(G*S));s[l+n>>2]=q;d=l|4;M=v(v(v(T*P)+v(U*Q))+v(S*O));s[d+n>>2]=M;c=l|8;N=v(H+ha);s[c+n>>2]=N;s[r+w>>2]=-A;s[j+r>>2]=-g;s[h+r>>2]=-C;s[r+l>>2]=-q;s[d+r>>2]=-M;s[c+r>>2]=-N;H=v(t+y);i=v(ea+da);t=v(ja+ia);z=v(K+L);k=v(v(H*i)-v(t*z));B=v(g*k);g=v(ca+ba);y=v(ga+fa);i=v(v(t*g)-v(y*i));g=v(v(y*z)-v(H*g));s[x+w>>2]=v(B+v(v(A*i)+v(C*g)))*D;s[l+x>>2]=v(v(N*k)+v(v(q*i)+v(M*g)))*D;b:{c:{if(p[a+716|0]){w=1;j=p[a+737|0]!=0;k=v(s[a+708>>2]*s[a+732>>2]);d=k>v(0)?1:2;break c}if(!p[a+737|0]){break b}w=0;k=v(0);j=1;d=0;}x=u(E,5);l=x<<2;s[l+n>>2]=H;h=l+8|0;s[h+n>>2]=y;c=l+4|0;s[c+n>>2]=t;s[h+r>>2]=-y;s[c+r>>2]=-t;s[r+l>>2]=-H;c=a+688|0;i=Tb(c);g=Ub(c);c=o[b+28>>2];o[l+c>>2]=0;l=i!=g;j=(l|w^1)&j;h=o[a+748>>2];if(h&2){I=s[a+764>>2];}if(j){if(h&4){o[o[b+32>>2]+(x<<2)>>2]=o[a+752>>2];}g=Wb(s[a+728>>2],i,g,s[a+680>>2],v(I*s[b>>2]));c=o[b+28>>2];j=x<<2;h=c+j|0;s[h>>2]=v(v(g*s[a+680>>2])*s[a+732>>2])+s[h>>2];s[j+o[b+36>>2]>>2]=-s[a+684>>2];o[j+o[b+40>>2]>>2]=o[a+684>>2];}if(!w){break b}h=c;c=x<<2;h=h+c|0;s[h>>2]=s[h>>2]+v(k*v(I*s[b>>2]));if(m[a+748|0]&1){o[c+o[b+32>>2]>>2]=o[a+760>>2];}d:{if(!l){o[o[b+36>>2]+(x<<2)>>2]=-8388609;g=v(3.4028234663852886e+38);break d}c=o[b+36>>2]+(x<<2)|0;if((d|0)==1){o[c>>2]=0;g=v(3.4028234663852886e+38);break d}o[c>>2]=-8388609;g=v(0);}s[o[b+40>>2]+(x<<2)>>2]=g;g=s[a+704>>2];e:{if(!(g>v(0))){break e}i=v(v(v(v(H*s[e>>2])+v(t*s[e+4>>2]))+v(y*s[e+8>>2]))-v(v(v(H*s[f>>2])+v(t*s[f+4>>2]))+v(y*s[f+8>>2])));if((d|0)==1){if(!(i<v(0))){break e}g=v(i*v(-g));if(!(g>s[h>>2])){break e}s[h>>2]=g;break e}if(!(i>v(0))){break e}g=v(i*v(-g));if(!(g<s[h>>2])){break e}s[h>>2]=g;}s[h>>2]=s[a+700>>2]*s[h>>2];}}function nu(a,b,c){var d=0,f=0,g=0,h=0,j=0,k=v(0),n=v(0),q=v(0),r=0,t=0,x=0,y=0,z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=0,G=0,H=0;f=K-48|0;K=f;j=-246811958;h=1900671690;a:{if((c|0)>0){d=b;x=1900671690;r=1900671690;g=-246811958;t=-246811958;while(1){y=o[d+8>>2];k=s[d+8>>2];j=(e(0,j),i())<k?y:j;F=o[d+4>>2];n=s[d+4>>2];g=(e(0,g),i())<n?F:g;G=o[d>>2];q=s[d>>2];t=(e(0,t),i())<q?G:t;h=k<(e(0,h),i())?y:h;x=n<(e(0,x),i())?F:x;r=q<(e(0,r),i())?G:r;d=d+16|0;H=H+1|0;if((H|0)!=(c|0)){continue}break}break a}t=-246811958;g=-246811958;r=1900671690;x=1900671690;}z=(e(0,g),i());A=(e(0,x),i());k=v(z-A);B=(e(0,j),i());C=(e(0,h),i());n=v(B-C);g=k<n;D=(e(0,t),i());E=(e(0,r),i());q=v(D-E);h=q<n;j=q<k;d=j?g?2:1:h<<1;o[a+112>>2]=d;h=j?(h^1)<<1:g?1:2;if((d|0)==(h|0)){h=(d+1>>>0)%3|0;}o[a+104>>2]=h;o[a+12>>2]=0;o[a+28>>2]=0;g=(d^3)-h|0;o[a+108>>2]=g;s[a+24>>2]=v(B+C)*v(.5);s[a+20>>2]=v(z+A)*v(.5);s[a+16>>2]=v(D+E)*v(.5);d=(d|0)==((g+1|0)%3|0);n=d?v(n*v(9788566967472434e-20)):v(n*v(-9788566967472434e-20));s[a+8>>2]=n;k=d?v(k*v(9788566967472434e-20)):v(k*v(-9788566967472434e-20));s[a+4>>2]=k;q=d?v(q*v(9788566967472434e-20)):v(q*v(-9788566967472434e-20));s[a>>2]=q;o[f+36>>2]=0;m[f+40|0]=1;o[f+28>>2]=0;o[f+32>>2]=0;b:{c:{if((c|0)>=1){o[6257]=o[6257]+1;d=l[o[4968]](c<<4,16)|0;o[f+36>>2]=d;j=1;m[f+40|0]=1;o[f+32>>2]=c;g=o[f+20>>2];o[d+8>>2]=o[f+16>>2];o[d+12>>2]=g;g=o[f+12>>2];o[d>>2]=o[f+8>>2];o[d+4>>2]=g;if((c|0)!=1){while(1){g=o[f+12>>2];d=o[f+36>>2]+(j<<4)|0;o[d>>2]=o[f+8>>2];o[d+4>>2]=g;g=o[f+20>>2];o[d+8>>2]=o[f+16>>2];o[d+12>>2]=g;j=j+1|0;if((j|0)!=(c|0)){continue}break}}n=n!=v(0)?v(v(1)/n):n;z=k!=v(0)?v(v(1)/k):k;q=q!=v(0)?v(v(1)/q):q;o[f+28>>2]=c;r=(f+8|0)+(o[a+104>>2]<<2)|0;t=(f+8|0)+(o[a+112>>2]<<2)|0;x=(f+8|0)+(o[a+108>>2]<<2)|0;A=s[a+24>>2];B=s[a+20>>2];C=s[a+16>>2];y=o[f+36>>2];h=0;while(1){k=s[b>>2];D=s[b+4>>2];E=s[b+8>>2];o[f+20>>2]=0;s[f+16>>2]=n*v(E-A);s[f+12>>2]=z*v(D-B);s[f+8>>2]=q*v(k-C);d=y+(h<<4)|0;j=d;k=s[x>>2];d:{if(v(w(k))<v(2147483648)){g=~~k;break d}g=-2147483648;}o[j>>2]=g;j=d;k=s[t>>2];e:{if(v(w(k))<v(2147483648)){g=~~k;break e}g=-2147483648;}o[j+4>>2]=g;k=s[r>>2];o[d+12>>2]=h;if(v(w(k))<v(2147483648)){j=~~k;}else {j=-2147483648;}o[d+8>>2]=j;b=b+16|0;h=h+1|0;if((h|0)!=(c|0)){continue}break}break c}o[f+28>>2]=c;break b}if((c|0)<2){break b}Fd(f+24|0,f+8|0,0,c+ -1|0);}o[a+44>>2]=c;o[a+40>>2]=0;o[a+36>>2]=o[a+32>>2];b=o[a+84>>2];if((b|0)<(c|0)){if(o[a+88>>2]<(c|0)){f:{if(!c){t=0;d=b;break f}o[6257]=o[6257]+1;t=l[o[4968]](c<<2,16)|0;d=o[a+84>>2];}if((d|0)>=1){j=0;while(1){g=j<<2;o[g+t>>2]=o[g+o[a+92>>2]>>2];j=j+1|0;if((d|0)!=(j|0)){continue}break}}d=o[a+92>>2];if(d){if(p[a+96|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+92>>2]=0;}o[a+92>>2]=t;o[a+88>>2]=c;m[a+96|0]=1;}while(1){o[o[a+92>>2]+(b<<2)>>2]=0;b=b+1|0;if((c|0)!=(b|0)){continue}break}}o[a+84>>2]=c;if((c|0)>=1){r=0;while(1){g=o[a+40>>2];g:{if(g){break g}h=o[a+36>>2];h:{if(h){o[a+36>>2]=o[h+8>>2];break h}o[6257]=o[6257]+1;h=l[o[4968]](12,16)|0;b=o[a+44>>2];o[h+8>>2]=0;o[h+4>>2]=b;o[6257]=o[6257]+1;o[h>>2]=l[o[4968]](u(b,112),16);o[h+8>>2]=o[a+32>>2];o[a+32>>2]=h;}b=0;g=o[h>>2];j=g;d=o[h+4>>2];if((d|0)<1){break g}while(1){h=j;j=j+112|0;b=b+1|0;o[h>>2]=(b|0)<(d|0)?j:0;if((b|0)!=(d|0)){continue}break}}o[a+40>>2]=o[g>>2];o[g+8>>2]=0;o[g+12>>2]=0;o[g+16>>2]=0;o[g>>2]=0;o[g+4>>2]=0;o[g+104>>2]=-1;o[g+8>>2]=0;b=o[f+36>>2]+(r<<4)|0;d=o[b+4>>2];o[g+88>>2]=o[b>>2];o[g+92>>2]=d;d=o[b+12>>2];o[g+96>>2]=o[b+8>>2];o[g+100>>2]=d;o[g+104>>2]=-1;o[o[a+92>>2]+(r<<2)>>2]=g;r=r+1|0;if((r|0)!=(c|0)){continue}break}}b=o[f+36>>2];if(b){if(p[f+40|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[f+36>>2]=0;}o[f+36>>2]=0;m[f+40|0]=1;o[f+28>>2]=0;o[f+32>>2]=0;o[a+100>>2]=-3;o[a+56>>2]=0;o[a+60>>2]=u(c,6);o[a+116>>2]=0;o[a+120>>2]=0;o[a+52>>2]=o[a+48>>2];o[f+16>>2]=0;o[f+20>>2]=0;o[f+8>>2]=0;o[f+12>>2]=0;Hd(a,0,c,f+8|0);o[a+124>>2]=o[f+8>>2];a=o[f+36>>2];if(a){if(p[f+40|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[f+36>>2]=0;}K=f+48|0;}function jm(a,b){var c=v(0),d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),o=v(0),q=v(0),r=v(0),t=v(0),u=v(0),x=0,y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),K=v(0),L=v(0),M=0,N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=0;c=s[a+84>>2];d=s[b+80>>2];x=c<d;M=x?0:-1;f=s[a+292>>2];c=x?c:d;x=f<c;T=x?1:M;d=s[a+500>>2];c=x?f:c;x=d<c;M=s[a+708>>2]<(x?d:c);x=M?3:x?2:T;i=s[b>>2];a:{b:{c:{d:{if(p[19852]){if(!x){q=s[a+636>>2];y=s[a+428>>2];g=v(q-y);u=s[a+632>>2];z=s[a+424>>2];f=v(u-z);e=s[a+628>>2];D=s[a+420>>2];l=v(e-D);c=s[b+8>>2];d=s[b+4>>2];break d}h=s[a+212>>2];j=v(i-h);u=s[a+632>>2];z=s[a+424>>2];f=v(u-z);d=s[b+4>>2];n=s[a+216>>2];c=v(d-n);e=s[a+628>>2];D=s[a+420>>2];l=v(e-D);g=v(v(j*f)-v(c*l));k=v(g*g);q=s[a+636>>2];y=s[a+428>>2];g=v(q-y);m=v(c*g);c=s[b+8>>2];A=s[a+220>>2];r=v(c-A);t=v(m-v(r*f));j=v(v(r*l)-v(j*g));S=v(k+v(v(t*t)+v(j*j)));if((x|0)!=1){break d}i=v(i-s[a+4>>2]);c=v(c-s[a+12>>2]);d=v(d-s[a+8>>2]);l=v(0);break c}e:{f:{g:{if(!x){A=s[a+428>>2];j=s[a+636>>2];l=v(A-j);n=s[a+424>>2];r=s[a+632>>2];C=v(n-r);h=s[a+420>>2];t=s[a+628>>2];E=v(h-t);y=s[b+8>>2];f=v(y-j);z=s[b+4>>2];J=v(z-r);K=v(i-t);d=v(y-A);c=v(z-n);g=v(i-h);break g}G=s[a+212>>2];u=v(i-G);n=s[a+424>>2];r=s[a+632>>2];C=v(n-r);z=s[b+4>>2];H=s[a+216>>2];q=v(z-H);h=s[a+420>>2];t=s[a+628>>2];E=v(h-t);c=v(v(u*C)-v(q*E));d=v(c*c);A=s[a+428>>2];j=s[a+636>>2];l=v(A-j);y=s[b+8>>2];e=s[a+220>>2];D=v(y-e);c=v(v(q*l)-v(D*C));f=v(c*c);c=v(v(D*E)-v(u*l));f=v(d+v(f+v(c*c)));g=v(i-h);F=v(H-r);c=v(z-n);N=v(G-t);d=v(v(g*F)-v(c*N));k=v(d*d);O=v(e-j);d=v(y-A);m=v(v(c*O)-v(d*F));o=v(m*m);m=v(v(d*N)-v(g*O));m=v(k+v(o+v(m*m)));m=f>m?f:m;f=v(H-n);K=v(i-t);o=v(G-h);J=v(z-r);B=v(v(f*K)-v(o*J));I=v(B*B);B=v(e-A);k=f;f=v(y-j);k=v(v(B*J)-v(k*f));o=v(v(o*f)-v(B*K));o=v(I+v(v(k*k)+v(o*o)));S=m>o?m:o;if((x|0)!=1){break g}m=s[a+4>>2];P=v(m-t);k=v(i-m);o=s[a+12>>2];Q=v(o-j);B=s[a+8>>2];R=v(B-r);I=v(y-o);L=v(z-B);l=v(0);break f}m=s[a+4>>2];k=v(i-m);B=s[a+8>>2];L=v(z-B);e=v(v(k*C)-v(L*E));q=v(e*e);o=s[a+12>>2];I=v(y-o);e=v(v(L*l)-v(I*C));l=v(v(I*E)-v(k*l));l=v(q+v(v(e*e)+v(l*l)));R=v(B-r);P=v(m-t);e=v(v(g*R)-v(c*P));q=v(e*e);Q=v(o-j);e=v(v(c*Q)-v(d*R));u=v(e*e);e=v(v(d*P)-v(g*Q));e=v(q+v(u+v(e*e)));l=l>e?l:e;C=v(B-n);E=v(m-h);e=v(v(C*K)-v(E*J));q=v(e*e);F=v(o-A);e=v(v(F*J)-v(C*f));u=v(e*e);e=v(v(E*f)-v(F*K));e=v(q+v(u+v(e*e)));l=l>e?l:e;e=s[a+220>>2];D=v(y-e);H=s[a+216>>2];q=v(z-H);G=s[a+212>>2];u=v(i-G);if((x|0)==2){j=v(o-e);r=v(B-H);t=v(m-G);f=v(0);break e}O=v(e-j);F=v(H-r);N=v(G-t);}c=v(v(k*F)-v(L*N));d=v(c*c);c=v(v(L*O)-v(I*F));g=v(c*c);c=v(v(I*N)-v(k*O));c=v(d+v(g+v(c*c)));d=v(v(u*R)-v(q*P));g=v(d*d);d=v(v(q*Q)-v(D*R));j=v(d*d);d=v(v(D*P)-v(u*Q));d=v(g+v(j+v(d*d)));c=c>d?c:d;r=v(B-H);t=v(m-G);d=v(v(r*K)-v(t*J));g=v(d*d);j=v(o-e);d=v(v(j*J)-v(r*f));C=v(d*d);d=v(v(t*f)-v(j*K));d=v(g+v(C+v(d*d)));f=c>d?c:d;g=v(0);if(M){break a}F=v(o-A);C=v(B-n);E=v(m-h);d=v(y-A);c=v(z-n);g=v(i-h);}i=v(H-n);h=v(G-h);n=v(v(k*i)-v(L*h));m=v(n*n);n=v(e-A);i=v(v(L*n)-v(I*i));e=v(i*i);i=v(v(I*h)-v(k*n));i=v(m+v(e+v(i*i)));h=v(v(u*C)-v(q*E));k=v(h*h);h=v(v(q*F)-v(D*C));e=v(h*h);h=v(v(D*E)-v(u*F));h=v(k+v(e+v(h*h)));i=i>h?i:h;h=v(v(r*g)-v(t*c));c=v(v(j*c)-v(r*d));k=v(c*c);c=v(v(t*d)-v(j*g));c=v(v(h*h)+v(k+v(c*c)));g=i>c?i:c;break a}i=v(i-s[a+4>>2]);d=v(d-s[a+8>>2]);h=v(v(i*f)-v(d*l));c=v(c-s[a+12>>2]);f=v(v(d*g)-v(c*f));k=v(f*f);f=v(v(c*l)-v(i*g));l=v(v(h*h)+v(k+v(f*f)));A=s[a+220>>2];n=s[a+216>>2];h=s[a+212>>2];f=v(0);if((x|0)==2){break b}}f=v(u-n);g=v(e-h);j=v(v(i*f)-v(d*g));k=v(j*j);j=v(q-A);f=v(v(d*j)-v(c*f));e=v(f*f);f=v(v(c*g)-v(i*j));f=v(k+v(e+v(f*f)));g=v(0);if(M){break a}}g=v(z-n);h=v(D-h);n=v(v(i*g)-v(d*h));k=d;d=v(y-A);g=v(v(k*d)-v(c*g));c=v(v(c*h)-v(i*d));g=v(v(n*n)+v(v(g*g)+v(c*c)));}c=v(w(S));a=c>v(-0xde0b6b000000000);b=a?0:-1;d=v(w(l));c=a?c:v(-0xde0b6b000000000);a=d>c;b=a?1:b;f=v(w(f));c=a?d:c;a=f>c;return v(w(g))>(a?f:c)?3:a?2:b}function rh(a,b,c,d,e){var f=0,g=0,h=0,i=0,j=0,k=0,r=0;f=K-112|0;K=f;m[a+60|0]=c;a:{if(c){Lu(a,d,e);o[f+96>>2]=a;o[f+92>>2]=a+104;o[f+88>>2]=14420;l[o[o[b>>2]+8>>2]](b,f+88|0,a+4|0,a+20|0);e=o[a+108>>2];o[f+16>>2]=0;o[f+20>>2]=0;o[f+8>>2]=0;o[f+12>>2]=0;c=o[a+128>>2];g=e<<1;if((c|0)<(g|0)){if(o[a+132>>2]<(g|0)){if(e){o[6257]=o[6257]+1;j=l[o[4968]](e<<5,16)|0;d=o[a+128>>2];}else {d=c;}if((d|0)>=1){b=0;while(1){h=b<<4;k=h+j|0;i=k;h=h+o[a+136>>2]|0;r=o[h+4>>2];o[i>>2]=o[h>>2];o[i+4>>2]=r;i=o[h+12>>2];o[k+8>>2]=o[h+8>>2];o[k+12>>2]=i;b=b+1|0;if((d|0)!=(b|0)){continue}break}}b=o[a+136>>2];if(b){if(p[a+140|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+136>>2]=0;}o[a+136>>2]=j;o[a+132>>2]=g;m[a+140|0]=1;}while(1){j=o[f+12>>2];b=o[a+136>>2]+(c<<4)|0;o[b>>2]=o[f+8>>2];o[b+4>>2]=j;d=o[f+20>>2];o[b+8>>2]=o[f+16>>2];o[b+12>>2]=d;c=c+1|0;if((g|0)!=(c|0)){continue}break}}o[a+128>>2]=g;break a}o[f+104>>2]=14552;o[f+108>>2]=a- -64;o[f+96>>2]=-581039253;o[f+100>>2]=0;o[f+88>>2]=-581039253;o[f+92>>2]=-581039253;o[f+80>>2]=1566444395;o[f+84>>2]=0;o[f+72>>2]=1566444395;o[f+76>>2]=1566444395;l[o[o[b>>2]+8>>2]](b,f+104|0,f+88|0,f+72|0);e=o[a+68>>2];b=f- -64|0;o[b>>2]=0;o[b+4>>2]=0;o[f+56>>2]=0;o[f+60>>2]=0;o[f+48>>2]=0;o[f+52>>2]=0;o[f+40>>2]=0;o[f+44>>2]=0;o[f+32>>2]=0;o[f+36>>2]=0;o[f+24>>2]=0;o[f+28>>2]=0;o[f+16>>2]=0;o[f+20>>2]=0;o[f+8>>2]=0;o[f+12>>2]=0;b=o[a+88>>2];h=e<<1;if((b|0)<(h|0)){if(o[a+92>>2]<(h|0)){if(e){o[6257]=o[6257]+1;j=l[o[4968]](e<<7,16)|0;c=o[a+88>>2];}else {c=b;}if((c|0)>=1){while(1){d=k<<6;g=d+j|0;d=d+o[a+96>>2]|0;r=o[d+4>>2];o[g>>2]=o[d>>2];o[g+4>>2]=r;i=o[d+60>>2];o[g+56>>2]=o[d+56>>2];o[g+60>>2]=i;i=o[d+52>>2];o[g+48>>2]=o[d+48>>2];o[g+52>>2]=i;i=o[d+44>>2];o[g+40>>2]=o[d+40>>2];o[g+44>>2]=i;i=o[d+36>>2];o[g+32>>2]=o[d+32>>2];o[g+36>>2]=i;i=o[d+28>>2];o[g+24>>2]=o[d+24>>2];o[g+28>>2]=i;i=o[d+20>>2];o[g+16>>2]=o[d+16>>2];o[g+20>>2]=i;i=o[d+12>>2];o[g+8>>2]=o[d+8>>2];o[g+12>>2]=i;k=k+1|0;if((c|0)!=(k|0)){continue}break}}c=o[a+96>>2];if(c){if(p[a+100|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+96>>2]=0;}o[a+96>>2]=j;o[a+92>>2]=h;m[a+100|0]=1;}while(1){g=o[f+12>>2];c=o[a+96>>2]+(b<<6)|0;o[c>>2]=o[f+8>>2];o[c+4>>2]=g;d=f- -64|0;g=o[d+4>>2];o[c+56>>2]=o[d>>2];o[c+60>>2]=g;d=o[f+60>>2];o[c+48>>2]=o[f+56>>2];o[c+52>>2]=d;d=o[f+52>>2];o[c+40>>2]=o[f+48>>2];o[c+44>>2]=d;d=o[f+44>>2];o[c+32>>2]=o[f+40>>2];o[c+36>>2]=d;d=o[f+36>>2];o[c+24>>2]=o[f+32>>2];o[c+28>>2]=d;d=o[f+28>>2];o[c+16>>2]=o[f+24>>2];o[c+20>>2]=d;d=o[f+20>>2];o[c+8>>2]=o[f+16>>2];o[c+12>>2]=d;b=b+1|0;if((h|0)!=(b|0)){continue}break}}o[a+88>>2]=h;}o[a+56>>2]=0;Nd(a,0,e);if(!(o[a+152>>2]|!p[a+60|0])){b=a;b:{if(o[a+156>>2]){e=o[a+160>>2];c=1;break b}o[6257]=o[6257]+1;e=l[o[4968]](32,16)|0;j=o[a+152>>2];if((j|0)>=1){d=0;while(1){c=d<<5;g=c+e|0;c=c+o[a+160>>2]|0;k=o[c+4>>2];o[g>>2]=o[c>>2];o[g+4>>2]=k;h=o[c+28>>2];o[g+24>>2]=o[c+24>>2];o[g+28>>2]=h;h=o[c+20>>2];o[g+16>>2]=o[c+16>>2];o[g+20>>2]=h;h=o[c+12>>2];o[g+8>>2]=o[c+8>>2];o[g+12>>2]=h;d=d+1|0;if((j|0)!=(d|0)){continue}break}}c=o[a+160>>2];if(c){if(p[a+164|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+160>>2]=0;}o[a+160>>2]=e;o[a+156>>2]=1;m[a+164|0]=1;c=o[a+152>>2]+1|0;}o[b+152>>2]=c;b=o[f+36>>2];o[e+24>>2]=o[f+32>>2];o[e+28>>2]=b;b=o[f+28>>2];o[e+16>>2]=o[f+24>>2];o[e+20>>2]=b;b=o[f+20>>2];o[e+8>>2]=o[f+16>>2];o[e+12>>2]=b;b=o[f+12>>2];o[e>>2]=o[f+8>>2];o[e+4>>2]=b;b=o[a+160>>2];c=o[a+136>>2];n[b>>1]=q[c>>1];n[b+2>>1]=q[c+2>>1];n[b+4>>1]=q[c+4>>1];n[b+6>>1]=q[c+6>>1];n[b+8>>1]=q[c+8>>1];d=q[c+10>>1];o[b+12>>2]=0;n[b+10>>1]=d;d=b;b=o[c+12>>2];o[d+16>>2]=(b|0)>-1?1:0-b|0;}o[a+168>>2]=o[a+152>>2];b=o[a+116>>2];if(b){if(p[a+120|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+116>>2]=0;}o[a+116>>2]=0;o[a+108>>2]=0;o[a+112>>2]=0;m[a+120|0]=1;b=o[a+76>>2];if(b){if(p[a+80|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+76>>2]=0;}o[a+76>>2]=0;o[a+68>>2]=0;o[a+72>>2]=0;m[a+80|0]=1;K=f+112|0;}function Hv(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),r=v(0),w=0,x=0,y=0,z=0,A=0;c=K-80|0;K=c;A=l[o[o[a>>2]+28>>2]](a)|0;if((A|0)>=1){i=s[a+12>>2];j=s[a+8>>2];k=s[a+4>>2];while(1){l[o[o[a>>2]+16>>2]](a,c+76|0,c+52|0,c- -64|0,c+56|0,c+72|0,c+68|0,c+48|0,c+60|0,z);d=o[c+64>>2];a:{if(d>>>0>1){break a}if(d-1){d=o[c+60>>2]+ -2|0;if(d>>>0>3){break a}b:{switch(d-1|0){default:d=0;if(o[c+48>>2]<1){break a}while(1){g=o[c+76>>2];h=o[c+56>>2];e=o[c+72>>2]+u(o[c+68>>2],d)|0;f=g+u(h,o[e>>2])|0;m=s[f>>2];n=s[f+4>>2];r=s[f+8>>2];o[c+12>>2]=0;s[c+8>>2]=i*r;s[c+4>>2]=j*n;s[c>>2]=k*m;f=g+u(h,o[e+4>>2])|0;m=s[f>>2];n=s[f+4>>2];r=s[f+8>>2];o[c+28>>2]=0;s[c+24>>2]=i*r;s[c+20>>2]=j*n;s[c+16>>2]=k*m;e=g+u(h,o[e+8>>2])|0;m=s[e>>2];n=s[e+4>>2];r=s[e+8>>2];o[c+44>>2]=0;s[c+40>>2]=i*r;s[c+36>>2]=j*n;s[c+32>>2]=k*m;l[o[o[b>>2]+8>>2]](b,c,z,d);d=d+1|0;if((d|0)<o[c+48>>2]){continue}break}break a;case 0:d=0;if(o[c+48>>2]<=0){break a}while(1){g=o[c+76>>2];h=o[c+56>>2];e=o[c+72>>2]+u(o[c+68>>2],d)|0;f=g+u(h,q[e>>1])|0;m=s[f>>2];n=s[f+4>>2];r=s[f+8>>2];o[c+12>>2]=0;s[c+8>>2]=i*r;s[c+4>>2]=j*n;s[c>>2]=k*m;f=g+u(h,q[e+2>>1])|0;m=s[f>>2];n=s[f+4>>2];r=s[f+8>>2];o[c+28>>2]=0;s[c+24>>2]=i*r;s[c+20>>2]=j*n;s[c+16>>2]=k*m;e=g+u(h,q[e+4>>1])|0;m=s[e>>2];n=s[e+4>>2];r=s[e+8>>2];o[c+44>>2]=0;s[c+40>>2]=i*r;s[c+36>>2]=j*n;s[c+32>>2]=k*m;l[o[o[b>>2]+8>>2]](b,c,z,d);d=d+1|0;if((d|0)<o[c+48>>2]){continue}break}break a;case 1:break a;case 2:break b}}d=0;if(o[c+48>>2]<=0){break a}while(1){g=o[c+76>>2];h=o[c+56>>2];e=o[c+72>>2]+u(o[c+68>>2],d)|0;f=g+u(h,p[e|0])|0;m=s[f>>2];n=s[f+4>>2];r=s[f+8>>2];o[c+12>>2]=0;s[c+8>>2]=i*r;s[c+4>>2]=j*n;s[c>>2]=k*m;f=g+u(h,p[e+1|0])|0;m=s[f>>2];n=s[f+4>>2];r=s[f+8>>2];o[c+28>>2]=0;s[c+24>>2]=i*r;s[c+20>>2]=j*n;s[c+16>>2]=k*m;e=g+u(h,p[e+2|0])|0;m=s[e>>2];n=s[e+4>>2];r=s[e+8>>2];o[c+44>>2]=0;s[c+40>>2]=i*r;s[c+36>>2]=j*n;s[c+32>>2]=k*m;l[o[o[b>>2]+8>>2]](b,c,z,d);d=d+1|0;if((d|0)<o[c+48>>2]){continue}break}break a}d=o[c+60>>2]+ -2|0;if(d>>>0>3){break a}c:{switch(d-1|0){default:d=0;if(o[c+48>>2]<1){break a}while(1){g=o[c+76>>2];h=o[c+56>>2];e=o[c+72>>2]+u(o[c+68>>2],d)|0;f=g+u(h,o[e>>2])|0;w=t[f>>3];x=t[f+8>>3];y=t[f+16>>3];o[c+12>>2]=0;s[c+8>>2]=i*v(y);s[c+4>>2]=j*v(x);s[c>>2]=k*v(w);f=g+u(h,o[e+4>>2])|0;w=t[f>>3];x=t[f+8>>3];y=t[f+16>>3];o[c+28>>2]=0;s[c+24>>2]=i*v(y);s[c+20>>2]=j*v(x);s[c+16>>2]=k*v(w);e=g+u(h,o[e+8>>2])|0;w=t[e>>3];x=t[e+8>>3];y=t[e+16>>3];o[c+44>>2]=0;s[c+40>>2]=i*v(y);s[c+36>>2]=j*v(x);s[c+32>>2]=k*v(w);l[o[o[b>>2]+8>>2]](b,c,z,d);d=d+1|0;if((d|0)<o[c+48>>2]){continue}break}break a;case 0:d=0;if(o[c+48>>2]<=0){break a}while(1){g=o[c+76>>2];h=o[c+56>>2];e=o[c+72>>2]+u(o[c+68>>2],d)|0;f=g+u(h,q[e>>1])|0;w=t[f>>3];x=t[f+8>>3];y=t[f+16>>3];o[c+12>>2]=0;s[c+8>>2]=i*v(y);s[c+4>>2]=j*v(x);s[c>>2]=k*v(w);f=g+u(h,q[e+2>>1])|0;w=t[f>>3];x=t[f+8>>3];y=t[f+16>>3];o[c+28>>2]=0;s[c+24>>2]=i*v(y);s[c+20>>2]=j*v(x);s[c+16>>2]=k*v(w);e=g+u(h,q[e+4>>1])|0;w=t[e>>3];x=t[e+8>>3];y=t[e+16>>3];o[c+44>>2]=0;s[c+40>>2]=i*v(y);s[c+36>>2]=j*v(x);s[c+32>>2]=k*v(w);l[o[o[b>>2]+8>>2]](b,c,z,d);d=d+1|0;if((d|0)<o[c+48>>2]){continue}break}break a;case 2:break c;case 1:break a}}d=0;if(o[c+48>>2]<=0){break a}while(1){g=o[c+76>>2];h=o[c+56>>2];e=o[c+72>>2]+u(o[c+68>>2],d)|0;f=g+u(h,p[e|0])|0;w=t[f>>3];x=t[f+8>>3];y=t[f+16>>3];o[c+12>>2]=0;s[c+8>>2]=i*v(y);s[c+4>>2]=j*v(x);s[c>>2]=k*v(w);f=g+u(h,p[e+1|0])|0;w=t[f>>3];x=t[f+8>>3];y=t[f+16>>3];o[c+28>>2]=0;s[c+24>>2]=i*v(y);s[c+20>>2]=j*v(x);s[c+16>>2]=k*v(w);e=g+u(h,p[e+2|0])|0;w=t[e>>3];x=t[e+8>>3];y=t[e+16>>3];o[c+44>>2]=0;s[c+40>>2]=i*v(y);s[c+36>>2]=j*v(x);s[c+32>>2]=k*v(w);l[o[o[b>>2]+8>>2]](b,c,z,d);d=d+1|0;if((d|0)<o[c+48>>2]){continue}break}}l[o[o[a>>2]+24>>2]](a,z);z=z+1|0;if((A|0)!=(z|0)){continue}break}}K=c+80|0;}function nm(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=v(0),g=v(0),h=0,i=0,j=0,k=v(0),n=v(0),q=v(0),r=v(0),t=0,x=0;b=o[d+72>>2];a:{if(!(b&4)){break a}h=o[a+28>>2];if((h|0)<1){break a}i=b&16;j=o[a+76>>2];t=o[a+36>>2];c=0;while(1){b=t+u(c,152)|0;e=o[b+132>>2];o[e+132>>2]=o[b+100>>2];b=j+u(o[b+140>>2],152)|0;o[e+136>>2]=o[b+100>>2];if(i){o[e+140>>2]=o[b+252>>2];}c=c+1|0;if((h|0)!=(c|0)){continue}break}}t=o[a+48>>2];if((t|0)>=1){x=o[a+56>>2];e=0;while(1){c=u(e,152)+x|0;h=o[c+132>>2];b=o[h+44>>2];if(b){i=o[h+28>>2];k=s[i+416>>2];n=s[c+24>>2];q=s[i+412>>2];r=s[c+20>>2];f=s[c+100>>2];g=v(v(1)/s[d+12>>2]);s[b>>2]=s[b>>2]+v(v(v(s[c+16>>2]*f)*s[i+408>>2])*g);s[b+4>>2]=v(v(q*v(f*r))*g)+s[b+4>>2];s[b+8>>2]=v(v(k*v(f*n))*g)+s[b+8>>2];j=o[h+32>>2];k=s[j+416>>2];n=s[c+56>>2];q=s[j+412>>2];r=s[c+52>>2];f=s[c+100>>2];g=v(v(1)/s[d+12>>2]);s[b+32>>2]=s[b+32>>2]+v(v(v(s[c+48>>2]*f)*s[j+408>>2])*g);s[b+36>>2]=v(v(q*v(f*r))*g)+s[b+36>>2];s[b+40>>2]=v(v(k*v(f*n))*g)+s[b+40>>2];k=s[i+612>>2];n=s[c+8>>2];q=s[i+608>>2];r=s[c+4>>2];f=s[c+100>>2];g=v(v(1)/s[d+12>>2]);s[b+16>>2]=s[b+16>>2]+v(v(v(s[c>>2]*s[i+604>>2])*f)*g);s[b+20>>2]=v(v(f*v(r*q))*g)+s[b+20>>2];s[b+24>>2]=v(v(f*v(n*k))*g)+s[b+24>>2];k=s[j+612>>2];n=s[c+40>>2];q=s[j+608>>2];r=s[c+36>>2];f=s[c+100>>2];g=v(v(1)/s[d+12>>2]);s[b+48>>2]=s[b+48>>2]+v(v(v(s[c+32>>2]*s[j+604>>2])*f)*g);s[b+52>>2]=v(v(f*v(r*q))*g)+s[b+52>>2];s[b+56>>2]=v(v(f*v(n*k))*g)+s[b+56>>2];}f=s[c+100>>2];s[h+36>>2]=f;if(!!(v(w(f))>=s[h+16>>2])){m[h+20|0]=0;}e=e+1|0;if((t|0)!=(e|0)){continue}break}}e=o[a+8>>2];if((e|0)>=1){i=o[a+16>>2];j=0;while(1){h=u(j,244);b=h+i|0;c=o[b+240>>2];if(c){b:{if(o[d+52>>2]){mm(b,s[d+12>>2],s[d+60>>2]);i=o[a+16>>2];b=h+i|0;f=s[b+176>>2];c=o[b+240>>2];g=s[b+184>>2];k=s[b+180>>2];break b}f=v(s[b+64>>2]+s[b+176>>2]);s[b+176>>2]=f;s[b+192>>2]=s[b+80>>2]+s[b+192>>2];k=v(s[b+68>>2]+s[b+180>>2]);s[b+180>>2]=k;g=v(s[b+72>>2]+s[b+184>>2]);s[b+184>>2]=g;s[b+196>>2]=s[b+84>>2]+s[b+196>>2];s[b+200>>2]=s[b+88>>2]+s[b+200>>2];}b=h+i|0;n=s[b+212>>2];q=s[b+216>>2];r=s[b+208>>2];o[c+384>>2]=0;s[c+372>>2]=f+r;o[c+304>>2]=o[c+304>>2]+1;s[c+380>>2]=g+q;s[c+376>>2]=k+n;b=h+o[a+16>>2]|0;f=s[b+228>>2];g=s[b+196>>2];k=s[b+232>>2];n=s[b+200>>2];q=s[b+224>>2];r=s[b+192>>2];b=o[b+240>>2];o[b+400>>2]=0;s[b+388>>2]=r+q;s[b+396>>2]=n+k;s[b+392>>2]=g+f;o[b+304>>2]=o[b+304>>2]+1;if(o[d+52>>2]){c=h+o[a+16>>2]|0;b=o[c+240>>2];o[b+304>>2]=o[b+304>>2]+1;e=o[c+12>>2];o[b+12>>2]=o[c+8>>2];o[b+16>>2]=e;e=o[c+4>>2];o[b+4>>2]=o[c>>2];o[b+8>>2]=e;e=o[c+28>>2];o[b+28>>2]=o[c+24>>2];o[b+32>>2]=e;e=o[c+20>>2];o[b+20>>2]=o[c+16>>2];o[b+24>>2]=e;e=o[c+36>>2];o[b+36>>2]=o[c+32>>2];o[b+40>>2]=e;e=o[c+44>>2];o[b+44>>2]=o[c+40>>2];o[b+48>>2]=e;e=o[c+60>>2];o[b+60>>2]=o[c+56>>2];o[b+64>>2]=e;e=o[c+52>>2];o[b+52>>2]=o[c+48>>2];o[b+56>>2]=e;}i=o[a+16>>2];o[o[(h+i|0)+240>>2]+212>>2]=-1;e=o[a+8>>2];}j=j+1|0;if((j|0)<(e|0)){continue}break}}if(!(o[a+28>>2]>-1|o[a+32>>2]>-1)){b=o[a+36>>2];if(b){if(p[a+40|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+36>>2]=0;}o[a+32>>2]=0;o[a+36>>2]=0;m[a+40|0]=1;}o[a+28>>2]=0;if(!(o[a+48>>2]>-1|o[a+52>>2]>-1)){b=o[a+56>>2];if(b){if(p[a+60|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+56>>2]=0;}o[a+52>>2]=0;o[a+56>>2]=0;m[a+60|0]=1;}o[a+48>>2]=0;if(!(o[a+68>>2]>-1|o[a+72>>2]>-1)){b=o[a+76>>2];if(b){if(p[a+80|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+76>>2]=0;}o[a+72>>2]=0;o[a+76>>2]=0;m[a+80|0]=1;}o[a+68>>2]=0;if(!(o[a+88>>2]>-1|o[a+92>>2]>-1)){b=o[a+96>>2];if(b){if(p[a+100|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+96>>2]=0;}o[a+92>>2]=0;o[a+96>>2]=0;m[a+100|0]=1;}o[a+88>>2]=0;if(!(o[a+8>>2]>-1|o[a+12>>2]>-1)){b=o[a+16>>2];if(b){if(p[a+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+16>>2]=0;}o[a+12>>2]=0;o[a+16>>2]=0;m[a+20|0]=1;}o[a+8>>2]=0;return v(v(0))}function $k(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=0,m=v(0),n=v(0),q=0,r=v(0),t=v(0),u=v(0),x=v(0),z=v(0),A=v(0),B=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=0,S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0),Z=v(0),_=v(0),$=v(0),aa=v(0),ba=v(0),ca=v(0),ea=v(0),fa=v(0),ga=v(0),ha=v(0),ia=v(0),ja=v(0),ka=v(0);d=K-48|0;K=d;a:{if(!o[a+12>>2]){break a}f=p[a+16|0];R=f?b:c;k=o[R+12>>2];x=s[k+56>>2];X=s[k+52>>2];z=s[k+48>>2];q=f?c:b;f=o[q+12>>2];A=s[f+56>>2];P=s[f+52>>2];Q=s[f+48>>2];q=o[q+4>>2];B=s[f+32>>2];G=s[f>>2];H=s[f+16>>2];E=s[f+36>>2];J=s[f+20>>2];L=s[f+4>>2];g=s[k+40>>2];h=s[k+24>>2];i=s[k+8>>2];j=s[k+36>>2];r=s[k+20>>2];n=s[k+4>>2];t=s[k+32>>2];D=s[f+40>>2];u=s[k+16>>2];M=s[f+24>>2];m=s[k>>2];N=s[f+8>>2];k=o[R+4>>2];F=s[k+60>>2];I=s[k+56>>2];O=s[k+52>>2];o[d+28>>2]=0;T=v(v(v(N*n)+v(M*r))+v(D*j));I=v(-I);U=v(v(v(N*m)+v(M*u))+v(D*t));D=v(v(v(N*i)+v(M*h))+v(D*g));s[d+24>>2]=v(v(T*I)-v(O*U))-v(F*D);M=v(v(v(L*n)+v(J*r))+v(E*j));N=v(v(v(L*m)+v(J*u))+v(E*t));V=v(v(v(L*i)+v(J*h))+v(E*g));s[d+20>>2]=v(v(M*I)-v(O*N))-v(F*V);W=v(v(v(G*n)+v(H*r))+v(B*j));S=O;O=v(v(v(G*m)+v(H*u))+v(B*t));E=F;F=v(v(v(G*i)+v(H*h))+v(B*g));s[d+16>>2]=v(v(W*I)-v(S*O))-v(E*F);l[o[o[q>>2]+64>>2]](d+32|0,q,d+16|0);f=o[R+12>>2];I=s[f+48>>2];Y=s[f+32>>2];Z=s[f+16>>2];_=s[f+8>>2];$=s[f+4>>2];aa=s[f>>2];ba=s[f+56>>2];ca=s[f+52>>2];ea=s[f+40>>2];fa=s[f+36>>2];ga=s[f+24>>2];ha=s[f+20>>2];ia=s[k+68>>2];E=s[k+60>>2];J=s[k+52>>2];L=s[k+56>>2];B=s[d+40>>2];G=s[d+32>>2];H=s[d+36>>2];ja=s[o[a+12>>2]+848>>2];o[e+4>>2]=o[a+12>>2];ka=v(v(v(Q*i)+v(P*h))+v(A*g));S=h;h=v(-X);D=v(v(ka+v(v(v(S*h)-v(z*i))-v(x*g)))+v(v(v(F*G)+v(V*H))+v(D*B)));t=v(v(v(v(v(Q*m)+v(P*u))+v(A*t))+v(v(v(u*h)-v(z*m))-v(x*t)))+v(v(v(O*G)+v(N*H))+v(U*B)));r=v(v(v(v(v(Q*n)+v(P*r))+v(A*j))+v(v(v(r*h)-v(z*n))-v(x*j)))+v(v(v(W*G)+v(M*H))+v(T*B)));g=v(v(v(E*D)+v(v(J*t)+v(L*r)))-ia);if(!!(g<ja)){f=o[R+12>>2];n=s[f+24>>2];u=s[f+20>>2];m=s[f+40>>2];x=s[f+36>>2];z=s[f+16>>2];A=s[f+32>>2];h=s[k+60>>2];P=s[f+8>>2];i=s[k+52>>2];Q=s[f>>2];j=s[k+56>>2];B=s[f+4>>2];o[d+28>>2]=0;s[d+16>>2]=v(v(Q*i)+v(B*j))+v(P*h);s[d+24>>2]=v(v(i*A)+v(j*x))+v(h*m);s[d+20>>2]=v(v(i*z)+v(j*u))+v(h*n);o[d+12>>2]=0;h=v(t-v(J*g));i=v(r-v(L*g));j=v(D-v(E*g));s[d+8>>2]=v(v(v(h*Y)+v(i*fa))+v(j*ea))+ba;s[d+4>>2]=v(v(v(h*Z)+v(i*ha))+v(j*ga))+ca;s[d>>2]=v(v(_*j)+v(v(aa*h)+v($*i)))+I;l[o[o[e>>2]+16>>2]](e,d+16|0,d,g);}b:{if(o[q+4>>2]>6|o[o[e+4>>2]+844>>2]>=o[a+24>>2]){break b}h=s[k+60>>2];c:{if(!!(v(w(h))>v(.7071067690849304))){g=s[k+56>>2];i=v(v(1)/v(C(v(v(h*h)+v(g*g)))));g=v(g*i);h=v(i*v(-h));i=v(0);break c}g=s[k+52>>2];i=s[k+56>>2];j=v(v(1)/v(C(v(v(g*g)+v(i*i)))));h=v(g*j);g=v(0);i=v(j*v(-i));}f=0;j=v(l[o[o[q>>2]+16>>2]](q));j=v(v(y(v(s[4962]/j),v(.39269909262657166)))*v(.5));n=va(j);q=o[a+20>>2];r=wa(j);if((q|0)<1){break b}F=g;g=v(n/v(C(v(v(v(i*i)+v(h*h))+v(g*g)))));n=v(F*g);t=v(h*g);u=v(i*g);while(1){h=s[k+56>>2];j=s[k+52>>2];g=s[k+60>>2];i=v(v(v(v(6.2831854820251465)/v(q|0))*v(f|0))*v(.5));m=v(va(i)/v(C(v(v(v(j*j)+v(h*h))+v(g*g)))));g=v(g*m);h=v(h*m);i=wa(i);j=v(j*m);m=v(v(n*g)+v(v(t*h)+v(v(r*i)+v(u*j))));x=v(v(t*g)+v(v(v(u*i)-v(r*j))-v(n*h)));z=v(v(n*j)+v(v(v(t*i)-v(r*h))-v(u*g)));A=v(v(u*h)+v(v(v(n*i)-v(r*g))-v(t*j)));s[d+28>>2]=v(v(v(i*m)-v(j*x))-v(h*z))-v(g*A);s[d+24>>2]=v(v(h*x)+v(v(g*m)+v(i*A)))-v(j*z);s[d+20>>2]=v(v(j*A)+v(v(i*z)+v(h*m)))-v(g*x);s[d+16>>2]=v(v(g*z)+v(v(j*m)+v(i*x)))-v(h*A);al(a,d+16|0,b,c,e);f=f+1|0;q=o[a+20>>2];if((f|0)<(q|0)){continue}break}}if(!p[a+8|0]|!o[o[a+12>>2]+844>>2]){break a}a=o[e+4>>2];if(!o[a+844>>2]){break a}b=o[a+836>>2];c=o[o[e+8>>2]+8>>2];if((b|0)!=(c|0)){da(a,o[o[e+12>>2]+8>>2]+4|0,c+4|0);break a}da(a,b+4|0,o[o[e+12>>2]+8>>2]+4|0);}K=d+48|0;}function cf(a){var b=v(0),c=0,d=v(0),e=v(0),f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),n=v(0),q=v(0),r=v(0),t=v(0),u=0,w=0,x=v(0),y=v(0);u=K-16|0;K=u;a:{if(!p[a+356|0]){f=p[a+312|0];break a}m[a+356|0]=0;m[a+352|0]=0;o[a+344>>2]=0;o[a+348>>2]=0;o[a+336>>2]=0;o[a+340>>2]=0;w=p[a+332|0]&-16;m[a+332|0]=w;c=o[a>>2];b:{if(c>>>0>4){break b}f=a+316|0;c:{d:{e:{switch(c-1|0){case 1:e=s[a+4>>2];h=v(s[a+20>>2]-e);d=s[a+8>>2];i=v(s[a+24>>2]-d);b=s[a+12>>2];n=v(s[a+28>>2]-b);d=v(v(v(v(v(0)-e)*h)+v(v(v(0)-d)*i))+v(v(v(0)-b)*n));c=1;f:{if(!(d>v(0))){break f}b=v(v(v(h*h)+v(i*i))+v(n*n));if(!(d<b)){g=v(1);c=2;break f}g=v(d/b);c=3;}o[a+344>>2]=0;o[a+348>>2]=0;s[a+340>>2]=g;s[a+336>>2]=v(1)-g;m[a+332|0]=c|w;f=0;o[a+256>>2]=0;b=s[a+92>>2];e=v(b+v(g*v(s[a+108>>2]-b)));s[a+252>>2]=e;b=s[a+88>>2];h=v(b+v(g*v(s[a+104>>2]-b)));s[a+248>>2]=h;b=s[a+84>>2];i=v(b+v(g*v(s[a+100>>2]-b)));s[a+244>>2]=i;n=s[a+180>>2];d=s[a+184>>2];j=s[a+168>>2];b=s[a+188>>2];k=s[a+172>>2];l=s[a+164>>2];o[a+288>>2]=0;q=e;e=v(k+v(g*v(b-k)));s[a+284>>2]=q-e;d=v(j+v(g*v(d-j)));s[a+280>>2]=h-d;b=v(l+v(g*v(n-l)));s[a+276>>2]=i-b;o[a+272>>2]=0;s[a+268>>2]=e;s[a+264>>2]=d;s[a+260>>2]=b;Xc(a,a+332|0);if(s[a+336>>2]>=v(0)^1|s[a+340>>2]>=v(0)^1|s[a+344>>2]>=v(0)^1){break b}f=s[a+348>>2]>=v(0);break b;case 2:c=u;o[c+8>>2]=0;o[c+12>>2]=0;o[c>>2]=0;o[c+4>>2]=0;qb(c,a+4|0,a+20|0,a+36|0,f);f=0;o[a+256>>2]=0;q=s[a+336>>2];r=s[a+340>>2];t=s[a+344>>2];x=v(v(v(q*s[a+92>>2])+v(r*s[a+108>>2]))+v(t*s[a+124>>2]));s[a+252>>2]=x;y=v(v(v(q*s[a+88>>2])+v(r*s[a+104>>2]))+v(t*s[a+120>>2]));s[a+248>>2]=y;g=v(v(v(q*s[a+84>>2])+v(r*s[a+100>>2]))+v(t*s[a+116>>2]));s[a+244>>2]=g;j=s[a+180>>2];k=s[a+196>>2];l=s[a+168>>2];h=s[a+184>>2];i=s[a+200>>2];n=s[a+172>>2];e=s[a+188>>2];d=s[a+204>>2];b=s[a+164>>2];o[a+288>>2]=0;e=v(v(v(q*n)+v(r*e))+v(t*d));s[a+284>>2]=x-e;d=v(v(v(q*l)+v(r*h))+v(t*i));s[a+280>>2]=y-d;b=v(v(v(q*b)+v(r*j))+v(t*k));s[a+276>>2]=g-b;o[a+272>>2]=0;s[a+268>>2]=e;s[a+264>>2]=d;s[a+260>>2]=b;Xc(a,a+332|0);if(s[a+336>>2]>=v(0)^1|s[a+340>>2]>=v(0)^1|s[a+344>>2]>=v(0)^1){break b}f=s[a+348>>2]>=v(0);break b;case 3:c=u;o[c+8>>2]=0;o[c+12>>2]=0;o[c>>2]=0;o[c+4>>2]=0;if(Il(c,a+4|0,a+20|0,a+36|0,a+52|0,f)){f=0;o[a+256>>2]=0;j=s[a+336>>2];k=s[a+340>>2];l=s[a+344>>2];b=s[a+348>>2];h=v(v(v(v(j*s[a+92>>2])+v(k*s[a+108>>2]))+v(l*s[a+124>>2]))+v(b*s[a+140>>2]));s[a+252>>2]=h;i=v(v(v(v(j*s[a+88>>2])+v(k*s[a+104>>2]))+v(l*s[a+120>>2]))+v(b*s[a+136>>2]));s[a+248>>2]=i;n=v(v(v(v(j*s[a+84>>2])+v(k*s[a+100>>2]))+v(l*s[a+116>>2]))+v(b*s[a+132>>2]));s[a+244>>2]=n;o[a+288>>2]=0;o[a+272>>2]=0;e=v(v(v(v(j*s[a+164>>2])+v(k*s[a+180>>2]))+v(l*s[a+196>>2]))+v(b*s[a+212>>2]));s[a+260>>2]=e;d=v(v(v(v(j*s[a+168>>2])+v(k*s[a+184>>2]))+v(l*s[a+200>>2]))+v(b*s[a+216>>2]));s[a+264>>2]=d;b=v(v(v(v(j*s[a+172>>2])+v(k*s[a+188>>2]))+v(l*s[a+204>>2]))+v(b*s[a+220>>2]));s[a+268>>2]=b;s[a+276>>2]=n-e;s[a+280>>2]=i-d;s[a+284>>2]=h-b;Xc(a,a+332|0);if(s[a+336>>2]>=v(0)^1|s[a+340>>2]>=v(0)^1|s[a+344>>2]>=v(0)^1){break b}f=s[a+348>>2]>=v(0);break b}if(!p[a+352|0]){break d}break;case 0:break c;default:break e}}f=0;break b}o[a+276>>2]=0;o[a+280>>2]=0;f=1;m[a+312|0]=1;o[a+284>>2]=0;o[a+288>>2]=0;break a}c=o[a+168>>2];o[a+260>>2]=o[a+164>>2];o[a+264>>2]=c;c=o[a+88>>2];o[a+244>>2]=o[a+84>>2];o[a+248>>2]=c;c=o[a+176>>2];o[a+268>>2]=o[a+172>>2];o[a+272>>2]=c;c=o[a+96>>2];o[a+252>>2]=o[a+92>>2];o[a+256>>2]=c;m[a+352|0]=0;o[a+288>>2]=0;s[a+280>>2]=s[a+248>>2]-s[a+264>>2];s[a+276>>2]=s[a+244>>2]-s[a+260>>2];s[a+284>>2]=s[a+252>>2]-s[a+268>>2];o[a+344>>2]=0;o[a+348>>2]=0;o[a+336>>2]=1065353216;o[a+340>>2]=0;m[a+332|0]=w;f=1;}m[a+312|0]=f;}K=u+16|0;return (f|0)!=0}function Ol(a,b,c,d,e,f){var g=0,h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),t=v(0),u=v(0),w=0,x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=0,J=0,L=v(0),M=v(0),N=v(0),O=v(0),P=0;g=K-544|0;K=g;o[f>>2]=0;o[f+4>>2]=0;o[f+32>>2]=0;o[f+24>>2]=0;o[f+28>>2]=0;o[f+16>>2]=0;o[f+20>>2]=0;o[f+8>>2]=0;o[f+12>>2]=0;o[g+388>>2]=c;o[g+384>>2]=a;j=s[d+20>>2];k=s[d+36>>2];m=s[b+20>>2];n=s[b+36>>2];p=s[d+24>>2];h=s[b+24>>2];i=s[d+40>>2];q=s[b+40>>2];t=s[d+32>>2];u=s[d>>2];x=s[d+16>>2];y=s[d+4>>2];z=s[b+32>>2];B=s[b>>2];D=s[b+16>>2];E=s[b+4>>2];A=s[d+8>>2];F=s[b+8>>2];o[g+436>>2]=0;o[g+420>>2]=0;o[g+404>>2]=0;G=v(v(v(F*A)+v(h*p))+v(q*i));s[g+432>>2]=G;H=v(v(v(E*A)+v(m*p))+v(n*i));s[g+428>>2]=H;p=v(v(v(B*A)+v(D*p))+v(z*i));s[g+424>>2]=p;i=v(v(v(F*y)+v(h*j))+v(q*k));s[g+416>>2]=i;A=v(v(v(E*y)+v(m*j))+v(n*k));s[g+412>>2]=A;j=v(v(v(B*y)+v(D*j))+v(z*k));s[g+408>>2]=j;k=v(v(v(u*F)+v(x*h))+v(t*q));s[g+400>>2]=k;m=v(v(v(u*E)+v(x*m))+v(t*n));s[g+396>>2]=m;n=v(v(v(u*B)+v(x*D))+v(t*z));s[g+392>>2]=n;h=s[b+20>>2];q=s[b+36>>2];t=s[b+24>>2];u=s[b+52>>2];x=s[d+52>>2];y=s[b+40>>2];z=s[b+56>>2];B=s[d+56>>2];D=s[b>>2];E=s[b+16>>2];F=s[b+32>>2];L=s[b+4>>2];M=s[b+8>>2];N=s[b+48>>2];O=s[d+48>>2];o[g+508>>2]=0;o[g+500>>2]=0;o[g+484>>2]=0;s[g+480>>2]=G;s[g+476>>2]=i;s[g+472>>2]=k;o[g+468>>2]=0;s[g+464>>2]=H;s[g+460>>2]=A;s[g+456>>2]=m;o[g+452>>2]=0;s[g+448>>2]=p;s[g+444>>2]=j;j=v(O-N);k=v(x-u);m=v(B-z);s[g+496>>2]=v(v(M*j)+v(t*k))+v(y*m);s[g+492>>2]=v(v(j*L)+v(k*h))+v(m*q);s[g+488>>2]=v(v(j*D)+v(k*E))+v(m*F);o[g+504>>2]=183;s[g+440>>2]=n;o[g+136>>2]=0;o[g+140>>2]=0;o[g+128>>2]=0;o[g+132>>2]=0;o[g+364>>2]=0;o[g+368>>2]=0;o[g+376>>2]=2;o[g+144>>2]=0;a:{b:{a=ff(g,g+384|0,e);if(!a){w=o[g+372>>2];if(!o[w+32>>2]){j=v(0);k=v(0);m=v(0);n=v(0);p=v(0);h=v(0);break b}h=v(0);d=0;p=v(0);n=v(0);m=v(0);k=v(0);j=v(0);while(1){c=d<<2;e=c+w|0;i=s[e+16>>2];a=o[g+504>>2];w=g+528|0;I=o[g+508>>2];J=o[g+384>>2]+(I>>1)|0;P=J;e=o[e>>2];if(I&1){a=o[a+o[J>>2]>>2];}l[a](w,P,e);e=o[g+508>>2];a=o[g+388>>2]+(e>>1)|0;x=v(i*s[g+536>>2]);y=v(i*s[g+532>>2]);z=v(i*s[g+528>>2]);c=o[c+o[g+372>>2]>>2];q=s[c+8>>2];t=s[c>>2];u=v(-s[c+4>>2]);w=o[g+504>>2];w=e&1?o[o[a>>2]+w>>2]:w;h=v(h+x);p=v(p+y);n=v(n+z);o[g+524>>2]=0;s[g+520>>2]=v(v(s[g+428>>2]*u)-v(t*s[g+424>>2]))-v(q*s[g+432>>2]);s[g+516>>2]=v(v(s[g+412>>2]*u)-v(t*s[g+408>>2]))-v(q*s[g+416>>2]);s[g+512>>2]=v(v(s[g+396>>2]*u)-v(t*s[g+392>>2]))-v(q*s[g+400>>2]);l[w](g+528|0,a,g+512|0);q=s[g+528>>2];t=s[g+532>>2];u=s[g+536>>2];m=v(m+v(i*v(v(v(v(q*s[g+472>>2])+v(t*s[g+476>>2]))+v(u*s[g+480>>2]))+s[g+496>>2])));k=v(k+v(i*v(v(v(v(q*s[g+456>>2])+v(t*s[g+460>>2]))+v(u*s[g+464>>2]))+s[g+492>>2])));j=v(j+v(i*v(v(v(v(q*s[g+440>>2])+v(t*s[g+444>>2]))+v(u*s[g+448>>2]))+s[g+488>>2])));d=d+1|0;w=o[g+372>>2];if(d>>>0<r[w+32>>2]){continue}break}break b}o[f>>2]=(a|0)==1?1:2;break a}i=s[b+48>>2];q=s[b+8>>2];t=s[b>>2];u=s[b+4>>2];x=s[b+52>>2];y=s[b+24>>2];z=s[b+16>>2];B=s[b+20>>2];D=s[b+56>>2];E=s[b+40>>2];A=s[b+32>>2];F=s[b+36>>2];o[f+16>>2]=0;s[f+12>>2]=D+v(v(v(n*A)+v(p*F))+v(h*E));s[f+8>>2]=x+v(v(v(n*z)+v(p*B))+v(h*y));s[f+4>>2]=i+v(v(v(n*t)+v(p*u))+v(h*q));q=s[b+48>>2];t=s[b+8>>2];u=s[b>>2];x=s[b+4>>2];y=s[b+52>>2];z=s[b+24>>2];B=s[b+16>>2];D=s[b+20>>2];E=s[b+56>>2];A=s[b+40>>2];F=s[b+32>>2];G=s[b+36>>2];n=v(n-j);p=v(p-k);h=v(h-m);i=v(C(v(v(v(n*n)+v(p*p))+v(h*h))));s[f+52>>2]=i;o[f+48>>2]=0;o[f+32>>2]=0;H=h;h=i>v(9999999747378752e-20)?v(v(1)/i):v(1);s[f+44>>2]=H*h;s[f+40>>2]=p*h;s[f+36>>2]=n*h;s[f+28>>2]=E+v(v(v(j*F)+v(k*G))+v(m*A));s[f+24>>2]=y+v(v(v(j*B)+v(k*D))+v(m*z));s[f+20>>2]=q+v(v(v(j*u)+v(k*x))+v(m*t));w=1;}K=g+544|0;return w}function Ml(a,b,c,d,e,f){var g=0,h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),t=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=0,H=v(0),I=0,J=v(0),L=v(0),M=v(0),N=v(0),O=0,P=0;g=K-19040|0;K=g;o[f>>2]=0;o[f+4>>2]=0;o[f+32>>2]=0;o[f+24>>2]=0;o[f+28>>2]=0;o[f+16>>2]=0;o[f+20>>2]=0;o[f+8>>2]=0;o[f+12>>2]=0;o[g+18916>>2]=c;o[g+18912>>2]=a;h=s[d+20>>2];i=s[d+36>>2];j=s[b+20>>2];k=s[b+36>>2];m=s[d+24>>2];p=s[b+24>>2];n=s[d+40>>2];q=s[b+40>>2];t=s[d+32>>2];w=s[d>>2];x=s[d+16>>2];y=s[d+4>>2];z=s[b+32>>2];A=s[b>>2];B=s[b+16>>2];D=s[b+4>>2];C=s[d+8>>2];E=s[b+8>>2];o[g+18964>>2]=0;o[g+18948>>2]=0;o[g+18932>>2]=0;F=v(v(v(E*C)+v(p*m))+v(q*n));s[g+18960>>2]=F;H=v(v(v(D*C)+v(j*m))+v(k*n));s[g+18956>>2]=H;m=v(v(v(A*C)+v(B*m))+v(z*n));s[g+18952>>2]=m;n=v(v(v(E*y)+v(p*h))+v(q*i));s[g+18944>>2]=n;C=v(v(v(D*y)+v(j*h))+v(k*i));s[g+18940>>2]=C;h=v(v(v(A*y)+v(B*h))+v(z*i));s[g+18936>>2]=h;i=v(v(v(w*E)+v(x*p))+v(t*q));s[g+18928>>2]=i;j=v(v(v(w*D)+v(x*j))+v(t*k));s[g+18924>>2]=j;k=v(v(v(w*A)+v(x*B))+v(t*z));s[g+18920>>2]=k;p=s[b+20>>2];q=s[b+36>>2];t=s[b+24>>2];w=s[b+52>>2];x=s[d+52>>2];y=s[b+40>>2];z=s[b+56>>2];A=s[d+56>>2];B=s[b>>2];D=s[b+16>>2];E=s[b+32>>2];J=s[b+4>>2];L=s[b+8>>2];M=s[b+48>>2];N=s[d+48>>2];o[g+19036>>2]=0;o[g+19028>>2]=0;o[g+19012>>2]=0;s[g+19008>>2]=F;s[g+19004>>2]=n;s[g+19e3>>2]=i;o[g+18996>>2]=0;s[g+18992>>2]=H;s[g+18988>>2]=C;s[g+18984>>2]=j;o[g+18980>>2]=0;s[g+18976>>2]=m;s[g+18972>>2]=h;h=v(N-M);i=v(x-w);j=v(A-z);s[g+19024>>2]=v(v(L*h)+v(t*i))+v(y*j);s[g+19020>>2]=v(v(h*J)+v(i*p))+v(j*q);s[g+19016>>2]=v(v(h*B)+v(i*D))+v(j*E);o[g+19032>>2]=184;s[g+18968>>2]=k;a=g+18664|0;o[a>>2]=0;o[a+4>>2]=0;o[g+18656>>2]=0;o[g+18660>>2]=0;o[g+18892>>2]=0;o[g+18896>>2]=0;o[g+18904>>2]=2;o[g+18672>>2]=0;h=s[e>>2];i=s[e+4>>2];j=s[e+8>>2];o[g+28>>2]=0;s[g+24>>2]=-j;s[g+20>>2]=-i;s[g+16>>2]=-h;a=ff(g+18528|0,g+18912|0,g+16|0)+ -1|0;a:{if(a>>>0>1){break a}b:{if(a-1){a=g+18520|0;o[a>>2]=0;o[a+4>>2]=0;a=g- -64|0;o[a>>2]=0;o[a+4>>2]=0;o[g+72>>2]=0;o[g+18512>>2]=0;o[g+18516>>2]=0;o[g+18508>>2]=0;o[g+16>>2]=9;o[g+56>>2]=0;o[g+60>>2]=0;d=0;while(1){a=(u(0-d|0,56)+g|0)+14296|0;o[a+4200>>2]=0;c=o[g+18520>>2];o[a+4204>>2]=c;a=a+4156|0;if(c){o[c+44>>2]=a;}o[g+18520>>2]=a;d=d+1|0;if((d|0)!=256){continue}break}o[g+18524>>2]=256;h=s[e>>2];i=s[e+4>>2];j=s[e+8>>2];o[g+12>>2]=0;s[g+8>>2]=-j;s[g+4>>2]=-i;s[g>>2]=-h;if((Ll(g+16|0,g+18528|0,g)|0)!=9){if(!o[g+52>>2]){h=v(0);i=v(0);j=v(0);break b}j=v(0);d=0;i=v(0);h=v(0);while(1){a=o[g+19032>>2];c=g;e=o[g+19036>>2];G=o[g+18912>>2]+(e>>1)|0;O=G;I=(g+16|0)+(d<<2)|0;P=o[I+4>>2];if(e&1){a=o[a+o[G>>2]>>2];}l[a](c,O,P);k=s[I+20>>2];j=v(j+v(k*s[g+8>>2]));i=v(i+v(k*s[g+4>>2]));h=v(h+v(s[g>>2]*k));d=d+1|0;if(d>>>0<r[g+52>>2]){continue}break}break b}o[f>>2]=3;break a}o[f>>2]=2;break a}G=1;o[f>>2]=1;k=s[b+48>>2];m=s[b+8>>2];p=s[b>>2];n=s[b+4>>2];q=s[b+52>>2];t=s[b+24>>2];w=s[b+16>>2];x=s[b+20>>2];y=s[b+56>>2];z=s[b+40>>2];A=s[b+32>>2];B=s[b+36>>2];o[f+16>>2]=0;s[f+12>>2]=y+v(v(v(h*A)+v(i*B))+v(j*z));s[f+8>>2]=q+v(v(v(h*w)+v(i*x))+v(j*t));s[f+4>>2]=k+v(v(v(h*p)+v(i*n))+v(j*m));q=s[b+48>>2];t=s[b+8>>2];w=s[b>>2];x=s[b+4>>2];y=s[b+52>>2];z=s[b+24>>2];A=s[b+16>>2];B=s[b+20>>2];D=s[b+56>>2];C=s[b+40>>2];E=s[b+32>>2];F=s[b+36>>2];m=s[g+60>>2];p=s[g- -64>>2];n=s[g+56>>2];k=s[g+72>>2];o[f+48>>2]=0;o[f+32>>2]=0;s[f+52>>2]=-k;s[f+44>>2]=-p;s[f+40>>2]=-m;s[f+36>>2]=-n;h=v(h-v(n*k));i=v(i-v(k*m));j=v(j-v(k*p));s[f+28>>2]=D+v(v(v(E*h)+v(F*i))+v(C*j));s[f+24>>2]=y+v(v(v(h*A)+v(i*B))+v(j*z));s[f+20>>2]=q+v(v(v(h*w)+v(i*x))+v(j*t));}K=g+19040|0;return G}function Og(a,b){var c=v(0),d=0,f=0,j=0,k=v(0),l=0,m=0,n=v(0),o=v(0),p=v(0),q=0,r=v(0),t=0,u=v(0),x=v(0),y=v(0),z=v(0);k=v(1);a:{b:{l=(g(a),h(0));c:{if((l|0)==1065353216){break c}m=(g(b),h(0));d=m&2147483647;if(!d){break c}f=l&2147483647;if(!(d>>>0<2139095041?f>>>0<=2139095040:0)){return v(a+b)}q=0;d:{if((l|0)>-1){break d}q=2;if(d>>>0>1266679807){break d}q=0;if(d>>>0<1065353216){break d}j=150-(d>>>23|0)|0;t=d>>>j|0;q=0;if((d|0)!=t<<j){break d}q=2-(t&1)|0;}j=q;e:{if((d|0)!=1065353216){if((d|0)!=2139095040){break e}if((f|0)==1065353216){break c}if(f>>>0>=1065353217){return (m|0)>-1?b:v(0)}return (m|0)>-1?v(0):v(-b)}return (m|0)>-1?a:v(v(1)/a)}if((m|0)==1073741824){return v(a*a)}if(!((m|0)!=1056964608|(l|0)<0)){return v(C(a))}c=v(w(a));if(!(f?(l&1073741823)!=1065353216:0)){k=(m|0)<0?v(v(1)/c):c;if((l|0)>-1){break c}if(!(j|f+ -1065353216)){a=v(k-k);return v(a/a)}return (j|0)==1?v(-k):k}if(!((l|0)>-1|j>>>0>1)){if(j-1){a=v(a-a);return v(a/a)}k=v(-1);}f:{if(d>>>0>=1291845633){if(f>>>0<=1065353207){return (m|0)<0?v(v(k*v(1.0000000150474662e+30))*v(1.0000000150474662e+30)):v(v(k*v(1.0000000031710769e-30))*v(1.0000000031710769e-30))}if(f>>>0>=1065353224){return (m|0)>0?v(v(k*v(1.0000000150474662e+30))*v(1.0000000150474662e+30)):v(v(k*v(1.0000000031710769e-30))*v(1.0000000031710769e-30))}a=v(c+v(-1));c=v(a*v(1.44268798828125));n=v(v(a*v(7052607543300837e-21))+v(v(v(a*a)*v(v(.5)-v(a*v(v(a*v(-.25))+v(.3333333432674408)))))*v(-1.4426950216293335)));a=(e(0,(g(v(c+n)),h(0))&-4096),i());r=v(a-c);break f}d=f>>>0<8388608;f=d?(g(v(c*v(16777216))),h(0)):f;l=f&8388607;j=l|1065353216;d=(f>>23)+(d?-151:-127)|0;f=0;g:{if(l>>>0<1885298){break g}if(l>>>0<6140887){f=1;break g}j=j+ -8388608|0;d=d+1|0;}l=f<<2;r=s[l+19408>>2];n=(e(0,j),i());o=s[l+19392>>2];p=v(n-o);u=v(v(1)/v(o+n));c=v(p*u);a=(e(0,(g(c),h(0))&-4096),i());x=v(a*a);y=a;z=p;p=(e(0,((j>>1&-536875008|536870912)+(f<<21)|0)+4194304|0),i());n=v(u*v(v(z-v(a*p))-v(a*v(n-v(p-o)))));p=v(v(c+a)*n);a=v(c*c);o=v(p+v(v(a*a)*v(v(a*v(v(a*v(v(a*v(v(a*v(v(a*v(.20697501301765442))+v(.23066075146198273)))+v(.2727281153202057)))+v(.3333333432674408)))+v(.4285714328289032)))+v(.6000000238418579))));a=(e(0,(g(v(v(x+v(3))+o)),h(0))&-4096),i());p=v(y*a);c=v(v(n*a)+v(c*v(o-v(v(a+v(-3))-x))));a=(e(0,(g(v(p+c)),h(0))&-4096),i());o=v(a*v(.9619140625));n=v(s[l+19400>>2]+v(v(v(c-v(a-p))*v(.9617967009544373))+v(a*v(-.00011736857413779944))));c=v(d|0);a=(e(0,(g(v(v(r+v(o+n))+c)),h(0))&-4096),i());r=v(v(v(a-c)-r)-o);}o=(e(0,m&-4096),i());c=v(a*o);a=v(v(v(n-r)*b)+v(v(b-o)*a));b=v(c+a);j=(g(b),h(0));if((j|0)>=1124073473){break b}f=1124073472;h:{i:{if((j|0)==1124073472){if(!(v(a+v(4.299566569443414e-8))>v(b-c))){break i}break b}f=j&2147483647;if(!(a<=v(b-c)^1|(j|0)!=-1021968384)|f>>>0>=1125515265){break a}d=0;if(f>>>0<1056964609){break h}}m=(8388608>>>(f>>>23|0)+ -126|0)+j|0;f=m>>>23&255;d=(m&8388607|8388608)>>>150-f|0;d=(j|0)<0?0-d|0:d;c=v(c-(e(0,m&-8388608>>f+ -127),i()));j=(g(v(a+c)),h(0));}b=(e(0,j&-32768),i());n=v(b*v(.693145751953125));c=v(v(b*v(14286065379565116e-22))+v(v(a-v(b-c))*v(.6931471824645996)));a=v(n+c);b=v(a*a);b=v(a-v(b*v(v(b*v(v(b*v(v(b*v(v(b*v(4.138136944220605e-8))+v(-16533901998627698e-22)))+v(661375597701408e-19)))+v(-.0027777778450399637)))+v(.1666666716337204))));p=v(v(a*b)/v(b+v(-2)));b=v(c-v(a-n));a=v(v(a-v(p-v(b+v(a*b))))+v(1));j=(g(a),h(0))+(d<<23)|0;j:{if((j|0)<=8388607){a=ju(a,d);break j}a=(e(0,j),i());}k=v(k*a);}return k}return v(v(k*v(1.0000000150474662e+30))*v(1.0000000150474662e+30))}return v(v(k*v(1.0000000031710769e-30))*v(1.0000000031710769e-30))}function Ce(a,b,c,d,e,f,g,h){var i=0,j=0,k=0,n=0,q=0,r=v(0),t=v(0),w=v(0),x=0,y=v(0),z=v(0),A=0,B=v(0),C=v(0),D=v(0),E=v(0),F=0,G=0,H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0);q=K-32|0;K=q;i=o[e+4>>2];if((i|0)<=-1){if(o[e+8>>2]<=-1){j=o[e+12>>2];if(j){if(p[e+16|0]){if(j){o[6258]=o[6258]+1;l[o[4969]](j);}}o[e+12>>2]=0;}m[e+16|0]=1;o[e+8>>2]=0;o[e+12>>2]=0;}while(1){k=o[q+20>>2];j=o[e+12>>2]+(i<<4)|0;o[j>>2]=o[q+16>>2];o[j+4>>2]=k;n=o[q+28>>2];o[j+8>>2]=o[q+24>>2];o[j+12>>2]=n;j=i+1|0;n=j>>>0>=i>>>0;i=j;if(n){continue}break}}j=0;o[e+4>>2]=0;n=o[d+4>>2];if(o[e+8>>2]<(n|0)){a:{if(!n){break a}o[6257]=o[6257]+1;j=l[o[4968]](n<<4,16)|0;G=o[e+4>>2];if((G|0)<1){break a}i=0;while(1){k=i<<4;A=k+j|0;x=A;k=k+o[e+12>>2]|0;F=o[k+4>>2];o[x>>2]=o[k>>2];o[x+4>>2]=F;x=o[k+12>>2];o[A+8>>2]=o[k+8>>2];o[A+12>>2]=x;i=i+1|0;if((G|0)!=(i|0)){continue}break}}i=o[e+12>>2];if(i){if(p[e+16|0]){if(i){o[6258]=o[6258]+1;l[o[4969]](i);}}o[e+12>>2]=0;}o[e+12>>2]=j;m[e+16|0]=1;o[e+8>>2]=n;}k=o[b+28>>2];b:{if((k|0)<1){break b}B=s[c+40>>2];H=s[c+36>>2];y=s[c+24>>2];I=s[c+20>>2];A=o[b+36>>2];C=s[a+8>>2];J=s[a+4>>2];D=s[a>>2];L=s[c+32>>2];M=s[c+16>>2];N=s[c+8>>2];O=s[c+4>>2];E=s[c>>2];i=0;w=v(3.4028234663852886e+38);n=-1;while(1){j=A+u(i,36)|0;t=s[j+20>>2];r=s[j+24>>2];z=s[j+28>>2];t=v(v(v(v(v(v(t*E)+v(r*O))+v(z*N))*D)+v(v(v(v(t*M)+v(r*I))+v(z*y))*J))+v(v(v(v(t*L)+v(r*H))+v(z*B))*C));j=t<w;w=j?t:w;n=j?i:n;i=i+1|0;if((k|0)!=(i|0)){continue}break}if((n|0)<0){break b}k=o[b+36>>2]+u(n,36)|0;G=o[k+4>>2];c:{if((G|0)<1){j=d;break c}i=0;while(1){j=e;n=i+1|0;A=(n|0)==(G|0);F=o[b+16>>2];x=o[k+12>>2];e=F+(o[x+((A?0:n)<<2)>>2]<<4)|0;P=s[e+8>>2];E=s[e>>2];Q=s[e+4>>2];e=F+(o[(i<<2)+x>>2]<<4)|0;w=s[e+8>>2];t=s[e>>2];r=s[e+4>>2];W=s[c+56>>2];X=s[c+52>>2];Y=s[c+48>>2];z=s[c+40>>2];B=s[c+32>>2];H=s[c+36>>2];y=s[k+28>>2];I=s[c+8>>2];C=s[k+20>>2];J=s[c>>2];D=s[k+24>>2];L=s[c+4>>2];M=s[c+24>>2];N=s[c+16>>2];O=s[c+20>>2];o[q+28>>2]=0;E=v(t-E);Q=v(r-Q);P=v(w-P);R=v(v(v(J*E)+v(L*Q))+v(I*P));S=v(v(v(N*C)+v(O*D))+v(M*y));T=v(v(v(E*N)+v(Q*O))+v(P*M));U=v(v(v(J*C)+v(L*D))+v(I*y));V=v(v(R*S)-v(T*U));s[q+24>>2]=-V;y=v(v(v(B*C)+v(H*D))+v(z*y));C=v(v(v(E*B)+v(Q*H))+v(P*z));D=v(v(T*y)-v(C*S));s[q+16>>2]=-D;y=v(-v(v(C*U)-v(R*y)));s[q+20>>2]=y;e=d;Hj(e,j,q+16|0,v(-v(v(v(v(X+v(v(v(t*N)+v(r*O))+v(w*M)))*y)-v(D*v(Y+v(v(v(t*J)+v(r*L))+v(w*I)))))-v(V*v(W+v(v(v(t*B)+v(r*H))+v(w*z)))))));i=o[e+4>>2];if((i|0)<=-1){if(o[e+8>>2]<=-1){d=o[e+12>>2];if(d){if(p[e+16|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[e+12>>2]=0;}m[e+16|0]=1;o[e+8>>2]=0;o[e+12>>2]=0;}while(1){F=o[q+4>>2];d=o[e+12>>2]+(i<<4)|0;o[d>>2]=o[q>>2];o[d+4>>2]=F;x=o[q+12>>2];o[d+8>>2]=o[q+8>>2];o[d+12>>2]=x;d=i+1|0;x=d>>>0>=i>>>0;i=d;if(x){continue}break}}o[e+4>>2]=0;i=n;d=j;if(!A){continue}break}}n=o[j+4>>2];if((n|0)<1){break b}w=s[k+20>>2];t=s[k+24>>2];r=s[k+28>>2];z=v(v(v(w*s[c>>2])+v(t*s[c+4>>2]))+v(r*s[c+8>>2]));B=v(v(v(w*s[c+16>>2])+v(t*s[c+20>>2]))+v(r*s[c+24>>2]));w=v(v(v(w*s[c+32>>2])+v(t*s[c+36>>2]))+v(r*s[c+40>>2]));t=v(s[k+32>>2]-v(v(v(z*s[c+48>>2])+v(B*s[c+52>>2]))+v(w*s[c+56>>2])));c=0;while(1){b=o[j+12>>2]+(c<<4)|0;r=v(t+v(v(v(z*s[b>>2])+v(B*s[b+4>>2]))+v(w*s[b+8>>2])));r=r<=f?f:r;if(!!(r<=g)){d=o[b+12>>2];o[q+24>>2]=o[b+8>>2];o[q+28>>2]=d;d=o[b+4>>2];o[q+16>>2]=o[b>>2];o[q+20>>2]=d;l[o[o[h>>2]+16>>2]](h,a,q+16|0,r);n=o[j+4>>2];}c=c+1|0;if((c|0)<(n|0)){continue}break}}K=q+32|0;}function rf(a,b,c,d,e,f,g,h,i,j,k,l,m){var n=v(0),q=v(0),r=v(0),t=0,w=v(0),x=v(0),A=0,B=v(0),D=v(0),E=v(0),F=v(0),G=v(0);j=u(o[i+24>>2],j);t=o[b+84>>2]+ -3|0;a:{if(t>>>0>1){t=0;break a}b:{if(!(t-1)){c:{if(l){n=s[k>>2];r=s[k+4>>2];q=v(v(s[g>>2]*n)+v(s[g+4>>2]*r));w=s[k+8>>2];B=v(s[g+8>>2]*w);t=h;break c}n=s[k>>2];r=s[k+4>>2];q=v(v(s[e>>2]*n)+v(s[e+4>>2]*r));w=s[k+8>>2];B=v(s[e+8>>2]*w);t=f;}D=s[t+8>>2];E=s[t>>2];F=s[t+4>>2];Ya(a,c,d,i,j,k,l,m);t=o[i+28>>2]+(j<<2)|0;G=v((l?-1:1)|0);x=v(v(v(s[i>>2]*s[b+12>>2])*s[b+72>>2])*G);s[t>>2]=x;q=v(v(q+B)-v(v(v(n*E)+v(r*F))+v(w*D)));n=v(x-v(q*s[b+12>>2]));d:{if(l){if(!(n>v(0))){break d}n=v(q*v(-s[b+8>>2]));if(!(n>x)){break d}s[t>>2]=n;break d}if(!(n<v(0))){break d}n=v(q*v(-s[b+8>>2]));if(!(n<x)){break d}s[t>>2]=n;}t=j<<2;s[t+o[i+36>>2]>>2]=l?v(0):v(-3.4028234663852886e+38);s[t+o[i+40>>2]>>2]=l?v(3.4028234663852886e+38):v(0);o[t+o[i+32>>2]>>2]=o[b+16>>2];j=o[i+24>>2]+j|0;Ya(a,c,d,i,j,k,l,m);t=o[i+28>>2]+(j<<2)|0;n=v(v(v(s[i>>2]*s[b+12>>2])*s[b+76>>2])*G);s[t>>2]=n;r=v(n-v(q*s[b+12>>2]));A=b+16|0;e:{if(l){if(!(r<v(0))){break e}q=v(q*v(-s[b+8>>2]));if(!(q<n)){break e}s[t>>2]=q;break e}if(!(r>v(0))){break e}q=v(q*v(-s[b+8>>2]));if(!(q>n)){break e}s[t>>2]=q;}t=j<<2;s[t+o[i+36>>2]>>2]=l?v(-3.4028234663852886e+38):v(0);s[t+o[i+40>>2]>>2]=l?v(0):v(3.4028234663852886e+38);t=2;break b}Ya(a,c,d,i,j,k,l,m);t=j<<2;s[t+o[i+28>>2]>>2]=v(v(s[i>>2]*s[b+12>>2])*s[b+72>>2])*v((l?-1:1)|0);o[t+o[i+36>>2]>>2]=-8388609;o[t+o[i+40>>2]>>2]=2139095039;A=b+16|0;t=1;}o[o[i+32>>2]+(j<<2)>>2]=o[A>>2];j=o[i+24>>2]+j|0;}f:{if(!p[b+28|0]){break f}if(!p[b+40|0]){Ya(a,c,d,i,j,k,l,m);q=s[b+32>>2];q=Wb(s[b+80>>2],s[b>>2],s[b+4>>2],l?q:v(-q),v(s[i>>2]*s[b+20>>2]));A=j<<2;s[A+o[i+28>>2]>>2]=q*s[b+32>>2];s[A+o[i+36>>2]>>2]=-s[b+36>>2];o[A+o[i+40>>2]>>2]=o[b+36>>2];o[A+o[i+32>>2]>>2]=o[b+24>>2];t=t+1|0;j=o[i+24>>2]+j|0;if(!p[b+28|0]|!p[b+40|0]){break f}}q=s[b+44>>2];n=v(s[b+80>>2]-q);g:{if(!l){break g}A=n>v(3.1415927410125732);q=A?v(q+v(6.2831854820251465)):q;n=A?v(n+v(-6.2831854820251465)):n;if(!(n<v(-3.1415927410125732))){break g}q=v(q+v(-6.2831854820251465));n=v(n+v(6.2831854820251465));}Ya(a,c,d,i,j,k,l,m);r=v(0);w=s[b+32>>2];x=n<v(0)?v(-w):w;if(n!=v(0)){B=v(-x);D=s[b+80>>2];r=s[b>>2];w=s[b+4>>2];h:{if(!!(r>w)){w=n<v(0)?q:v(3.4028234663852886e+38);n=n>v(0)?q:v(-3.4028234663852886e+38);break h}w=n<v(0)?q<w?q:w:w;n=n>v(0)?q>r?q:r:r;}r=Wb(D,n,w,B,v(s[i>>2]*s[b+20>>2]));}A=j<<2;s[A+o[i+28>>2]>>2]=v(x*r)*v((l?-1:1)|0);s[A+o[i+36>>2]>>2]=-s[b+36>>2];o[A+o[i+40>>2]>>2]=o[b+36>>2];o[A+o[i+32>>2]>>2]=o[b+24>>2];t=t+1|0;j=o[i+24>>2]+j|0;}if(p[b+48|0]){r=s[b+68>>2];x=s[b+80>>2];Ya(a,c,d,i,j,k,l,m);q=s[b+52>>2];w=s[b+60>>2];n=v(v(1)/s[i>>2]);F=v(x-r);i:{if(l){r=s[k>>2];D=s[k+4>>2];E=v(v(s[g>>2]*r)+v(s[g+4>>2]*D));x=s[k+8>>2];B=v(s[g+8>>2]*x);break i}h=f;r=s[k>>2];D=s[k+4>>2];E=v(v(s[e>>2]*r)+v(s[e+4>>2]*D));x=s[k+8>>2];B=v(s[e+8>>2]*x);}x=v(v(E+B)-v(v(v(r*s[h>>2])+v(D*s[h+4>>2]))+v(x*s[h+8>>2])));r=v(v(1)/s[o[a+32>>2]+404>>2]);B=v(v(1)/s[o[a+28>>2]+404>>2]);r=B>r?r:B;if(!(!p[b+56|0]|v(n*v(C(v(q/r))))>v(.25)^1)){q=v(v(v(v(v(1)/n)/n)*v(.0625))*r);}a=j<<2;B=v(n*v(F*q));q=v(x*v(-(v(w*n)>r?p[b+64|0]?v(r/n):w:w)));r=v((l?-1:1)|0);q=v(n*v(q*r));n=v(B+q);s[a+o[i+28>>2]>>2]=x+v(n*r);b=n<q;r=b?q:n;q=b?n:q;j:{if(!l){s[a+o[i+36>>2]>>2]=y(q,v(0));break j}s[a+o[i+36>>2]>>2]=y(v(-r),v(0));r=v(-q);}a=j<<2;s[a+o[i+40>>2]>>2]=z(r,v(0));o[a+o[i+32>>2]>>2]=0;t=t+1|0;}return t}function Wi(a,b,c){var d=0,e=0,f=0,g=0,h=v(0),i=0;d=K-144|0;K=d;o[a+72>>2]=o[a+72>>2]+1;o[d+140>>2]=0;e=o[b+12>>2];o[d+72>>2]=o[b+8>>2];o[d+76>>2]=e;e=o[b+4>>2];o[d+64>>2]=o[b>>2];o[d+68>>2]=e;e=o[b+28>>2];o[d+88>>2]=o[b+24>>2];o[d+92>>2]=e;e=o[b+20>>2];o[d+80>>2]=o[b+16>>2];o[d+84>>2]=e;e=o[b+44>>2];o[d+104>>2]=o[b+40>>2];o[d+108>>2]=e;e=o[b+36>>2];o[d+96>>2]=o[b+32>>2];o[d+100>>2]=e;e=o[b+60>>2];o[d+120>>2]=o[b+56>>2];o[d+124>>2]=e;e=o[b+52>>2];f=o[b+48>>2];o[d+128>>2]=c;o[d+112>>2]=f;o[d+116>>2]=e;o[d+132>>2]=o[c+4>>2];s[d+136>>2]=l[o[o[c>>2]+48>>2]](c);l[o[o[c>>2]+8>>2]](c,b,d+48|0,d+32|0);h=s[d+48>>2];if(!!(s[a+36>>2]>h)){s[a+36>>2]=h;}h=s[d+32>>2];if(!!(s[a+52>>2]<h)){s[a+52>>2]=h;}h=s[d+52>>2];if(s[a+40>>2]>h){s[a+40>>2]=h;}h=s[d+36>>2];if(!!(s[a+56>>2]<h)){s[a+56>>2]=h;}h=s[d+56>>2];if(!!(s[a+44>>2]>h)){s[a+44>>2]=h;}h=s[d+40>>2];if(!!(s[a+60>>2]<h)){s[a+60>>2]=h;}b=o[a+68>>2];if(b){c=o[d+60>>2];o[d+8>>2]=o[d+56>>2];o[d+12>>2]=c;c=o[d+44>>2];o[d+24>>2]=o[d+40>>2];o[d+28>>2]=c;c=o[d+36>>2];o[d+16>>2]=o[d+32>>2];o[d+20>>2]=c;c=o[d+52>>2];o[d>>2]=o[d+48>>2];o[d+4>>2]=c;o[d+140>>2]=wc(b,d,o[a+20>>2]);}Vi(a+16|0,d- -64|0);c=o[a+84>>2];a:{if((c|0)!=o[a+88>>2]){break a}f=c?c<<1:1;if((c|0)>=(f|0)){break a}b=0;if(f){o[6257]=o[6257]+1;g=l[o[4968]](f<<2,16)|0;c=o[a+84>>2];}e=o[a+92>>2];b:{c:{if((c|0)>=1){while(1){i=b<<2;o[i+g>>2]=o[e+i>>2];b=b+1|0;if((c|0)!=(b|0)){continue}break c}}if(!e){break b}}if(p[a+96|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}c=o[a+84>>2];}o[a+92>>2]=0;}o[a+92>>2]=g;o[a+88>>2]=f;m[a+96|0]=1;}o[o[a+92>>2]+(c<<2)>>2]=1056964608;o[a+84>>2]=c+1;c=o[a+124>>2];d:{if((c|0)!=o[a+128>>2]){break d}f=c?c<<1:1;if((c|0)>=(f|0)){break d}b=0;g=0;if(f){o[6257]=o[6257]+1;g=l[o[4968]](f<<2,16)|0;c=o[a+124>>2];}e=o[a+132>>2];e:{f:{if((c|0)>=1){while(1){i=b<<2;o[i+g>>2]=o[e+i>>2];b=b+1|0;if((c|0)!=(b|0)){continue}break f}}if(!e){break e}}if(p[a+136|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}c=o[a+124>>2];}o[a+132>>2]=0;}o[a+132>>2]=g;o[a+128>>2]=f;m[a+136|0]=1;}o[o[a+132>>2]+(c<<2)>>2]=0;o[a+124>>2]=c+1;c=o[a+104>>2];g:{if((c|0)!=o[a+108>>2]){break g}f=c?c<<1:1;if((c|0)>=(f|0)){break g}b=0;g=0;if(f){o[6257]=o[6257]+1;g=l[o[4968]](f<<2,16)|0;c=o[a+104>>2];}e=o[a+112>>2];h:{i:{if((c|0)>=1){while(1){i=b<<2;o[i+g>>2]=o[e+i>>2];b=b+1|0;if((c|0)!=(b|0)){continue}break i}}if(!e){break h}}if(p[a+116|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}c=o[a+104>>2];}o[a+112>>2]=0;}o[a+112>>2]=g;o[a+108>>2]=f;m[a+116|0]=1;}o[o[a+112>>2]+(c<<2)>>2]=0;o[a+104>>2]=c+1;c=o[a+144>>2];j:{if((c|0)!=o[a+148>>2]){break j}f=c?c<<1:1;if((c|0)>=(f|0)){break j}b=0;g=0;if(f){o[6257]=o[6257]+1;g=l[o[4968]](f<<2,16)|0;c=o[a+144>>2];}e=o[a+152>>2];k:{l:{if((c|0)>=1){while(1){i=b<<2;o[i+g>>2]=o[e+i>>2];b=b+1|0;if((c|0)!=(b|0)){continue}break l}}if(!e){break k}}if(p[a+156|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}c=o[a+144>>2];}o[a+152>>2]=0;}o[a+152>>2]=g;o[a+148>>2]=f;m[a+156|0]=1;}o[o[a+152>>2]+(c<<2)>>2]=0;o[a+144>>2]=c+1;c=o[a+164>>2];m:{if((c|0)!=o[a+168>>2]){break m}f=c?c<<1:1;if((c|0)>=(f|0)){break m}b=0;g=0;if(f){o[6257]=o[6257]+1;g=l[o[4968]](f<<2,16)|0;c=o[a+164>>2];}e=o[a+172>>2];n:{o:{if((c|0)>=1){while(1){i=b<<2;o[i+g>>2]=o[e+i>>2];b=b+1|0;if((c|0)!=(b|0)){continue}break o}}if(!e){break n}}if(p[a+176|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[a+172>>2]=0;c=o[a+164>>2];}o[a+172>>2]=g;o[a+168>>2]=f;m[a+176|0]=1;}o[o[a+172>>2]+(c<<2)>>2]=2;o[a+164>>2]=o[a+164>>2]+1;K=d+144|0;}function Qa(a){var b=0,c=0,d=0,e=0,f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=0,l=v(0),m=v(0),n=v(0),p=0,q=v(0),r=v(0);d=K-48|0;K=d;a:{b:{c=o[a+372>>2];b=o[c+32>>2]+ -1|0;c:{if(b>>>0>3){break c}d:{switch(b-1|0){default:e=o[a+364>>2];b=1;while(1){o[d+40>>2]=0;o[d+44>>2]=0;o[d+32>>2]=0;o[d+36>>2]=0;o[(d+32|0)+(f<<2)>>2]=1065353216;k=(b<<2)+c|0;o[k+16>>2]=0;e=e+ -1|0;o[a+364>>2]=e;e=o[((e<<2)+a|0)+348>>2];o[k>>2]=e;o[c+32>>2]=b+1;Ia(a,d+32|0,e);if(Qa(a)){break b}c=o[a+372>>2];b=o[c+32>>2]+ -1|0;o[c+32>>2]=b;e=o[a+364>>2];b=o[c+(b<<2)>>2];o[((e<<2)+a|0)+348>>2]=b;c=o[a+372>>2];o[d+28>>2]=0;s[d+24>>2]=-s[d+40>>2];s[d+20>>2]=-s[d+36>>2];s[d+16>>2]=-s[d+32>>2];k=o[c+32>>2];p=c+(k<<2)|0;o[p+16>>2]=0;o[a+364>>2]=e;o[p>>2]=b;o[c+32>>2]=k+1;Ia(a,d+16|0,b);if(Qa(a)){break b}c=o[a+372>>2];b=o[c+32>>2]+ -1|0;o[c+32>>2]=b;c=o[c+(b<<2)>>2];b=o[a+364>>2];e=b+1|0;o[a+364>>2]=e;o[((b<<2)+a|0)+348>>2]=c;f=f+1|0;if((f|0)==3){break c}c=o[a+372>>2];b=o[c+32>>2];continue}case 0:b=o[c+4>>2];c=o[c>>2];g=v(s[b+24>>2]-s[c+24>>2]);i=v(s[b+20>>2]-s[c+20>>2]);h=v(s[b+16>>2]-s[c+16>>2]);c=0;while(1){o[d+40>>2]=0;o[d+44>>2]=0;o[d+32>>2]=0;o[d+36>>2]=0;o[(d+32|0)+(c<<2)>>2]=1065353216;o[d+28>>2]=0;j=s[d+32>>2];l=s[d+40>>2];m=v(v(g*j)-v(h*l));s[d+20>>2]=m;n=s[d+36>>2];l=v(v(i*l)-v(g*n));s[d+16>>2]=l;j=v(v(h*n)-v(i*j));s[d+24>>2]=j;if(!!(v(v(j*j)+v(v(l*l)+v(m*m)))>v(0))){b=o[a+372>>2];e=o[b+32>>2];f=(e<<2)+b|0;o[f+16>>2]=0;k=o[a+364>>2]+ -1|0;o[a+364>>2]=k;p=f;f=o[((k<<2)+a|0)+348>>2];o[p>>2]=f;o[b+32>>2]=e+1;Ia(a,d+16|0,f);if(Qa(a)){break b}b=o[a+372>>2];e=o[b+32>>2]+ -1|0;o[b+32>>2]=e;f=o[a+364>>2];e=o[b+(e<<2)>>2];o[((f<<2)+a|0)+348>>2]=e;b=o[a+372>>2];o[d+12>>2]=0;s[d+8>>2]=-s[d+24>>2];s[d+4>>2]=-s[d+20>>2];s[d>>2]=-s[d+16>>2];k=o[b+32>>2];p=b+(k<<2)|0;o[p+16>>2]=0;o[a+364>>2]=f;o[p>>2]=e;o[b+32>>2]=k+1;Ia(a,d,e);if(Qa(a)){break b}b=o[a+372>>2];e=o[b+32>>2]+ -1|0;o[b+32>>2]=e;b=o[b+(e<<2)>>2];e=o[a+364>>2];o[a+364>>2]=e+1;o[((e<<2)+a|0)+348>>2]=b;}c=c+1|0;if((c|0)!=3){continue}break}break c;case 1:b=o[c+4>>2];m=s[b+20>>2];e=o[c+8>>2];l=s[e+24>>2];f=o[c>>2];g=s[f+24>>2];j=s[b+24>>2];n=s[e+20>>2];i=s[f+20>>2];q=s[e+16>>2];h=s[f+16>>2];r=s[b+16>>2];o[d+44>>2]=0;m=v(m-i);l=v(l-g);j=v(j-g);n=v(n-i);g=v(v(m*l)-v(j*n));s[d+32>>2]=g;i=j;j=v(q-h);h=v(r-h);i=v(v(i*j)-v(h*l));s[d+36>>2]=i;h=v(v(h*n)-v(m*j));s[d+40>>2]=h;if(!(v(v(h*h)+v(v(g*g)+v(i*i)))>v(0))){break c}o[c+28>>2]=0;b=o[a+364>>2]+ -1|0;o[a+364>>2]=b;b=o[((b<<2)+a|0)+348>>2];o[c+32>>2]=4;o[c+12>>2]=b;Ia(a,d+32|0,b);if(Qa(a)){break b}c=o[a+372>>2];b=o[c+32>>2]+ -1|0;o[c+32>>2]=b;e=o[a+364>>2];b=o[c+(b<<2)>>2];o[((e<<2)+a|0)+348>>2]=b;c=o[a+372>>2];o[d+28>>2]=0;s[d+24>>2]=-s[d+40>>2];s[d+20>>2]=-s[d+36>>2];s[d+16>>2]=-s[d+32>>2];f=o[c+32>>2];k=c+(f<<2)|0;o[k+16>>2]=0;o[a+364>>2]=e;o[k>>2]=b;o[c+32>>2]=f+1;Ia(a,d+16|0,b);b=1;if(Qa(a)){break a}c=o[a+372>>2];b=o[c+32>>2]+ -1|0;o[c+32>>2]=b;c=o[c+(b<<2)>>2];b=o[a+364>>2];o[a+364>>2]=b+1;o[((b<<2)+a|0)+348>>2]=c;b=0;break a;case 2:break d}}a=o[c>>2];e=o[c+12>>2];g=s[e+16>>2];m=v(s[a+16>>2]-g);f=o[c+4>>2];i=s[e+20>>2];l=v(s[f+20>>2]-i);c=o[c+8>>2];h=s[e+24>>2];j=v(s[c+24>>2]-h);n=v(s[a+20>>2]-i);q=v(s[f+24>>2]-h);r=v(s[c+16>>2]-g);h=v(s[a+24>>2]-h);g=v(s[f+16>>2]-g);i=v(s[c+20>>2]-i);g=v(v(v(v(m*l)*j)+v(v(v(v(v(n*q)*r)+v(v(h*g)*i))-v(v(m*q)*i))-v(v(n*g)*j)))-v(v(h*l)*r));b=1;if(g!=v(0)&g==g){break a}}b=0;break a}b=1;}K=d+48|0;return b}function ej(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=0,F=0,G=0,H=0,I=v(0),J=v(0),L=v(0),M=0,N=0,O=0;d=K-256|0;K=d;l[o[4966]](10772);o[a+4>>2]=o[a+4>>2]+1;G=o[c+36>>2];M=u(G,80);N=o[a+12>>2];O=o[N+4>>2];E=o[(M+o[O+28>>2]|0)+64>>2];c=o[a+8>>2];H=o[b+36>>2];b=o[o[c+4>>2]+28>>2]+u(H,80)|0;F=o[b+64>>2];c=o[c+12>>2];I=s[c+52>>2];J=s[c+56>>2];f=s[c+24>>2];e=s[c+20>>2];g=s[c+40>>2];h=s[c+36>>2];L=s[c+48>>2];i=s[c+8>>2];j=s[c>>2];k=s[c+4>>2];m=s[c+16>>2];n=s[c+32>>2];p=s[b+32>>2];q=s[b>>2];r=s[b+16>>2];t=s[b+56>>2];w=s[b+48>>2];x=s[b+52>>2];y=s[b+36>>2];z=s[b+4>>2];A=s[b+20>>2];B=s[b+40>>2];C=s[b+8>>2];D=s[b+24>>2];c=0;o[d+244>>2]=0;o[d+228>>2]=0;o[d+212>>2]=0;s[d+224>>2]=v(v(n*C)+v(h*D))+v(g*B);s[d+220>>2]=v(v(n*z)+v(h*A))+v(g*y);s[d+208>>2]=v(v(m*C)+v(e*D))+v(f*B);s[d+204>>2]=v(v(m*z)+v(e*A))+v(f*y);s[d+240>>2]=J+v(v(v(n*w)+v(h*x))+v(g*t));s[d+236>>2]=I+v(v(v(m*w)+v(e*x))+v(f*t));o[d+196>>2]=0;s[d+216>>2]=v(v(n*q)+v(h*r))+v(g*p);s[d+200>>2]=v(v(m*q)+v(e*r))+v(f*p);s[d+192>>2]=v(v(j*C)+v(k*D))+v(i*B);s[d+188>>2]=v(v(j*z)+v(k*A))+v(i*y);s[d+184>>2]=v(v(j*q)+v(k*r))+v(i*p);s[d+232>>2]=L+v(v(v(j*w)+v(k*x))+v(i*t));b=o[N+12>>2];I=s[b+52>>2];J=s[b+56>>2];f=s[b+24>>2];e=s[b+20>>2];g=s[b+40>>2];h=s[b+36>>2];L=s[b+48>>2];i=s[b+8>>2];j=s[b>>2];k=s[b+4>>2];m=s[b+16>>2];n=s[b+32>>2];b=o[O+28>>2]+M|0;p=s[b+32>>2];q=s[b>>2];r=s[b+16>>2];t=s[b+56>>2];w=s[b+48>>2];x=s[b+52>>2];y=s[b+36>>2];z=s[b+4>>2];A=s[b+20>>2];B=s[b+40>>2];C=s[b+8>>2];D=s[b+24>>2];o[d+180>>2]=0;o[d+164>>2]=0;o[d+148>>2]=0;s[d+160>>2]=v(v(n*C)+v(h*D))+v(g*B);s[d+156>>2]=v(v(n*z)+v(h*A))+v(g*y);s[d+144>>2]=v(v(m*C)+v(e*D))+v(f*B);s[d+140>>2]=v(v(m*z)+v(e*A))+v(f*y);s[d+176>>2]=J+v(v(v(n*w)+v(h*x))+v(g*t));s[d+172>>2]=I+v(v(v(m*w)+v(e*x))+v(f*t));o[d+132>>2]=0;s[d+152>>2]=v(v(n*q)+v(h*r))+v(g*p);s[d+136>>2]=v(v(m*q)+v(e*r))+v(f*p);s[d+128>>2]=v(v(j*C)+v(k*D))+v(i*B);s[d+124>>2]=v(v(j*z)+v(k*A))+v(i*y);s[d+120>>2]=v(v(j*q)+v(k*r))+v(i*p);s[d+168>>2]=L+v(v(v(j*w)+v(k*x))+v(i*t));l[o[o[F>>2]+8>>2]](F,d+184|0,d+104|0,d+88|0);l[o[o[E>>2]+8>>2]](E,d+120|0,d+72|0,d+56|0);e=s[o[a+24>>2]+32>>2];f=v(s[d+104>>2]-e);s[d+104>>2]=f;s[d+108>>2]=s[d+108>>2]-e;s[d+112>>2]=s[d+112>>2]-e;s[d+88>>2]=e+s[d+88>>2];s[d+92>>2]=e+s[d+92>>2];s[d+96>>2]=e+s[d+96>>2];b=o[5647];a:{if(b){if(!l[b](F,E)){break a}f=s[d+104>>2];}if(!(s[d+88>>2]<s[d+72>>2]|f>s[d+56>>2])){c=1;}b=0;b=s[d+96>>2]<s[d+80>>2]|s[d+112>>2]>s[d+64>>2]?b:c;if(s[d+92>>2]<s[d+76>>2]|s[d+108>>2]>s[d+60>>2]|b^1){break a}b=o[a+8>>2];c=o[b+8>>2];o[d+52>>2]=H;o[d+48>>2]=-1;o[d+40>>2]=c;o[d+36>>2]=F;o[d+32>>2]=b;o[d+44>>2]=d+184;b=o[a+12>>2];c=o[b+8>>2];o[d+28>>2]=G;o[d+24>>2]=-1;o[d+16>>2]=c;o[d+12>>2]=E;o[d+8>>2]=b;o[d+20>>2]=d+120;b=nj(o[a+28>>2],H,G);b:{if(!!(s[o[a+24>>2]+32>>2]>v(0))){b=o[a+16>>2];c=l[o[o[b>>2]+8>>2]](b,d+32|0,d+8|0,0,2)|0;break b}if(b){c=o[b+8>>2];break b}b=o[a+16>>2];c=l[o[o[b>>2]+8>>2]](b,d+32|0,d+8|0,o[a+32>>2],1)|0;b=o[a+28>>2];o[(l[o[o[b>>2]+12>>2]](b,H,G)|0)+8>>2]=c;}b=o[a+24>>2];E=o[b+12>>2];F=o[b+8>>2];o[b+12>>2]=d+8;o[b+8>>2]=d+32;l[o[o[b>>2]+8>>2]](b,-1,H);b=o[a+24>>2];l[o[o[b>>2]+12>>2]](b,-1,G);l[o[o[c>>2]+8>>2]](c,d+32|0,d+8|0,o[a+20>>2],o[a+24>>2]);a=o[a+24>>2];o[a+8>>2]=F;o[a+12>>2]=E;}l[o[4967]]();K=d+256|0;}function xm(a,b,c,d,e,f,g,h,i,j,k,l){var m=v(0),n=0,q=0,r=v(0),t=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),K=v(0),L=v(0),M=v(0),N=0,O=v(0),P=v(0),Q=0,R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0);N=o[a+16>>2];n=o[(N+u(e,244)|0)+240>>2];q=o[(u(d,244)+N|0)+240>>2];o[b+148>>2]=e;o[b+144>>2]=d;R=s[f+84>>2];Q=o[f+84>>2];o[b+132>>2]=0;o[b+104>>2]=Q;o[b+96>>2]=0;o[b+100>>2]=0;a:{if(q){a=o[c+4>>2];o[b+16>>2]=o[c>>2];o[b+20>>2]=a;a=o[c+12>>2];o[b+24>>2]=o[c+8>>2];o[b+28>>2]=a;r=s[g+8>>2];w=s[g>>2];x=s[g+4>>2];o[b+12>>2]=0;B=s[b+20>>2];H=s[b+16>>2];C=v(v(w*B)-v(x*H));s[b+8>>2]=C;I=s[b+24>>2];w=v(v(r*H)-v(w*I));s[b+4>>2]=w;x=v(v(x*I)-v(r*B));s[b>>2]=x;r=s[q+612>>2];m=s[q+364>>2];D=s[q+356>>2];y=s[q+360>>2];t=s[q+608>>2];J=s[q+348>>2];K=s[q+340>>2];L=s[q+344>>2];z=s[q+332>>2];E=s[q+328>>2];F=s[q+604>>2];A=s[q+324>>2];o[b+76>>2]=0;E=v(F*v(v(v(x*A)+v(w*E))+v(C*z)));s[b+64>>2]=E;F=v(t*v(v(v(x*K)+v(w*L))+v(C*J)));s[b+68>>2]=F;A=v(r*v(v(v(x*D)+v(w*y))+v(C*m)));s[b+72>>2]=A;break a}o[b+64>>2]=0;o[b+68>>2]=0;o[b>>2]=0;o[b+4>>2]=0;o[b+72>>2]=0;o[b+76>>2]=0;o[b+8>>2]=0;o[b+12>>2]=0;o[b+16>>2]=0;o[b+20>>2]=0;o[b+24>>2]=0;o[b+28>>2]=0;}b:{if(n){r=s[c>>2];m=s[c+4>>2];t=s[c+8>>2];o[b+60>>2]=0;J=v(-t);s[b+56>>2]=J;K=v(-m);s[b+52>>2]=K;L=v(-r);s[b+48>>2]=L;z=s[h+8>>2];G=s[h+4>>2];y=s[h>>2];o[b+44>>2]=0;D=v(v(r*G)-v(m*y));s[b+40>>2]=D;y=v(v(t*y)-v(r*z));s[b+36>>2]=y;t=v(v(m*z)-v(t*G));s[b+32>>2]=t;r=s[n+332>>2];G=s[n+328>>2];z=s[n+608>>2];O=s[n+348>>2];M=s[n+340>>2];P=s[n+344>>2];m=s[n+612>>2];S=s[n+364>>2];T=s[n+356>>2];U=s[n+360>>2];V=s[n+604>>2];W=s[n+324>>2];o[b+92>>2]=0;m=v(m*v(v(v(t*T)+v(y*U))+v(D*S)));s[b+88>>2]=m;z=v(z*v(v(v(t*M)+v(y*P))+v(D*O)));s[b+84>>2]=z;G=v(V*v(v(v(t*W)+v(y*G))+v(D*r)));s[b+80>>2]=G;break b}o[b+80>>2]=0;o[b+84>>2]=0;o[b+32>>2]=0;o[b+36>>2]=0;o[b+88>>2]=0;o[b+92>>2]=0;o[b+40>>2]=0;o[b+44>>2]=0;o[b+48>>2]=0;o[b+52>>2]=0;o[b+56>>2]=0;o[b+60>>2]=0;D=v(0);y=v(0);t=v(0);J=v(0);K=v(0);L=v(0);m=v(0);z=v(0);}a=b;r=i;if(q){i=s[g+8>>2];O=s[g+4>>2];P=v(v(v(F*i)-v(A*O))*s[c>>2]);M=A;A=s[g>>2];i=v(s[q+404>>2]+v(v(P+v(v(v(M*A)-v(i*E))*s[c+4>>2]))+v(v(v(O*E)-v(F*A))*s[c+8>>2])));}else {i=v(0);}if(n){E=s[h+4>>2];F=s[h+8>>2];M=v(v(v(m*E)-v(z*F))*s[c>>2]);A=m;m=s[h>>2];m=v(s[n+404>>2]+v(v(M+v(v(v(G*F)-v(A*m))*s[c+4>>2]))+v(v(v(z*m)-v(G*E))*s[c+8>>2])));}else {m=v(0);}r=v(r/v(i+m));s[a+108>>2]=r;c:{if(!q){m=v(0);B=v(v(v(H*v(0))+v(B*v(0)))+v(I*v(0)));I=v(0);i=v(0);break c}a=u(d,244)+N|0;B=v(v(v(v(s[a+176>>2]+s[a+208>>2])*H)+v(v(s[a+180>>2]+s[a+212>>2])*B))+v(v(s[a+184>>2]+s[a+216>>2])*I));m=s[a+192>>2];I=s[a+200>>2];i=s[a+196>>2];}B=v(B+v(v(v(m*x)+v(i*w))+v(I*C)));d:{if(!n){w=v(0);x=v(v(v(L*v(0))+v(K*v(0)))+v(J*v(0)));H=v(0);i=v(0);break d}a=u(e,244)+N|0;x=v(v(v(v(s[a+176>>2]+s[a+208>>2])*L)+v(v(s[a+180>>2]+s[a+212>>2])*K))+v(v(s[a+184>>2]+s[a+216>>2])*J));H=s[a+192>>2];w=s[a+200>>2];i=s[a+196>>2];}C=v(0);C=p[f+128|0]&16?v(r*v(v(s[j+44>>2]*v(-v(v(v(v(s[f+48>>2]-s[f+32>>2])*s[c>>2])+v(v(s[f+52>>2]-s[f+36>>2])*s[c+4>>2]))+v(v(s[f+56>>2]-s[f+40>>2])*s[c+8>>2]))))/s[j+12>>2])):C;o[b+128>>2]=0;o[b+124>>2]=Q;s[b+116>>2]=l;s[b+112>>2]=v(r*v(k-v(B+v(x+v(v(v(H*t)+v(i*y))+v(w*D))))))+C;s[b+120>>2]=-R;}function sn(a,b,c,d,e){dd(a,12,b,c);o[a>>2]=3248;b=o[d+12>>2];o[a+56>>2]=o[d+8>>2];o[a+60>>2]=b;b=o[d+4>>2];o[a+48>>2]=o[d>>2];o[a+52>>2]=b;b=o[d+28>>2];o[a+72>>2]=o[d+24>>2];o[a+76>>2]=b;c=o[d+20>>2];b=a- -64|0;o[b>>2]=o[d+16>>2];o[b+4>>2]=c;b=o[d+44>>2];o[a+88>>2]=o[d+40>>2];o[a+92>>2]=b;b=o[d+36>>2];o[a+80>>2]=o[d+32>>2];o[a+84>>2]=b;b=o[d+60>>2];o[a+104>>2]=o[d+56>>2];o[a+108>>2]=b;b=o[d+52>>2];o[a+96>>2]=o[d+48>>2];o[a+100>>2]=b;b=o[e+12>>2];o[a+120>>2]=o[e+8>>2];o[a+124>>2]=b;b=o[e+4>>2];o[a+112>>2]=o[e>>2];o[a+116>>2]=b;b=o[e+20>>2];o[a+128>>2]=o[e+16>>2];o[a+132>>2]=b;b=o[e+28>>2];o[a+136>>2]=o[e+24>>2];o[a+140>>2]=b;b=o[e+36>>2];o[a+144>>2]=o[e+32>>2];o[a+148>>2]=b;b=o[e+44>>2];o[a+152>>2]=o[e+40>>2];o[a+156>>2]=b;b=o[e+52>>2];o[a+160>>2]=o[e+48>>2];o[a+164>>2]=b;b=o[e+60>>2];o[a+168>>2]=o[e+56>>2];o[a+172>>2]=b;o[a+680>>2]=0;o[a+684>>2]=0;o[a+688>>2]=0;o[a+692>>2]=0;o[a+696>>2]=0;o[a+700>>2]=0;o[a+704>>2]=0;o[a+708>>2]=0;o[a+712>>2]=0;o[a+716>>2]=0;o[a+720>>2]=0;o[a+724>>2]=0;o[a+736>>2]=1045220557;o[a+728>>2]=1045220557;o[a+732>>2]=1045220557;o[a+756>>2]=0;o[a+748>>2]=0;o[a+752>>2]=0;o[a+740>>2]=0;o[a+744>>2]=0;o[a+768>>2]=1063675494;o[a+760>>2]=1063675494;o[a+764>>2]=1063675494;o[a+812>>2]=0;o[a+804>>2]=0;o[a+808>>2]=0;o[a+828>>2]=0;o[a+820>>2]=0;o[a+824>>2]=0;m[a+838|0]=0;m[a+836|0]=0;m[a+837|0]=0;o[a+848>>2]=0;o[a+840>>2]=0;o[a+844>>2]=0;m[a+858|0]=0;m[a+856|0]=0;m[a+857|0]=0;o[a+868>>2]=0;o[a+860>>2]=0;o[a+864>>2]=0;o[a+884>>2]=0;o[a+876>>2]=0;o[a+880>>2]=0;o[a+900>>2]=0;o[a+892>>2]=0;o[a+896>>2]=0;m[a+793|0]=0;m[a+794|0]=0;m[a+795|0]=0;m[a+796|0]=0;m[a+797|0]=0;m[a+798|0]=0;m[a+799|0]=0;m[a+800|0]=0;o[a+788>>2]=0;o[a+792>>2]=0;o[a+780>>2]=0;o[a+784>>2]=0;o[a+772>>2]=0;o[a+776>>2]=0;o[a+964>>2]=0;o[a+956>>2]=0;o[a+960>>2]=0;o[a+948>>2]=0;o[a+952>>2]=0;o[a+940>>2]=0;o[a+944>>2]=0;o[a+932>>2]=0;o[a+936>>2]=0;o[a+924>>2]=0;o[a+928>>2]=0;o[a+916>>2]=0;o[a+920>>2]=0;o[a+908>>2]=0;o[a+912>>2]=0;m[a+1032|0]=0;o[a+1028>>2]=0;m[a+1024|0]=0;o[a+1020>>2]=0;m[a+1016|0]=0;o[a+1012>>2]=0;m[a+1008|0]=0;o[a+1e3>>2]=0;o[a+1004>>2]=1036831949;m[a+996|0]=0;o[a+992>>2]=0;o[a+984>>2]=0;o[a+988>>2]=1063675494;o[a+976>>2]=0;o[a+980>>2]=1045220557;o[a+968>>2]=1065353216;o[a+972>>2]=-1082130432;o[a+1052>>2]=0;b=a+1044|0;o[b>>2]=0;o[b+4>>2]=0;b=a+1036|0;o[b>>2]=0;o[b+4>>2]=0;m[a+1120|0]=0;o[a+1116>>2]=0;m[a+1112|0]=0;o[a+1108>>2]=0;m[a+1104|0]=0;o[a+1100>>2]=0;m[a+1096|0]=0;b=a+1088|0;o[b>>2]=0;o[b+4>>2]=1036831949;m[a+1084|0]=0;o[a+1080>>2]=0;b=a+1072|0;o[b>>2]=0;o[b+4>>2]=1063675494;b=a+1064|0;o[b>>2]=0;o[b+4>>2]=1045220557;b=a+1056|0;o[b>>2]=1065353216;o[b+4>>2]=-1082130432;o[a+1140>>2]=0;b=a+1132|0;o[b>>2]=0;o[b+4>>2]=0;b=a+1124|0;o[b>>2]=0;o[b+4>>2]=0;m[a+1208|0]=0;o[a+1204>>2]=0;m[a+1200|0]=0;o[a+1196>>2]=0;m[a+1192|0]=0;o[a+1188>>2]=0;m[a+1184|0]=0;b=a+1176|0;o[b>>2]=0;o[b+4>>2]=1036831949;m[a+1172|0]=0;o[a+1168>>2]=0;b=a+1160|0;o[b>>2]=0;o[b+4>>2]=1063675494;b=a+1152|0;o[b>>2]=0;o[b+4>>2]=1045220557;b=a+1144|0;o[b>>2]=1065353216;o[b+4>>2]=-1082130432;o[a+1228>>2]=0;b=a+1220|0;o[b>>2]=0;o[b+4>>2]=0;b=a+1212|0;o[b>>2]=0;o[b+4>>2]=0;o[a+1456>>2]=0;o[a+1232>>2]=0;sf(a,o[a+28>>2]+4|0,o[a+32>>2]+4|0);}function Il(a,b,c,d,e,f){var g=v(0),h=0,i=v(0),j=v(0),k=v(0),l=0,n=v(0),q=v(0),r=v(0),t=0,u=v(0),w=v(0),x=0,y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=0,X=v(0),Y=v(0),Z=v(0),_=0,$=0;h=K-48|0;K=h;m[h+24|0]=0;l=o[a+12>>2];o[f+8>>2]=o[a+8>>2];o[f+12>>2]=l;l=o[a+4>>2];o[f>>2]=o[a>>2];o[f+4>>2]=l;m[f+16|0]=p[f+16|0]|15;R=s[a+8>>2];y=s[b+8>>2];N=v(R-y);z=s[c+8>>2];A=v(z-y);S=s[d>>2];B=s[b>>2];C=v(S-B);M=s[e+4>>2];D=s[b+4>>2];E=v(M-D);F=s[d+4>>2];G=v(F-D);n=s[e>>2];H=v(n-B);q=v(v(C*E)-v(G*H));I=s[c>>2];J=v(I-B);T=s[e+8>>2];r=v(T-y);j=s[d+8>>2];k=v(j-y);g=v(v(G*r)-v(k*E));L=s[c+4>>2];u=v(L-D);i=v(v(k*H)-v(C*r));w=v(v(A*q)+v(v(J*g)+v(u*i)));U=s[a>>2];O=v(U-B);V=s[a+4>>2];P=v(V-D);W=v(w*w)<v(9.99999905104687e-9)?-1:v(v(v(N*q)+v(v(O*g)+v(P*i)))*w)<v(0);X=v(v(u*k)-v(A*G));Y=v(v(A*C)-v(J*k));Z=v(v(J*G)-v(u*C));Q=v(v(v(X*H)+v(Y*E))+v(Z*r));i=k;k=v(v(u*H)-v(J*E));u=v(v(A*E)-v(u*r));w=v(v(J*r)-v(A*H));r=v(v(i*k)+v(v(C*u)+v(G*w)));g=v(F-L);F=v(n-I);n=v(S-I);i=v(M-L);q=v(v(g*F)-v(n*i));j=v(j-z);M=v(j*i);i=v(T-z);g=v(M-v(g*i));i=v(v(n*i)-v(j*F));j=v(v(v(y-z)*q)+v(v(v(B-I)*g)+v(v(D-L)*i)));_=v(j*j)<v(9.99999905104687e-9)?-1:v(v(v(v(R-z)*q)+v(v(v(U-I)*g)+v(v(V-L)*i)))*j)<v(0);$=v(r*r)<v(9.99999905104687e-9)?-1:v(v(v(N*k)+v(v(O*u)+v(P*w)))*r)<v(0);t=v(Q*Q)<v(9.99999905104687e-9)?-1:v(v(v(v(O*X)+v(P*Y))+v(Z*N))*Q)<v(0);l=_|($|(t|W));a:{if((l|0)<=-1){m[f+36|0]=1;break a}if(!l){break a}i=v(3.4028234663852886e+38);b:{if(!t){break b}qb(a,b,c,d,h+8|0);n=s[h+8>>2];g=v(n-s[a>>2]);i=v(g*g);q=s[h+12>>2];g=v(q-s[a+4>>2]);i=v(i+v(g*g));j=s[h+16>>2];g=v(j-s[a+8>>2]);g=v(i+v(g*g));i=v(3.4028234663852886e+38);if(!(g<v(3.4028234663852886e+38))){break b}o[f+12>>2]=o[h+20>>2];s[f+8>>2]=j;s[f+4>>2]=q;s[f>>2]=n;l=p[h+24|0];m[f+16|0]=l&1|p[f+16|0]&240|l&2|l&4;x=o[h+36>>2];t=o[h+32>>2];l=o[h+28>>2];o[f+32>>2]=0;o[f+28>>2]=x;o[f+20>>2]=l;o[f+24>>2]=t;i=g;}c:{if(!W){break c}qb(a,b,d,e,h+8|0);n=s[h+8>>2];g=v(n-s[a>>2]);k=v(g*g);q=s[h+12>>2];g=v(q-s[a+4>>2]);k=v(k+v(g*g));j=s[h+16>>2];g=v(j-s[a+8>>2]);g=v(k+v(g*g));if(!(g<i)){break c}o[f+12>>2]=o[h+20>>2];s[f+8>>2]=j;s[f+4>>2]=q;s[f>>2]=n;l=p[h+24|0];t=l<<1;m[f+16|0]=t&8|(t&4|(l&1|p[f+16|0]&240));x=o[h+36>>2];t=o[h+32>>2];l=o[h+28>>2];o[f+24>>2]=0;o[f+28>>2]=t;o[f+32>>2]=x;o[f+20>>2]=l;i=g;}d:{if(!$){break d}qb(a,b,e,c,h+8|0);n=s[h+8>>2];g=v(n-s[a>>2]);k=v(g*g);q=s[h+12>>2];g=v(q-s[a+4>>2]);k=v(k+v(g*g));j=s[h+16>>2];g=v(j-s[a+8>>2]);g=v(k+v(g*g));if(!(g<i)){break d}o[f+12>>2]=o[h+20>>2];s[f+8>>2]=j;s[f+4>>2]=q;s[f>>2]=n;b=p[h+24|0];m[f+16|0]=b&1|p[f+16|0]&240|b>>>1&2|b<<2&8;l=o[h+36>>2];b=o[h+28>>2];o[f+32>>2]=o[h+32>>2];o[f+28>>2]=0;o[f+24>>2]=l;o[f+20>>2]=b;i=g;}if(!_){x=1;break a}qb(a,c,e,d,h+8|0);x=1;n=s[h+8>>2];g=v(n-s[a>>2]);k=v(g*g);q=s[h+12>>2];g=v(q-s[a+4>>2]);k=v(k+v(g*g));j=s[h+16>>2];g=v(j-s[a+8>>2]);if(!(v(k+v(g*g))<i)){break a}o[f+12>>2]=o[h+20>>2];s[f+8>>2]=j;s[f+4>>2]=q;s[f>>2]=n;a=p[h+24|0];m[f+16|0]=a&4|p[f+16|0]&240|a<<1&2|a<<2&8;b=o[h+36>>2];a=o[h+28>>2];o[f+32>>2]=o[h+32>>2];o[f+28>>2]=b;o[f+24>>2]=a;o[f+20>>2]=0;}K=h+48|0;return x}function Ne(a,b,c,d){var e=0,f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=0,G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=0,O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0),Z=v(0),_=0,$=0,aa=v(0),ba=v(0),ca=v(0),da=v(0),ea=v(0),fa=v(0);e=K-240|0;K=e;a:{if(o[a+16>>2]){Pb(o[a+4>>2]);f=o[a+12>>2];F=o[f+4>>2];N=o[a+16>>2];_=f;$=o[N+4>>2];G=v(l[o[o[f>>2]+48>>2]](f));f=o[a+16>>2];a=Hl(e+160|0,_,N,F,$,G,v(l[o[o[f>>2]+48>>2]](f)),o[a+4>>2],o[a+8>>2]);o[e+152>>2]=1566444395;f=o[b+12>>2];o[e+32>>2]=o[b+8>>2];o[e+36>>2]=f;f=o[b+4>>2];o[e+24>>2]=o[b>>2];o[e+28>>2]=f;f=o[b+28>>2];o[e+48>>2]=o[b+24>>2];o[e+52>>2]=f;f=o[b+20>>2];o[e+40>>2]=o[b+16>>2];o[e+44>>2]=f;F=o[b+44>>2];f=e- -64|0;o[f>>2]=o[b+40>>2];o[f+4>>2]=F;f=o[b+36>>2];o[e+56>>2]=o[b+32>>2];o[e+60>>2]=f;f=o[b+60>>2];o[e+80>>2]=o[b+56>>2];o[e+84>>2]=f;f=o[b+52>>2];o[e+72>>2]=o[b+48>>2];o[e+76>>2]=f;b=o[c+12>>2];o[e+96>>2]=o[c+8>>2];o[e+100>>2]=b;b=o[c+4>>2];o[e+88>>2]=o[c>>2];o[e+92>>2]=b;b=o[c+20>>2];o[e+104>>2]=o[c+16>>2];o[e+108>>2]=b;b=o[c+28>>2];o[e+112>>2]=o[c+24>>2];o[e+116>>2]=b;b=o[c+44>>2];o[e+128>>2]=o[c+40>>2];o[e+132>>2]=b;b=o[c+36>>2];o[e+120>>2]=o[c+32>>2];o[e+124>>2]=b;b=o[c+52>>2];o[e+136>>2]=o[c+48>>2];o[e+140>>2]=b;b=o[c+60>>2];o[e+144>>2]=o[c+56>>2];o[e+148>>2]=b;Ha(a,e+24|0,d,0);break a}aa=s[c+52>>2];H=s[c+56>>2];I=s[b+52>>2];J=s[b+56>>2];j=s[b+20>>2];k=s[b+36>>2];i=s[c+20>>2];m=s[c+36>>2];g=s[c+24>>2];n=s[b+24>>2];h=s[c+40>>2];t=s[b+40>>2];L=s[c+48>>2];M=s[b+48>>2];f=o[a+12>>2];u=s[b+32>>2];w=s[b>>2];x=s[b+16>>2];y=s[b+4>>2];q=s[c+32>>2];p=s[c+16>>2];C=s[c>>2];D=s[c+4>>2];E=s[c+8>>2];z=s[b+8>>2];a=o[a+20>>2];r=s[a+56>>2];A=s[a+60>>2];B=s[a+52>>2];o[e+172>>2]=0;O=v(v(v(z*D)+v(n*i))+v(t*m));r=v(-r);P=v(v(v(z*C)+v(n*p))+v(t*q));Q=v(v(v(z*E)+v(n*g))+v(t*h));s[e+168>>2]=v(v(O*r)-v(B*P))-v(A*Q);R=v(v(v(y*D)+v(j*i))+v(k*m));S=v(v(v(y*C)+v(j*p))+v(k*q));T=v(v(v(y*E)+v(j*g))+v(k*h));s[e+164>>2]=v(v(R*r)-v(B*S))-v(A*T);U=v(v(v(w*D)+v(x*i))+v(u*m));V=v(v(v(w*C)+v(x*p))+v(u*q));W=v(v(v(w*E)+v(x*g))+v(u*h));s[e+160>>2]=v(v(U*r)-v(B*V))-v(A*W);l[o[o[f>>2]+64>>2]](e+24|0,f,e+160|0);j=s[a+56>>2];k=s[a+60>>2];ba=s[a+68>>2];n=s[a+52>>2];t=s[e+24>>2];u=s[e+28>>2];w=s[e+32>>2];ca=s[c+52>>2];x=s[c+24>>2];y=s[c+20>>2];da=s[c+56>>2];z=s[c+40>>2];A=s[c+36>>2];ea=s[c+48>>2];B=s[c+8>>2];r=s[c>>2];X=s[c+4>>2];Y=s[c+16>>2];Z=s[c+32>>2];o[e+172>>2]=0;fa=v(v(v(M*C)+v(I*p))+v(J*q));G=p;p=v(-aa);q=v(v(fa+v(v(v(G*p)-v(C*L))-v(q*H)))+v(v(v(V*t)+v(S*u))+v(P*w)));h=v(v(v(v(v(M*E)+v(I*g))+v(J*h))+v(v(v(g*p)-v(E*L))-v(h*H)))+v(v(v(W*t)+v(T*u))+v(Q*w)));g=v(v(v(v(v(M*D)+v(I*i))+v(J*m))+v(v(v(i*p)-v(D*L))-v(m*H)))+v(v(v(U*t)+v(R*u))+v(O*w)));i=v(v(v(k*h)+v(v(n*q)+v(j*g)))-ba);m=v(q-v(n*i));g=v(g-v(j*i));h=v(h-v(k*i));s[e+168>>2]=da+v(v(v(Z*m)+v(A*g))+v(z*h));s[e+164>>2]=ca+v(v(v(m*Y)+v(g*y))+v(h*x));s[e+160>>2]=ea+v(v(B*h)+v(v(r*m)+v(X*g)));o[e+20>>2]=0;s[e+16>>2]=v(v(n*Z)+v(j*A))+v(k*z);s[e+12>>2]=v(v(n*Y)+v(j*y))+v(k*x);s[e+8>>2]=v(v(r*n)+v(X*j))+v(B*k);l[o[o[d>>2]+16>>2]](d,e+8|0,e+160|0,i);}K=e+240|0;}function Ma(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0),f=v(0),g=0,h=v(0),i=v(0),j=v(0),k=0,m=v(0),n=0,p=v(0),q=0,r=v(0),t=0;d=K-48|0;K=d;a:{b:{g=o[b+4>>2];if(g>>>0>13){break b}c:{switch(g-1|0){case 7:o[a>>2]=0;o[a+4>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;break a;default:m=s[b+36>>2];i=s[b+40>>2];h=s[c+4>>2];f=s[c+8>>2];j=s[b+32>>2];e=s[c>>2];o[a+12>>2]=0;s[a>>2]=e>=v(0)?j:v(-j);s[a+8>>2]=f>=v(0)?i:v(-i);s[a+4>>2]=h>=v(0)?m:v(-m);break a;case 0:i=s[c>>2];j=s[c+4>>2];e=s[c+8>>2];h=v(v(v(i*s[b+76>>2])+v(j*s[b+80>>2]))+v(e*s[b+84>>2]));f=v(v(v(i*s[b+92>>2])+v(j*s[b+96>>2]))+v(e*s[b+100>>2]));e=v(v(v(i*s[b+60>>2])+v(j*s[b- -64>>2]))+v(e*s[b+68>>2]));b=(b+60|0)+((e<h?h<f?2:1:(e<f)<<1)<<4)|0;g=o[b+4>>2];c=o[b>>2];b=o[b+8>>2];o[a+12>>2]=0;o[a+8>>2]=b;o[a>>2]=c;o[a+4>>2]=g;break a;case 12:g=o[b+44>>2];o[d+40>>2]=o[b+40>>2];o[d+44>>2]=g;g=o[b+36>>2];o[d+32>>2]=o[b+32>>2];o[d+36>>2]=g;o[d+16>>2]=o[c>>2];f=s[c+4>>2];o[d+20>>2]=o[c+4>>2];e=s[c+8>>2];c=o[c+8>>2];o[d+28>>2]=0;o[d+24>>2]=c;g=2;k=o[b+56>>2];b=k+ -1|0;c=1;d:{if(b>>>0>1){break d}if(b-1){q=1;c=0;break d}e=f;q=2;g=1;c=0;}b=g;i=s[(d+32|0)+(k<<2)>>2];g=c<<2;j=s[(g|d+32)>>2];h=s[(g|d+16)>>2];f=v(C(v(v(h*h)+v(e*e))));e:{if(f!=v(0)){f=v(j/f);s[(c<<2|d)>>2]=h*f;c=q<<2;s[c+d>>2]=s[c+(d+16|0)>>2]<v(0)?v(-i):i;s[(b<<2)+d>>2]=e*f;c=d|4;b=d+8|0;break e}s[(c<<2|d)>>2]=j;c=q<<2;s[c+d>>2]=s[c+(d+16|0)>>2]<v(0)?v(-i):i;o[(b<<2)+d>>2]=0;c=d|4;b=d+8|0;}o[a>>2]=o[d>>2];o[a+4>>2]=o[c>>2];b=o[b>>2];o[a+12>>2]=0;o[a+8>>2]=b;break a;case 9:g=b;t=o[b+56>>2];b=t<<2;i=s[(g+b|0)+32>>2];j=s[c>>2];h=s[c+4>>2];f=s[c+8>>2];e=v(v(v(j*j)+v(h*h))+v(f*f));f:{if(e<v(1.4210854715202004e-14)){h=v(1);break f}e=v(v(1)/v(C(e)));m=v(f*e);p=v(h*e);h=v(j*e);}o[d+40>>2]=0;o[d+44>>2]=0;o[d+32>>2]=0;o[d+36>>2]=0;s[b+(d+32|0)>>2]=i;e=v(-0xde0b6b000000000);c=0;k=o[d+32>>2];g=o[d+36>>2];b=o[d+40>>2];f=v(v(v(h*s[d+32>>2])+v(p*s[d+36>>2]))+v(m*s[d+40>>2]));if(!!(f>v(-0xde0b6b000000000))){q=b;n=g;e=f;c=k;}o[d+40>>2]=0;o[d+44>>2]=0;o[d+32>>2]=0;o[d+36>>2]=0;s[(d+32|0)+(t<<2)>>2]=-i;k=o[d+40>>2];i=s[d+40>>2];g=o[d+32>>2];j=s[d+32>>2];b=o[d+36>>2];f=s[d+36>>2];o[a+12>>2]=0;t=k;k=v(v(v(h*j)+v(p*f))+v(m*i))>e;o[a+8>>2]=k?t:q;o[a+4>>2]=k?b:n;o[a>>2]=k?g:c;break a;case 4:r=s[b+16>>2];p=s[b+24>>2];m=s[b+20>>2];k=o[b+96>>2];n=-1;g=o[b+100>>2];if((g|0)>=1){i=v(s[c>>2]*r);j=v(s[c+8>>2]*p);h=v(s[c+4>>2]*m);b=0;e=v(-3.4028234663852886e+38);while(1){c=k+(b<<4)|0;f=v(v(v(i*s[c>>2])+v(h*s[c+4>>2]))+v(j*s[c+8>>2]));c=f>e;e=c?f:e;n=c?b:n;b=b+1|0;if((g|0)!=(b|0)){continue}break}}b=k+(n<<4)|0;h=s[b>>2];f=s[b+4>>2];e=s[b+8>>2];o[a+12>>2]=0;s[a+8>>2]=p*e;s[a+4>>2]=m*f;s[a>>2]=r*h;break a;case 1:case 2:case 5:case 6:case 8:case 10:case 11:break b;case 3:break c}}r=s[b+16>>2];p=s[b+24>>2];m=s[b+20>>2];k=o[b+108>>2];n=-1;g=o[b+100>>2];if((g|0)>=1){i=v(s[c>>2]*r);j=v(s[c+8>>2]*p);h=v(s[c+4>>2]*m);b=0;e=v(-3.4028234663852886e+38);while(1){c=k+(b<<4)|0;f=v(v(v(i*s[c>>2])+v(h*s[c+4>>2]))+v(j*s[c+8>>2]));c=f>e;e=c?f:e;n=c?b:n;b=b+1|0;if((g|0)!=(b|0)){continue}break}}b=k+(n<<4)|0;h=s[b>>2];f=s[b+4>>2];e=s[b+8>>2];o[a+12>>2]=0;s[a+8>>2]=p*e;s[a+4>>2]=m*f;s[a>>2]=r*h;break a}l[o[o[b>>2]+68>>2]](a,b,c);}K=d+48|0;}function al(a,b,c,d,e){var f=v(0),g=v(0),h=0,i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),q=v(0),r=v(0),t=v(0),u=0,w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=0,S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0),Z=v(0),_=v(0),$=v(0),aa=v(0),ba=v(0),ca=v(0),da=0,ea=v(0),fa=v(0);h=K-48|0;K=h;da=p[a+16|0];R=da?c:d;u=o[R+12>>2];Z=s[u+56>>2];S=s[u+52>>2];_=s[u+48>>2];d=da?d:c;c=o[d+12>>2];$=s[c+56>>2];aa=s[c+52>>2];ba=s[c+48>>2];d=o[d+4>>2];r=s[u+40>>2];j=s[u+8>>2];k=s[u+24>>2];m=s[u+36>>2];w=s[u+4>>2];z=s[u+20>>2];x=s[u+32>>2];C=s[c+40>>2];D=s[c+32>>2];E=s[c+36>>2];A=s[u>>2];F=s[c+8>>2];G=s[c>>2];H=s[c+4>>2];B=s[u+16>>2];L=s[c+24>>2];M=s[c+16>>2];N=s[c+20>>2];i=s[b+12>>2];q=s[b+8>>2];f=s[b>>2];g=s[b+4>>2];c=o[R+4>>2];O=s[c+60>>2];ca=s[c+56>>2];P=s[c+52>>2];o[h+28>>2]=0;t=v(v(2)/v(v(v(v(f*f)+v(g*g))+v(q*q))+v(i*i)));n=v(q*t);T=v(f*n);I=v(g*t);U=v(i*I);J=v(T+U);V=v(g*n);y=v(f*t);W=v(i*y);t=v(V-W);X=v(f*y);Y=v(g*I);g=v(v(1)-v(X+Y));y=v(v(v(D*J)+v(E*t))+v(C*g));Q=v(v(v(G*J)+v(H*t))+v(F*g));g=v(v(v(M*J)+v(N*t))+v(L*g));t=v(-ca);s[h+24>>2]=v(v(v(v(m*y)+v(v(w*Q)+v(z*g)))*t)-v(P*v(v(x*y)+v(v(A*Q)+v(B*g)))))-v(O*v(v(r*y)+v(v(j*Q)+v(k*g))));g=v(V+W);I=v(f*I);J=v(i*n);f=v(I-J);y=v(q*n);i=v(v(1)-v(X+y));q=v(v(C*g)+v(v(D*f)+v(E*i)));n=v(v(F*g)+v(v(G*f)+v(H*i)));f=v(v(L*g)+v(v(M*f)+v(N*i)));s[h+20>>2]=v(v(v(v(m*q)+v(v(w*n)+v(z*f)))*t)-v(P*v(v(x*q)+v(v(A*n)+v(B*f)))))-v(O*v(v(r*q)+v(v(j*n)+v(k*f))));f=v(T-U);i=v(I+J);g=v(v(1)-v(Y+y));q=v(v(C*f)+v(v(E*i)+v(D*g)));n=v(v(F*f)+v(v(H*i)+v(G*g)));f=v(v(L*f)+v(v(N*i)+v(M*g)));s[h+16>>2]=v(v(v(v(m*q)+v(v(w*n)+v(z*f)))*t)-v(P*v(v(x*q)+v(v(A*n)+v(B*f)))))-v(O*v(v(r*q)+v(v(j*n)+v(k*f))));l[o[o[d>>2]+64>>2]](h+32|0,d,h+16|0);b=o[R+12>>2];t=s[b+48>>2];I=s[b+32>>2];J=s[b+16>>2];y=s[b+8>>2];Q=s[b+4>>2];ca=s[b>>2];T=s[b+56>>2];U=s[b+52>>2];V=s[b+40>>2];W=s[b+36>>2];X=s[b+24>>2];Y=s[b+20>>2];ea=s[c+68>>2];q=s[c+60>>2];O=s[c+52>>2];P=s[c+56>>2];f=s[h+40>>2];i=s[h+32>>2];g=s[h+36>>2];fa=s[o[a+12>>2]+848>>2];o[e+4>>2]=o[a+12>>2];n=v(-S);S=v(v(v(v(v(ba*j)+v(aa*k))+v($*r))+v(v(v(k*n)-v(j*_))-v(r*Z)))+v(v(v(i*v(v(v(G*j)+v(M*k))+v(D*r)))+v(g*v(v(v(H*j)+v(N*k))+v(E*r))))+v(f*v(v(v(F*j)+v(L*k))+v(C*r)))));x=v(v(v(v(v(ba*A)+v(aa*B))+v($*x))+v(v(v(B*n)-v(A*_))-v(x*Z)))+v(v(v(i*v(v(v(G*A)+v(M*B))+v(D*x)))+v(g*v(v(v(H*A)+v(N*B))+v(E*x))))+v(f*v(v(v(F*A)+v(L*B))+v(C*x)))));w=v(v(v(v(v(ba*w)+v(aa*z))+v($*m))+v(v(v(z*n)-v(w*_))-v(m*Z)))+v(v(v(i*v(v(v(G*w)+v(M*z))+v(D*m)))+v(g*v(v(v(H*w)+v(N*z))+v(E*m))))+v(f*v(v(v(F*w)+v(L*z))+v(C*m)))));r=v(v(v(q*S)+v(v(O*x)+v(P*w)))-ea);if(!!(r<fa)){a=o[R+12>>2];z=s[a+24>>2];A=s[a+20>>2];B=s[a+40>>2];C=s[a+36>>2];D=s[a+16>>2];E=s[a+32>>2];j=s[c+60>>2];F=s[a+8>>2];k=s[c+52>>2];G=s[a>>2];m=s[c+56>>2];H=s[a+4>>2];o[h+28>>2]=0;s[h+16>>2]=v(v(G*k)+v(H*m))+v(F*j);s[h+24>>2]=v(v(k*E)+v(m*C))+v(j*B);s[h+20>>2]=v(v(k*D)+v(m*A))+v(j*z);o[h+12>>2]=0;j=v(x-v(O*r));k=v(w-v(P*r));m=v(S-v(q*r));s[h+8>>2]=v(v(v(j*I)+v(k*W))+v(m*V))+T;s[h+4>>2]=v(v(v(j*J)+v(k*Y))+v(m*X))+U;s[h>>2]=v(v(y*m)+v(v(ca*j)+v(Q*k)))+t;l[o[o[e>>2]+16>>2]](e,h+16|0,h,r);}K=h+48|0;}function Ou(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=v(0),m=v(0),n=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=0,A=v(0),B=v(0),C=v(0),D=0;e=K-96|0;o[e+24>>2]=0;o[e+28>>2]=0;o[e+16>>2]=0;o[e+20>>2]=0;f=(c|0)<=(b|0);if(!f){z=p[a+60|0];k=b;while(1){a:{if(z){h=o[a+116>>2]+(k<<4)|0;u=s[a+44>>2];m=s[a+12>>2];n=v(v(v(q[h+4>>1])/u)+m);r=s[a+40>>2];A=s[a+8>>2];l=v(v(v(q[h+2>>1])/r)+A);B=s[a+36>>2];C=s[a+4>>2];t=v(v(v(q[h>>1])/B)+C);u=v(v(v(q[h+10>>1])/u)+m);m=v(v(v(q[h+8>>1])/r)+A);r=v(v(v(q[h+6>>1])/B)+C);break a}h=o[a+76>>2]+(k<<6)|0;n=s[h+8>>2];l=s[h+4>>2];t=s[h>>2];u=s[h+24>>2];m=s[h+20>>2];r=s[h+16>>2];}w=v(v(v(u+n)*v(.5))+w);x=v(v(v(m+l)*v(.5))+x);y=v(v(v(r+t)*v(.5))+y);k=k+1|0;if((k|0)!=(c|0)){continue}break}s[e+24>>2]=w;s[e+20>>2]=x;s[e+16>>2]=y;}z=c-b|0;l=v(v(1)/v(z|0));s[e+24>>2]=l*w;s[e+20>>2]=l*x;s[e+16>>2]=l*y;h=b;if(!f){d=d<<2;u=s[d+(e+16|0)>>2];D=d+e|0;k=b;h=k;while(1){f=p[a+60|0];b:{if(f){d=o[a+116>>2]+(k<<4)|0;l=s[a+44>>2];t=s[a+12>>2];w=v(v(v(q[d+4>>1])/l)+t);n=s[a+40>>2];m=s[a+8>>2];x=v(v(v(q[d+2>>1])/n)+m);r=s[a+36>>2];A=s[a+4>>2];y=v(v(v(q[d>>1])/r)+A);l=v(v(v(q[d+10>>1])/l)+t);t=v(v(v(q[d+8>>1])/n)+m);n=v(v(v(q[d+6>>1])/r)+A);break b}d=o[a+76>>2]+(k<<6)|0;w=s[d+8>>2];x=s[d+4>>2];y=s[d>>2];l=s[d+24>>2];t=s[d+20>>2];n=s[d+16>>2];}o[e+12>>2]=0;s[e+8>>2]=v(l+w)*v(.5);s[e+4>>2]=v(t+x)*v(.5);s[e>>2]=v(n+y)*v(.5);if(!!(s[D>>2]>u)){c:{if(f){j=o[a+116>>2];f=j+(k<<4)|0;d=f;g=d+8|0;i=o[g+4>>2];o[e+40>>2]=o[g>>2];o[e+44>>2]=i;g=o[d+4>>2];o[e+32>>2]=o[d>>2];o[e+36>>2]=g;f=j;j=h<<4;f=f+j|0;g=o[f+4>>2];o[d>>2]=o[f>>2];o[d+4>>2]=g;g=o[f+12>>2];o[d+8>>2]=o[f+8>>2];o[d+12>>2]=g;d=j+o[a+116>>2]|0;j=o[e+36>>2];o[d>>2]=o[e+32>>2];o[d+4>>2]=j;f=o[e+44>>2];o[d+8>>2]=o[e+40>>2];o[d+12>>2]=f;break c}f=o[a+76>>2];d=f+(k<<6)|0;j=d+56|0;g=o[j+4>>2];o[e+88>>2]=o[j>>2];o[e+92>>2]=g;j=o[d+52>>2];o[e+80>>2]=o[d+48>>2];o[e+84>>2]=j;j=o[d+44>>2];o[e+72>>2]=o[d+40>>2];o[e+76>>2]=j;i=o[d+36>>2];j=e- -64|0;g=j;o[g>>2]=o[d+32>>2];o[g+4>>2]=i;g=o[d+28>>2];o[e+56>>2]=o[d+24>>2];o[e+60>>2]=g;g=o[d+20>>2];o[e+48>>2]=o[d+16>>2];o[e+52>>2]=g;g=o[d+12>>2];o[e+40>>2]=o[d+8>>2];o[e+44>>2]=g;g=o[d+4>>2];o[e+32>>2]=o[d>>2];o[e+36>>2]=g;g=h<<6;f=f+g|0;i=o[f+4>>2];o[d>>2]=o[f>>2];o[d+4>>2]=i;i=o[f+12>>2];o[d+8>>2]=o[f+8>>2];o[d+12>>2]=i;i=o[f+20>>2];o[d+16>>2]=o[f+16>>2];o[d+20>>2]=i;i=o[f+28>>2];o[d+24>>2]=o[f+24>>2];o[d+28>>2]=i;i=o[f+36>>2];o[d+32>>2]=o[f+32>>2];o[d+36>>2]=i;i=o[f+44>>2];o[d+40>>2]=o[f+40>>2];o[d+44>>2]=i;i=o[f+52>>2];o[d+48>>2]=o[f+48>>2];o[d+52>>2]=i;i=o[f+60>>2];o[d+56>>2]=o[f+56>>2];o[d+60>>2]=i;d=o[a+76>>2]+g|0;g=o[e+36>>2];o[d>>2]=o[e+32>>2];o[d+4>>2]=g;f=o[e+44>>2];o[d+8>>2]=o[e+40>>2];o[d+12>>2]=f;f=o[e+52>>2];o[d+16>>2]=o[e+48>>2];o[d+20>>2]=f;f=o[e+60>>2];o[d+24>>2]=o[e+56>>2];o[d+28>>2]=f;f=o[j+4>>2];o[d+32>>2]=o[j>>2];o[d+36>>2]=f;f=o[e+76>>2];o[d+40>>2]=o[e+72>>2];o[d+44>>2]=f;f=o[e+84>>2];o[d+48>>2]=o[e+80>>2];o[d+52>>2]=f;f=o[e+92>>2];o[d+56>>2]=o[e+88>>2];o[d+60>>2]=f;}h=h+1|0;}k=k+1|0;if((k|0)!=(c|0)){continue}break}}a=(z>>1)+b|0;d=a;a=(z|0)/3|0;return (h|0)<=(a+b|0)?d:(h|0)>=((a^-1)+c|0)?d:h}function Ie(a){a=a|0;var b=0,c=0,d=0,e=v(0),f=0,g=0,h=0,i=v(0),j=0,k=0,n=0,q=0,r=v(0),t=v(0),w=v(0),x=v(0);b=K-192|0;K=b;a:{if(!l[o[o[a>>2]+20>>2]](a)){break a}c=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[c>>2]+100>>2]](c);c=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[c>>2]+8>>2]](b+80|0,c);c=l[o[o[a>>2]+20>>2]](a)|0;b:{if(!(l[o[o[c>>2]+56>>2]](c)&8)){break b}c=o[a+24>>2];if(!c){break b}j=l[o[o[c>>2]+36>>2]](c)|0;if((j|0)<1){break b}q=b+176|0;c=0;while(1){g=0;h=o[a+24>>2];k=l[o[o[h>>2]+40>>2]](h,c)|0;n=o[k+844>>2];if((n|0)>0){while(1){f=l[o[o[a>>2]+20>>2]](a)|0;h=k+u(g,208)|0;l[o[o[f>>2]+40>>2]](f,h+36|0,h+68|0,s[h+84>>2],o[h+168>>2],q);g=g+1|0;if((n|0)!=(g|0)){continue}break}}c=c+1|0;if((j|0)!=(c|0)){continue}break}}c=l[o[o[a>>2]+20>>2]](a)|0;if(!(l[o[o[c>>2]+56>>2]](c)&3)|o[a+8>>2]<1){break a}h=b+160|0;j=b+96|0;q=b+112|0;k=b+128|0;n=b+144|0;g=0;while(1){f=o[o[a+16>>2]+(g<<2)>>2];c:{if(p[f+204|0]&32){break c}d:{if(!l[o[o[a>>2]+20>>2]](a)){break d}c=l[o[o[a>>2]+20>>2]](a)|0;if(!(l[o[o[c>>2]+56>>2]](c)&1)){break d}o[b+72>>2]=1053609165;o[b+76>>2]=0;o[b+64>>2]=1053609165;o[b+68>>2]=1053609165;c=o[f+220>>2]+ -1|0;e:{if(c>>>0<=4){f:{switch(c-1|0){default:c=o[b+92>>2];o[b+72>>2]=o[b+88>>2];o[b+76>>2]=c;c=o[b+84>>2];o[b+64>>2]=o[b+80>>2];o[b+68>>2]=c;break e;case 0:c=j;d=o[c+12>>2];o[b+72>>2]=o[c+8>>2];o[b+76>>2]=d;d=o[c+4>>2];o[b+64>>2]=o[c>>2];o[b+68>>2]=d;break e;case 1:c=q;d=o[c+12>>2];o[b+72>>2]=o[c+8>>2];o[b+76>>2]=d;d=o[c+4>>2];o[b+64>>2]=o[c>>2];o[b+68>>2]=d;break e;case 2:c=k;d=o[c+12>>2];o[b+72>>2]=o[c+8>>2];o[b+76>>2]=d;d=o[c+4>>2];o[b+64>>2]=o[c>>2];o[b+68>>2]=d;break e;case 3:break f}}c=n;d=o[c+12>>2];o[b+72>>2]=o[c+8>>2];o[b+76>>2]=d;d=o[c+4>>2];o[b+64>>2]=o[c>>2];o[b+68>>2]=d;break e}o[b+72>>2]=1050253722;o[b+76>>2]=0;o[b+64>>2]=1050253722;o[b+68>>2]=1050253722;}if(m[f+205|0]&1){c=o[f+320>>2];o[b+72>>2]=o[f+316>>2];o[b+76>>2]=c;c=o[f+312>>2];o[b+64>>2]=o[f+308>>2];o[b+68>>2]=c;}l[o[o[a>>2]+28>>2]](a,f+4|0,o[f+192>>2],b- -64|0);}c=o[a+72>>2];if(!c){break c}if(!(l[o[o[c>>2]+56>>2]](c)&2)){break c}c=h;d=o[c+12>>2];o[b+40>>2]=o[c+8>>2];o[b+44>>2]=d;d=o[c+4>>2];o[b+32>>2]=o[c>>2];o[b+36>>2]=d;c=o[f+192>>2];l[o[o[c>>2]+8>>2]](c,f+4|0,b- -64|0,b+48|0);e=s[4962];s[b+64>>2]=s[b+64>>2]-e;s[b+68>>2]=s[b+68>>2]-e;s[b+72>>2]=s[b+72>>2]-e;s[b+48>>2]=e+s[b+48>>2];s[b+52>>2]=e+s[b+52>>2];s[b+56>>2]=e+s[b+56>>2];g:{if(p[f+204|0]&3|(!p[a+44|0]|o[f+252>>2]!=2)){break g}c=o[f+192>>2];l[o[o[c>>2]+8>>2]](c,f+68|0,b+16|0,b);i=v(s[b+16>>2]-e);s[b+16>>2]=i;r=v(s[b+20>>2]-e);s[b+20>>2]=r;t=v(s[b+24>>2]-e);s[b+24>>2]=t;w=v(e+s[b>>2]);s[b>>2]=w;x=v(e+s[b+4>>2]);s[b+4>>2]=x;e=v(e+s[b+8>>2]);s[b+8>>2]=e;if(!!(i<s[b+64>>2])){s[b+64>>2]=i;}if(!!(r<s[b+68>>2])){s[b+68>>2]=r;}if(!!(t<s[b+72>>2])){s[b+72>>2]=t;}i=s[b+28>>2];if(!!(i<s[b+76>>2])){s[b+76>>2]=i;}if(!!(s[b+48>>2]<w)){s[b+48>>2]=w;}if(!!(s[b+52>>2]<x)){s[b+52>>2]=x;}if(!!(s[b+56>>2]<e)){s[b+56>>2]=e;}e=s[b+12>>2];if(!(s[b+60>>2]<e)){break g}s[b+60>>2]=e;}c=o[a+72>>2];l[o[o[c>>2]+60>>2]](c,b- -64|0,b+48|0,b+32|0);}g=g+1|0;if((g|0)<o[a+8>>2]){continue}break}}K=b+192|0;}function aa(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0;a:{if(!a){break a}d=a+ -8|0;c=o[a+ -4>>2];a=c&-8;f=d+a|0;b:{if(c&1){break b}if(!(c&3)){break a}c=o[d>>2];d=d-c|0;if(d>>>0<r[6265]){break a}a=a+c|0;if(o[6266]!=(d|0)){if(c>>>0<=255){e=o[d+8>>2];c=c>>>3|0;b=o[d+12>>2];if((b|0)==(e|0)){o[6261]=o[6261]&Rw(c);break b}o[e+12>>2]=b;o[b+8>>2]=e;break b}h=o[d+24>>2];c=o[d+12>>2];c:{if((d|0)!=(c|0)){b=o[d+8>>2];o[b+12>>2]=c;o[c+8>>2]=b;break c}d:{e=d+20|0;b=o[e>>2];if(b){break d}e=d+16|0;b=o[e>>2];if(b){break d}c=0;break c}while(1){g=e;c=b;e=c+20|0;b=o[e>>2];if(b){continue}e=c+16|0;b=o[c+16>>2];if(b){continue}break}o[g>>2]=0;}if(!h){break b}e=o[d+28>>2];b=(e<<2)+25348|0;e:{if(o[b>>2]==(d|0)){o[b>>2]=c;if(c){break e}o[6262]=o[6262]&Rw(e);break b}o[h+(o[h+16>>2]==(d|0)?16:20)>>2]=c;if(!c){break b}}o[c+24>>2]=h;b=o[d+16>>2];if(b){o[c+16>>2]=b;o[b+24>>2]=c;}b=o[d+20>>2];if(!b){break b}o[c+20>>2]=b;o[b+24>>2]=c;break b}c=o[f+4>>2];if((c&3)!=3){break b}o[6263]=a;o[f+4>>2]=c&-2;o[d+4>>2]=a|1;o[a+d>>2]=a;return}if(f>>>0<=d>>>0){break a}c=o[f+4>>2];if(!(c&1)){break a}f:{if(!(c&2)){if(o[6267]==(f|0)){o[6267]=d;a=o[6264]+a|0;o[6264]=a;o[d+4>>2]=a|1;if(o[6266]!=(d|0)){break a}o[6263]=0;o[6266]=0;return}if(o[6266]==(f|0)){o[6266]=d;a=o[6263]+a|0;o[6263]=a;o[d+4>>2]=a|1;o[a+d>>2]=a;return}a=(c&-8)+a|0;g:{if(c>>>0<=255){b=o[f+8>>2];c=c>>>3|0;e=o[f+12>>2];if((b|0)==(e|0)){o[6261]=o[6261]&Rw(c);break g}o[b+12>>2]=e;o[e+8>>2]=b;break g}h=o[f+24>>2];c=o[f+12>>2];h:{if((f|0)!=(c|0)){b=o[f+8>>2];o[b+12>>2]=c;o[c+8>>2]=b;break h}i:{e=f+20|0;b=o[e>>2];if(b){break i}e=f+16|0;b=o[e>>2];if(b){break i}c=0;break h}while(1){g=e;c=b;e=c+20|0;b=o[e>>2];if(b){continue}e=c+16|0;b=o[c+16>>2];if(b){continue}break}o[g>>2]=0;}if(!h){break g}e=o[f+28>>2];b=(e<<2)+25348|0;j:{if(o[b>>2]==(f|0)){o[b>>2]=c;if(c){break j}o[6262]=o[6262]&Rw(e);break g}o[h+(o[h+16>>2]==(f|0)?16:20)>>2]=c;if(!c){break g}}o[c+24>>2]=h;b=o[f+16>>2];if(b){o[c+16>>2]=b;o[b+24>>2]=c;}b=o[f+20>>2];if(!b){break g}o[c+20>>2]=b;o[b+24>>2]=c;}o[d+4>>2]=a|1;o[a+d>>2]=a;if(o[6266]!=(d|0)){break f}o[6263]=a;return}o[f+4>>2]=c&-2;o[d+4>>2]=a|1;o[a+d>>2]=a;}if(a>>>0<=255){a=a>>>3|0;c=(a<<3)+25084|0;b=o[6261];a=1<<a;k:{if(!(b&a)){o[6261]=a|b;a=c;break k}a=o[c+8>>2];}o[c+8>>2]=d;o[a+12>>2]=d;o[d+12>>2]=c;o[d+8>>2]=a;return}o[d+16>>2]=0;o[d+20>>2]=0;f=d;e=a>>>8|0;b=0;l:{if(!e){break l}b=31;if(a>>>0>16777215){break l}c=e;e=e+1048320>>>16&8;b=c<<e;h=b+520192>>>16&4;b=b<<h;g=b+245760>>>16&2;b=(b<<g>>>15|0)-(g|(e|h))|0;b=(b<<1|a>>>b+21&1)+28|0;}o[f+28>>2]=b;g=(b<<2)+25348|0;m:{n:{e=o[6262];c=1<<b;o:{if(!(e&c)){o[6262]=c|e;o[g>>2]=d;o[d+24>>2]=g;break o}e=a<<((b|0)==31?0:25-(b>>>1|0)|0);c=o[g>>2];while(1){b=c;if((o[c+4>>2]&-8)==(a|0)){break n}c=e>>>29|0;e=e<<1;g=b+(c&4)|0;c=o[g+16>>2];if(c){continue}break}o[g+16>>2]=d;o[d+24>>2]=b;}o[d+12>>2]=d;o[d+8>>2]=d;break m}a=o[b+8>>2];o[a+12>>2]=d;o[b+8>>2]=d;o[d+24>>2]=0;o[d+12>>2]=b;o[d+8>>2]=a;}a=o[6269]+ -1|0;o[6269]=a;if(a){break a}d=25500;while(1){a=o[d>>2];d=a+8|0;if(a){continue}break}o[6269]=-1;}}function Pc(a,b,c,d,e){var f=0,g=0,h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0);f=K-400|0;K=f;l[o[4966]](7901);g=o[c+12>>2];o[f+336>>2]=o[c+8>>2];o[f+340>>2]=g;g=o[c+4>>2];o[f+328>>2]=o[c>>2];o[f+332>>2]=g;g=o[c+28>>2];o[f+352>>2]=o[c+24>>2];o[f+356>>2]=g;g=o[c+20>>2];o[f+344>>2]=o[c+16>>2];o[f+348>>2]=g;g=o[c+44>>2];o[f+368>>2]=o[c+40>>2];o[f+372>>2]=g;g=o[c+36>>2];o[f+360>>2]=o[c+32>>2];o[f+364>>2]=g;g=o[c+60>>2];o[f+384>>2]=o[c+56>>2];o[f+388>>2]=g;g=o[c+52>>2];o[f+376>>2]=o[c+48>>2];o[f+380>>2]=g;g=o[d+12>>2];o[f+272>>2]=o[d+8>>2];o[f+276>>2]=g;g=o[d+4>>2];o[f+264>>2]=o[d>>2];o[f+268>>2]=g;g=o[d+28>>2];o[f+288>>2]=o[d+24>>2];o[f+292>>2]=g;g=o[d+20>>2];o[f+280>>2]=o[d+16>>2];o[f+284>>2]=g;g=o[d+44>>2];o[f+304>>2]=o[d+40>>2];o[f+308>>2]=g;g=o[d+36>>2];o[f+296>>2]=o[d+32>>2];o[f+300>>2]=g;g=o[d+60>>2];o[f+320>>2]=o[d+56>>2];o[f+324>>2]=g;g=o[d+52>>2];o[f+312>>2]=o[d+48>>2];o[f+316>>2]=g;_b(f+328|0,f+264|0,f,f+248|0);o[f+228>>2]=0;h=s[f+248>>2];s[f+224>>2]=h*s[f+8>>2];s[f+220>>2]=h*s[f+4>>2];s[f+216>>2]=h*s[f>>2];o[f+208>>2]=0;o[f+212>>2]=0;o[f+200>>2]=0;o[f+204>>2]=0;o[f+56>>2]=0;o[f+60>>2]=0;o[f+48>>2]=0;o[f+52>>2]=0;fb(f+328|0,f+248|0);o[f+44>>2]=0;o[f+28>>2]=0;h=s[f+248>>2];i=s[f+252>>2];k=s[f+256>>2];n=s[f+260>>2];p=v(v(2)/v(v(v(v(h*h)+v(i*i))+v(k*k))+v(n*n)));q=v(k*p);m=v(i*q);j=v(h*p);r=v(n*j);s[f+36>>2]=m+r;s[f+24>>2]=m-r;m=v(h*j);j=i;i=v(i*p);p=v(j*i);s[f+40>>2]=v(1)-v(m+p);k=v(k*q);s[f+20>>2]=v(1)-v(m+k);o[f+12>>2]=0;m=v(h*q);j=v(n*i);s[f+32>>2]=m-j;h=v(h*i);i=v(n*q);s[f+16>>2]=h+i;s[f+8>>2]=m+j;s[f+4>>2]=h-i;s[f>>2]=v(1)-v(p+k);Kw(b,f,f+200|0,f+216|0,f+248|0,f+232|0);o[f>>2]=9544;g=o[c+12>>2];o[f+44>>2]=o[c+8>>2];o[f+48>>2]=g;g=o[c+4>>2];o[f+36>>2]=o[c>>2];o[f+40>>2]=g;g=o[c+28>>2];o[f+60>>2]=o[c+24>>2];o[f+64>>2]=g;g=o[c+20>>2];o[f+52>>2]=o[c+16>>2];o[f+56>>2]=g;g=o[c+44>>2];o[f+76>>2]=o[c+40>>2];o[f+80>>2]=g;g=o[c+36>>2];o[f+68>>2]=o[c+32>>2];o[f+72>>2]=g;g=o[c+60>>2];o[f+92>>2]=o[c+56>>2];o[f+96>>2]=g;g=o[c+52>>2];o[f+84>>2]=o[c+48>>2];o[f+88>>2]=g;c=o[d+12>>2];o[f+108>>2]=o[d+8>>2];o[f+112>>2]=c;c=o[d+4>>2];o[f+100>>2]=o[d>>2];o[f+104>>2]=c;c=o[d+20>>2];o[f+116>>2]=o[d+16>>2];o[f+120>>2]=c;c=o[d+28>>2];o[f+124>>2]=o[d+24>>2];o[f+128>>2]=c;c=o[d+44>>2];o[f+140>>2]=o[d+40>>2];o[f+144>>2]=c;c=o[d+36>>2];o[f+132>>2]=o[d+32>>2];o[f+136>>2]=c;c=o[d+52>>2];o[f+148>>2]=o[d+48>>2];o[f+152>>2]=c;c=o[d+60>>2];o[f+156>>2]=o[d+56>>2];o[f+160>>2]=c;o[f+184>>2]=e;s[f+188>>2]=0;o[f+192>>2]=b;o[f+180>>2]=a;h=v(s[f+148>>2]-s[f+84>>2]);i=v(s[f+152>>2]-s[f+88>>2]);n=v(s[f+156>>2]-s[f+92>>2]);k=v(v(1)/v(C(v(v(v(h*h)+v(i*i))+v(n*n)))));p=v(n*k);m=p==v(0)?v(0xde0b6b000000000):v(v(1)/p);s[f+12>>2]=m;q=v(i*k);j=q==v(0)?v(0xde0b6b000000000):v(v(1)/q);s[f+8>>2]=j;o[f+28>>2]=m<v(0);o[f+24>>2]=j<v(0);j=h;h=v(h*k);s[f+32>>2]=v(n*p)+v(v(j*h)+v(i*q));h=h==v(0)?v(0xde0b6b000000000):v(v(1)/h);s[f+4>>2]=h;o[f+20>>2]=h<v(0);a=o[a+68>>2];l[o[o[a>>2]+24>>2]](a,f+376|0,f+312|0,f,f+248|0,f+232|0);l[o[4967]]();K=f+400|0;}function Gf(a,b){var c=0,d=0,e=v(0),f=v(0),g=0,h=v(0),i=v(0);d=K-16|0;K=d;o[a+372>>2]=0;o[a+376>>2]=0;o[a+252>>2]=2;o[a+604>>2]=1065353216;o[a+608>>2]=1065353216;o[a+408>>2]=1065353216;o[a+412>>2]=1065353216;o[a+472>>2]=0;o[a+476>>2]=0;o[a+380>>2]=0;o[a+384>>2]=0;o[a+388>>2]=0;o[a+392>>2]=0;o[a+396>>2]=0;o[a+400>>2]=0;o[a+612>>2]=1065353216;o[a+616>>2]=0;o[a+420>>2]=0;o[a+424>>2]=0;o[a+416>>2]=1065353216;o[a+428>>2]=0;o[a+432>>2]=0;o[a+436>>2]=0;o[a+440>>2]=0;o[a+444>>2]=0;o[a+448>>2]=0;o[a+452>>2]=0;o[a+480>>2]=0;o[a+484>>2]=0;o[a+488>>2]=0;o[a+492>>2]=0;o[a+496>>2]=0;o[a+500>>2]=0;e=s[b+96>>2];f=s[b+92>>2];s[d+12>>2]=f;s[d+8>>2]=e;o[d+4>>2]=0;o[d>>2]=1065353216;o[a+504>>2]=o[(f<v(0)?d+4|0:f>v(1)?d:d+12|0)>>2];o[d+4>>2]=0;o[d>>2]=1065353216;o[a+508>>2]=o[(e<v(0)?d+4|0:e>v(1)?d:d+8|0)>>2];o[a+532>>2]=o[b+116>>2];o[a+536>>2]=o[b+120>>2];g=o[b+4>>2];o[a+668>>2]=0;o[a+672>>2]=0;o[a+540>>2]=g;m[a+512|0]=p[b+124|0];o[a+516>>2]=o[b+128>>2];o[a+520>>2]=o[b+132>>2];o[a+524>>2]=o[b+136>>2];o[a+528>>2]=o[b+140>>2];a:{if(g){c=a+4|0;l[o[o[g>>2]+8>>2]](g,c);break a}c=o[b+12>>2];o[a+4>>2]=o[b+8>>2];o[a+8>>2]=c;c=o[b+20>>2];o[a+12>>2]=o[b+16>>2];o[a+16>>2]=c;c=o[b+36>>2];o[a+28>>2]=o[b+32>>2];o[a+32>>2]=c;c=o[b+28>>2];o[a+20>>2]=o[b+24>>2];o[a+24>>2]=c;c=o[b+44>>2];o[a+36>>2]=o[b+40>>2];o[a+40>>2]=c;c=o[b+52>>2];o[a+44>>2]=o[b+48>>2];o[a+48>>2]=c;c=b- -64|0;g=o[c+4>>2];o[a+60>>2]=o[c>>2];o[a+64>>2]=g;c=o[b+60>>2];o[a+52>>2]=o[b+56>>2];o[a+56>>2]=c;c=a+4|0;}g=o[c+4>>2];o[a+68>>2]=o[c>>2];o[a+72>>2]=g;g=o[c+12>>2];o[a+76>>2]=o[c+8>>2];o[a+80>>2]=g;c=o[a+32>>2];o[a+92>>2]=o[a+28>>2];o[a+96>>2]=c;c=o[a+24>>2];o[a+84>>2]=o[a+20>>2];o[a+88>>2]=c;c=o[a+40>>2];o[a+100>>2]=o[a+36>>2];o[a+104>>2]=c;c=o[a+48>>2];o[a+108>>2]=o[a+44>>2];o[a+112>>2]=c;c=o[a+56>>2];o[a+116>>2]=o[a+52>>2];o[a+120>>2]=c;c=o[a+64>>2];o[a+124>>2]=o[a+60>>2];o[a+128>>2]=c;o[a+132>>2]=0;o[a+136>>2]=0;o[a+140>>2]=0;o[a+144>>2]=0;o[a+148>>2]=0;o[a+152>>2]=0;o[a+156>>2]=0;o[a+160>>2]=0;o[a+228>>2]=o[b+100>>2];o[a+236>>2]=o[b+104>>2];o[a+240>>2]=o[b+108>>2];o[a+232>>2]=o[b+112>>2];l[o[o[a>>2]+8>>2]](a,o[b+72>>2]);c=o[5206];o[5206]=c+1;o[a+568>>2]=c;e=v(0);c=o[a+204>>2];f=s[b>>2];b:{if(f==v(0)){o[a+204>>2]=c|1;break b}o[a+204>>2]=c&-2;e=v(v(1)/f);}o[a+436>>2]=0;s[a+404>>2]=e;s[a+432>>2]=f*s[a+448>>2];s[a+428>>2]=f*s[a+444>>2];s[a+424>>2]=f*s[a+440>>2];f=s[b+84>>2];h=s[b+80>>2];i=s[b+76>>2];s[a+620>>2]=e*s[a+408>>2];s[a+624>>2]=e*s[a+412>>2];s[a+628>>2]=e*s[a+416>>2];o[a+632>>2]=0;o[a+468>>2]=0;s[a+456>>2]=i!=v(0)?v(v(1)/i):v(0);s[a+460>>2]=h!=v(0)?v(v(1)/h):v(0);s[a+464>>2]=f!=v(0)?v(v(1)/f):v(0);jd(a);o[a+572>>2]=0;o[a+576>>2]=0;o[a+564>>2]=8;o[a+580>>2]=0;o[a+584>>2]=0;o[a+588>>2]=0;o[a+592>>2]=0;o[a+596>>2]=0;o[a+600>>2]=0;o[a+632>>2]=0;o[a+636>>2]=0;o[a+640>>2]=0;o[a+644>>2]=0;o[a+648>>2]=0;o[a+652>>2]=0;o[a+656>>2]=0;o[a+660>>2]=0;o[a+664>>2]=0;e=s[a+404>>2];s[a+628>>2]=e*s[a+416>>2];s[a+624>>2]=e*s[a+412>>2];s[a+620>>2]=e*s[a+408>>2];K=d+16|0;}function ke(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=v(0),j=v(0),k=0;e=K-80|0;K=e;o[a+72>>2]=o[a+72>>2]+1;c=o[a+68>>2];if(c){vc(c,o[(o[a+28>>2]+u(b,80)|0)+76>>2]);}d=o[a+20>>2];g=o[a+28>>2];h=u(b,80);c=g+h|0;f=c+8|0;k=o[f+4>>2];o[e+8>>2]=o[f>>2];o[e+12>>2]=k;f=o[c+4>>2];o[e>>2]=o[c>>2];o[e+4>>2]=f;f=o[c+28>>2];o[e+24>>2]=o[c+24>>2];o[e+28>>2]=f;f=o[c+20>>2];o[e+16>>2]=o[c+16>>2];o[e+20>>2]=f;f=o[c+44>>2];o[e+40>>2]=o[c+40>>2];o[e+44>>2]=f;f=o[c+36>>2];o[e+32>>2]=o[c+32>>2];o[e+36>>2]=f;f=o[c+60>>2];o[e+56>>2]=o[c+56>>2];o[e+60>>2]=f;f=o[c+52>>2];o[e+48>>2]=o[c+48>>2];o[e+52>>2]=f;f=o[c+76>>2];o[e+72>>2]=o[c+72>>2];o[e+76>>2]=f;f=o[c+68>>2];o[e+64>>2]=o[c+64>>2];o[e+68>>2]=f;f=g;g=u(d,80)+ -80|0;d=f+g|0;f=o[d+4>>2];o[c>>2]=o[d>>2];o[c+4>>2]=f;f=o[d+12>>2];o[c+8>>2]=o[d+8>>2];o[c+12>>2]=f;f=o[d+20>>2];o[c+16>>2]=o[d+16>>2];o[c+20>>2]=f;f=o[d+28>>2];o[c+24>>2]=o[d+24>>2];o[c+28>>2]=f;f=o[d+44>>2];o[c+40>>2]=o[d+40>>2];o[c+44>>2]=f;f=o[d+36>>2];o[c+32>>2]=o[d+32>>2];o[c+36>>2]=f;f=o[d+52>>2];o[c+48>>2]=o[d+48>>2];o[c+52>>2]=f;f=o[d+60>>2];o[c+56>>2]=o[d+56>>2];o[c+60>>2]=f;f=o[d+76>>2];o[c+72>>2]=o[d+72>>2];o[c+76>>2]=f;f=o[d+68>>2];o[c+64>>2]=o[d+64>>2];o[c+68>>2]=f;c=g+o[a+28>>2]|0;g=o[e+4>>2];o[c>>2]=o[e>>2];o[c+4>>2]=g;d=o[e+12>>2];o[c+8>>2]=o[e+8>>2];o[c+12>>2]=d;d=o[e+20>>2];o[c+16>>2]=o[e+16>>2];o[c+20>>2]=d;d=o[e+28>>2];o[c+24>>2]=o[e+24>>2];o[c+28>>2]=d;d=o[e+36>>2];o[c+32>>2]=o[e+32>>2];o[c+36>>2]=d;d=o[e+44>>2];o[c+40>>2]=o[e+40>>2];o[c+44>>2]=d;d=o[e+52>>2];o[c+48>>2]=o[e+48>>2];o[c+52>>2]=d;d=o[e+60>>2];o[c+56>>2]=o[e+56>>2];o[c+60>>2]=d;d=o[e+68>>2];o[c+64>>2]=o[e+64>>2];o[c+68>>2]=d;d=o[e+76>>2];o[c+72>>2]=o[e+72>>2];o[c+76>>2]=d;if(o[a+68>>2]){o[o[(h+o[a+28>>2]|0)+76>>2]+36>>2]=b;}o[a+20>>2]=o[a+20>>2]+ -1;j=v(b|0);d=o[a+84>>2];a:{if((d|0)<1){break a}g=o[a+92>>2];c=0;while(1){h=g+(c<<2)|0;i=s[h>>2];if(i!=j){c=c+1|0;if((d|0)!=(c|0)){continue}break a}break}if((d|0)<=(c|0)){break a}c=d+ -1|0;d=g+(c<<2)|0;o[h>>2]=o[d>>2];s[d>>2]=i;o[a+84>>2]=c;}d=o[a+124>>2];b:{if((d|0)<1){break b}g=o[a+132>>2];c=0;while(1){h=g+(c<<2)|0;i=s[h>>2];if(i!=j){c=c+1|0;if((d|0)!=(c|0)){continue}break b}break}if((d|0)<=(c|0)){break b}c=d+ -1|0;d=g+(c<<2)|0;o[h>>2]=o[d>>2];s[d>>2]=i;o[a+124>>2]=c;}d=o[a+104>>2];c:{if((d|0)<1){break c}g=o[a+112>>2];c=0;while(1){h=g+(c<<2)|0;i=s[h>>2];if(i!=j){c=c+1|0;if((d|0)!=(c|0)){continue}break c}break}if((d|0)<=(c|0)){break c}c=d+ -1|0;d=g+(c<<2)|0;o[h>>2]=o[d>>2];s[d>>2]=i;o[a+104>>2]=c;}d=o[a+144>>2];d:{if((d|0)<1){break d}g=o[a+152>>2];c=0;while(1){h=g+(c<<2)|0;i=s[h>>2];if(i!=j){c=c+1|0;if((d|0)!=(c|0)){continue}break d}break}if((d|0)<=(c|0)){break d}c=d+ -1|0;d=g+(c<<2)|0;o[h>>2]=o[d>>2];s[d>>2]=i;o[a+144>>2]=c;}d=o[a+164>>2];e:{if((d|0)<1){break e}g=o[a+172>>2];c=0;while(1){h=g+(c<<2)|0;if(o[h>>2]!=(b|0)){c=c+1|0;if((d|0)!=(c|0)){continue}break e}break}if((d|0)<=(c|0)){break e}c=(g+(d<<2)|0)+ -4|0;o[h>>2]=o[c>>2];o[c>>2]=b;o[a+164>>2]=o[a+164>>2]+ -1;}K=e+80|0;}function Me(a,b,c,d,f,g){a=a|0;b=b|0;c=c|0;d=d|0;f=f|0;g=g|0;var h=0,j=v(0),k=v(0),n=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=0,x=0,y=v(0),z=v(0),A=v(0),B=v(0),D=v(0),E=v(0),F=v(0),G=0,H=0,I=0,J=0;h=K-304|0;K=h;j=s[b+52>>2];q=s[c+52>>2];k=s[b+56>>2];r=s[c+56>>2];t=s[b+48>>2];n=s[c+48>>2];o[h+300>>2]=0;k=v(r-k);s[h+296>>2]=k;D=v(q-j);s[h+292>>2]=D;E=v(n-t);s[h+288>>2]=E;_b(b,c,h+112|0,h+48|0);o[h+284>>2]=0;j=s[h+48>>2];q=v(j*s[h+120>>2]);s[h+280>>2]=q;r=v(j*s[h+116>>2]);s[h+276>>2]=r;t=v(j*s[h+112>>2]);s[h+272>>2]=t;j=s[d+52>>2];n=s[f+52>>2];u=s[d+56>>2];y=s[f+56>>2];z=s[d+48>>2];B=s[f+48>>2];o[h+268>>2]=0;y=v(y-u);s[h+264>>2]=y;F=v(n-j);s[h+260>>2]=F;z=v(B-z);s[h+256>>2]=z;_b(d,f,h+112|0,h+48|0);o[h+252>>2]=0;j=s[h+48>>2];n=v(j*s[h+120>>2]);s[h+248>>2]=n;u=v(j*s[h+116>>2]);s[h+244>>2]=u;j=v(j*s[h+112>>2]);s[h+240>>2]=j;c=o[a+12>>2];A=v(l[o[o[c>>2]+16>>2]](c));B=v(0);c=o[a+16>>2];if(c){B=v(l[o[o[c>>2]+16>>2]](c));k=s[h+296>>2];y=s[h+264>>2];D=s[h+292>>2];F=s[h+260>>2];E=s[h+288>>2];z=s[h+256>>2];n=s[h+248>>2];u=s[h+244>>2];q=s[h+280>>2];r=s[h+276>>2];t=s[h+272>>2];j=s[h+240>>2];}n=v(v(A*v(C(v(v(v(t*t)+v(r*r))+v(q*q)))))+v(B*v(C(v(v(v(j*j)+v(u*u))+v(n*n))))));q=v(z-E);r=v(F-D);t=v(y-k);a:{if(v(n+v(C(v(v(v(q*q)+v(r*r))+v(t*t)))))==v(0)){break a}m[h+216|0]=0;o[h+212>>2]=1566444395;o[h+176>>2]=7284;Ne(a,b,d,h+176|0);c=o[h+208>>2];o[h+232>>2]=o[h+204>>2];o[h+236>>2]=c;c=o[h+200>>2];o[h+224>>2]=o[h+196>>2];o[h+228>>2]=c;if(!p[h+216|0]){break a}c=o[h+180>>2];G=o[h+184>>2];H=o[h+188>>2];if(v(n+v(v(v(q*s[h+180>>2])+v(r*s[h+184>>2]))+v(t*s[h+188>>2])))<=v(1.1920928955078125e-7)){break a}x=1;j=v(0);b:{k=v(s[h+212>>2]+s[g+172>>2]);A=s[h+192>>2];c:{if(!(k>v(.0010000000474974513))){break c}I=h+20|0;J=h+160|0;f=0;while(1){w=o[g+168>>2];if(w){o[h+120>>2]=1065353216;o[h+124>>2]=0;o[h+112>>2]=1065353216;o[h+116>>2]=1065353216;l[o[o[w>>2]+28>>2]](w,h+224|0,v(.20000000298023224),h+112|0);}u=v(n+v(v(v(q*(e(0,c),i()))+v(r*(e(0,G),i())))+v(t*(e(0,H),i()))));if(u<=v(1.1920928955078125e-7)){x=0;break a}k=v(j+v(k/u));if(k<=j){x=0;break a}if(k>v(1)){x=0;break a}if(k<v(0)){x=0;break a}_a(b,h+288|0,h+272|0,k,h+112|0);_a(d,h+256|0,h+240|0,k,h+48|0);c=o[g+168>>2];if(c){o[h+8>>2]=0;o[h+12>>2]=0;o[h>>2]=1065353216;o[h+4>>2]=0;l[o[o[c>>2]+28>>2]](c,J,v(.20000000298023224),h);}l[o[o[g>>2]>>2]](g,k);m[h+40|0]=0;o[h+36>>2]=1566444395;o[h>>2]=7284;Ne(a,h+112|0,h+48|0,h);if(!p[h+40|0]){break b}u=s[g+172>>2];c=I;w=o[c+12>>2];o[h+232>>2]=o[c+8>>2];o[h+236>>2]=w;w=o[c+4>>2];o[h+224>>2]=o[c>>2];o[h+228>>2]=w;w=f+1|0;if(f>>>0>63){l[o[o[g>>2]+8>>2]](g,-2,w);x=0;break a}c=o[h+4>>2];G=o[h+8>>2];H=o[h+12>>2];f=w;j=k;k=v(s[h+36>>2]+u);if(k>v(.0010000000474974513)){continue}break}A=s[h+16>>2];}k=A;o[g+132>>2]=c;s[g+164>>2]=j;s[g+144>>2]=k;o[g+140>>2]=H;o[g+136>>2]=G;a=o[h+228>>2];o[g+148>>2]=o[h+224>>2];o[g+152>>2]=a;a=o[h+236>>2];o[g+156>>2]=o[h+232>>2];o[g+160>>2]=a;break a}l[o[o[g>>2]+8>>2]](g,-1,f);x=0;}K=h+304|0;return x|0}function Hj(a,b,c,d){var e=0,f=0,g=0,h=0,i=v(0),j=0,k=0,n=0,q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=0,z=v(0),A=0,B=v(0),C=v(0),D=v(0),E=0;a:{A=o[a+4>>2];if((A|0)<2){break a}g=o[a+12>>2];e=(g+(A<<4)|0)+ -16|0;t=s[e>>2];B=s[c>>2];q=s[e+4>>2];C=s[c+4>>2];r=s[e+8>>2];D=s[c+8>>2];i=v(v(v(v(t*B)+v(q*C))+v(r*D))+d);while(1){e=(E<<4)+g|0;u=s[e>>2];w=s[e+4>>2];x=s[e+8>>2];z=v(v(v(v(u*B)+v(w*C))+v(x*D))+d);y=o[e+12>>2];b:{c:{if(!!(i<v(0))){if(!!(z<v(0))){e=o[b+4>>2];d:{if((e|0)!=o[b+8>>2]){break d}j=e?e<<1:1;if((e|0)>=(j|0)){break d}g=0;k=0;if(j){o[6257]=o[6257]+1;k=l[o[4968]](j<<4,16)|0;e=o[b+4>>2];}if((e|0)>=1){while(1){f=g<<4;h=f+k|0;f=f+o[b+12>>2]|0;n=o[f+4>>2];o[h>>2]=o[f>>2];o[h+4>>2]=n;n=o[f+12>>2];o[h+8>>2]=o[f+8>>2];o[h+12>>2]=n;g=g+1|0;if((g|0)!=(e|0)){continue}break}}e=o[b+12>>2];if(e){if(p[b+16|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[b+12>>2]=0;}o[b+12>>2]=k;m[b+16|0]=1;o[b+8>>2]=j;e=o[b+4>>2];}e=o[b+12>>2]+(e<<4)|0;o[e+12>>2]=y;s[e+8>>2]=x;s[e+4>>2]=w;s[e>>2]=u;break c}i=v(i/v(i-z));r=v(r+v(v(x-r)*i));q=v(q+v(v(w-q)*i));i=v(t+v(v(u-t)*i));e=o[b+4>>2];e:{if((e|0)!=o[b+8>>2]){break e}k=e?e<<1:1;if((e|0)>=(k|0)){break e}g=0;j=0;if(k){o[6257]=o[6257]+1;j=l[o[4968]](k<<4,16)|0;e=o[b+4>>2];}if((e|0)>=1){while(1){f=g<<4;y=f+j|0;h=y;f=f+o[b+12>>2]|0;n=o[f+4>>2];o[h>>2]=o[f>>2];o[h+4>>2]=n;h=o[f+12>>2];o[y+8>>2]=o[f+8>>2];o[y+12>>2]=h;g=g+1|0;if((g|0)!=(e|0)){continue}break}}e=o[b+12>>2];if(e){if(p[b+16|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[b+12>>2]=0;}o[b+12>>2]=j;m[b+16|0]=1;o[b+8>>2]=k;e=o[b+4>>2];}e=o[b+12>>2]+(e<<4)|0;o[e+12>>2]=0;s[e+8>>2]=r;s[e+4>>2]=q;s[e>>2]=i;break c}if(!(z<v(0))){break b}i=v(i/v(i-z));r=v(r+v(v(x-r)*i));q=v(q+v(v(w-q)*i));i=v(t+v(v(u-t)*i));e=o[b+4>>2];f:{if((e|0)!=o[b+8>>2]){break f}j=e?e<<1:1;if((e|0)>=(j|0)){break f}g=0;k=0;if(j){o[6257]=o[6257]+1;k=l[o[4968]](j<<4,16)|0;e=o[b+4>>2];}if((e|0)>=1){while(1){f=g<<4;h=f+k|0;f=f+o[b+12>>2]|0;n=o[f+4>>2];o[h>>2]=o[f>>2];o[h+4>>2]=n;n=o[f+12>>2];o[h+8>>2]=o[f+8>>2];o[h+12>>2]=n;g=g+1|0;if((g|0)!=(e|0)){continue}break}}e=o[b+12>>2];if(e){if(p[b+16|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[b+12>>2]=0;}o[b+12>>2]=k;m[b+16|0]=1;o[b+8>>2]=j;e=o[b+4>>2];}e=o[b+12>>2]+(e<<4)|0;o[e+12>>2]=0;s[e+8>>2]=r;s[e+4>>2]=q;s[e>>2]=i;e=o[b+4>>2]+1|0;o[b+4>>2]=e;g:{if(o[b+8>>2]!=(e|0)){break g}j=e?e<<1:1;if((e|0)>=(j|0)){break g}g=0;k=0;if(j){o[6257]=o[6257]+1;k=l[o[4968]](j<<4,16)|0;e=o[b+4>>2];}if((e|0)>=1){while(1){f=g<<4;h=f+k|0;f=f+o[b+12>>2]|0;n=o[f+4>>2];o[h>>2]=o[f>>2];o[h+4>>2]=n;n=o[f+12>>2];o[h+8>>2]=o[f+8>>2];o[h+12>>2]=n;g=g+1|0;if((g|0)!=(e|0)){continue}break}}e=o[b+12>>2];if(e){if(p[b+16|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[b+12>>2]=0;}o[b+12>>2]=k;m[b+16|0]=1;o[b+8>>2]=j;e=o[b+4>>2];}e=o[b+12>>2]+(e<<4)|0;o[e+12>>2]=y;s[e+8>>2]=x;s[e+4>>2]=w;s[e>>2]=u;}o[b+4>>2]=o[b+4>>2]+1;}E=E+1|0;if((E|0)==(A|0)){break a}D=s[c+8>>2];C=s[c+4>>2];B=s[c>>2];g=o[a+12>>2];i=z;r=x;q=w;t=u;continue}}}function Tc(a,b,c,d,f,g){a=a|0;b=b|0;c=c|0;d=d|0;f=f|0;g=g|0;var h=0,j=0,k=v(0),n=v(0),q=0,r=v(0),t=0,u=v(0),w=v(0),x=v(0),y=0,z=0,A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0);h=K-288|0;K=h;Pb(o[a+4>>2]);k=s[b+52>>2];n=s[c+52>>2];r=s[d+52>>2];u=s[f+52>>2];w=s[b+56>>2];x=s[c+56>>2];A=s[d+56>>2];B=s[f+56>>2];C=s[b+48>>2];D=s[c+48>>2];E=s[d+48>>2];F=s[f+48>>2];m[h+264|0]=0;o[h+260>>2]=1566444395;o[h+224>>2]=7284;z=Wc(h+144|0,o[a+8>>2],o[a+12>>2],o[a+4>>2],0);o[h+136>>2]=1566444395;a=b;j=o[a+12>>2];o[h+16>>2]=o[a+8>>2];o[h+20>>2]=j;j=o[a+4>>2];o[h+8>>2]=o[a>>2];o[h+12>>2]=j;j=o[a+28>>2];o[h+32>>2]=o[a+24>>2];o[h+36>>2]=j;j=o[a+20>>2];o[h+24>>2]=o[a+16>>2];o[h+28>>2]=j;j=o[a+44>>2];o[h+48>>2]=o[a+40>>2];o[h+52>>2]=j;j=o[a+36>>2];o[h+40>>2]=o[a+32>>2];o[h+44>>2]=j;t=o[a+60>>2];j=h- -64|0;o[j>>2]=o[a+56>>2];o[j+4>>2]=t;j=o[a+52>>2];o[h+56>>2]=o[a+48>>2];o[h+60>>2]=j;a=d;j=o[a+12>>2];o[h+80>>2]=o[a+8>>2];o[h+84>>2]=j;j=o[a+4>>2];o[h+72>>2]=o[a>>2];o[h+76>>2]=j;j=o[a+20>>2];o[h+88>>2]=o[a+16>>2];o[h+92>>2]=j;j=o[a+28>>2];o[h+96>>2]=o[a+24>>2];o[h+100>>2]=j;j=o[a+44>>2];o[h+112>>2]=o[a+40>>2];o[h+116>>2]=j;j=o[a+36>>2];o[h+104>>2]=o[a+32>>2];o[h+108>>2]=j;j=o[a+52>>2];o[h+120>>2]=o[a+48>>2];o[h+124>>2]=j;j=o[a+60>>2];o[h+128>>2]=o[a+56>>2];o[h+132>>2]=j;Ha(z,h+8|0,h+224|0,0);a=o[h+256>>2];o[h+280>>2]=o[h+252>>2];o[h+284>>2]=a;a=o[h+248>>2];o[h+272>>2]=o[h+244>>2];o[h+276>>2]=a;q=0;a:{if(!p[h+264|0]){break a}w=v(v(x-w)-v(B-A));u=v(v(n-k)-v(u-r));x=v(v(D-C)-v(F-E));t=o[h+232>>2];j=o[h+236>>2];y=o[h+228>>2];r=s[h+260>>2];b:{c:{if(!(r>v(.0010000000474974513))){k=v(0);n=s[h+240>>2];break c}a=0;n=v(0);while(1){q=0;if((a|0)==32){break a}k=v(n-v(r/v(v(w*(e(0,j),i()))+v(v(u*(e(0,t),i()))+v(x*(e(0,y),i()))))));q=0;if(k<=n){break a}q=0;if(k>v(1)){break a}q=0;if(k<v(0)){break a}l[o[o[g>>2]>>2]](g,k);n=v(v(1)-k);s[h+56>>2]=v(n*s[b+48>>2])+v(k*s[c+48>>2]);s[h+60>>2]=v(n*s[b+52>>2])+v(k*s[c+52>>2]);s[h+64>>2]=v(n*s[b+56>>2])+v(k*s[c+56>>2]);s[h+120>>2]=v(n*s[d+48>>2])+v(k*s[f+48>>2]);s[h+124>>2]=v(n*s[d+52>>2])+v(k*s[f+52>>2]);s[h+128>>2]=v(n*s[d+56>>2])+v(k*s[f+56>>2]);Ha(z,h+8|0,h+224|0,0);q=0;if(!p[h+264|0]){break a}r=s[h+260>>2];if(!!(r<v(0))){s[g+164>>2]=k;a=o[h+228>>2];b=o[h+232>>2];c=o[h+240>>2];o[g+140>>2]=o[h+236>>2];o[g+144>>2]=c;o[g+132>>2]=a;o[g+136>>2]=b;a=o[h+256>>2];o[g+156>>2]=o[h+252>>2];o[g+160>>2]=a;a=o[h+248>>2];o[g+148>>2]=o[h+244>>2];o[g+152>>2]=a;break b}a=a+1|0;j=o[h+256>>2];o[h+280>>2]=o[h+252>>2];o[h+284>>2]=j;j=o[h+248>>2];o[h+272>>2]=o[h+244>>2];o[h+276>>2]=j;y=o[h+228>>2];t=o[h+232>>2];j=o[h+236>>2];n=k;if(r>v(.0010000000474974513)){continue}break}n=s[h+240>>2];}q=0;if(v(v(w*(e(0,j),i()))+v(v(u*(e(0,t),i()))+v(x*(e(0,y),i()))))>=v(-s[g+172>>2])){break a}o[g+132>>2]=y;s[g+164>>2]=k;s[g+144>>2]=n;o[g+140>>2]=j;o[g+136>>2]=t;a=o[h+276>>2];o[g+148>>2]=o[h+272>>2];o[g+152>>2]=a;a=o[h+284>>2];o[g+156>>2]=o[h+280>>2];o[g+160>>2]=a;}q=1;}j=q;K=h+288|0;return j|0}function lu(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0,r=0,s=0,v=0,x=0,y=0,z=0;g=K-560|0;K=g;e=c;c=(c+ -3|0)/24|0;q=(c|0)>0?c:0;j=e+u(q,-24)|0;k=o[4120];if((k|0)>=0){e=k+1|0;c=q;while(1){t[(g+320|0)+(f<<3)>>3]=(c|0)<0?0:+o[(c<<2)+16496>>2];c=c+1|0;f=f+1|0;if((e|0)!=(f|0)){continue}break}}l=j+ -24|0;e=0;r=(k|0)>0?k:0;while(1){c=0;d=0;while(1){d=d+t[(c<<3)+a>>3]*t[(g+320|0)+(e-c<<3)>>3];c=c+1|0;if((c|0)!=1){continue}break}t[(e<<3)+g>>3]=d;c=(e|0)==(r|0);e=e+1|0;if(!c){continue}break}z=47-j|0;s=48-j|0;v=j+ -25|0;e=k;a:{while(1){d=t[(e<<3)+g>>3];c=0;f=e;n=(e|0)<1;if(!n){while(1){i=(g+480|0)+(c<<2)|0;m=d;d=d*5.960464477539063e-8;b:{if(w(d)<2147483648){h=~~d;break b}h=-2147483648;}d=+(h|0);m=m+d*-16777216;c:{if(w(m)<2147483648){h=~~m;break c}h=-2147483648;}o[i>>2]=h;f=f+ -1|0;d=t[(f<<3)+g>>3]+d;c=c+1|0;if((e|0)!=(c|0)){continue}break}}d=tc(d,l);d=d+A(d*.125)*-8;d:{if(w(d)<2147483648){h=~~d;break d}h=-2147483648;}d=d- +(h|0);e:{f:{g:{x=(l|0)<1;h:{if(!x){f=(e<<2)+g|0;i=o[f+476>>2];c=i>>s;p=f;f=i-(c<<s)|0;o[p+476>>2]=f;h=c+h|0;i=f>>z;break h}if(l){break g}i=o[((e<<2)+g|0)+476>>2]>>23;}if((i|0)<1){break e}break f}i=2;if(!!(d>=.5)){break f}i=0;break e}c=0;f=0;if(!n){while(1){p=(g+480|0)+(c<<2)|0;n=o[p>>2];y=16777215;i:{j:{if(f){break j}y=16777216;if(n){break j}f=0;break i}o[p>>2]=y-n;f=1;}c=c+1|0;if((e|0)!=(c|0)){continue}break}}k:{if(v>>>0>1|x){break k}if(v-1){c=(e<<2)+g|0;o[c+476>>2]=o[c+476>>2]&8388607;break k}c=(e<<2)+g|0;o[c+476>>2]=o[c+476>>2]&4194303;}h=h+1|0;if((i|0)!=2){break e}d=1-d;i=2;if(!f){break e}d=d-tc(1,l);}if(d==0){f=0;l:{c=e;if((c|0)<=(k|0)){break l}while(1){c=c+ -1|0;f=o[(g+480|0)+(c<<2)>>2]|f;if((c|0)>(k|0)){continue}break}if(!f){break l}j=l;while(1){j=j+ -24|0;e=e+ -1|0;if(!o[(g+480|0)+(e<<2)>>2]){continue}break}break a}c=1;while(1){f=c;c=c+1|0;if(!o[(g+480|0)+(k-f<<2)>>2]){continue}break}f=e+f|0;while(1){h=e+1|0;e=e+1|0;t[(g+320|0)+(h<<3)>>3]=o[(q+e<<2)+16496>>2];c=0;d=0;while(1){d=d+t[(c<<3)+a>>3]*t[(g+320|0)+(h-c<<3)>>3];c=c+1|0;if((c|0)!=1){continue}break}t[(e<<3)+g>>3]=d;if((e|0)<(f|0)){continue}break}e=f;continue}break}d=tc(d,0-l|0);m:{if(!!(d>=16777216)){f=(g+480|0)+(e<<2)|0;m=d;d=d*5.960464477539063e-8;n:{if(w(d)<2147483648){c=~~d;break n}c=-2147483648;}d=m+ +(c|0)*-16777216;o:{if(w(d)<2147483648){a=~~d;break o}a=-2147483648;}o[f>>2]=a;e=e+1|0;break m}if(w(d)<2147483648){c=~~d;}else {c=-2147483648;}j=l;}o[(g+480|0)+(e<<2)>>2]=c;}d=tc(1,j);if((e|0)>=0){c=e;while(1){t[(c<<3)+g>>3]=d*+o[(g+480|0)+(c<<2)>>2];d=d*5.960464477539063e-8;a=0;f=(c|0)>0;c=c+ -1|0;if(f){continue}break}f=e;while(1){j=r>>>0<a>>>0?r:a;l=e-f|0;c=0;d=0;while(1){d=d+t[(c<<3)+19264>>3]*t[(c+f<<3)+g>>3];k=(c|0)!=(j|0);c=c+1|0;if(k){continue}break}t[(g+160|0)+(l<<3)>>3]=d;f=f+ -1|0;c=(a|0)!=(e|0);a=a+1|0;if(c){continue}break}}d=0;if((e|0)>=0){while(1){d=d+t[(g+160|0)+(e<<3)>>3];a=(e|0)>0;e=e+ -1|0;if(a){continue}break}}t[b>>3]=i?-d:d;K=g+560|0;return h&7}function wq(a,b){a=a|0;b=v(b);var c=0,d=0,e=0,f=0,g=0,h=0;c=K-768|0;K=c;o[c+764>>2]=a;s[c+760>>2]=b;a=o[c+764>>2];l[o[4966]](1220);d=K-16|0;o[d+12>>2]=a;d=o[d+12>>2]+348|0;o[c+748>>2]=0;bq(d,c+748|0);Nn(a);d=K-16|0;o[d+12>>2]=a+244;o[c+744>>2]=o[o[d+12>>2]+4>>2];if(o[c+744>>2]>0){wb(c+680|0);o[c+676>>2]=0;while(1){if(o[c+676>>2]<o[c+744>>2]){e=o[c+676>>2];d=K-16|0;o[d+12>>2]=a+244;o[d+8>>2]=e;o[c+672>>2]=o[o[o[d+12>>2]+12>>2]+(o[d+8>>2]<<2)>>2];d=K-16|0;o[d+12>>2]=o[c+672>>2];s[d+8>>2]=1;s[o[d+12>>2]+268>>2]=s[d+8>>2];a:{if(!(pd(o[c+672>>2])&1)){break a}d=K-16|0;o[d+12>>2]=o[c+672>>2];if(o[o[d+12>>2]+204>>2]&3){break a}d=c+680|0;ub(o[c+672>>2],s[c+760>>2],d);e=K-16|0;o[e+12>>2]=o[c+672>>2];o[c+668>>2]=o[e+12>>2]+4;e=K-16|0;o[e+12>>2]=d;d=o[e+12>>2]+48|0;e=K-16|0;o[e+12>>2]=o[c+668>>2];f=c+648|0;gc(f,d,o[e+12>>2]+48|0);s[c+664>>2]=eg(f);d=K-16|0;o[d+12>>2]=a;b:{if(!(m[(o[d+12>>2]+28|0)+16|0]&1)){break b}d=K-16|0;o[d+12>>2]=o[c+672>>2];d=o[d+12>>2];if(v(s[d+276>>2]*s[d+276>>2])==v(0)){break b}d=K-16|0;o[d+12>>2]=o[c+672>>2];d=o[d+12>>2];if(!(v(s[d+276>>2]*s[d+276>>2])<s[c+664>>2])){break b}l[o[4966]](1245);d=K-16|0;o[d+12>>2]=o[c+672>>2];if(Sp(o[o[d+12>>2]+192>>2])&1){e=o[c+672>>2];d=K-16|0;o[d+12>>2]=o[c+668>>2];f=o[d+12>>2]+48|0;g=K-16|0;h=c+680|0;o[g+12>>2]=h;d=c+536|0;Hp(d,e,a,f,o[g+12>>2]+48|0);e=K-16|0;o[e+12>>2]=o[c+672>>2];f=c+480|0;Xf(f,s[o[e+12>>2]+272>>2]);e=K-16|0;o[e+12>>2]=o[c+672>>2];o[c+544>>2]=o[o[o[e+12>>2]+188>>2]+4>>2];e=K-16|0;o[e+12>>2]=o[c+672>>2];o[c+548>>2]=o[o[o[e+12>>2]+188>>2]+8>>2];e=c+416|0;Bb(e,h);g=K-16|0;o[g+12>>2]=o[c+668>>2];rp(e,o[g+12>>2]);Pc(a,f,o[c+668>>2],e,d);e=K-16|0;o[e+12>>2]=d;if(s[o[e+12>>2]+4>>2]<v(1)){d=K-16|0;o[d+12>>2]=c+680;d=o[d+12>>2]+48|0;e=K-16|0;o[e+12>>2]=o[c+668>>2];f=c+384|0;gc(f,d,o[e+12>>2]+48|0);e=c+400|0;d=f;f=c+536|0;md(e,d,f+4|0);d=c+360|0;lg(d,f+48|0);s[c+380>>2]=Ga(e,d);d=o[a+24>>2];o[c+356>>2]=l[o[o[d>>2]+12>>2]](d,o[c+672>>2],o[c+616>>2]);o[(K-16|0)+12>>2]=a+340;Ka(a+320|0,c+356|0);o[(K-16|0)+12>>2]=a+340;g=K-16|0;o[g+12>>2]=o[c+668>>2];d=c+336|0;mg(d,o[g+12>>2]+48|0,e);e=K-16|0;o[e+12>>2]=o[c+616>>2];g=c+256|0;bc(g,o[e+12>>2]+4|0);e=c+320|0;_o(e,g,d);s[c+28>>2]=0;s[c+24>>2]=0;s[c+20>>2]=0;g=c+32|0;Z(g,c+28|0,c+24|0,c+20|0);h=c+48|0;Ro(h,g,e,f+48|0,s[c+380>>2]);o[c+16>>2]=$c(o[c+356>>2],h);f=o[c+16>>2];e=K-16|0;o[e+12>>2]=o[c+356>>2];o[e+8>>2]=f;o[c+12>>2]=(o[e+12>>2]+4|0)+u(o[e+8>>2],208);s[o[c+12>>2]+96>>2]=0;s[o[c+12>>2]+84>>2]=y(v(z(v(s[o[c+672>>2]+228>>2]*s[o[c+616>>2]+228>>2]),v(-10))),v(10));f=K-16|0;o[f+12>>2]=o[c+668>>2];f=o[f+12>>2]+48|0;g=o[f+4>>2];e=o[c+12>>2];o[e+48>>2]=o[f>>2];o[e+52>>2]=g;g=o[f+12>>2];o[e+56>>2]=o[f+8>>2];o[e+60>>2]=g;f=o[d+4>>2];e=o[c+12>>2];o[e+32>>2]=o[d>>2];o[e+36>>2]=f;f=o[d+12>>2];o[e+40>>2]=o[d+8>>2];o[e+44>>2]=f;}Ho(c+480|0);$b(c+536|0);}l[o[4967]]();}}o[c+676>>2]=o[c+676>>2]+1;continue}break}}l[o[4967]]();K=c+768|0;}function Nb(){a:{if(m[22544]&1){break a}if(!Fa(22544)){break a}o[5554]=1062847606;o[5555]=0;o[5552]=1042701022;o[5553]=1056964440;o[5550]=1062847606;o[5551]=0;o[5548]=-1093024784;o[5549]=1050556081;o[5546]=1062847606;o[5547]=0;o[5544]=-1093024784;o[5545]=-1096927567;o[5542]=1062847606;o[5543]=0;o[5540]=1042701022;o[5541]=-1090519208;o[5538]=1062847572;o[5539]=0;o[5536]=1057396286;o[5537]=0;o[5534]=1057396386;o[5535]=0;o[5532]=1060121912;o[5533]=1056964507;o[5530]=1057396420;o[5531]=0;o[5528]=-1098475836;o[5529]=1062148969;o[5526]=1057396386;o[5527]=0;o[5524]=-1084636143;o[5525]=0;o[5522]=1057396420;o[5523]=0;o[5520]=-1098475836;o[5521]=-1085334679;o[5518]=1057396386;o[5519]=0;o[5516]=1060121912;o[5517]=-1090519141;o[5514]=-2147483648;o[5515]=0;o[5512]=1058437413;o[5513]=1062149053;o[5510]=-2147483648;o[5511]=0;o[5508]=-2147483648;o[5509]=1065353216;o[5506]=-2147483648;o[5507]=0;o[5504]=-1089046235;o[5505]=1062149053;o[5502]=-2147483648;o[5503]=0;o[5500]=-1082951543;o[5501]=1050556148;o[5498]=-2147483648;o[5499]=0;o[5496]=-1082951543;o[5497]=-1096927500;o[5494]=0;o[5495]=0;o[5492]=-1089046235;o[5493]=-1085334595;o[5490]=0;o[5491]=0;o[5488]=0;o[5489]=-1082130432;o[5486]=0;o[5487]=0;o[5484]=1058437413;o[5485]=-1085334595;o[5482]=0;o[5483]=0;o[5480]=1064532105;o[5481]=-1096927500;o[5478]=0;o[5479]=0;o[5476]=1064532105;o[5477]=1050556148;o[5474]=-1090087228;o[5475]=0;o[5472]=1049007812;o[5473]=1062148969;o[5470]=-1090087262;o[5471]=0;o[5468]=-1087361736;o[5469]=1056964507;o[5466]=-1084636042;o[5467]=0;o[5464]=-1104782626;o[5465]=1056964440;o[5462]=-1090087262;o[5463]=0;o[5460]=-1087361736;o[5461]=-1090519141;o[5458]=-1084636076;o[5459]=0;o[5456]=-1090087362;o[5457]=-2147483648;o[5454]=-1090087262;o[5455]=0;o[5452]=1062847505;o[5453]=-2147483648;o[5450]=-1084636042;o[5451]=0;o[5448]=1054458864;o[5449]=1050556081;o[5446]=-1090087228;o[5447]=0;o[5444]=1049007812;o[5445]=-1085334679;o[5442]=-1084636042;o[5443]=0;o[5440]=-1104782626;o[5441]=-1090519208;o[5438]=-1084636042;o[5439]=0;o[5436]=1054458864;o[5437]=-1096927567;o[5434]=1065353216;o[5435]=0;o[5432]=-2147483648;o[5433]=0;o[5430]=1055193471;o[5431]=0;o[5428]=1063581978;o[5429]=0;o[5426]=1055193572;o[5427]=0;o[5424]=1049461434;o[5425]=1062847522;o[5422]=1055193572;o[5423]=0;o[5420]=-1086767520;o[5421]=1057396202;o[5418]=1055193572;o[5419]=0;o[5416]=-1086767520;o[5417]=-1090087446;o[5414]=1055193605;o[5415]=0;o[5412]=1049461434;o[5413]=-1084636126;o[5410]=-1092290076;o[5411]=0;o[5408]=1060716128;o[5409]=1057396202;o[5406]=-1092290043;o[5407]=0;o[5404]=-1098022214;o[5405]=1062847522;o[5402]=-1092290177;o[5403]=0;o[5400]=-1083901670;o[5401]=-2147483648;o[5398]=-1092290076;o[5399]=0;o[5396]=-1098022214;o[5397]=-1084636126;o[5394]=-1092290076;o[5395]=0;o[5392]=1060716128;o[5393]=-1090087446;o[5390]=-1082130432;o[5391]=0;o[5388]=0;o[5389]=-2147483648;Ea(22544);}}function Sk(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0),U=v(0),V=v(0),W=v(0),X=v(0),Y=v(0),Z=v(0),_=v(0);d=K-240|0;K=d;Z=v(1);e=p[a+76|0];a=e?c:b;h=s[a+116>>2];i=s[a+52>>2];f=v(h-i);g=v(f*f);j=s[a+120>>2];B=s[a+56>>2];f=v(j-B);k=v(g+v(f*f));C=s[a+124>>2];g=s[a+60>>2];f=v(C-g);k=v(k+v(f*f));f=s[a+276>>2];a:{if(k<v(f*f)){break a}b=e?b:c;c=o[b+192>>2];if(o[c+4>>2]+ -21>>>0>8){break a}F=s[a+92>>2];G=s[a+76>>2];H=s[a+108>>2];I=s[a+88>>2];J=s[a+72>>2];L=s[a+104>>2];M=s[a+100>>2];N=s[a+84>>2];O=s[a+68>>2];n=s[b+36>>2];q=s[b+20>>2];r=s[b+4>>2];P=s[a+28>>2];Q=s[a+12>>2];R=s[a+44>>2];S=s[a+24>>2];T=s[a+8>>2];U=s[a+40>>2];V=s[a+36>>2];W=s[a+20>>2];X=s[a+4>>2];t=s[b+12>>2];u=s[b+28>>2];w=s[b+44>>2];Y=v(v(v(t*h)+v(u*j))+v(w*C));x=s[b+24>>2];y=v(-s[b+56>>2]);z=s[b+8>>2];D=s[b+52>>2];A=s[b+40>>2];E=s[b+60>>2];m=v(v(v(x*y)-v(z*D))-v(A*E));f=v(m+v(v(v(z*h)+v(x*j))+v(A*C)));o[d+236>>2]=0;_=v(v(v(u*y)-v(t*D))-v(w*E));k=v(_+v(v(v(t*i)+v(u*B))+v(w*g)));s[d+232>>2]=k;m=v(m+v(v(v(z*i)+v(x*B))+v(A*g)));s[d+228>>2]=m;y=v(v(v(q*y)-v(r*D))-v(n*E));i=v(y+v(v(v(r*i)+v(q*B))+v(n*g)));s[d+224>>2]=i;B=i;h=v(y+v(v(v(r*h)+v(q*j))+v(n*C)));if(!!(h<i)){s[d+224>>2]=h;B=h;}C=m;if(!!(f<m)){s[d+228>>2]=f;C=f;}j=v(_+Y);g=k;if(!!(j<g)){s[d+232>>2]=j;g=j;}o[d+220>>2]=0;s[d+216>>2]=k;s[d+212>>2]=m;s[d+208>>2]=i;y=i;if(!!(i<h)){s[d+208>>2]=h;y=h;}D=m;if(!!(m<f)){s[d+212>>2]=f;D=f;}E=k;if(!!(k<j)){s[d+216>>2]=j;E=j;}Y=g;g=s[a+272>>2];s[d+232>>2]=Y-g;s[d+228>>2]=C-g;s[d+224>>2]=B-g;s[d+216>>2]=g+E;s[d+212>>2]=g+D;s[d+208>>2]=g+y;o[d+128>>2]=0;s[d+124>>2]=j;s[d+120>>2]=f;s[d+116>>2]=h;o[d+112>>2]=0;s[d+108>>2]=v(v(t*G)+v(u*F))+v(w*H);s[d+104>>2]=v(v(t*J)+v(u*I))+v(w*L);s[d+100>>2]=v(v(t*O)+v(u*N))+v(w*M);o[d+96>>2]=0;s[d+92>>2]=v(v(z*G)+v(x*F))+v(A*H);s[d+88>>2]=v(v(z*J)+v(x*I))+v(A*L);s[d+84>>2]=v(v(z*O)+v(x*N))+v(A*M);o[d+80>>2]=0;s[d+76>>2]=v(v(r*G)+v(q*F))+v(n*H);s[d+72>>2]=v(v(r*J)+v(q*I))+v(n*L);o[d- -64>>2]=0;s[d+60>>2]=k;s[d+56>>2]=m;s[d+52>>2]=i;o[d+48>>2]=0;s[d+44>>2]=v(v(t*Q)+v(u*P))+v(w*R);s[d+40>>2]=v(v(t*T)+v(u*S))+v(w*U);s[d+36>>2]=v(v(t*X)+v(u*W))+v(w*V);o[d+32>>2]=0;s[d+28>>2]=v(v(z*Q)+v(x*P))+v(A*R);s[d+24>>2]=v(v(z*T)+v(x*S))+v(A*U);s[d+20>>2]=v(v(z*X)+v(x*W))+v(A*V);o[d+16>>2]=0;s[d+12>>2]=v(v(r*Q)+v(q*P))+v(n*R);s[d+8>>2]=v(v(r*T)+v(q*S))+v(n*U);s[d+196>>2]=g;s[d+68>>2]=v(v(r*O)+v(q*N))+v(n*M);s[d+4>>2]=v(v(r*X)+v(q*W))+v(n*V);o[d>>2]=6772;o[d+200>>2]=o[a+268>>2];b:{if(!c){break b}l[o[o[c>>2]+64>>2]](c,d,d+224|0,d+208|0);f=s[d+200>>2];if(!(f<s[a+268>>2])){break b}s[a+268>>2]=f;Z=f;}}K=d+240|0;return v(Z)}function Od(a,b,c){var d=0,e=0,f=0,g=0,h=v(0),i=0,j=v(0),k=v(0),n=v(0),q=v(0),r=v(0),t=0;a:{if(p[a+165|0]){d=o[a+88>>2];if(!(!c|(d|0)<1)){f=o[a+96>>2];k=s[a+168>>2];n=s[b+8>>2];q=s[b+4>>2];r=s[b>>2];c=0;while(1){e=f+(c<<4)|0;h=v(s[e>>2]-r);j=v(h*h);h=v(s[e+4>>2]-q);j=v(j+v(h*h));h=v(s[e+8>>2]-n);if(v(j+v(h*h))<=k){break a}c=c+1|0;if((c|0)<(d|0)){continue}break}}c=o[a+32>>2];o[c+12>>2]=o[c+12>>2]+1;b:{if(o[a+92>>2]!=(d|0)){break b}e=d?d<<1:1;if((d|0)>=(e|0)){break b}if(e){o[6257]=o[6257]+1;g=l[o[4968]](e<<4,16)|0;d=o[a+88>>2];}if((d|0)>=1){c=0;while(1){f=c<<4;i=f+g|0;f=f+o[a+96>>2]|0;t=o[f+4>>2];o[i>>2]=o[f>>2];o[i+4>>2]=t;t=o[f+12>>2];o[i+8>>2]=o[f+8>>2];o[i+12>>2]=t;c=c+1|0;if((d|0)!=(c|0)){continue}break}}c=o[a+96>>2];if(c){if(p[a+100|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+96>>2]=0;}o[a+96>>2]=g;o[a+92>>2]=e;m[a+100|0]=1;d=o[a+88>>2];}c=o[a+96>>2]+(d<<4)|0;d=o[b+4>>2];o[c>>2]=o[b>>2];o[c+4>>2]=d;d=o[b+12>>2];o[c+8>>2]=o[b+8>>2];o[c+12>>2]=d;b=o[a+88>>2];o[a+88>>2]=b+1;o[o[a+32>>2]+16>>2]=o[a+96>>2];return b}c:{d=o[a+108>>2];if(!c|(d|0)<1){break c}f=o[a+116>>2];k=s[a+168>>2];n=s[b+8>>2];q=s[b+4>>2];r=s[b>>2];c=0;while(1){e=f+(c<<2)|0;h=v(s[e>>2]-r);j=v(h*h);h=v(s[e+4>>2]-q);j=v(j+v(h*h));h=v(s[e+8>>2]-n);if(!(v(j+v(h*h))<=k)){c=c+3|0;if((c|0)<(d|0)){continue}break c}break}return (c>>>0)/3|0}e=o[a+112>>2];d:{if((e|0)!=(d|0)){break d}e=d?d<<1:1;if((d|0)>=(e|0)){e=d;break d}c=0;if(e){o[6257]=o[6257]+1;g=l[o[4968]](e<<2,16)|0;d=o[a+108>>2];}f=o[a+116>>2];e:{f:{if((d|0)>=1){while(1){i=c<<2;o[i+g>>2]=o[f+i>>2];c=c+1|0;if((d|0)!=(c|0)){continue}break f}}if(!f){break e}}if(p[a+120|0]){if(f){o[6258]=o[6258]+1;l[o[4969]](f);}d=o[a+108>>2];}o[a+116>>2]=0;}o[a+116>>2]=g;o[a+112>>2]=e;m[a+120|0]=1;}g=o[a+116>>2];o[g+(d<<2)>>2]=o[b>>2];c=d+1|0;o[a+108>>2]=c;g:{if((c|0)!=(e|0)){d=g;f=e;e=c;break g}f=e?e<<1:1;if((e|0)>=(f|0)){d=g;f=e;break g}c=0;d=0;if(f){o[6257]=o[6257]+1;d=l[o[4968]](f<<2,16)|0;e=o[a+108>>2];g=o[a+116>>2];}h:{i:{if((e|0)>=1){while(1){i=c<<2;o[i+d>>2]=o[g+i>>2];c=c+1|0;if((e|0)!=(c|0)){continue}break i}}if(!g){break h}}if(p[a+120|0]){if(g){o[6258]=o[6258]+1;l[o[4969]](g);}e=o[a+108>>2];}o[a+116>>2]=0;}o[a+116>>2]=d;o[a+112>>2]=f;m[a+120|0]=1;}o[(e<<2)+d>>2]=o[b+4>>2];c=e+1|0;o[a+108>>2]=c;j:{if((c|0)!=(f|0)){g=d;f=c;break j}e=f?f<<1:1;if((f|0)>=(e|0)){g=d;break j}c=0;g=0;if(e){o[6257]=o[6257]+1;g=l[o[4968]](e<<2,16)|0;f=o[a+108>>2];d=o[a+116>>2];}k:{l:{if((f|0)>=1){while(1){i=c<<2;o[i+g>>2]=o[d+i>>2];c=c+1|0;if((f|0)!=(c|0)){continue}break l}}if(!d){break k}}if(p[a+120|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}f=o[a+108>>2];}o[a+116>>2]=0;}o[a+116>>2]=g;o[a+112>>2]=e;m[a+120|0]=1;}o[(f<<2)+g>>2]=o[b+8>>2];b=f+1|0;o[a+108>>2]=b;a=o[a+32>>2];o[a+16>>2]=g;o[a+12>>2]=o[a+12>>2]+1;c=((b|0)/3|0)+ -1|0;}return c}function Nd(a,b,c){var d=0,e=0,f=0,g=v(0),h=0,i=v(0),j=v(0),k=0,l=0,m=v(0),r=v(0),t=v(0),u=0,w=0,x=0,y=v(0),z=0;h=K-32|0;K=h;u=o[a+56>>2];a:{if((c-b|0)==1){b:{if(p[a+60|0]){b=o[a+116>>2]+(b<<4)|0;d=b;l=o[d+4>>2];c=o[a+136>>2]+(u<<4)|0;e=c;o[e>>2]=o[d>>2];o[e+4>>2]=l;break b}b=o[a+76>>2]+(b<<6)|0;e=b;l=o[e+4>>2];c=o[a+96>>2]+(u<<6)|0;d=c;o[d>>2]=o[e>>2];o[d+4>>2]=l;d=o[e+60>>2];o[c+56>>2]=o[e+56>>2];o[c+60>>2]=d;d=o[e+52>>2];o[c+48>>2]=o[e+48>>2];o[c+52>>2]=d;d=o[e+44>>2];o[c+40>>2]=o[e+40>>2];o[c+44>>2]=d;d=o[e+36>>2];o[c+32>>2]=o[e+32>>2];o[c+36>>2]=d;d=o[e+28>>2];o[c+24>>2]=o[e+24>>2];o[c+28>>2]=d;d=o[e+20>>2];o[c+16>>2]=o[e+16>>2];o[c+20>>2]=d;}e=o[b+12>>2];o[c+8>>2]=o[b+8>>2];o[c+12>>2]=e;o[a+56>>2]=o[a+56>>2]+1;break a}x=Ou(a,b,c,Pu(a,b,c));l=o[a+56>>2];c:{if(p[a+60|0]){i=s[a+40>>2];j=s[a+8>>2];m=s[a+24>>2];r=s[a+44>>2];t=s[a+12>>2];y=s[a+28>>2];e=o[a+136>>2]+(l<<4)|0;d=e;g=v(v(s[a+20>>2]-s[a+4>>2])*s[a+36>>2]);d:{if(g<v(4294967296)&g>=v(0)){f=~~g>>>0;break d}f=0;}n[d>>1]=f&65534;d=e;g=v(v(y-t)*r);e:{if(g<v(4294967296)&g>=v(0)){f=~~g>>>0;break e}f=0;}n[d+4>>1]=f&65534;g=v(v(m-j)*i);f:{if(g<v(4294967296)&g>=v(0)){d=~~g>>>0;break f}d=0;}n[e+2>>1]=d&65534;break c}k=o[a+24>>2];e=o[a+96>>2]+(l<<6)|0;o[e>>2]=o[a+20>>2];o[e+4>>2]=k;d=o[a+32>>2];o[e+8>>2]=o[a+28>>2];o[e+12>>2]=d;}e=o[a+56>>2];g:{if(p[a+60|0]){m=s[a+40>>2];g=s[a+8>>2];r=s[a+44>>2];i=s[a+12>>2];e=o[a+136>>2]+(e<<4)|0;d=e;j=s[a+4>>2];j=v(v(v(j-j)*s[a+36>>2])+v(1));h:{if(j<v(4294967296)&j>=v(0)){f=~~j>>>0;break h}f=0;}n[d+6>>1]=f|1;d=e;i=v(v(v(i-i)*r)+v(1));i:{if(i<v(4294967296)&i>=v(0)){f=~~i>>>0;break i}f=0;}n[d+10>>1]=f|1;g=v(v(v(g-g)*m)+v(1));j:{if(g<v(4294967296)&g>=v(0)){d=~~g>>>0;break j}d=0;}n[e+8>>1]=d|1;break g}k=o[a+8>>2];e=o[a+96>>2]+(e<<6)|0;o[e+16>>2]=o[a+4>>2];o[e+20>>2]=k;d=o[a+16>>2];o[e+24>>2]=o[a+12>>2];o[e+28>>2]=d;}k=o[a+56>>2];if((c|0)>(b|0)){e=b;while(1){k:{if(p[a+60|0]){d=o[a+116>>2]+(e<<4)|0;f=q[d+4>>1];w=q[d+2>>1];z=q[d>>1];g=s[a+44>>2];i=s[a+40>>2];j=s[a+36>>2];o[h+28>>2]=0;m=s[a+4>>2];s[h+16>>2]=v(v(z>>>0)/j)+m;r=s[a+8>>2];s[h+20>>2]=v(v(w>>>0)/i)+r;t=s[a+12>>2];s[h+24>>2]=v(v(f>>>0)/g)+t;f=q[d+6>>1];w=q[d+8>>1];d=q[d+10>>1];o[h+12>>2]=0;s[h+8>>2]=t+v(v(d>>>0)/g);s[h+4>>2]=r+v(v(w>>>0)/i);s[h>>2]=m+v(v(f>>>0)/j);break k}d=o[a+76>>2]+(e<<6)|0;f=o[d+12>>2];o[h+24>>2]=o[d+8>>2];o[h+28>>2]=f;f=o[d+4>>2];o[h+16>>2]=o[d>>2];o[h+20>>2]=f;f=o[d+28>>2];o[h+8>>2]=o[d+24>>2];o[h+12>>2]=f;f=o[d+20>>2];o[h>>2]=o[d+16>>2];o[h+4>>2]=f;}Nu(a,k,h+16|0,h);k=o[a+56>>2];e=e+1|0;if((e|0)!=(c|0)){continue}break}}d=k+1|0;o[a+56>>2]=d;Nd(a,b,x);k=o[a+56>>2];Nd(a,x,c);e=p[a+60|0];b=o[a+56>>2]-u|0;if(!(!e|(b|0)<129)){Mu(a,d,k);e=p[a+60|0];}if(e&255){o[(o[a+136>>2]+(l<<4)|0)+12>>2]=0-b;break a}o[(o[a+96>>2]+(l<<6)|0)+32>>2]=b;}K=h+32|0;}function Zg(a,b,c,d,e,f,g){var h=v(0),i=v(0),j=0,k=v(0),m=0,n=v(0),p=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=0,z=v(0),A=v(0),B=v(0),D=v(0),E=v(0),F=v(0),G=0,H=0,I=0,J=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0;m=K-32|0;K=m;B=s[c+4>>2];D=s[d+4>>2];E=s[c>>2];F=s[d>>2];p=s[a+28>>2];z=s[a+12>>2];u=s[d+8>>2];w=s[c+8>>2];h=v((u<w?u:w)+s[e+8>>2]);h=h<z?z:h;k=s[a+44>>2];h=v(v((p<h?p:h)-z)*k);a:{if(h<v(4294967296)&h>=v(0)){G=~~h>>>0;break a}G=0;}r=s[a+24>>2];A=s[a+8>>2];h=v((D<B?D:B)+s[e+4>>2]);h=h<A?A:h;x=s[a+40>>2];h=v(v((r<h?r:h)-A)*x);b:{if(h<v(4294967296)&h>=v(0)){H=~~h>>>0;break b}H=0;}n=s[a+20>>2];t=s[a+4>>2];h=v((F<E?F:E)+s[e>>2]);h=h<t?t:h;i=s[a+36>>2];h=v(v((n<h?n:h)-t)*i);c:{if(h<v(4294967296)&h>=v(0)){I=~~h>>>0;break c}I=0;}h=v((w<u?u:w)+s[f+8>>2]);h=h<z?z:h;h=v(v(v((p<h?p:h)-z)*k)+v(1));d:{if(h<v(4294967296)&h>=v(0)){y=~~h>>>0;break d}y=0;}h=v((B<D?D:B)+s[f+4>>2]);h=h<A?A:h;h=v(v(v((r<h?r:h)-A)*x)+v(1));e:{if(h<v(4294967296)&h>=v(0)){j=~~h>>>0;break e}j=0;}h=v((E<F?F:E)+s[f>>2]);h=h<t?t:h;h=v(v(v((n<h?n:h)-t)*i)+v(1));f:{if(h<v(4294967296)&h>=v(0)){d=~~h>>>0;break f}d=0;}if(0<(g|0)){n=v(F-E);x=v(D-B);i=v(u-w);h=v(v(1)/v(C(v(v(v(n*n)+v(x*x))+v(i*i)))));k=v(i*h);p=v(i*k);i=v(n*h);h=v(x*h);x=v(p+v(v(n*i)+v(x*h)));O=G&65534;P=H&65534;Q=I&65534;R=y|1;S=j|1;T=d|1;d=o[a+136>>2];t=k==v(0)?v(0xde0b6b000000000):v(v(1)/k);y=t<v(0);U=(y<<4)+m|8;u=h==v(0)?v(0xde0b6b000000000):v(v(1)/h);j=u<v(0);V=(j<<4)+m|4;W=((y^1)<<4)+m|8;X=((j^1)<<4)+m|4;w=i==v(0)?v(0xde0b6b000000000):v(v(1)/i);j=w<v(0);Y=(j<<4)+m|0;Z=((j^1)<<4)+m|0;while(1){M=o[d+12>>2];j=0;g:{h:{i:{j:{if(Q>>>0>q[d+6>>1]){break j}N=q[d>>1];if(T>>>0<N>>>0|O>>>0>q[d+10>>1]){break j}G=q[d+4>>1];if(R>>>0<G>>>0|P>>>0>q[d+8>>1]){break j}H=q[d+2>>1];if(S>>>0<H>>>0){break j}p=s[a+12>>2];r=s[a+44>>2];n=s[a+8>>2];k=s[a+40>>2];i=s[a+4>>2];h=s[a+36>>2];o[m+12>>2]=0;I=q[d+10>>1];y=q[d+8>>1];j=q[d+6>>1];o[m+28>>2]=0;s[m>>2]=v(i+v(v(N>>>0)/h))-s[f>>2];s[m+4>>2]=v(n+v(v(H>>>0)/k))-s[f+4>>2];s[m+8>>2]=v(p+v(v(G>>>0)/r))-s[f+8>>2];s[m+16>>2]=v(i+v(v(j>>>0)/h))-s[e>>2];s[m+20>>2]=v(n+v(v(y>>>0)/k))-s[e+4>>2];s[m+24>>2]=v(p+v(v(I>>>0)/r))-s[e+8>>2];k:{i=s[c+4>>2];p=v(u*v(s[V>>2]-i));h=s[c>>2];k=v(w*v(s[Z>>2]-h));if(p>k){break k}r=v(w*v(s[Y>>2]-h));i=v(u*v(s[X>>2]-i));if(r>i){break k}h=s[c+8>>2];n=v(t*v(s[U>>2]-h));k=i<k?i:k;if(n>k){break k}i=p>r?p:r;h=v(t*v(s[W>>2]-h));if(i>h){break k}j=(n>i?n:i)<x&(h<k?h:k)>v(0);if(!j|(M|0)<0){break j}j=o[d+12>>2];l[o[o[b>>2]+8>>2]](b,j>>21,j&2097151);break i}j=0;}if((M|0)>-1){break i}if(!j){break h}}J=J+1|0;d=d+16|0;break g}j=o[d+12>>2];J=J-j|0;d=d-(j<<4)|0;}L=L+1|0;if((J|0)<(g|0)){continue}break}}if(o[5677]<(L|0)){o[5677]=L;}K=m+32|0;}function Gv(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,r=0,s=0,t=0,v=0,w=0,x=0;e=K-32|0;K=e;d=l[o[o[a>>2]+28>>2]](a)|0;o[b>>2]=0;o[b+20>>2]=d;if(d){t=l[o[o[c>>2]+16>>2]](c,32,d)|0;i=o[t+8>>2];o[b>>2]=l[o[o[c>>2]+28>>2]](c,i);x=l[o[o[a>>2]+28>>2]](a)|0;if((x|0)>0){while(1){l[o[o[a>>2]+16>>2]](a,e+28|0,e+4|0,e+16|0,e+8|0,e+24|0,e+20|0,e,e+12|0,s);d=o[e>>2];o[i+24>>2]=d;f=o[e+4>>2];o[i>>2]=0;o[i+4>>2]=0;o[i+28>>2]=f;o[i+8>>2]=0;o[i+12>>2]=0;o[i+16>>2]=0;o[i+20>>2]=0;f=o[e+12>>2]+ -2|0;a:{if(f>>>0>3){break a}b:{switch(f-1|0){default:if(!d){break a}f=l[o[o[c>>2]+16>>2]](c,4,u(d,3))|0;j=o[f+8>>2];o[i+8>>2]=l[o[o[c>>2]+28>>2]](c,j);if(o[e>>2]>=1){d=0;k=o[e+24>>2];while(1){h=j+u(d,12)|0;g=k+u(o[e+20>>2],d)|0;o[h>>2]=o[g>>2];o[h+4>>2]=o[g+4>>2];o[h+8>>2]=o[g+8>>2];d=d+1|0;if((d|0)<o[e>>2]){continue}break}}l[o[o[c>>2]+20>>2]](c,f,14966,1497453121,o[f+8>>2]);break a;case 0:if(!d){break a}h=l[o[o[c>>2]+16>>2]](c,8,d)|0;j=o[h+8>>2];o[i+12>>2]=l[o[o[c>>2]+28>>2]](c,j);d=0;if(o[e>>2]>=1){while(1){f=j+(d<<3)|0;g=o[e+24>>2]+u(o[e+20>>2],d)|0;n[f>>1]=q[g>>1];n[f+2>>1]=q[g+2>>1];g=q[g+4>>1];n[f+6>>1]=0;n[f+4>>1]=g;d=d+1|0;if((d|0)<o[e>>2]){continue}break}}l[o[o[c>>2]+20>>2]](c,h,14981,1497453121,o[h+8>>2]);break a;case 1:break a;case 2:break b}}if(!d){break a}h=l[o[o[c>>2]+16>>2]](c,4,d)|0;j=o[h+8>>2];o[i+16>>2]=l[o[o[c>>2]+28>>2]](c,j);d=0;if(o[e>>2]>=1){while(1){f=j+(d<<2)|0;g=o[e+24>>2]+u(o[e+20>>2],d)|0;m[f|0]=p[g|0];m[f+1|0]=p[g+1|0];g=p[g+2|0];m[f+3|0]=0;m[f+2|0]=g;d=d+1|0;if((d|0)<o[e>>2]){continue}break}}l[o[o[c>>2]+20>>2]](c,h,15008,1497453121,o[h+8>>2]);}d=o[e+16>>2];c:{if(d>>>0>1){break c}if(d-1){d=o[e+4>>2];if(!d){break c}f=l[o[o[c>>2]+16>>2]](c,16,d)|0;j=o[f+8>>2];o[i>>2]=l[o[o[c>>2]+28>>2]](c,j);k=o[e+4>>2];if((k|0)>=1){d=0;v=o[e+8>>2];w=o[e+28>>2];while(1){h=j+(d<<4)|0;g=w+u(d,v)|0;o[h>>2]=o[g>>2];o[h+4>>2]=o[g+4>>2];o[h+8>>2]=o[g+8>>2];d=d+1|0;if((k|0)!=(d|0)){continue}break}}l[o[o[c>>2]+20>>2]](c,f,15031,1497453121,o[f+8>>2]);break c}d=o[e+4>>2];if(!d){break c}g=l[o[o[c>>2]+16>>2]](c,32,d)|0;j=o[g+8>>2];o[i+4>>2]=l[o[o[c>>2]+28>>2]](c,j);k=o[e+4>>2];if((k|0)>=1){d=0;v=o[e+8>>2];w=o[e+28>>2];while(1){h=w+u(d,v)|0;r=o[h+4>>2];f=j+(d<<5)|0;o[f>>2]=o[h>>2];o[f+4>>2]=r;r=o[h+12>>2];o[f+8>>2]=o[h+8>>2];o[f+12>>2]=r;r=o[h+20>>2];o[f+16>>2]=o[h+16>>2];o[f+20>>2]=r;d=d+1|0;if((k|0)!=(d|0)){continue}break}}l[o[o[c>>2]+20>>2]](c,g,15050,1497453121,o[g+8>>2]);}l[o[o[a>>2]+24>>2]](a,s);i=i+32|0;s=s+1|0;if((x|0)!=(s|0)){continue}break}}l[o[o[c>>2]+20>>2]](c,t,15070,1497453121,o[t+8>>2]);}o[b+24>>2]=0;o[b+4>>2]=o[a+4>>2];o[b+8>>2]=o[a+8>>2];o[b+12>>2]=o[a+12>>2];o[b+16>>2]=o[a+16>>2];K=e+32|0;return 15085}function $v(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var f=v(0),g=0,h=0,j=0,k=v(0),q=0,r=v(0),t=0,u=0,w=0,x=v(0),y=v(0),z=v(0),A=v(0),B=0,C=0,D=0,E=v(0),F=v(0),G=v(0),H=0;h=o[b+40>>2];g=o[b+24>>2];q=o[b+8>>2];x=s[b+8>>2];t=x<v(0xde0b6b000000000)?q:1566444395;r=s[b+24>>2];t=r<(e(0,t),i())?g:t;k=s[b+40>>2];f=(e(0,k<(e(0,t),i())?h:t),i());j=h;h=x>v(-0xde0b6b000000000)?q:-581039253;h=r>(e(0,h),i())?g:h;x=(e(0,k>(e(0,h),i())?j:h),i());q=v(x-f)<v(.0020000000949949026);h=o[a+8>>2];E=s[h+12>>2];F=s[h+44>>2];f=v(v((q?v(f+v(-.0010000000474974513)):f)-E)*F);a:{if(f<v(4294967296)&f>=v(0)){g=~~f>>>0;break a}g=0;}t=g&65534;g=o[b+36>>2];u=o[b+20>>2];B=o[b+4>>2];r=s[b+4>>2];j=r<v(0xde0b6b000000000)?B:1566444395;k=s[b+20>>2];j=k<(e(0,j),i())?u:j;y=s[b+36>>2];f=(e(0,y<(e(0,j),i())?g:j),i());j=g;g=r>v(-0xde0b6b000000000)?B:-581039253;g=k>(e(0,g),i())?u:g;r=(e(0,y>(e(0,g),i())?j:g),i());u=v(r-f)<v(.0020000000949949026);y=s[h+8>>2];G=s[h+40>>2];f=v(v((u?v(f+v(-.0010000000474974513)):f)-y)*G);b:{if(f<v(4294967296)&f>=v(0)){g=~~f>>>0;break b}g=0;}B=g&65534;g=o[b+32>>2];j=o[b+16>>2];C=o[b>>2];k=s[b>>2];w=k<v(0xde0b6b000000000)?C:1566444395;z=s[b+16>>2];w=z<(e(0,w),i())?j:w;A=s[b+32>>2];f=(e(0,A<(e(0,w),i())?g:w),i());b=k>v(-0xde0b6b000000000)?C:-581039253;b=z>(e(0,b),i())?j:b;k=(e(0,A>(e(0,b),i())?g:b),i());g=v(k-f)<v(.0020000000949949026);z=s[h+4>>2];A=s[h+36>>2];f=v(v((g?v(f+v(-.0010000000474974513)):f)-z)*A);c:{if(f<v(4294967296)&f>=v(0)){b=~~f>>>0;break c}b=0;}j=b&65534;f=v(v(v((q?v(x+v(.0010000000474974513)):x)-E)*F)+v(1));d:{if(f<v(4294967296)&f>=v(0)){b=~~f>>>0;break d}b=0;}C=b|1;f=v(v(v((u?v(r+v(.0010000000474974513)):r)-y)*G)+v(1));e:{if(f<v(4294967296)&f>=v(0)){b=~~f>>>0;break e}b=0;}u=b|1;f=v(v(v((g?v(k+v(.0010000000474974513)):k)-z)*A)+v(1));f:{if(f<v(4294967296)&f>=v(0)){b=~~f>>>0;break f}b=0;}w=b|1;H=c<<21|d;a=o[a+4>>2];c=o[a+4>>2];g:{if((c|0)!=o[a+8>>2]){break g}d=c?c<<1:1;if((c|0)>=(d|0)){break g}h:{if(!d){h=0;break h}o[6257]=o[6257]+1;h=l[o[4968]](d<<4,16)|0;c=o[a+4>>2];}if((c|0)>=1){b=0;while(1){g=b<<4;q=g+h|0;g=g+o[a+12>>2]|0;D=o[g+4>>2];o[q>>2]=o[g>>2];o[q+4>>2]=D;D=o[g+12>>2];o[q+8>>2]=o[g+8>>2];o[q+12>>2]=D;b=b+1|0;if((c|0)!=(b|0)){continue}break}}b=o[a+12>>2];if(b){if(p[a+16|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+12>>2]=0;}o[a+12>>2]=h;m[a+16|0]=1;o[a+8>>2]=d;c=o[a+4>>2];}b=o[a+12>>2]+(c<<4)|0;o[b+12>>2]=H;n[b+6>>1]=w;n[b+4>>1]=t;n[b+2>>1]=B;n[b>>1]=j;n[b+10>>1]=C;n[b+8>>1]=u;o[a+4>>2]=o[a+4>>2]+1;}function zn(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,n=0,q=0,r=0;a:{b:{if((f|0)>=0){h=o[a+16>>2];c:{if((h|0)>=1){n=o[a+12>>2];while(1){q=n+(g<<2)|0;k=o[q>>2];i=o[o[k+28>>2]+208>>2];if((i|0)<=-1){i=o[o[k+32>>2]+208>>2];}if((f|0)==(i|0)){break c}g=g+1|0;if((g|0)<(h|0)){continue}break}}q=0;}k=0;if((g|0)<(h|0)){r=o[a+12>>2];while(1){n=o[r+(g<<2)>>2];i=o[o[n+28>>2]+208>>2];if((i|0)<=-1){i=o[o[n+32>>2]+208>>2];}k=((f|0)==(i|0))+k|0;g=g+1|0;if((h|0)!=(g|0)){continue}break}}g=o[a+4>>2];if(o[g+80>>2]<2){break a}if((c|0)<1){break b}f=o[a+36>>2];g=o[a+32>>2];while(1){r=(j<<2)+b|0;d:{if((f|0)!=(g|0)){break d}i=f?f<<1:1;if((f|0)>=(i|0)){g=f;break d}g=0;h=0;if(i){o[6257]=o[6257]+1;h=l[o[4968]](i<<2,16)|0;f=o[a+32>>2];}if((f|0)>=1){while(1){n=g<<2;o[n+h>>2]=o[o[a+40>>2]+n>>2];g=g+1|0;if((g|0)!=(f|0)){continue}break}}g=o[a+40>>2];if(g){if(p[a+44|0]){if(g){o[6258]=o[6258]+1;l[o[4969]](g);}f=o[a+32>>2];}o[a+40>>2]=0;}g=f;o[a+40>>2]=h;m[a+44|0]=1;o[a+36>>2]=i;f=i;}o[o[a+40>>2]+(g<<2)>>2]=o[r>>2];g=g+1|0;o[a+32>>2]=g;j=j+1|0;if((j|0)!=(c|0)){continue}break}break b}f=o[a+8>>2];v(l[o[o[f>>2]+12>>2]](f,b,c,d,e,o[a+12>>2],o[a+16>>2],o[a+4>>2],o[a+20>>2],o[a+24>>2]));return}if((e|0)>=1){f=o[a+56>>2];g=o[a+52>>2];j=0;while(1){i=(j<<2)+d|0;e:{if((f|0)!=(g|0)){break e}b=f?f<<1:1;if((f|0)>=(b|0)){g=f;break e}g=0;h=0;if(b){o[6257]=o[6257]+1;h=l[o[4968]](b<<2,16)|0;f=o[a+52>>2];}if((f|0)>=1){while(1){c=g<<2;o[c+h>>2]=o[c+o[a+60>>2]>>2];g=g+1|0;if((g|0)!=(f|0)){continue}break}}c=o[a+60>>2];if(c){if(p[a+64|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}f=o[a+52>>2];}o[a+60>>2]=0;}g=f;o[a+60>>2]=h;m[a+64|0]=1;o[a+56>>2]=b;f=b;}o[o[a+60>>2]+(g<<2)>>2]=o[i>>2];g=g+1|0;o[a+52>>2]=g;j=j+1|0;if((j|0)!=(e|0)){continue}break}}f:{if(!k){g=o[a+72>>2];break f}f=o[a+76>>2];g=o[a+72>>2];j=0;while(1){d=(j<<2)+q|0;g:{if((f|0)!=(g|0)){break g}b=f?f<<1:1;if((f|0)>=(b|0)){g=f;break g}g=0;h=0;if(b){o[6257]=o[6257]+1;h=l[o[4968]](b<<2,16)|0;f=o[a+72>>2];}if((f|0)>=1){while(1){c=g<<2;o[c+h>>2]=o[c+o[a+80>>2]>>2];g=g+1|0;if((g|0)!=(f|0)){continue}break}}c=o[a+80>>2];if(c){if(p[a+84|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}f=o[a+72>>2];}o[a+80>>2]=0;}g=f;o[a+80>>2]=h;m[a+84|0]=1;o[a+76>>2]=b;f=b;}o[o[a+80>>2]+(g<<2)>>2]=o[d>>2];g=g+1|0;o[a+72>>2]=g;j=j+1|0;if((k|0)!=(j|0)){continue}break}}if((o[a+52>>2]+g|0)>o[o[a+4>>2]+80>>2]){xf(a);}return}f=o[a+8>>2];v(l[o[o[f>>2]+12>>2]](f,b,c,d,e,q,k,g,o[a+20>>2],o[a+24>>2]));}function ym(a,b,c){var d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0);b=b?o[b+252>>2]<<30>>31&b:0;o[a+64>>2]=0;o[a+68>>2]=0;o[a+144>>2]=0;o[a+148>>2]=0;o[a+88>>2]=0;o[a+92>>2]=0;o[a+80>>2]=0;o[a+84>>2]=0;o[a+72>>2]=0;o[a+76>>2]=0;o[a+152>>2]=0;o[a+156>>2]=0;o[a+160>>2]=0;o[a+164>>2]=0;o[a+168>>2]=0;o[a+172>>2]=0;a:{if(b){d=o[b+8>>2];o[a>>2]=o[b+4>>2];o[a+4>>2]=d;d=o[b+16>>2];o[a+8>>2]=o[b+12>>2];o[a+12>>2]=d;d=o[b+32>>2];o[a+24>>2]=o[b+28>>2];o[a+28>>2]=d;d=o[b+24>>2];o[a+16>>2]=o[b+20>>2];o[a+20>>2]=d;d=o[b+48>>2];o[a+40>>2]=o[b+44>>2];o[a+44>>2]=d;d=o[b+40>>2];o[a+32>>2]=o[b+36>>2];o[a+36>>2]=d;d=o[b+64>>2];o[a+56>>2]=o[b+60>>2];o[a+60>>2]=d;d=o[b+56>>2];o[a+48>>2]=o[b+52>>2];o[a+52>>2]=d;f=s[b+412>>2];g=s[b+416>>2];h=s[b+408>>2];e=s[b+404>>2];o[a+240>>2]=b;o[a+140>>2]=0;s[a+136>>2]=e*g;s[a+132>>2]=e*f;s[a+128>>2]=e*h;d=o[b+616>>2];o[a+104>>2]=o[b+612>>2];o[a+108>>2]=d;d=o[b+608>>2];o[a+96>>2]=o[b+604>>2];o[a+100>>2]=d;d=o[b+420>>2];o[a+120>>2]=o[b+416>>2];o[a+124>>2]=d;d=o[b+412>>2];o[a+112>>2]=o[b+408>>2];o[a+116>>2]=d;d=o[b+384>>2];o[a+184>>2]=o[b+380>>2];o[a+188>>2]=d;d=o[b+376>>2];o[a+176>>2]=o[b+372>>2];o[a+180>>2]=d;d=o[b+400>>2];o[a+200>>2]=o[b+396>>2];o[a+204>>2]=d;d=o[b+392>>2];o[a+192>>2]=o[b+388>>2];o[a+196>>2]=d;f=s[b+476>>2];g=s[b+480>>2];h=s[b+472>>2];e=s[b+404>>2];o[a+220>>2]=0;s[a+216>>2]=v(e*g)*c;s[a+212>>2]=v(e*f)*c;s[a+208>>2]=v(e*h)*c;h=s[b+340>>2];i=s[b+356>>2];j=s[b+328>>2];k=s[b+344>>2];l=s[b+360>>2];m=s[b+324>>2];e=s[b+488>>2];f=s[b+492>>2];g=s[b+496>>2];s[a+232>>2]=v(v(v(e*s[b+332>>2])+v(f*s[b+348>>2]))+v(g*s[b+364>>2]))*c;s[a+228>>2]=v(v(v(e*j)+v(f*k))+v(g*l))*c;s[a+224>>2]=v(v(v(m*e)+v(h*f))+v(i*g))*c;break a}o[a+4>>2]=0;o[a+8>>2]=0;o[a>>2]=1065353216;o[a+32>>2]=0;o[a+36>>2]=0;o[a+240>>2]=0;o[a+128>>2]=0;o[a+132>>2]=0;o[a+112>>2]=1065353216;o[a+116>>2]=1065353216;o[a+96>>2]=1065353216;o[a+100>>2]=1065353216;o[a+176>>2]=0;o[a+180>>2]=0;o[a+12>>2]=0;o[a+16>>2]=0;o[a+24>>2]=0;o[a+28>>2]=0;o[a+20>>2]=1065353216;o[a+44>>2]=0;o[a+48>>2]=0;o[a+40>>2]=1065353216;o[a+52>>2]=0;o[a+56>>2]=0;o[a+60>>2]=0;o[a+136>>2]=0;o[a+140>>2]=0;o[a+120>>2]=1065353216;o[a+124>>2]=0;o[a+104>>2]=1065353216;o[a+108>>2]=0;o[a+232>>2]=0;o[a+224>>2]=0;o[a+228>>2]=0;o[a+216>>2]=0;o[a+220>>2]=0;o[a+208>>2]=0;o[a+212>>2]=0;o[a+200>>2]=0;o[a+204>>2]=0;o[a+192>>2]=0;o[a+196>>2]=0;o[a+184>>2]=0;o[a+188>>2]=0;}o[a+236>>2]=0;}function tj(a,b,c,d){var e=0,f=0,g=0,h=0,i=v(0),j=v(0),k=v(0),n=v(0),q=v(0),r=v(0);if(a){i=s[b+24>>2];j=s[b+20>>2];f=o[c+8>>2];k=s[b+16>>2];n=s[b+8>>2];q=s[b+4>>2];r=s[b>>2];b=o[c+4>>2];if((b|0)<=-1){if((f|0)<=-1){e=o[c+12>>2];if(e){if(p[c+16|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[c+12>>2]=0;}m[c+16|0]=1;o[c+8>>2]=0;o[c+12>>2]=0;f=0;}while(1){o[o[c+12>>2]+(b<<2)>>2]=0;e=b+1|0;g=e>>>0>=b>>>0;b=e;if(g){continue}break}}e=0;o[c+4>>2]=0;if((f|0)<=63){o[6257]=o[6257]+1;f=l[o[4968]](256,16)|0;e=o[c+4>>2];if((e|0)>=1){b=0;while(1){g=b<<2;o[g+f>>2]=o[g+o[c+12>>2]>>2];b=b+1|0;if((e|0)!=(b|0)){continue}break}}b=o[c+12>>2];if(b){if(p[c+16|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}e=o[c+4>>2];}o[c+12>>2]=0;}o[c+12>>2]=f;m[c+16|0]=1;o[c+8>>2]=64;f=64;}a:{if((e|0)!=(f|0)){break a}h=f<<1;if((f|0)>=(h|0)){e=f;break a}b=0;b:{c:{if(!f){g=0;e=f;break c}o[6257]=o[6257]+1;g=l[o[4968]](f<<3,16)|0;e=o[c+4>>2];if((e|0)<1){break b}}while(1){f=b<<2;o[f+g>>2]=o[f+o[c+12>>2]>>2];b=b+1|0;if((e|0)!=(b|0)){continue}break}}b=o[c+12>>2];if(b){if(p[c+16|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}e=o[c+4>>2];}o[c+12>>2]=0;}o[c+12>>2]=g;m[c+16|0]=1;o[c+8>>2]=h;}o[o[c+12>>2]+(e<<2)>>2]=a;e=e+1|0;o[c+4>>2]=e;while(1){g=o[c+12>>2];b=e+ -1|0;a=o[g+(b<<2)>>2];o[c+4>>2]=b;d:{if(!(s[a>>2]<=k)){e=b;break d}if(!(s[a+16>>2]>=r)){e=b;break d}if(!(s[a+4>>2]<=j)){e=b;break d}if(!(s[a+20>>2]>=q)){e=b;break d}if(!(s[a+8>>2]<=i)){e=b;break d}if(!(s[a+24>>2]>=n)){e=b;break d}if(o[a+40>>2]){f=o[c+8>>2];e:{if((f|0)!=(b|0)){break e}f=b?b<<1:1;if((e|0)>(f|0)){f=b;break e}e=0;g=0;if(f){o[6257]=o[6257]+1;g=l[o[4968]](f<<2,16)|0;b=o[c+4>>2];}if((b|0)>=1){while(1){h=e<<2;o[h+g>>2]=o[h+o[c+12>>2]>>2];e=e+1|0;if((e|0)!=(b|0)){continue}break}}e=o[c+12>>2];if(e){if(p[c+16|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}b=o[c+4>>2];}o[c+12>>2]=0;}o[c+12>>2]=g;m[c+16|0]=1;o[c+8>>2]=f;}o[(b<<2)+g>>2]=o[a+36>>2];b=b+1|0;o[c+4>>2]=b;if((b|0)==(f|0)){e=f?f<<1:1;if((f|0)<(e|0)){b=0;g=0;if(e){o[6257]=o[6257]+1;g=l[o[4968]](e<<2,16)|0;f=o[c+4>>2];}if((f|0)>=1){while(1){h=b<<2;o[h+g>>2]=o[h+o[c+12>>2]>>2];b=b+1|0;if((f|0)!=(b|0)){continue}break}}b=o[c+12>>2];if(b){if(p[c+16|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}f=o[c+4>>2];}o[c+12>>2]=0;}o[c+12>>2]=g;m[c+16|0]=1;o[c+8>>2]=e;}b=f;}o[o[c+12>>2]+(b<<2)>>2]=o[a+40>>2];e=b+1|0;o[c+4>>2]=e;break d}l[o[o[d>>2]+12>>2]](d,a);e=o[c+4>>2];}if((e|0)>0){continue}break}}}function xj(a,b,c,d){a=a|0;b=b|0;c=c|0;d=v(d);var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),q=v(0),r=0,t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0);r=K-16|0;K=r;G=s[b+8>>2];E=s[c+8>>2];k=v(v(G*d)+E);H=s[b+4>>2];F=s[c+4>>2];I=v(v(H*d)+F);J=s[b>>2];e=v(J*d);d=s[c>>2];L=v(e+d);a:{if(p[a+232|0]){t=s[a+56>>2];m=v(-s[a+92>>2]);u=s[a+40>>2];j=s[a+88>>2];i=s[a+72>>2];e=s[a+96>>2];z=v(v(v(t*m)-v(u*j))-v(i*e));f=s[a+200>>2];w=s[a+60>>2];x=s[a+44>>2];n=s[a+76>>2];C=v(v(v(w*m)-v(x*j))-v(n*e));g=s[a+204>>2];y=s[a- -64>>2];h=v(y*m);m=s[a+48>>2];h=v(h-v(m*j));j=s[a+80>>2];A=v(h-v(j*e));e=s[a+208>>2];h=v(v(v(v(v(z*f)+v(C*g))+v(A*e))+s[a+224>>2])+v(v(k*v(v(v(i*f)+v(n*g))+v(j*e)))+v(v(L*v(v(v(u*f)+v(x*g))+v(m*e)))+v(I*v(v(v(t*f)+v(w*g))+v(y*e))))));f=s[a+168>>2];g=s[a+172>>2];e=s[a+176>>2];f=v(v(v(k*v(v(v(i*f)+v(n*g))+v(j*e)))+v(v(L*v(v(v(u*f)+v(x*g))+v(m*e)))+v(I*v(v(v(t*f)+v(w*g))+v(y*e)))))+v(v(v(v(f*z)+v(C*g))+v(A*e))+s[a+216>>2]));g=v(J*v(f-d));e=k;d=s[a+184>>2];k=s[a+188>>2];n=v(v(i*d)+v(n*k));i=s[a+192>>2];k=v(v(v(e*v(n+v(j*i)))+v(v(L*v(v(v(u*d)+v(x*k))+v(m*i)))+v(I*v(v(v(t*d)+v(w*k))+v(y*i)))))+v(v(v(v(z*d)+v(C*k))+v(A*i))+s[a+220>>2]));d=v(v(g+v(H*v(k-F)))+v(G*v(h-E)));s[r+8>>2]=h+v(G*d);s[r+4>>2]=k+v(H*d);s[r>>2]=f+v(J*d);break a}O=s[a+224>>2];t=s[a+208>>2];u=s[a+200>>2];i=s[a+204>>2];P=s[a+216>>2];f=s[a+172>>2];w=s[a+176>>2];x=s[a+168>>2];n=s[a+120>>2];h=v(-s[a+156>>2]);g=s[a+104>>2];B=s[a+152>>2];y=s[a+136>>2];D=s[a+160>>2];m=v(v(v(n*h)-v(g*B))-v(y*D));j=s[a+124>>2];e=s[a+108>>2];z=s[a+140>>2];C=v(v(v(j*h)-v(e*B))-v(z*D));A=s[a+128>>2];q=v(A*h);h=s[a+112>>2];q=v(q-v(h*B));B=s[a+144>>2];D=v(q-v(B*D));q=s[a+184>>2];M=s[a+188>>2];N=s[a+192>>2];q=v(v(v(E*v(v(v(y*q)+v(z*M))+v(B*N)))+v(v(d*v(v(v(g*q)+v(e*M))+v(h*N)))+v(F*v(v(v(n*q)+v(j*M))+v(A*N)))))+v(v(v(v(m*q)+v(C*M))+v(D*N))+s[a+220>>2]));s[r+4>>2]=q;f=v(v(v(E*v(v(v(y*x)+v(z*f))+v(B*w)))+v(v(d*v(v(v(g*x)+v(e*f))+v(h*w)))+v(F*v(v(v(n*x)+v(j*f))+v(A*w)))))+v(P+v(v(v(x*m)+v(C*f))+v(D*w))));s[r>>2]=f;d=v(v(O+v(v(v(m*u)+v(C*i))+v(D*t)))+v(v(E*v(v(v(y*u)+v(z*i))+v(B*t)))+v(v(d*v(v(v(g*u)+v(e*i))+v(h*t)))+v(F*v(v(v(n*u)+v(j*i))+v(A*t))))));s[r+8>>2]=d;d=v(v(v(J*v(L-f))+v(H*v(I-q)))+v(G*v(k-d)));}o[r+12>>2]=0;a=o[a+36>>2];l[o[o[a>>2]+16>>2]](a,b,r,d);K=r+16|0;}function Nl(a,b,c,d,e,f){var g=0,h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=0,w=0,x=0,y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=0,F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=0;g=K-96|0;K=g;o[g+92>>2]=d;o[g+88>>2]=c;o[g+84>>2]=b;o[g+80>>2]=a;h=s[d>>2];j=s[a>>2];i=s[d+4>>2];y=s[a+4>>2];m=s[d+8>>2];z=s[a+8>>2];o[g+44>>2]=0;n=v(z-m);s[g+40>>2]=n;p=v(y-i);s[g+36>>2]=p;r=v(j-h);s[g+32>>2]=r;A=s[b>>2];B=s[b+4>>2];G=s[b+8>>2];o[g+60>>2]=0;q=v(G-m);s[g+56>>2]=q;C=v(B-i);s[g+52>>2]=C;D=v(A-h);s[g+48>>2]=D;t=s[c>>2];k=s[c+4>>2];F=s[c+8>>2];o[g+76>>2]=0;H=v(F-m);s[g+72>>2]=H;I=v(k-i);s[g+68>>2]=I;J=v(t-h);s[g+64>>2]=J;l=v(-1);q=v(v(v(v(r*C)*H)+v(v(v(v(v(p*q)*J)+v(v(n*D)*I))-v(v(r*q)*I))-v(v(p*D)*H)))-v(v(n*C)*J));a:{if(q==v(0)|q!=q){break a}C=v(y-B);D=v(A-t);A=v(j-A);B=v(B-k);t=v(z*v(v(C*D)-v(A*B)));k=j;j=v(z-G);z=v(G-F);if(!(v(q*v(t+v(v(k*v(v(j*B)-v(C*z)))+v(y*v(v(A*z)-v(j*D))))))<=v(0))){break a}o[g+24>>2]=0;o[g+16>>2]=0;o[g+20>>2]=0;o[g+12>>2]=0;while(1){u=E<<2;w=o[u+4264>>2];x=(g+32|0)+(w<<4)|0;j=s[x+8>>2];y=s[x+4>>2];k=v(v(v(p*j)-v(n*y))*h);h=s[x>>2];b:{if(!(v(q*v(v(k+v(i*v(v(n*h)-v(j*r))))+v(v(v(y*r)-v(p*h))*m)))>v(0))){break b}x=w<<2;h=ef(o[u+(g+80|0)>>2],o[x+(g+80|0)>>2],d,g+16|0,g+12|0);if(h<l^1?!(l<v(0)):0){break b}L=1<<w;w=o[g+12>>2];o[f>>2]=((L&w<<30>>31)+(w<<1&8)|0)+(0-(w&1)&1<<E);o[e+u>>2]=o[g+16>>2];o[e+x>>2]=o[g+20>>2];o[(o[x+4264>>2]<<2)+e>>2]=0;o[e+12>>2]=o[g+24>>2];l=h;}E=E+1|0;if((E|0)!=3){u=(g+32|0)+(E<<4)|0;r=s[u>>2];n=s[u+8>>2];p=s[u+4>>2];m=s[d+8>>2];i=s[d+4>>2];h=s[d>>2];continue}break}if(!(l<v(0))){break a}o[f>>2]=15;l=s[c+4>>2];h=s[b+8>>2];i=s[d>>2];m=s[c+8>>2];n=s[b>>2];p=s[d+4>>2];t=v(v(v(l*h)*i)+v(v(m*n)*p));k=h;h=s[c>>2];j=v(l*n);l=s[d+8>>2];j=v(v(t-v(p*v(k*h)))-v(j*l));k=l;l=s[b+4>>2];l=v(v(v(j+v(k*v(h*l)))-v(i*v(m*l)))/q);s[e>>2]=l;h=s[a+4>>2];i=s[c+8>>2];m=s[d>>2];n=s[a+8>>2];p=s[c>>2];r=s[d+4>>2];t=v(v(v(h*i)*m)+v(v(n*p)*r));k=i;i=s[a>>2];j=v(h*p);h=s[d+8>>2];j=v(v(t-v(r*v(k*i)))-v(j*h));k=h;h=s[c+4>>2];h=v(v(v(j+v(k*v(i*h)))-v(m*v(n*h)))/q);s[e+4>>2]=h;i=s[b+4>>2];m=s[a+8>>2];n=s[d>>2];p=s[b+8>>2];r=s[a>>2];j=s[d+4>>2];F=v(v(v(i*m)*n)+v(v(p*r)*j));k=m;m=s[b>>2];t=v(i*r);i=s[d+8>>2];j=v(v(F-v(j*v(k*m)))-v(t*i));k=i;i=s[a+4>>2];q=v(v(v(j+v(k*v(m*i)))-v(n*v(p*i)))/q);s[e+8>>2]=q;s[e+12>>2]=v(1)-v(v(l+h)+q);l=v(0);}K=g+96|0;return l}function De(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0);d=K-144|0;K=d;o[d+108>>2]=0;f=s[b+80>>2];h=s[b+96>>2];q=s[b+120>>2];E=s[b+56>>2];z=s[b+112>>2];A=s[b+116>>2];F=s[b+52>>2];i=s[b+68>>2];r=s[b+84>>2];t=s[b+100>>2];g=s[b+20>>2];n=s[b+36>>2];u=s[b+72>>2];j=s[b+88>>2];p=s[b+24>>2];k=s[b+104>>2];w=s[b+40>>2];m=s[b+64>>2];x=s[b+32>>2];y=s[b>>2];B=s[b+16>>2];G=s[b+48>>2];C=s[b+4>>2];D=s[b+8>>2];o[d+100>>2]=0;o[d+84>>2]=0;o[d+68>>2]=0;s[d+80>>2]=v(v(D*u)+v(p*j))+v(w*k);s[d+76>>2]=v(v(C*u)+v(g*j))+v(n*k);s[d- -64>>2]=v(v(D*i)+v(p*r))+v(w*t);s[d+60>>2]=v(v(C*i)+v(g*r))+v(n*t);z=v(G-z);A=v(F-A);q=v(E-q);s[d+96>>2]=v(v(u*z)+v(j*A))+v(k*q);s[d+92>>2]=v(v(z*i)+v(A*r))+v(q*t);o[d+52>>2]=0;s[d+72>>2]=v(v(y*u)+v(B*j))+v(x*k);s[d+56>>2]=v(v(y*i)+v(B*r))+v(x*t);s[d+48>>2]=v(v(m*D)+v(f*p))+v(h*w);s[d+44>>2]=v(v(m*C)+v(f*g))+v(h*n);s[d+40>>2]=v(v(m*y)+v(f*B))+v(h*x);s[d+88>>2]=v(v(z*m)+v(A*f))+v(q*h);a:{if(!Oj(a,d+88|0,d+128|0,d+112|0,d+108|0,s[a+12>>2])){break a}if(e){r=s[b+72>>2];t=s[b+64>>2];u=s[b+68>>2];j=s[b+88>>2];k=s[b+80>>2];m=s[b+84>>2];g=s[b+104>>2];n=s[b+96>>2];p=s[b+100>>2];f=s[d+120>>2];h=s[d+112>>2];i=s[d+116>>2];o[d+36>>2]=0;w=v(v(v(h*n)+v(i*p))+v(f*g));s[d+32>>2]=-w;x=v(v(v(h*k)+v(i*m))+v(f*j));s[d+28>>2]=-x;y=v(v(v(t*h)+v(u*i))+v(r*f));s[d+24>>2]=-y;B=s[b+112>>2];C=s[b+116>>2];f=s[b+120>>2];o[d+20>>2]=0;h=s[d+128>>2];i=s[d+132>>2];q=g;g=s[d+136>>2];q=v(f+v(v(v(n*h)+v(p*i))+v(q*g)));f=s[d+108>>2];s[d+16>>2]=q+v(w*f);s[d+12>>2]=v(C+v(v(v(h*k)+v(i*m))+v(g*j)))+v(x*f);s[d+8>>2]=v(B+v(v(v(h*t)+v(i*u))+v(g*r)))+v(y*f);l[o[o[c>>2]+16>>2]](c,d+24|0,d+8|0,f);break a}f=s[b+72>>2];h=s[b+64>>2];i=s[b+68>>2];r=s[b+88>>2];t=s[b+80>>2];u=s[b+84>>2];j=s[b+104>>2];k=s[b+96>>2];m=s[b+100>>2];o[d+36>>2]=0;g=s[d+112>>2];n=s[d+116>>2];p=s[d+120>>2];s[d+32>>2]=v(v(k*g)+v(m*n))+v(j*p);s[d+28>>2]=v(v(g*t)+v(n*u))+v(p*r);s[d+24>>2]=v(v(h*g)+v(i*n))+v(f*p);g=s[b+112>>2];n=s[b+116>>2];p=s[b+120>>2];o[d+20>>2]=0;q=k;k=s[d+128>>2];w=m;m=s[d+132>>2];x=j;j=s[d+136>>2];s[d+16>>2]=p+v(v(v(q*k)+v(w*m))+v(x*j));s[d+12>>2]=n+v(v(v(k*t)+v(m*u))+v(j*r));s[d+8>>2]=g+v(v(v(k*h)+v(m*i))+v(j*f));l[o[o[c>>2]+16>>2]](c,d+24|0,d+8|0,s[d+108>>2]);}K=d+144|0;}function qu(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0,r=0,s=0,t=0,v=0,w=0,x=0,y=0;f=o[a+12>>2];l=o[b+8>>2];a:{b:{if(o[f+88>>2]!=o[l+88>>2]|o[f+92>>2]!=o[l+92>>2]){break b}e=o[l+4>>2];if((e|0)==(l|0)){o[c>>2]=f;b=o[l+8>>2];a=0;if(!b){break a}o[d>>2]=o[b+12>>2];return 0}f=o[l>>2];o[e>>2]=f;o[f+4>>2]=e;if(o[b>>2]==(l|0)){k=b;i=f;j=o[f+88>>2];g=o[e+88>>2];if(!((j|0)<(g|0)|(o[f+92>>2]<o[e+92>>2]?(g|0)==(j|0):0))){i=e;}o[k>>2]=i;}if(o[b+4>>2]!=(l|0)){break b}j=o[f+88>>2];g=o[e+88>>2];if(!((g|0)!=(j|0)|o[f+92>>2]<=o[e+92>>2]?(j|0)<=(g|0):0)){o[b+4>>2]=f;break b}o[b+4>>2]=e;}t=o[b>>2];x=o[a>>2];y=o[a+4>>2];g=y;v=o[b+4>>2];e=v;j=0;f=0;i=1;while(1){q=h;l=f;w=j;k=o[g+88>>2];h=u(o[e+88>>2]-k|0,i);c:{if((h|0)>=1){j=g;while(1){f=e;k=o[e+92>>2];g=h;while(1){d:{h=o[j+92>>2];n=k-h|0;p=!q<<2;e=o[p+j>>2];if((e|0)==(j|0)){break d}m=o[e+92>>2]-h|0;if((m|0)>0){break d}r=o[e+88>>2];h=u(r-o[j+88>>2]|0,i);if((h|0)>-1|(u(g,m)|0)>(u(h,n)|0)?h:0){break d}g=u(o[f+88>>2]-r|0,i);j=e;continue}break}e=o[f+p>>2];if((f|0)==(e|0)){break c}p=o[e+92>>2]-k|0;if((p|0)>-1){break c}k=o[e+88>>2];h=u(k-o[j+88>>2]|0,i);if((h|0)<1){break c}k=u(k-o[f+88>>2]|0,i);if(!k){continue}if((k|0)>-1){break c}if((u(g,p)|0)<(u(k,n)|0)){continue}break}break c}if((h|0)<=-1){e:while(1){n=o[e+92>>2];r=((q|0)!=0)<<2;f=o[r+e>>2];while(1){k=h;j=g;h=o[g+92>>2];p=n-h|0;f:{if((e|0)==(f|0)){break f}m=o[f+92>>2]-n|0;if((m|0)<0){break f}s=o[f+88>>2];g=u(s-o[e+88>>2]|0,i);if((g|0)>-1|(u(k,m)|0)>(u(g,p)|0)?g:0){break f}h=u(s-o[j+88>>2]|0,i);e=f;g=j;continue e}g=o[j+r>>2];if((j|0)==(g|0)){f=e;break c}s=o[g+92>>2]-h|0;if((s|0)<1){f=e;break c}m=o[g+88>>2];h=u(o[e+88>>2]-m|0,i);if((h|0)>-1){f=e;break c}m=u(m-o[j+88>>2]|0,i);if(!m){continue}if((m|0)>-1){f=e;break c}if((u(k,s)|0)<(u(m,p)|0)){continue}break}break}f=e;break c}h=o[g+92>>2];i=g;while(1){g:{j=i;i=o[(!q<<2)+i>>2];if((i|0)==(g|0)|(k|0)!=o[i+88>>2]){break g}f=o[i+92>>2];n=(f|0)<=(h|0);h=f;if(n){continue}}break}h=o[e+92>>2];i=e;while(1){f=i;i=o[f+(((q|0)!=0)<<2)>>2];if((i|0)==(e|0)|(k|0)!=o[i+88>>2]){break c}g=o[i+92>>2];n=(g|0)>=(h|0);h=g;if(n){continue}break}}h=1;i=-1;g=x;e=t;if(!q){continue}break}o[j+4>>2]=f;o[f>>2]=j;o[w>>2]=l;o[l+4>>2]=w;if(o[t+88>>2]<o[x+88>>2]){o[a>>2]=t;}if(o[v+88>>2]>=o[y+88>>2]){o[a+4>>2]=v;}o[a+12>>2]=o[b+12>>2];o[c>>2]=w;a=1;}o[d>>2]=l;return a}function wm(a,b,c,d,e,f){var i=0,j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=0,t=v(0),w=v(0),x=v(0),y=0,z=0,A=0,B=0,C=0,D=0,E=v(0),F=v(0),G=v(0),H=v(0),I=v(0);o[b+48>>2]=-2147483648;o[b+52>>2]=-2147483648;o[b+16>>2]=0;o[b+20>>2]=0;o[b+56>>2]=-2147483648;o[b+60>>2]=0;o[b+24>>2]=0;o[b+28>>2]=0;r=o[a+16>>2];a=o[(r+u(d,244)|0)+240>>2];i=o[(u(e,244)+r|0)+240>>2];o[b+148>>2]=e;o[b+144>>2]=d;o[b+132>>2]=0;s[b+104>>2]=f;o[b+96>>2]=0;o[b+100>>2]=0;j=s[c>>2];w=s[c+4>>2];l=s[c+8>>2];o[b+12>>2]=0;s[b+8>>2]=-l;k=v(-w);s[b+4>>2]=k;x=v(-j);s[b>>2]=x;z=b;if(a){A=(g(v(v(v(v(s[a+360>>2]*k)-v(j*s[a+356>>2]))-v(l*s[a+364>>2]))*s[a+612>>2])),h(0));B=(g(v(v(v(v(s[a+344>>2]*k)-v(j*s[a+340>>2]))-v(l*s[a+348>>2]))*s[a+608>>2])),h(0));y=(g(v(v(v(v(s[a+328>>2]*k)-v(j*s[a+324>>2]))-v(l*s[a+332>>2]))*s[a+604>>2])),h(0));}else {y=0;}o[z+64>>2]=y;o[b+76>>2]=0;o[b+72>>2]=A;o[b+68>>2]=B;m=s[c>>2];n=s[c+4>>2];p=s[c+8>>2];o[b+44>>2]=o[c+12>>2];s[b+40>>2]=p;s[b+36>>2]=n;s[b+32>>2]=m;c=0;if(i){C=(g(v(v(v(v(m*s[i+356>>2])+v(n*s[i+360>>2]))+v(p*s[i+364>>2]))*s[i+612>>2])),h(0));D=(g(v(v(v(v(m*s[i+324>>2])+v(n*s[i+328>>2]))+v(p*s[i+332>>2]))*s[i+604>>2])),h(0));c=(g(v(v(v(v(m*s[i+340>>2])+v(n*s[i+344>>2]))+v(p*s[i+348>>2]))*s[i+608>>2])),h(0));}o[b+80>>2]=D;o[b+92>>2]=0;o[b+88>>2]=C;o[b+84>>2]=c;if(a){t=v(v(v(s[a+360>>2]*k)-v(j*s[a+356>>2]))-v(l*s[a+364>>2]));E=v(v(v(s[a+344>>2]*k)-v(j*s[a+340>>2]))-v(l*s[a+348>>2]));q=v(v(v(s[a+328>>2]*k)-v(j*s[a+324>>2]))-v(l*s[a+332>>2]));}c=b;k=v(v(v(v(E*k)-v(j*q))-v(l*t))+v(0));if(i){F=v(v(v(m*s[i+356>>2])+v(n*s[i+360>>2]))+v(p*s[i+364>>2]));G=v(v(v(m*s[i+340>>2])+v(n*s[i+344>>2]))+v(p*s[i+348>>2]));j=v(v(v(s[i+324>>2]*m)+v(s[i+328>>2]*n))+v(s[i+332>>2]*p));}else {j=v(0);}t=v(v(1)/v(k+v(v(v(j*m)+v(G*n))+v(F*p))));s[c+108>>2]=t;j=v(0);k=v(0);q=v(0);if(a){a=u(d,244)+r|0;j=v(v(v(v(s[a+176>>2]+s[a+208>>2])*v(0))+v(v(s[a+180>>2]+s[a+212>>2])*v(0)))+v(v(s[a+184>>2]+s[a+216>>2])*v(0)));q=s[a+192>>2];H=s[a+196>>2];k=s[a+200>>2];}q=v(j+v(v(v(q*x)-v(w*H))-v(l*k)));a:{if(!i){j=v(-0);k=v(0);l=v(0);break a}a=u(e,244)+r|0;j=v(v(v(v(s[a+176>>2]+s[a+208>>2])*v(-0))+v(v(s[a+180>>2]+s[a+212>>2])*v(-0)))+v(v(s[a+184>>2]+s[a+216>>2])*v(-0)));I=s[a+200>>2];k=s[a+196>>2];l=s[a+192>>2];}s[b+124>>2]=f;s[b+116>>2]=0;s[b+120>>2]=-f;s[b+112>>2]=t*v(v(0)-v(q+v(j+v(v(p*I)+v(v(n*k)+v(m*l))))));}function we(a,b,c){var d=0,e=0,f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=0,H=v(0),I=v(0),J=v(0);d=K-160|0;K=d;f=o[a+4>>2];e=o[f+12>>2];H=s[e+52>>2];I=s[e+56>>2];g=s[e+24>>2];h=s[e+20>>2];i=s[e+40>>2];j=s[e+36>>2];J=s[e+48>>2];k=s[e+8>>2];m=s[e>>2];n=s[e+4>>2];p=s[e+16>>2];q=s[e+32>>2];e=o[o[f+4>>2]+28>>2]+u(c,80)|0;r=s[e+32>>2];t=s[e>>2];w=s[e+16>>2];x=s[e+56>>2];y=s[e+52>>2];z=s[e+48>>2];A=s[e+36>>2];B=s[e+20>>2];C=s[e+4>>2];D=s[e+40>>2];E=s[e+24>>2];F=s[e+8>>2];f=0;o[d+156>>2]=0;o[d+140>>2]=0;o[d+124>>2]=0;s[d+136>>2]=v(v(q*F)+v(j*E))+v(i*D);s[d+132>>2]=v(v(q*C)+v(j*B))+v(i*A);s[d+120>>2]=v(v(p*F)+v(h*E))+v(g*D);s[d+116>>2]=v(v(p*C)+v(h*B))+v(g*A);s[d+152>>2]=I+v(v(v(q*z)+v(j*y))+v(i*x));s[d+148>>2]=H+v(v(v(p*z)+v(h*y))+v(g*x));o[d+108>>2]=0;s[d+128>>2]=v(v(q*t)+v(j*w))+v(i*r);s[d+112>>2]=v(v(p*t)+v(h*w))+v(g*r);s[d+96>>2]=v(v(m*t)+v(n*w))+v(k*r);s[d+104>>2]=v(v(m*F)+v(n*E))+v(k*D);s[d+100>>2]=v(v(m*C)+v(n*B))+v(k*A);s[d+144>>2]=J+v(v(v(m*z)+v(n*y))+v(k*x));l[o[o[b>>2]+8>>2]](b,d+96|0,d+80|0,d- -64|0);g=s[o[a+20>>2]+32>>2];s[d+80>>2]=s[d+80>>2]-g;s[d+84>>2]=s[d+84>>2]-g;s[d+88>>2]=s[d+88>>2]-g;s[d+64>>2]=g+s[d+64>>2];s[d+68>>2]=g+s[d+68>>2];s[d+72>>2]=g+s[d+72>>2];e=o[a+8>>2];G=o[e+4>>2];l[o[o[G>>2]+8>>2]](G,o[e+12>>2],d+48|0,d+32|0);e=o[5643];a:{if(e){if(!l[e](o[o[a+8>>2]+4>>2],b)){break a}}f=s[d+64>>2]<s[d+48>>2]|s[d+80>>2]>s[d+32>>2]?f:1;e=0;e=s[d+72>>2]<s[d+56>>2]|s[d+88>>2]>s[d+40>>2]?e:f;if(s[d+68>>2]<s[d+52>>2]|s[d+84>>2]>s[d+36>>2]|e^1){break a}e=o[a+4>>2];f=o[e+8>>2];o[d+28>>2]=c;o[d+24>>2]=-1;o[d+16>>2]=f;o[d+12>>2]=b;o[d+8>>2]=e;o[d+20>>2]=d+96;b:{if(!!(s[o[a+20>>2]+32>>2]>v(0))){b=o[a+12>>2];b=l[o[o[b>>2]+8>>2]](b,d+8|0,o[a+8>>2],0,2)|0;break b}e=c<<2;b=o[e+o[a+24>>2]>>2];if(b){break b}b=o[a+12>>2];b=l[o[o[b>>2]+8>>2]](b,d+8|0,o[a+8>>2],o[a+28>>2],1)|0;o[e+o[a+24>>2]>>2]=b;b=o[e+o[a+24>>2]>>2];}f=o[a+20>>2];e=o[f+8>>2];c:{if(o[e+8>>2]==o[o[a+4>>2]+8>>2]){o[f+8>>2]=d+8;l[o[o[f>>2]+8>>2]](f,-1,c);break c}e=o[f+12>>2];o[f+12>>2]=d+8;l[o[o[f>>2]+12>>2]](f,-1,c);}l[o[o[b>>2]+8>>2]](b,d+8|0,o[a+8>>2],o[a+16>>2],o[a+20>>2]);b=o[a+20>>2];o[(o[o[b+8>>2]+8>>2]==o[o[a+4>>2]+8>>2]?8:12)+b>>2]=e;}K=d+160|0;}function Mu(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,r=0,s=0,t=0,u=0;r=K-32|0;K=r;s=o[a+136>>2];d=o[(s+(c<<4)|0)+12>>2];t=(d|0)>-1?1:0-d|0;d=o[((b<<4)+s|0)+12>>2];u=(d|0)>-1?1:0-d|0;if((u|0)<=128){f=o[a+152>>2];d=f;a:{if((d|0)!=o[a+156>>2]){break a}d=f;i=d?d<<1:1;if((d|0)>=(i|0)){break a}b:{if(!i){d=0;g=f;break b}o[6257]=o[6257]+1;d=l[o[4968]](i<<5,16)|0;g=o[a+152>>2];}if((g|0)>=1){while(1){e=j<<5;h=e+d|0;e=e+o[a+160>>2]|0;k=o[e+4>>2];o[h>>2]=o[e>>2];o[h+4>>2]=k;k=o[e+28>>2];o[h+24>>2]=o[e+24>>2];o[h+28>>2]=k;k=o[e+20>>2];o[h+16>>2]=o[e+16>>2];o[h+20>>2]=k;k=o[e+12>>2];o[h+8>>2]=o[e+8>>2];o[h+12>>2]=k;j=j+1|0;if((g|0)!=(j|0)){continue}break}}g=o[a+160>>2];if(g){if(p[a+164|0]){if(g){o[6258]=o[6258]+1;l[o[4969]](g);}}o[a+160>>2]=0;}o[a+160>>2]=d;o[a+156>>2]=i;m[a+164|0]=1;d=o[a+152>>2];}o[a+152>>2]=d+1;d=r;e=o[d+4>>2];g=f<<5;f=g+o[a+160>>2]|0;o[f>>2]=o[d>>2];o[f+4>>2]=e;e=o[d+28>>2];o[f+24>>2]=o[d+24>>2];o[f+28>>2]=e;e=o[d+20>>2];o[f+16>>2]=o[d+16>>2];o[f+20>>2]=e;e=o[d+12>>2];o[f+8>>2]=o[d+8>>2];o[f+12>>2]=e;d=g+o[a+160>>2]|0;f=(b<<4)+s|0;n[d>>1]=q[f>>1];n[d+2>>1]=q[f+2>>1];n[d+4>>1]=q[f+4>>1];n[d+6>>1]=q[f+6>>1];n[d+8>>1]=q[f+8>>1];f=q[f+10>>1];o[d+16>>2]=u;o[d+12>>2]=b;n[d+10>>1]=f;}if((t|0)<=128){f=o[a+152>>2];d=f;c:{if((d|0)!=o[a+156>>2]){break c}d=f;h=d?d<<1:1;if((d|0)>=(h|0)){break c}d:{if(!h){b=0;d=f;break d}o[6257]=o[6257]+1;b=l[o[4968]](h<<5,16)|0;d=o[a+152>>2];}if((d|0)>=1){j=0;while(1){e=j<<5;g=e+b|0;e=e+o[a+160>>2]|0;i=o[e+4>>2];o[g>>2]=o[e>>2];o[g+4>>2]=i;i=o[e+28>>2];o[g+24>>2]=o[e+24>>2];o[g+28>>2]=i;i=o[e+20>>2];o[g+16>>2]=o[e+16>>2];o[g+20>>2]=i;i=o[e+12>>2];o[g+8>>2]=o[e+8>>2];o[g+12>>2]=i;j=j+1|0;if((d|0)!=(j|0)){continue}break}}d=o[a+160>>2];if(d){if(p[a+164|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+160>>2]=0;}o[a+160>>2]=b;o[a+156>>2]=h;m[a+164|0]=1;d=o[a+152>>2];}o[a+152>>2]=d+1;b=r;e=o[b+4>>2];f=f<<5;d=f+o[a+160>>2]|0;o[d>>2]=o[b>>2];o[d+4>>2]=e;g=o[b+28>>2];o[d+24>>2]=o[b+24>>2];o[d+28>>2]=g;g=o[b+20>>2];o[d+16>>2]=o[b+16>>2];o[d+20>>2]=g;g=o[b+12>>2];o[d+8>>2]=o[b+8>>2];o[d+12>>2]=g;b=f+o[a+160>>2]|0;d=(c<<4)+s|0;n[b>>1]=q[d>>1];n[b+2>>1]=q[d+2>>1];n[b+4>>1]=q[d+4>>1];n[b+6>>1]=q[d+6>>1];n[b+8>>1]=q[d+8>>1];d=q[d+10>>1];o[b+16>>2]=t;o[b+12>>2]=c;n[b+10>>1]=d;}o[a+168>>2]=o[a+152>>2];K=r+32|0;}function Ln(a,b,c,d){var e=0,f=0,g=0,h=v(0),i=0,j=0,k=0,m=0,n=v(0),q=v(0);e=K-304|0;K=e;if((c|0)>=1){while(1){g=o[(m<<2)+b>>2];o[g+268>>2]=1065353216;a:{b:{j=o[g+220>>2]+ -2|0;if(j>>>0>3){break b}switch(j-1|0){case 0:case 1:break b;default:break a}}if(p[g+204|0]&3){break a}ub(g,d,e+240|0);c:{if(!p[a+44|0]){break c}h=s[g+276>>2];h=v(h*h);if(h==v(0)){break c}q=h;h=v(s[e+288>>2]-s[g+52>>2]);n=v(h*h);h=v(s[e+292>>2]-s[g+56>>2]);n=v(n+v(h*h));h=v(s[e+296>>2]-s[g+60>>2]);if(!(q<v(n+v(h*h)))){break c}l[o[4966]](2729);d:{if(o[o[g+192>>2]+4>>2]<=19){j=0;o[5207]=o[5207]+1;f=o[a+68>>2];f=l[o[o[f>>2]+36>>2]](f)|0;k=o[a+24>>2];o[e+140>>2]=-1;o[e+132>>2]=1065353216;o[e+136>>2]=1;i=o[g+64>>2];o[e+152>>2]=o[g+60>>2];o[e+156>>2]=i;i=o[g+56>>2];o[e+144>>2]=o[g+52>>2];o[e+148>>2]=i;i=o[e+300>>2];o[e+168>>2]=o[e+296>>2];o[e+172>>2]=i;i=o[e+292>>2];o[e+160>>2]=o[e+288>>2];o[e+164>>2]=i;o[e+208>>2]=0;o[e+128>>2]=3052;o[e+220>>2]=f;o[e+224>>2]=k;o[e+216>>2]=0;o[e+212>>2]=g;f=o[g+272>>2];sa(e+72|0);o[e+96>>2]=1065353216;o[e+88>>2]=1065353216;o[e+92>>2]=1065353216;o[e+76>>2]=8;o[e+72>>2]=11388;o[e+108>>2]=0;o[e+112>>2]=0;o[e+116>>2]=0;o[e+100>>2]=0;o[e+104>>2]=0;o[e+124>>2]=0;o[e+120>>2]=f;o[e+104>>2]=f;o[e+216>>2]=o[a+56>>2];f=o[g+188>>2];o[e+136>>2]=o[f+4>>2];o[e+140>>2]=o[f+8>>2];f=o[e+252>>2];o[e+16>>2]=o[e+248>>2];o[e+20>>2]=f;f=o[e+244>>2];o[e+8>>2]=o[e+240>>2];o[e+12>>2]=f;f=o[e+268>>2];o[e+32>>2]=o[e+264>>2];o[e+36>>2]=f;f=o[e+260>>2];o[e+24>>2]=o[e+256>>2];o[e+28>>2]=f;f=o[e+284>>2];o[e+48>>2]=o[e+280>>2];o[e+52>>2]=f;f=o[e+276>>2];o[e+40>>2]=o[e+272>>2];o[e+44>>2]=f;f=o[e+300>>2];o[e+64>>2]=o[e+296>>2];o[e+68>>2]=f;f=o[e+292>>2];o[e+56>>2]=o[e+288>>2];o[e+60>>2]=f;k=g+4|0;f=k;i=o[f+12>>2];o[e+16>>2]=o[f+8>>2];o[e+20>>2]=i;i=o[f+4>>2];o[e+8>>2]=o[f>>2];o[e+12>>2]=i;f=o[g+32>>2];o[e+32>>2]=o[g+28>>2];o[e+36>>2]=f;f=o[g+24>>2];o[e+24>>2]=o[g+20>>2];o[e+28>>2]=f;f=o[g+48>>2];o[e+48>>2]=o[g+44>>2];o[e+52>>2]=f;f=o[g+40>>2];o[e+40>>2]=o[g+36>>2];o[e+44>>2]=f;Pc(a,e+72|0,k,e+8|0,e+128|0);h=s[e+132>>2];if(!!(h<v(1))){s[g+268>>2]=h;ub(g,v(h*d),e+240|0);o[g+268>>2]=0;hd(g,e+240|0);j=4;}if(j){break d}}j=0;}l[o[4967]]();if(j){break a}}hd(g,e+240|0);}m=m+1|0;if((m|0)!=(c|0)){continue}break}}K=e+304|0;}function da(a,b,c){var d=0,e=0,f=v(0),g=v(0),h=v(0),i=0,j=0,k=0,m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0);k=K-16|0;K=k;d=o[a+844>>2];a:{if((d|0)<1){break a}while(1){p=s[b+48>>2];w=s[b+8>>2];x=s[b>>2];y=s[b+4>>2];q=s[b+52>>2];z=s[b+24>>2];m=s[b+16>>2];A=s[b+20>>2];f=s[b+56>>2];g=s[b+40>>2];h=s[b+32>>2];r=s[b+36>>2];i=d+ -1|0;e=u(i,208)+a|0;o[e- -64>>2]=0;B=f;f=s[e+4>>2];C=v(h*f);h=s[e+8>>2];n=g;g=s[e+12>>2];r=v(B+v(v(C+v(r*h))+v(n*g)));s[e+60>>2]=r;q=v(q+v(v(v(f*m)+v(h*A))+v(g*z)));s[e+56>>2]=q;p=v(p+v(v(v(f*x)+v(h*y))+v(g*w)));s[e+52>>2]=p;w=s[c+56>>2];x=s[c+40>>2];y=s[c+32>>2];z=s[c+36>>2];m=s[c+52>>2];A=s[c+24>>2];D=s[c+16>>2];E=s[c+20>>2];f=s[c+48>>2];g=s[c+8>>2];h=s[c>>2];t=s[c+4>>2];o[e+48>>2]=0;B=f;f=s[e+20>>2];C=v(h*f);h=s[e+24>>2];n=g;g=s[e+28>>2];t=v(B+v(v(C+v(t*h))+v(n*g)));s[e+36>>2]=t;m=v(m+v(v(v(f*D)+v(h*E))+v(g*A)));s[e+40>>2]=m;f=v(w+v(v(v(f*y)+v(h*z))+v(g*x)));s[e+44>>2]=f;s[e+84>>2]=v(v(v(p-t)*s[e+68>>2])+v(v(q-m)*s[e+72>>2]))+v(v(r-f)*s[e+76>>2]);o[e+168>>2]=o[e+168>>2]+1;e=(d|0)>1;d=i;if(e){continue}break}c=o[a+844>>2];if((c|0)<1){break a}while(1){b=c;c=b+ -1|0;d=u(c,208)+a|0;e=d+4|0;f=s[d+84>>2];h=s[a+848>>2];b:{if(!(f<=h)){i=o[d+120>>2];c:{if(!i){break c}j=o[5379];if(!j){break c}l[j](i)|0;o[d+120>>2]=0;}i=a;j=o[a+844>>2];d=b;if((j|0)!=(d|0)){d=u(j+ -1|0,208)+a|0;ra(e,d+4|0,208);o[d+168>>2]=0;o[d+120>>2]=0;o[d+132>>2]=0;o[d+136>>2]=0;o[d+140>>2]=0;o[d+144>>2]=0;d=o[a+844>>2];}d=d+ -1|0;o[i+844>>2]=d;if(d){break b}d=o[5382];if(!d){break b}o[k+12>>2]=a;l[d](k+12|0);break b}g=v(s[d+36>>2]-v(s[d+52>>2]-v(s[d+68>>2]*f)));n=v(g*g);g=v(s[d+40>>2]-v(s[d+56>>2]-v(f*s[d+72>>2])));f=v(s[d+44>>2]-v(s[d+60>>2]-v(f*s[d+76>>2])));if(!!(v(v(n+v(g*g))+v(f*f))>v(h*h))){i=o[d+120>>2];d:{if(!i){break d}j=o[5379];if(!j){break d}l[j](i)|0;o[d+120>>2]=0;}i=a;j=o[a+844>>2];d=b;if((j|0)!=(d|0)){d=u(j+ -1|0,208)+a|0;ra(e,d+4|0,208);o[d+168>>2]=0;o[d+120>>2]=0;o[d+132>>2]=0;o[d+136>>2]=0;o[d+140>>2]=0;o[d+144>>2]=0;d=o[a+844>>2];}d=d+ -1|0;o[i+844>>2]=d;if(d){break b}d=o[5382];if(!d){break b}o[k+8>>2]=a;l[d](k+8|0);break b}d=o[5380];if(!d){break b}l[d](e,o[a+836>>2],o[a+840>>2])|0;}if((b|0)>1){continue}break}}K=k+16|0;}function um(a,b,c,d,e,f){var g=v(0),h=v(0),i=0,j=v(0),k=v(0),l=0,m=0,n=0,p=0,q=v(0),r=v(0),t=0,w=0,x=v(0),y=v(0),z=v(0);p=o[a+76>>2];t=o[b+140>>2];w=o[f+72>>2];a:{if(w&4){n=o[a+16>>2];b=o[(n+u(d,244)|0)+240>>2];m=o[(u(c,244)+n|0)+240>>2];i=u(t,152)+p|0;g=v(s[e+136>>2]*s[f+68>>2]);s[i+100>>2]=g;if(m){j=s[m+416>>2];k=s[i+24>>2];q=s[m+412>>2];r=s[i+20>>2];a=u(c,244)+n|0;h=s[m+404>>2];s[a+64>>2]=v(v(g*v(v(h*s[i+16>>2])*s[m+408>>2]))*s[a+112>>2])+s[a+64>>2];s[a+68>>2]=v(v(g*v(q*v(h*r)))*s[a+116>>2])+s[a+68>>2];s[a+72>>2]=v(v(g*v(j*v(h*k)))*s[a+120>>2])+s[a+72>>2];h=s[i+72>>2];j=s[i+68>>2];s[a+80>>2]=v(v(g*s[a+96>>2])*s[i+64>>2])+s[a+80>>2];k=s[a+104>>2];s[a+84>>2]=v(j*v(g*s[a+100>>2]))+s[a+84>>2];s[a+88>>2]=v(h*v(g*k))+s[a+88>>2];}if(b){l=u(t,152)+p|0;j=s[l+88>>2];k=s[l+84>>2];q=s[l+80>>2];r=s[b+416>>2];x=s[l+56>>2];y=s[b+412>>2];z=s[l+52>>2];a=u(d,244)+n|0;h=s[b+404>>2];g=s[i+100>>2];s[a+64>>2]=s[a+64>>2]+v(v(v(v(h*s[l+48>>2])*s[b+408>>2])*g)*s[a+112>>2]);s[a+68>>2]=s[a+68>>2]+v(v(g*v(y*v(h*z)))*s[a+116>>2]);s[a+72>>2]=s[a+72>>2]+v(v(g*v(r*v(h*x)))*s[a+120>>2]);s[a+80>>2]=s[a+80>>2]+v(q*v(g*s[a+96>>2]));h=s[a+104>>2];s[a+84>>2]=s[a+84>>2]+v(k*v(g*s[a+100>>2]));s[a+88>>2]=s[a+88>>2]+v(j*v(h*g));}if(!(w&16)){break a}l=t+1|0;i=u(l,152)+p|0;g=v(s[e+140>>2]*s[f+68>>2]);s[i+100>>2]=g;if(m){j=s[i+24>>2];k=s[i+20>>2];a=u(c,244)+n|0;h=s[m+404>>2];s[a+64>>2]=v(v(g*v(h*s[i+16>>2]))*s[a+112>>2])+s[a+64>>2];s[a+68>>2]=v(v(g*v(h*k))*s[a+116>>2])+s[a+68>>2];s[a+72>>2]=v(v(g*v(h*j))*s[a+120>>2])+s[a+72>>2];h=s[i+72>>2];j=s[i+68>>2];s[a+80>>2]=v(v(g*s[a+96>>2])*s[i+64>>2])+s[a+80>>2];k=s[a+104>>2];s[a+84>>2]=v(j*v(g*s[a+100>>2]))+s[a+84>>2];s[a+88>>2]=v(h*v(g*k))+s[a+88>>2];}if(!b){break a}c=u(l,152)+p|0;j=s[c+88>>2];k=s[c+84>>2];q=s[c+56>>2];r=s[c+52>>2];x=s[c+48>>2];h=s[b+404>>2];a=u(d,244)+n|0;g=s[i+100>>2];s[a+80>>2]=s[a+80>>2]+v(s[c+80>>2]*v(s[a+96>>2]*g));s[a+64>>2]=s[a+64>>2]+v(v(g*v(h*x))*s[a+112>>2]);s[a+68>>2]=s[a+68>>2]+v(v(g*v(h*r))*s[a+116>>2]);s[a+72>>2]=s[a+72>>2]+v(v(g*v(h*q))*s[a+120>>2]);h=s[a+104>>2];s[a+84>>2]=s[a+84>>2]+v(k*v(g*s[a+100>>2]));s[a+88>>2]=s[a+88>>2]+v(j*v(h*g));return}a=u(t,152)+p|0;o[a+100>>2]=0;if(!(w&16)){break a}o[a+252>>2]=0;}}function cg(a,b,c){var d=0,e=v(0),f=v(0);d=K-32|0;K=d;o[d+28>>2]=a;o[d+24>>2]=b;o[d+20>>2]=c;a=K-16|0;o[a+12>>2]=o[d+28>>2];b=K-16|0;s[b+12>>2]=s[o[a+12>>2]+8>>2];a:{if(v(w(s[b+12>>2]))>v(.7071067690849304)){a=K-16|0;o[a+12>>2]=o[d+28>>2];e=s[o[a+12>>2]+4>>2];a=K-16|0;o[a+12>>2]=o[d+28>>2];e=v(e*s[o[a+12>>2]+4>>2]);a=K-16|0;o[a+12>>2]=o[d+28>>2];f=s[o[a+12>>2]+8>>2];a=K-16|0;o[a+12>>2]=o[d+28>>2];s[d+16>>2]=e+v(f*s[o[a+12>>2]+8>>2]);a=K-16|0;s[a+12>>2]=s[d+16>>2];s[d+12>>2]=v(1)/v(C(s[a+12>>2]));a=K-16|0;o[a+12>>2]=o[d+24>>2];s[o[a+12>>2]>>2]=0;a=K-16|0;o[a+12>>2]=o[d+28>>2];e=v(v(-s[o[a+12>>2]+8>>2])*s[d+12>>2]);a=K-16|0;o[a+12>>2]=o[d+24>>2];s[o[a+12>>2]+4>>2]=e;a=K-16|0;o[a+12>>2]=o[d+28>>2];e=v(s[o[a+12>>2]+4>>2]*s[d+12>>2]);a=K-16|0;o[a+12>>2]=o[d+24>>2];s[o[a+12>>2]+8>>2]=e;e=v(s[d+16>>2]*s[d+12>>2]);a=K-16|0;o[a+12>>2]=o[d+20>>2];s[o[a+12>>2]>>2]=e;a=K-16|0;o[a+12>>2]=o[d+28>>2];e=v(-s[o[a+12>>2]>>2]);a=K-16|0;o[a+12>>2]=o[d+24>>2];e=v(e*s[o[a+12>>2]+8>>2]);a=K-16|0;o[a+12>>2]=o[d+20>>2];s[o[a+12>>2]+4>>2]=e;a=K-16|0;o[a+12>>2]=o[d+28>>2];e=s[o[a+12>>2]>>2];a=K-16|0;o[a+12>>2]=o[d+24>>2];e=v(e*s[o[a+12>>2]+4>>2]);break a}a=K-16|0;o[a+12>>2]=o[d+28>>2];e=s[o[a+12>>2]>>2];a=K-16|0;o[a+12>>2]=o[d+28>>2];e=v(e*s[o[a+12>>2]>>2]);a=K-16|0;o[a+12>>2]=o[d+28>>2];f=s[o[a+12>>2]+4>>2];a=K-16|0;o[a+12>>2]=o[d+28>>2];s[d+8>>2]=e+v(f*s[o[a+12>>2]+4>>2]);a=K-16|0;s[a+12>>2]=s[d+8>>2];s[d+4>>2]=v(1)/v(C(s[a+12>>2]));a=K-16|0;o[a+12>>2]=o[d+28>>2];e=v(v(-s[o[a+12>>2]+4>>2])*s[d+4>>2]);a=K-16|0;o[a+12>>2]=o[d+24>>2];s[o[a+12>>2]>>2]=e;a=K-16|0;o[a+12>>2]=o[d+28>>2];e=v(s[o[a+12>>2]>>2]*s[d+4>>2]);a=K-16|0;o[a+12>>2]=o[d+24>>2];s[o[a+12>>2]+4>>2]=e;a=K-16|0;o[a+12>>2]=o[d+24>>2];s[o[a+12>>2]+8>>2]=0;a=K-16|0;o[a+12>>2]=o[d+28>>2];e=v(-s[o[a+12>>2]+8>>2]);a=K-16|0;o[a+12>>2]=o[d+24>>2];e=v(e*s[o[a+12>>2]+4>>2]);a=K-16|0;o[a+12>>2]=o[d+20>>2];s[o[a+12>>2]>>2]=e;a=K-16|0;o[a+12>>2]=o[d+28>>2];e=s[o[a+12>>2]+8>>2];a=K-16|0;o[a+12>>2]=o[d+24>>2];e=v(e*s[o[a+12>>2]>>2]);a=K-16|0;o[a+12>>2]=o[d+20>>2];s[o[a+12>>2]+4>>2]=e;e=v(s[d+8>>2]*s[d+4>>2]);}a=K-16|0;o[a+12>>2]=o[d+20>>2];s[o[a+12>>2]+8>>2]=e;K=d+32|0;}function Fj(a,b,c,d,e,f,g,h,i,j){var k=0,n=v(0),q=v(0),r=0,t=0,w=v(0),x=v(0),y=0,z=0,A=0,B=v(0),D=0,E=0,F=0,G=v(0),H=v(0),I=0,J=0,L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0),R=v(0),S=v(0),T=v(0);t=K-32|0;K=t;n=s[a+8>>2];q=s[a>>2];w=s[a+4>>2];o[t+28>>2]=o[a+12>>2];x=n;n=v(v(1)/v(C(v(v(v(q*q)+v(w*w))+v(n*n)))));B=v(x*n);s[t+24>>2]=B;G=v(w*n);s[t+20>>2]=G;H=v(q*n);s[t+16>>2]=H;D=-1;r=o[c+28>>2];if((r|0)>=1){L=s[e+40>>2];M=s[e+36>>2];N=s[e+24>>2];O=s[e+20>>2];z=o[c+36>>2];P=s[e+32>>2];Q=s[e+16>>2];R=s[e+8>>2];S=s[e+4>>2];T=s[e>>2];a=0;n=v(-3.4028234663852886e+38);while(1){k=z+u(a,36)|0;q=s[k+20>>2];w=s[k+24>>2];x=s[k+28>>2];q=v(v(v(H*v(v(v(q*T)+v(w*S))+v(x*R)))+v(G*v(v(v(q*Q)+v(w*O))+v(x*N))))+v(B*v(v(v(q*P)+v(w*M))+v(x*L))));k=q>n;n=k?q:n;D=k?a:D;a=a+1|0;if((r|0)!=(a|0)){continue}break}}a=o[h+4>>2];if((a|0)<=-1){if(o[h+8>>2]<=-1){k=o[h+12>>2];if(k){if(p[h+16|0]){if(k){o[6258]=o[6258]+1;l[o[4969]](k);}}o[h+12>>2]=0;}m[h+16|0]=1;o[h+8>>2]=0;o[h+12>>2]=0;}while(1){r=o[t+4>>2];k=o[h+12>>2]+(a<<4)|0;o[k>>2]=o[t>>2];o[k+4>>2]=r;r=o[t+12>>2];o[k+8>>2]=o[t+8>>2];o[k+12>>2]=r;k=a+1|0;r=k>>>0>=a>>>0;a=k;if(r){continue}break}}o[h+4>>2]=0;I=o[c+36>>2]+u(D,36)|0;J=o[I+4>>2];if((J|0)>=1){k=0;r=0;while(1){a=o[c+16>>2]+(o[o[I+12>>2]+(r<<2)>>2]<<4)|0;n=s[a>>2];q=s[a+4>>2];w=s[a+8>>2];x=v(v(v(v(n*s[e+32>>2])+v(q*s[e+36>>2]))+v(w*s[e+40>>2]))+s[e+56>>2]);B=v(v(v(v(n*s[e+16>>2])+v(q*s[e+20>>2]))+v(w*s[e+24>>2]))+s[e+52>>2]);n=v(v(v(v(n*s[e>>2])+v(q*s[e+4>>2]))+v(w*s[e+8>>2]))+s[e+48>>2]);a:{if(o[h+8>>2]!=(k|0)){break a}z=k?k<<1:1;if((k|0)>=(z|0)){break a}a=0;E=0;if(z){o[6257]=o[6257]+1;E=l[o[4968]](z<<4,16)|0;k=o[h+4>>2];}if((k|0)>=1){while(1){y=a<<4;A=y+E|0;y=y+o[h+12>>2]|0;F=o[y+4>>2];o[A>>2]=o[y>>2];o[A+4>>2]=F;F=o[y+12>>2];o[A+8>>2]=o[y+8>>2];o[A+12>>2]=F;a=a+1|0;if((k|0)!=(a|0)){continue}break}}a=o[h+12>>2];if(a){if(p[h+16|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[h+12>>2]=0;}o[h+12>>2]=E;m[h+16|0]=1;o[h+8>>2]=z;k=o[h+4>>2];}a=o[h+12>>2]+(k<<4)|0;o[a+12>>2]=0;s[a+8>>2]=x;s[a+4>>2]=B;s[a>>2]=n;k=o[h+4>>2]+1|0;o[h+4>>2]=k;r=r+1|0;if((J|0)!=(r|0)){continue}break}}if((D|0)>-1){Ce(t+16|0,b,d,h,i,f,g,j);}K=t+32|0;}function _v(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var f=0,g=0,h=0,j=0,k=v(0),n=0,q=v(0),r=v(0),t=v(0),u=0,w=0,x=0,y=0,z=0,A=0,B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=0,J=0,L=0;n=K-32|0;K=n;q=s[b+44>>2];r=s[b+28>>2];t=s[b+12>>2];k=t>v(0)?t:v(0);k=k<r?r:k;G=k<q?q:k;k=t<v(0)?t:v(0);k=r<k?r:k;H=q<k?q:k;A=o[b+40>>2];f=o[b+24>>2];y=o[b+8>>2];B=s[b+8>>2];g=B>v(-0xde0b6b000000000)?y:-581039253;C=s[b+24>>2];g=C>(e(0,g),i())?f:g;D=s[b+40>>2];I=D>(e(0,g),i())?A:g;h=o[b+36>>2];j=o[b+20>>2];z=o[b+4>>2];E=s[b+4>>2];g=E>v(-0xde0b6b000000000)?z:-581039253;F=s[b+20>>2];g=F>(e(0,g),i())?j:g;q=s[b+36>>2];J=q>(e(0,g),i())?h:g;u=o[b+32>>2];x=o[b+16>>2];w=o[b>>2];r=s[b>>2];g=r>v(-0xde0b6b000000000)?w:-581039253;t=s[b+16>>2];g=t>(e(0,g),i())?x:g;k=s[b+32>>2];L=k>(e(0,g),i())?u:g;b=B<v(0xde0b6b000000000)?y:1566444395;b=C<(e(0,b),i())?f:b;y=D<(e(0,b),i())?A:b;b=E<v(0xde0b6b000000000)?z:1566444395;b=F<(e(0,b),i())?j:b;z=q<(e(0,b),i())?h:b;b=r<v(0xde0b6b000000000)?w:1566444395;b=t<(e(0,b),i())?x:b;g=k<(e(0,b),i())?u:b;j=o[a+4>>2];b=o[j+4>>2];a:{if((b|0)!=o[j+8>>2]){break a}u=b?b<<1:1;if((b|0)>=(u|0)){break a}b:{if(!u){x=0;break b}o[6257]=o[6257]+1;x=l[o[4968]](u<<6,16)|0;b=o[j+4>>2];}if((b|0)>=1){w=0;while(1){a=w<<6;f=a+x|0;h=a+o[j+12>>2]|0;a=o[h+4>>2];o[f>>2]=o[h>>2];o[f+4>>2]=a;a=o[h+60>>2];o[f+56>>2]=o[h+56>>2];o[f+60>>2]=a;a=o[h+52>>2];o[f+48>>2]=o[h+48>>2];o[f+52>>2]=a;a=o[h+44>>2];o[f+40>>2]=o[h+40>>2];o[f+44>>2]=a;a=o[h+36>>2];o[f+32>>2]=o[h+32>>2];o[f+36>>2]=a;a=o[h+28>>2];o[f+24>>2]=o[h+24>>2];o[f+28>>2]=a;a=o[h+20>>2];o[f+16>>2]=o[h+16>>2];o[f+20>>2]=a;a=o[h+12>>2];o[f+8>>2]=o[h+8>>2];o[f+12>>2]=a;w=w+1|0;if((w|0)!=(b|0)){continue}break}}a=o[j+12>>2];if(a){if(p[j+16|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[j+12>>2]=0;}o[j+12>>2]=x;m[j+16|0]=1;o[j+8>>2]=u;b=o[j+4>>2];}b=o[j+12>>2]+(b<<6)|0;o[b+40>>2]=d;o[b+36>>2]=c;o[b+32>>2]=-1;o[b+16>>2]=L;s[b+12>>2]=H;o[b+8>>2]=y;o[b+4>>2]=z;o[b>>2]=g;s[b+28>>2]=G;o[b+24>>2]=I;o[b+20>>2]=J;a=o[n+16>>2];o[b+44>>2]=o[n+12>>2];o[b+48>>2]=a;a=o[n+24>>2];o[b+52>>2]=o[n+20>>2];o[b+56>>2]=a;o[b+60>>2]=o[n+28>>2];o[j+4>>2]=o[j+4>>2]+1;K=n+32|0;}function ef(a,b,c,d,e){var f=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=0,n=v(0),p=v(0),q=v(0),r=v(0),t=0,u=v(0),w=v(0),x=v(0),y=v(0),z=0,A=v(0),B=v(0),D=0,E=v(0),F=v(0),G=v(0),H=v(0),I=0,J=v(0),L=v(0),M=v(0),N=0,O=0,P=0,Q=0;m=K+ -64|0;o[m+60>>2]=c;o[m+56>>2]=b;o[m+52>>2]=a;f=s[b>>2];k=s[a>>2];p=s[b+4>>2];j=s[a+4>>2];r=s[b+8>>2];n=s[a+8>>2];o[m+12>>2]=0;i=v(n-r);s[m+8>>2]=i;q=v(j-p);s[m+4>>2]=q;l=v(k-f);s[m>>2]=l;w=s[c>>2];x=s[c+4>>2];y=s[c+8>>2];o[m+44>>2]=0;o[m+28>>2]=0;E=v(y-n);s[m+40>>2]=E;F=v(x-j);s[m+36>>2]=F;y=v(r-y);s[m+24>>2]=y;A=v(p-x);s[m+20>>2]=A;G=v(w-k);s[m+32>>2]=G;B=v(f-w);s[m+16>>2]=B;p=v(-1);r=v(v(l*A)-v(q*B));w=v(v(q*y)-v(i*A));x=v(v(i*B)-v(l*y));H=v(v(r*r)+v(v(w*w)+v(x*x)));if(!(H>v(0))){return v(-1)}while(1){a:{if(!(v(v(v(k*v(v(r*q)-v(x*i)))+v(j*v(v(w*i)-v(r*l))))+v(v(v(x*l)-v(w*q))*n))>v(0))){f=p;break a}P=z<<2;Q=o[P+4252>>2];t=Q<<2;I=o[t+(m+52|0)>>2];J=s[I>>2];i=v(J-k);L=s[I+4>>2];q=v(L-j);M=s[I+8>>2];l=v(M-n);f=v(v(v(i*i)+v(q*q))+v(l*l));u=v(-1);b:{if(!(f>v(0))){break b}f=v(v(-v(v(v(k*i)+v(j*q))+v(n*l)))/f);if(!!(f>=v(1))){N=1065353216;O=0;D=2;u=v(v(v(J*J)+v(L*L))+v(M*M));break b}if(!!(f<=v(0))){N=0;O=1065353216;D=1;u=v(v(v(k*k)+v(j*j))+v(n*n));break b}O=(g(v(v(1)-f)),h(0));N=(g(f),h(0));D=3;n=v(n+v(l*f));k=v(k+v(i*f));f=v(j+v(q*f));u=v(v(n*n)+v(v(k*k)+v(f*f)));}f=u;if(!(!!(f<p)|p<v(0))){f=p;break a}o[e>>2]=(0-(D&1)&1<<z)+(1<<Q&D<<30>>31);o[d+P>>2]=O;o[d+t>>2]=N;o[(o[t+4252>>2]<<2)+d>>2]=0;}z=z+1|0;if((z|0)!=3){t=(z<<4)+m|0;l=s[t>>2];i=s[t+8>>2];q=s[t+4>>2];t=o[(m+52|0)+(z<<2)>>2];n=s[t+8>>2];j=s[t+4>>2];k=s[t>>2];p=f;continue}break}if(f<v(0)){f=s[a+8>>2];p=s[a>>2];k=s[a+4>>2];o[e>>2]=7;k=v(v(v(v(w*p)+v(x*k))+v(r*f))/H);f=v(x*k);j=v(s[b+4>>2]-f);p=v(w*k);n=v(s[b>>2]-p);i=v(v(B*j)-v(A*n));u=v(i*i);k=v(r*k);i=v(s[b+8>>2]-k);j=v(v(A*i)-v(y*j));l=v(j*j);j=v(v(y*n)-v(B*i));u=v(C(v(u+v(l+v(j*j)))));j=v(C(H));n=v(u/j);s[d>>2]=n;i=v(s[c+4>>2]-f);q=v(s[c>>2]-p);l=v(v(G*i)-v(F*q));u=v(l*l);l=v(s[c+8>>2]-k);i=v(v(F*l)-v(E*i));r=v(i*i);i=v(v(E*q)-v(G*l));j=v(v(C(v(u+v(r+v(i*i)))))/j);s[d+4>>2]=j;s[d+8>>2]=v(1)-v(n+j);f=v(v(k*k)+v(v(p*p)+v(f*f)));}return f}function sf(a,b,c){var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0);D=s[b+52>>2];E=s[b+56>>2];n=s[a+96>>2];p=s[a+100>>2];q=s[a+104>>2];d=s[b+20>>2];e=s[b+24>>2];r=s[a- -64>>2];t=s[a+80>>2];u=s[a+52>>2];w=s[a+68>>2];x=s[a+84>>2];y=s[a+56>>2];f=s[b+36>>2];z=s[a+72>>2];g=s[b+40>>2];A=s[a+88>>2];C=s[b+48>>2];h=s[b+8>>2];i=s[b>>2];j=s[b+4>>2];k=s[b+16>>2];B=s[a+48>>2];l=s[b+32>>2];o[a+1296>>2]=0;o[a+1280>>2]=0;o[a+1264>>2]=0;o[a+1248>>2]=0;s[a+1276>>2]=v(v(y*l)+v(z*f))+v(A*g);s[a+1272>>2]=v(v(u*l)+v(w*f))+v(x*g);s[a+1268>>2]=v(v(B*l)+v(r*f))+v(t*g);s[a+1260>>2]=v(v(y*k)+v(z*d))+v(A*e);s[a+1256>>2]=v(v(u*k)+v(w*d))+v(x*e);s[a+1252>>2]=v(v(B*k)+v(r*d))+v(t*e);s[a+1244>>2]=v(v(i*y)+v(j*z))+v(h*A);s[a+1240>>2]=v(v(i*u)+v(j*w))+v(h*x);s[a+1236>>2]=v(v(B*i)+v(r*j))+v(t*h);s[a+1292>>2]=E+v(v(v(l*n)+v(f*p))+v(g*q));s[a+1288>>2]=D+v(v(v(k*n)+v(d*p))+v(e*q));s[a+1284>>2]=C+v(v(v(i*n)+v(j*p))+v(h*q));D=s[c+52>>2];E=s[c+56>>2];n=s[a+160>>2];p=s[a+164>>2];q=s[a+168>>2];d=s[c+20>>2];e=s[c+24>>2];r=s[a+128>>2];t=s[a+144>>2];u=s[a+116>>2];w=s[a+132>>2];x=s[a+148>>2];y=s[a+120>>2];z=s[a+136>>2];f=s[c+36>>2];A=s[a+152>>2];g=s[c+40>>2];C=s[c+48>>2];h=s[c+8>>2];i=s[c>>2];j=s[c+4>>2];k=s[c+16>>2];B=s[a+112>>2];l=s[c+32>>2];o[a+1360>>2]=0;o[a+1344>>2]=0;o[a+1328>>2]=0;o[a+1312>>2]=0;s[a+1340>>2]=v(v(y*l)+v(z*f))+v(A*g);s[a+1336>>2]=v(v(u*l)+v(w*f))+v(x*g);s[a+1332>>2]=v(v(B*l)+v(r*f))+v(t*g);s[a+1324>>2]=v(v(y*k)+v(z*d))+v(A*e);s[a+1320>>2]=v(v(u*k)+v(w*d))+v(x*e);s[a+1316>>2]=v(v(B*k)+v(r*d))+v(t*e);s[a+1308>>2]=v(v(i*y)+v(j*z))+v(h*A);s[a+1304>>2]=v(v(i*u)+v(j*w))+v(h*x);s[a+1300>>2]=v(v(B*i)+v(r*j))+v(t*h);s[a+1356>>2]=E+v(v(v(l*n)+v(f*p))+v(g*q));s[a+1352>>2]=D+v(v(v(k*n)+v(d*p))+v(e*q));s[a+1348>>2]=C+v(v(v(i*n)+v(j*p))+v(h*q));kn(a);ln(a);e=s[o[a+28>>2]+404>>2];d=s[o[a+32>>2]+404>>2];m[a+1452|0]=e<v(1.1920928955078125e-7)|d<v(1.1920928955078125e-7);C=d;d=v(e+d);d=d>v(0)?v(C/d):v(.5);s[a+1444>>2]=d;s[a+1448>>2]=v(1)-d;}function fb(a,b){var c=0,d=0,e=v(0);c=K+ -64|0;K=c;o[c+60>>2]=a;o[c+56>>2]=b;a=K-16|0;b=o[c+60>>2];o[a+12>>2]=b;e=s[o[a+12>>2]>>2];a=K-16|0;o[a+12>>2]=b+16;e=v(e+s[o[a+12>>2]+4>>2]);a=K-16|0;o[a+12>>2]=b+32;s[c+52>>2]=e+s[o[a+12>>2]+8>>2];a:{if(s[c+52>>2]>v(0)){a=K-16|0;s[a+12>>2]=s[c+52>>2]+v(1);s[c+28>>2]=C(s[a+12>>2]);s[c+44>>2]=s[c+28>>2]*v(.5);s[c+28>>2]=v(.5)/s[c+28>>2];a=K-16|0;o[a+12>>2]=b+32;e=s[o[a+12>>2]+4>>2];a=K-16|0;o[a+12>>2]=b+16;s[c+32>>2]=v(e-s[o[a+12>>2]+8>>2])*s[c+28>>2];a=K-16|0;o[a+12>>2]=b;e=s[o[a+12>>2]+8>>2];a=K-16|0;o[a+12>>2]=b+32;s[c+36>>2]=v(e-s[o[a+12>>2]>>2])*s[c+28>>2];a=K-16|0;o[a+12>>2]=b+16;e=s[o[a+12>>2]>>2];a=K-16|0;o[a+12>>2]=b;s[c+40>>2]=v(e-s[o[a+12>>2]+4>>2])*s[c+28>>2];break a}a=c;d=K-16|0;o[d+12>>2]=b;e=s[o[d+12>>2]>>2];d=K-16|0;o[d+12>>2]=b+16;b:{if(e<s[o[d+12>>2]+4>>2]){d=K-16|0;o[d+12>>2]=b+16;e=s[o[d+12>>2]+4>>2];d=K-16|0;o[d+12>>2]=b+32;d=e<s[o[d+12>>2]+8>>2]?2:1;break b}d=K-16|0;o[d+12>>2]=b;e=s[o[d+12>>2]>>2];d=K-16|0;o[d+12>>2]=b+32;d=e<s[o[d+12>>2]+8>>2]?2:0;}o[a+24>>2]=d;o[c+20>>2]=(o[c+24>>2]+1|0)%3;o[c+16>>2]=(o[c+24>>2]+2|0)%3;a=K-16|0;o[a+12>>2]=b+(o[c+24>>2]<<4);e=s[o[a+12>>2]+(o[c+24>>2]<<2)>>2];a=K-16|0;o[a+12>>2]=b+(o[c+20>>2]<<4);e=v(e-s[o[a+12>>2]+(o[c+20>>2]<<2)>>2]);a=K-16|0;o[a+12>>2]=b+(o[c+16>>2]<<4);d=K-16|0;s[d+12>>2]=v(e-s[o[a+12>>2]+(o[c+16>>2]<<2)>>2])+v(1);s[c+12>>2]=C(s[d+12>>2]);a=c+32|0;s[a+(o[c+24>>2]<<2)>>2]=s[c+12>>2]*v(.5);s[c+12>>2]=v(.5)/s[c+12>>2];d=K-16|0;o[d+12>>2]=b+(o[c+16>>2]<<4);e=s[o[d+12>>2]+(o[c+20>>2]<<2)>>2];d=K-16|0;o[d+12>>2]=b+(o[c+20>>2]<<4);s[c+44>>2]=v(e-s[o[d+12>>2]+(o[c+16>>2]<<2)>>2])*s[c+12>>2];d=K-16|0;o[d+12>>2]=b+(o[c+20>>2]<<4);e=s[o[d+12>>2]+(o[c+24>>2]<<2)>>2];d=K-16|0;o[d+12>>2]=b+(o[c+24>>2]<<4);s[a+(o[c+20>>2]<<2)>>2]=v(e+s[o[d+12>>2]+(o[c+20>>2]<<2)>>2])*s[c+12>>2];d=K-16|0;o[d+12>>2]=b+(o[c+16>>2]<<4);e=s[o[d+12>>2]+(o[c+24>>2]<<2)>>2];d=K-16|0;o[d+12>>2]=b+(o[c+24>>2]<<4);s[a+(o[c+16>>2]<<2)>>2]=v(e+s[o[d+12>>2]+(o[c+16>>2]<<2)>>2])*s[c+12>>2];}a=c+32|0;mc(o[c+56>>2],a,a+4|0,a+8|0,a+12|0);K=c- -64|0;}function fl(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0,q=0,r=0;q=K-16|0;K=q;l[o[4966]](6088);d=o[a+28>>2];if((d|0)<=-1){if(o[a+32>>2]<=-1){e=o[a+36>>2];if(e){if(p[a+40|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[a+36>>2]=0;}o[a+32>>2]=0;o[a+36>>2]=0;m[a+40|0]=1;}while(1){o[o[a+36>>2]+(d<<2)>>2]=0;e=d+1|0;f=e>>>0>=d>>>0;d=e;if(f){continue}break}}o[a+28>>2]=0;vj(a+4|0);j=o[a+8>>2];if((j|0)>=1){f=0;while(1){d=f;e=d+1|0;g=(j|0)>(e|0)?j:e;i=g+ -1|0;h=o[a+16>>2];n=o[h+(d<<3)>>2];while(1){a:{e=f;f=e+1|0;if((f|0)>=(j|0)){e=i;f=g;break a}if(o[(f<<3)+h>>2]==(n|0)){continue}}break}b:{if((d|0)>(e|0)){break b}i=(e|0)>(d|0)?e:d;r=o[c+16>>2];g=1;e=d;while(1){k=o[r+(o[((e<<3)+h|0)+4>>2]<<2)>>2];if(o[k+208>>2]==(n|0)){k=o[k+220>>2];g=(k|0)!=4&((k|0)!=1&g);}k=(e|0)!=(i|0);e=e+1|0;if(k){continue}break}if(g){while(1){e=o[o[c+16>>2]+(o[((d<<3)+h|0)+4>>2]<<2)>>2];if(o[e+208>>2]==(n|0)){if((o[e+220>>2]&-2)!=4){o[e+220>>2]=2;}}if((d|0)==(i|0)){break b}d=d+1|0;h=o[a+16>>2];continue}}while(1){e=o[o[c+16>>2]+(o[((d<<3)+h|0)+4>>2]<<2)>>2];if(!(o[e+208>>2]!=(n|0)|o[e+220>>2]!=2)){if((o[e+220>>2]&-2)!=4){o[e+220>>2]=3;}o[e+224>>2]=0;}if((d|0)==(i|0)){break b}d=d+1|0;h=o[a+16>>2];continue}}if((f|0)<(j|0)){continue}break}}h=l[o[o[b>>2]+36>>2]](b)|0;if((h|0)>=1){e=0;while(1){i=l[o[o[b>>2]+40>>2]](b,e)|0;c=o[i+840>>2];d=o[i+836>>2];c:{if(!c|o[c+220>>2]==2?!(o[d+220>>2]!=2?d:0):0){break c}f=o[d+204>>2];if(!(!(f&2)|f&4|o[d+220>>2]==2)){Qb(c,0);}f=o[c+204>>2];if(!(!(f&2)|f&4|o[c+220>>2]==2)){Qb(d,0);}if(!p[a+64|0]){break c}if(!l[o[o[b>>2]+28>>2]](b,d,c)){break c}c=o[a+28>>2];d:{if((c|0)!=o[a+32>>2]){break d}f=c?c<<1:1;if((c|0)>=(f|0)){break d}d=0;g=0;if(f){o[6257]=o[6257]+1;g=l[o[4968]](f<<2,16)|0;c=o[a+28>>2];}if((c|0)>=1){while(1){j=d<<2;o[j+g>>2]=o[j+o[a+36>>2]>>2];d=d+1|0;if((d|0)!=(c|0)){continue}break}}d=o[a+36>>2];if(d){if(p[a+40|0]){c=d;if(d){o[6258]=o[6258]+1;l[o[4969]](c);}c=o[a+28>>2];}o[a+36>>2]=0;}o[a+36>>2]=g;m[a+40|0]=1;o[a+32>>2]=f;}o[o[a+36>>2]+(c<<2)>>2]=i;o[a+28>>2]=c+1;}e=e+1|0;if((h|0)!=(e|0)){continue}break}}l[o[4967]]();K=q+16|0;}function Ze(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;o[a>>2]=5096;d=o[b+20>>2];o[6257]=o[6257]+1;c=l[o[4968]](4,16)|0;o[c>>2]=d?4308:4516;o[a+24>>2]=c;o[6257]=o[6257]+1;d=l[o[4968]](20,16)|0;c=o[a+24>>2];o[d+12>>2]=0;o[d+16>>2]=3;o[d>>2]=9836;m[d+4|0]=0;o[d+8>>2]=c;o[a+28>>2]=d;o[6257]=o[6257]+1;c=l[o[4968]](8,16)|0;o[c>>2]=5212;m[c+4|0]=0;o[a+32>>2]=c;o[6257]=o[6257]+1;c=l[o[4968]](8,16)|0;o[c>>2]=5336;m[c+4|0]=0;o[a+36>>2]=c;o[6257]=o[6257]+1;c=l[o[4968]](8,16)|0;o[c>>2]=5428;m[c+4|0]=0;o[a+40>>2]=c;o[6257]=o[6257]+1;c=l[o[4968]](8,16)|0;o[c>>2]=5508;m[c+4|0]=0;o[a+44>>2]=c;o[6257]=o[6257]+1;c=l[o[4968]](8,16)|0;o[c>>2]=5596;m[c+4|0]=0;o[a+48>>2]=c;o[6257]=o[6257]+1;c=l[o[4968]](8,16)|0;o[c>>2]=5680;m[c+4|0]=0;o[a+52>>2]=c;o[6257]=o[6257]+1;c=l[o[4968]](8,16)|0;o[c>>2]=5748;m[c+4|0]=0;o[a+56>>2]=c;o[6257]=o[6257]+1;c=l[o[4968]](8,16)|0;o[c>>2]=5832;m[c+4|0]=0;o[a+72>>2]=c;o[6257]=o[6257]+1;c=l[o[4968]](8,16)|0;o[c>>2]=5832;o[a+76>>2]=c;m[c+4|0]=1;o[6257]=o[6257]+1;c=l[o[4968]](8,16)|0;o[c>>2]=5916;m[c+4|0]=0;o[a+68>>2]=c;o[6257]=o[6257]+1;c=l[o[4968]](16,16)|0;o[c+8>>2]=1;o[c+12>>2]=0;o[c>>2]=5992;m[c+4|0]=0;o[a+84>>2]=c;o[6257]=o[6257]+1;c=l[o[4968]](16,16)|0;o[c+8>>2]=1;o[c+12>>2]=0;o[c>>2]=5992;o[a+80>>2]=c;m[c+4|0]=1;h=o[b+16>>2];c=o[b>>2];a:{if(c){o[a+8>>2]=c;m[a+12|0]=0;break a}m[a+12|0]=1;o[6257]=o[6257]+1;f=l[o[4968]](24,16)|0;c=o[b+8>>2];o[f+20>>2]=0;o[f+4>>2]=c;o[f>>2]=868;o[6257]=o[6257]+1;d=l[o[4968]](u(c,868),16)|0;o[f+12>>2]=d;o[f+16>>2]=d;c=o[f+4>>2];o[f+8>>2]=c;g=c+ -1|0;b:{if(!g){c=d;break b}e=o[f>>2];while(1){c=d+e|0;o[d>>2]=c;d=c;g=g+ -1|0;if(g){continue}break}}o[c>>2]=0;o[a+8>>2]=f;}c=o[b+4>>2];if(c){o[a+16>>2]=c;m[a+20|0]=0;return}m[a+20|0]=1;o[6257]=o[6257]+1;e=l[o[4968]](24,16)|0;c=o[b+12>>2];o[e+20>>2]=0;o[e+4>>2]=c;b=(h|0)>80?h:80;b=(b|0)>116?b+16&-16:128;o[e>>2]=b;o[6257]=o[6257]+1;d=l[o[4968]](u(b,c),16)|0;o[e+12>>2]=d;o[e+16>>2]=d;b=o[e+4>>2];o[e+8>>2]=b;g=b+ -1|0;c:{if(!g){c=d;break c}b=o[e>>2];while(1){c=b+d|0;o[d>>2]=c;d=c;g=g+ -1|0;if(g){continue}break}}o[c>>2]=0;o[a+16>>2]=e;}function qb(a,b,c,d,e){var f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=0,l=v(0),n=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0);k=p[e+16|0]&-16;m[e+16|0]=k;G=s[d>>2];n=s[b>>2];w=v(G-n);l=s[a>>2];f=v(l-n);H=s[d+4>>2];q=s[b+4>>2];x=v(H-q);i=s[a+4>>2];g=v(i-q);I=s[d+8>>2];r=s[b+8>>2];y=v(I-r);t=s[a+8>>2];h=v(t-r);j=v(v(v(w*f)+v(x*g))+v(y*h));a=e;C=s[c>>2];z=v(C-n);D=s[c+4>>2];A=v(D-q);E=s[c+8>>2];B=v(E-r);g=v(v(v(z*f)+v(A*g))+v(B*h));a:{if(!(g<=v(0)^1|j<=v(0)^1)){c=o[b+4>>2];o[e>>2]=o[b>>2];o[e+4>>2]=c;c=o[b+12>>2];o[e+8>>2]=o[b+8>>2];o[e+12>>2]=c;m[e+16|0]=k|1;g=v(0);f=v(0);h=v(1);break a}f=v(l-C);h=v(i-D);u=v(t-E);F=v(v(v(w*f)+v(x*h))+v(y*u));h=v(v(v(z*f)+v(A*h))+v(B*u));if(!(h>=v(0)^1|F<=h^1)){b=o[c+4>>2];o[e>>2]=o[c>>2];o[e+4>>2]=b;b=o[c+12>>2];o[e+8>>2]=o[c+8>>2];o[e+12>>2]=b;m[e+16|0]=k|2;g=v(1);f=v(0);h=v(0);break a}u=v(v(g*F)-v(h*j));b:{if(h<=v(0)^1|g>=v(0)^1){break b}f=v(0);if(!(u<=v(0))){break b}o[e+12>>2]=0;m[e+16|0]=k|3;g=v(g/v(g-h));s[e+8>>2]=r+v(B*g);s[e+4>>2]=q+v(A*g);s[e>>2]=n+v(z*g);h=v(v(1)-g);break a}f=v(l-G);i=v(i-H);t=v(t-I);l=v(v(v(z*f)+v(A*i))+v(B*t));f=v(v(v(w*f)+v(x*i))+v(y*t));if(!(f>=v(0)^1|l<=f^1)){b=o[d+4>>2];o[e>>2]=o[d>>2];o[e+4>>2]=b;b=o[d+12>>2];o[e+8>>2]=o[d+8>>2];o[e+12>>2]=b;m[e+16|0]=k|4;f=v(1);g=v(0);h=v(0);break a}i=v(v(l*j)-v(g*f));c:{if(f<=v(0)^1|j>=v(0)^1){break c}g=v(0);if(!(i<=v(0))){break c}o[e+12>>2]=0;m[e+16|0]=k|5;f=v(j/v(j-f));s[e+8>>2]=r+v(y*f);s[e+4>>2]=q+v(x*f);s[e>>2]=n+v(w*f);h=v(v(1)-f);break a}d:{j=v(v(h*f)-v(l*F));if(!(j<=v(0))){break d}g=v(F-h);if(!(g>=v(0))){break d}f=v(l-f);if(!(f>=v(0))){break d}o[e+12>>2]=0;m[e+16|0]=k|6;f=v(g/v(g+f));s[e+8>>2]=E+v(v(I-E)*f);s[e+4>>2]=D+v(v(H-D)*f);s[e>>2]=C+v(v(G-C)*f);g=v(v(1)-f);h=v(0);break a}o[e+12>>2]=0;m[e+16|0]=k|7;g=v(v(1)/v(u+v(j+i)));f=v(u*g);g=v(i*g);s[e+8>>2]=v(y*f)+v(r+v(B*g));s[e+4>>2]=v(x*f)+v(q+v(A*g));s[e>>2]=v(w*f)+v(n+v(z*g));h=v(v(v(1)-g)-f);}s[a+20>>2]=h;o[e+32>>2]=0;s[e+28>>2]=f;s[e+24>>2]=g;}function _g(a,b,c,d,e,f){var g=0,h=0,i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=0,w=v(0),x=v(0),y=v(0),z=0,A=v(0),B=0,D=0,E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=0,M=0,N=0,O=0,P=0,Q=0;g=K-32|0;K=g;a:{if(o[a+56>>2]<1){break a}k=s[d+8>>2];j=s[c+8>>2];p=v(k-j);x=p;i=s[d>>2];q=s[c>>2];m=v(i-q);r=s[d+4>>2];t=s[c+4>>2];n=v(r-t);w=v(v(1)/v(C(v(v(v(m*m)+v(n*n))+v(p*p)))));p=v(p*w);y=m;m=v(m*w);A=n;n=v(n*w);A=v(v(x*p)+v(v(y*m)+v(A*n)));w=s[f+8>>2];E=v((j<k?k:j)+w);x=s[f+4>>2];F=v((t<r?r:t)+x);y=s[f>>2];G=v((q<i?i:q)+y);j=k<j?k:j;k=s[e+8>>2];H=v(j+k);j=s[e+4>>2];I=v((r<t?r:t)+j);q=i<q?i:q;i=s[e>>2];J=v(q+i);d=o[a+96>>2];q=p==v(0)?v(0xde0b6b000000000):v(v(1)/p);h=q<v(0);L=(h<<4)+g|8;r=n==v(0)?v(0xde0b6b000000000):v(v(1)/n);u=r<v(0);M=(u<<4)+g|4;N=((h^1)<<4)+g|8;O=((u^1)<<4)+g|4;t=m==v(0)?v(0xde0b6b000000000):v(v(1)/m);h=t<v(0);P=(h<<4)+g|0;Q=((h^1)<<4)+g|0;while(1){h=o[d+4>>2];o[g>>2]=o[d>>2];o[g+4>>2]=h;h=o[d+12>>2];o[g+8>>2]=o[d+8>>2];o[g+12>>2]=h;h=o[d+28>>2];o[g+24>>2]=o[d+24>>2];o[g+28>>2]=h;h=o[d+20>>2];o[g+16>>2]=o[d+16>>2];o[g+20>>2]=h;s[g>>2]=s[g>>2]-y;s[g+4>>2]=s[g+4>>2]-x;s[g+16>>2]=s[g+16>>2]-i;s[g+20>>2]=s[g+20>>2]-j;s[g+8>>2]=s[g+8>>2]-w;s[g+24>>2]=s[g+24>>2]-k;h=0;b:{if(J>s[d+16>>2]){break b}h=0;if(G<s[d>>2]){break b}h=1;}u=0;u=E<s[d+8>>2]|H>s[d+24>>2]?u:h;c:{d:{e:{f:{g:{if(F<s[d+4>>2]|I>s[d+20>>2]|u^1){break g}m=s[c+4>>2];k=v(r*v(s[M>>2]-m));i=s[c>>2];j=v(t*v(s[Q>>2]-i));if(k>j){break g}i=v(t*v(s[P>>2]-i));m=v(r*v(s[O>>2]-m));if(i>m){break g}p=s[c+8>>2];n=v(q*v(s[L>>2]-p));j=m<j?m:j;if(n>j){break g}k=k>i?k:i;i=v(q*v(s[N>>2]-p));if(k>i){break g}D=o[d+32>>2];u=(D|0)==-1;h=(n>k?n:k)<A&(i<j?i:j)>v(0);if((h|0)!=1|(D|0)!=-1){break f}l[o[o[b>>2]+8>>2]](b,o[d+36>>2],o[d+40>>2]);break e}u=o[d+32>>2]==-1;h=0;}if(u){break e}if(!h){break d}}z=z+1|0;d=d- -64|0;break c}h=o[d+32>>2];z=h+z|0;d=(h<<6)+d|0;}B=B+1|0;if((z|0)>=o[a+56>>2]){break a}k=s[e+8>>2];j=s[e+4>>2];i=s[e>>2];w=s[f+8>>2];x=s[f+4>>2];y=s[f>>2];continue}}if(o[5677]<(B|0)){o[5677]=B;}K=g+32|0;}function vu(a,b){var c=0,d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=0,k=v(0),n=v(0),q=v(0),r=0,t=0,u=0,x=0,y=0,z=0,A=0,B=0,C=0,D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=0,K=0,L=0;t=o[a+4>>2];if((t|0)>=1){while(1){a:{c=y;y=c+1|0;if((y|0)>=(t|0)){break a}d=o[a+12>>2];z=d+(c<<4)|0;K=z;c=y;while(1){b:{A=c+1|0;if((A|0)>=(t|0)){break b}B=(c<<4)+d|0;L=B;C=A;while(1){c=(C<<4)+d|0;f=s[c+4>>2];g=s[B>>2];k=s[B+4>>2];n=s[c>>2];q=v(v(f*g)-v(k*n));h=s[c+8>>2];D=s[B+8>>2];E=v(v(k*h)-v(D*f));F=v(v(D*n)-v(h*g));c:{if(!(v(v(q*q)+v(v(E*E)+v(F*F)))>v(9999999747378752e-20))){break c}e=s[z+4>>2];i=s[z>>2];G=v(v(n*e)-v(f*i));H=f;f=s[z+8>>2];I=v(v(H*f)-v(h*e));n=v(v(h*i)-v(n*f));if(!(v(v(G*G)+v(v(I*I)+v(n*n)))>v(9999999747378752e-20))){break c}h=v(v(k*i)-v(g*e));k=v(v(D*e)-v(k*f));g=v(v(g*f)-v(D*i));if(!(v(v(h*h)+v(v(k*k)+v(g*g)))>v(9999999747378752e-20))){break c}e=v(v(f*q)+v(v(e*F)+v(E*i)));if(!(v(w(e))>v(9.999999974752427e-7))){break c}e=v(v(-1)/e);i=s[c+12>>2];f=s[K+12>>2];H=v(q*f);q=s[L+12>>2];h=v(e*v(v(h*i)+v(H+v(G*q))));g=v(e*v(v(g*i)+v(v(F*f)+v(n*q))));e=v(e*v(v(k*i)+v(v(E*f)+v(I*q))));c=0;u=o[a+4>>2];if((u|0)>0){while(1){j=(c<<4)+d|0;if(!!(v(v(s[j+12>>2]+v(v(v(e*s[j>>2])+v(g*s[j+4>>2]))+v(h*s[j+8>>2])))+v(-.009999999776482582))>v(0))){break c}c=c+1|0;if((u|0)!=(c|0)){continue}break}}d=o[b+4>>2];d:{if((d|0)!=o[b+8>>2]){break d}j=d?d<<1:1;if((d|0)>=(j|0)){break d}c=0;u=0;if(j){o[6257]=o[6257]+1;u=l[o[4968]](j<<4,16)|0;d=o[b+4>>2];}if((d|0)>=1){while(1){r=c<<4;x=r+u|0;r=r+o[b+12>>2]|0;J=o[r+4>>2];o[x>>2]=o[r>>2];o[x+4>>2]=J;J=o[r+12>>2];o[x+8>>2]=o[r+8>>2];o[x+12>>2]=J;c=c+1|0;if((d|0)!=(c|0)){continue}break}}c=o[b+12>>2];if(c){if(p[b+16|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[b+12>>2]=0;}o[b+12>>2]=u;m[b+16|0]=1;o[b+8>>2]=j;d=o[b+4>>2];}c=o[b+12>>2]+(d<<4)|0;o[c+12>>2]=0;s[c+8>>2]=h;s[c+4>>2]=g;s[c>>2]=e;o[b+4>>2]=o[b+4>>2]+1;}C=C+1|0;if((C|0)>=(t|0)){break b}d=o[a+12>>2];continue}}if((t|0)==(A|0)){break a}d=o[a+12>>2];c=A;continue}}if((t|0)!=(y|0)){continue}break}}}function Bc(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0,q=0,r=0;if(!(!b|!c)){if(!(o[a+24>>2]>127|o[a+28>>2]>127)){o[6257]=o[6257]+1;e=l[o[4968]](1024,16)|0;i=o[a+24>>2];if((i|0)>=1){while(1){f=g<<3;h=f+e|0;f=f+o[a+32>>2]|0;j=o[f+4>>2];o[h>>2]=o[f>>2];o[h+4>>2]=j;g=g+1|0;if((i|0)!=(g|0)){continue}break}}i=o[a+32>>2];if(i){if(p[a+36|0]){if(i){o[6258]=o[6258]+1;l[o[4969]](i);}}o[a+32>>2]=0;}o[a+32>>2]=e;o[a+28>>2]=128;m[a+36|0]=1;}o[a+24>>2]=128;e=o[a+32>>2];o[e+4>>2]=c;o[e>>2]=b;b=124;e=1;while(1){c=o[a+32>>2];i=e;e=e+ -1|0;j=e<<3;f=c+j|0;h=o[f+4>>2];f=o[f>>2];if((e|0)>(b|0)){g=o[a+24>>2];b=g<<1;if(!((g|0)>=(b|0)|o[a+28>>2]>=(b|0))){a:{if(!g){c=0;break a}o[6257]=o[6257]+1;c=l[o[4968]](g<<4,16)|0;g=0;n=o[a+24>>2];if((n|0)<1){break a}while(1){k=g<<3;q=k+c|0;k=o[a+32>>2]+k|0;r=o[k+4>>2];o[q>>2]=o[k>>2];o[q+4>>2]=r;g=g+1|0;if((n|0)!=(g|0)){continue}break}}g=o[a+32>>2];if(g){if(p[a+36|0]){if(g){o[6258]=o[6258]+1;l[o[4969]](g);}}o[a+32>>2]=0;}o[a+32>>2]=c;m[a+36|0]=1;o[a+28>>2]=b;}o[a+24>>2]=b;b=b+ -4|0;}b:{if((f|0)==(h|0)){if(!o[f+40>>2]){break b}c=c+j|0;e=o[f+36>>2];o[c+4>>2]=e;o[c>>2]=e;c=i<<3;e=c+o[a+32>>2]|0;h=o[f+40>>2];o[e+4>>2]=h;o[e>>2]=h;e=o[f+40>>2];c=c+o[a+32>>2]|0;o[c+8>>2]=o[f+36>>2];o[c+12>>2]=e;e=i+2|0;break b}if(s[f>>2]<=s[h+16>>2]^1|s[f+16>>2]>=s[h>>2]^1|(s[f+4>>2]<=s[h+20>>2]^1|s[f+20>>2]>=s[h+4>>2]^1)){break b}if(s[f+8>>2]<=s[h+24>>2]^1|s[f+24>>2]>=s[h+8>>2]^1){break b}g=o[h+40>>2];if(o[f+40>>2]){e=o[f+36>>2];if(g){c=c+j|0;o[c+4>>2]=o[h+36>>2];o[c>>2]=e;e=o[f+40>>2];c=i<<3;g=c+o[a+32>>2]|0;o[g+4>>2]=o[h+36>>2];o[g>>2]=e;e=o[f+36>>2];g=c+o[a+32>>2]|0;o[g+12>>2]=o[h+40>>2];o[g+8>>2]=e;e=o[f+40>>2];c=c+o[a+32>>2]|0;o[c+20>>2]=o[h+40>>2];o[c+16>>2]=e;e=i+3|0;break b}c=c+j|0;o[c+4>>2]=h;o[c>>2]=e;c=o[f+40>>2];e=o[a+32>>2]+(i<<3)|0;o[e+4>>2]=h;o[e>>2]=c;e=i+1|0;break b}if(g){c=c+j|0;o[c+4>>2]=o[h+36>>2];o[c>>2]=f;c=o[a+32>>2]+(i<<3)|0;o[c+4>>2]=o[h+40>>2];o[c>>2]=f;e=i+1|0;break b}l[o[o[d>>2]+8>>2]](d,f,h);}if(e){continue}break}}}function Cu(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;o[b+16>>2]=o[a+20>>2];o[b+20>>2]=o[a+24>>2];o[b+24>>2]=o[a+28>>2];o[b+28>>2]=o[a+32>>2];o[b>>2]=o[a+4>>2];o[b+4>>2]=o[a+8>>2];o[b+8>>2]=o[a+12>>2];o[b+12>>2]=o[a+16>>2];o[b+32>>2]=o[a+36>>2];o[b+36>>2]=o[a+40>>2];o[b+40>>2]=o[a+44>>2];o[b+44>>2]=o[a+48>>2];o[b+48>>2]=o[a+56>>2];o[b+52>>2]=p[a+60|0];d=o[a+88>>2];o[b+56>>2]=d;a:{if(!d){o[b+64>>2]=0;break a}d=l[o[o[c>>2]+28>>2]](c,o[a+96>>2])|0;o[b+64>>2]=d;if(!d){break a}g=o[a+88>>2];h=l[o[o[c>>2]+16>>2]](c,48,g)|0;e=o[a+96>>2];if((g|0)>=1){d=o[h+8>>2];while(1){e=(f<<6)+e|0;o[d+16>>2]=o[e+16>>2];o[d+20>>2]=o[e+20>>2];o[d+24>>2]=o[e+24>>2];o[d+28>>2]=o[e+28>>2];o[d>>2]=o[e>>2];o[d+4>>2]=o[e+4>>2];o[d+8>>2]=o[e+8>>2];o[d+12>>2]=o[e+12>>2];o[d+32>>2]=o[e+32>>2];o[d+36>>2]=o[e+36>>2];e=o[e+40>>2];o[d+44>>2]=0;o[d+40>>2]=e;d=d+48|0;e=o[a+96>>2];f=f+1|0;if((g|0)!=(f|0)){continue}break}}l[o[o[c>>2]+20>>2]](c,h,16324,1497453121,e);}d=o[a+128>>2];o[b+60>>2]=d;b:{if(!d){o[b+68>>2]=0;break b}d=l[o[o[c>>2]+28>>2]](c,o[a+136>>2])|0;o[b+68>>2]=d;if(!d){break b}g=o[a+128>>2];h=l[o[o[c>>2]+16>>2]](c,16,g)|0;i=o[a+136>>2];if((g|0)>=1){d=o[h+8>>2];f=0;while(1){e=(f<<4)+i|0;o[d+12>>2]=o[e+12>>2];n[d+6>>1]=q[e+6>>1];n[d+8>>1]=q[e+8>>1];n[d+10>>1]=q[e+10>>1];n[d>>1]=q[e>>1];n[d+2>>1]=q[e+2>>1];n[d+4>>1]=q[e+4>>1];d=d+16|0;f=f+1|0;if((g|0)!=(f|0)){continue}break}}l[o[o[c>>2]+20>>2]](c,h,16347,1497453121,i);}o[b+76>>2]=o[a+144>>2];d=o[a+152>>2];o[b+80>>2]=d;if(!d){o[b+72>>2]=0;return 16391}d=b;b=l[o[o[c>>2]+28>>2]](c,o[a+160>>2])|0;o[d+72>>2]=b;if(b){e=o[a+152>>2];f=l[o[o[c>>2]+16>>2]](c,20,e)|0;g=o[a+160>>2];if((e|0)>=1){d=o[f+8>>2];a=0;while(1){b=g+(a<<5)|0;n[d+14>>1]=q[b+6>>1];n[d+16>>1]=q[b+8>>1];n[d+18>>1]=q[b+10>>1];n[d+8>>1]=q[b>>1];n[d+10>>1]=q[b+2>>1];n[d+12>>1]=q[b+4>>1];o[d>>2]=o[b+12>>2];o[d+4>>2]=o[b+16>>2];d=d+20|0;a=a+1|0;if((e|0)!=(a|0)){continue}break}}l[o[o[c>>2]+20>>2]](c,f,16370,1497453121,g);}return 16391}function Qi(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0);c=K-144|0;K=c;if(o[a+20>>2]>=1){f=c- -64|0;while(1){g=u(h,80);d=g+o[a+28>>2]|0;e=o[d+12>>2];o[c+24>>2]=o[d+8>>2];o[c+28>>2]=e;e=o[d+4>>2];o[c+16>>2]=o[d>>2];o[c+20>>2]=e;e=o[d+28>>2];o[c+40>>2]=o[d+24>>2];o[c+44>>2]=e;e=o[d+20>>2];o[c+32>>2]=o[d+16>>2];o[c+36>>2]=e;e=o[d+44>>2];o[c+56>>2]=o[d+40>>2];o[c+60>>2]=e;e=o[d+36>>2];o[c+48>>2]=o[d+32>>2];o[c+52>>2]=e;e=o[d+60>>2];o[f+8>>2]=o[d+56>>2];o[f+12>>2]=e;e=o[d+52>>2];o[f>>2]=o[d+48>>2];o[f+4>>2]=e;d=o[d+64>>2];d=l[o[o[d>>2]+28>>2]](d)|0;o[c+8>>2]=o[d+8>>2];e=o[d+4>>2];o[c>>2]=o[d>>2];o[c+4>>2]=e;i=s[a+188>>2];j=s[b+4>>2];k=s[a+184>>2];m=s[b>>2];s[c+8>>2]=v(s[c+8>>2]*s[b+8>>2])/s[a+192>>2];o[c+12>>2]=0;s[c>>2]=v(m*s[c>>2])/k;s[c+4>>2]=v(j*s[c+4>>2])/i;d=o[(o[a+28>>2]+g|0)+64>>2];l[o[o[d>>2]+24>>2]](d,c);i=s[a+184>>2];j=s[b>>2];k=s[a+188>>2];m=s[b+4>>2];n=s[a+192>>2];p=s[b+8>>2];o[c+76>>2]=0;s[c+72>>2]=v(p*s[c+72>>2])/n;s[c+68>>2]=v(m*s[c+68>>2])/k;s[c+64>>2]=v(j*s[c+64>>2])/i;e=o[c+20>>2];d=o[a+28>>2]+g|0;o[d>>2]=o[c+16>>2];o[d+4>>2]=e;e=o[c+28>>2];o[d+8>>2]=o[c+24>>2];o[d+12>>2]=e;e=o[c+44>>2];o[d+24>>2]=o[c+40>>2];o[d+28>>2]=e;e=o[c+36>>2];o[d+16>>2]=o[c+32>>2];o[d+20>>2]=e;e=o[c+60>>2];o[d+40>>2]=o[c+56>>2];o[d+44>>2]=e;e=o[c+52>>2];o[d+32>>2]=o[c+48>>2];o[d+36>>2]=e;e=o[f+12>>2];o[d+56>>2]=o[f+8>>2];o[d+60>>2]=e;e=o[f+4>>2];o[d+48>>2]=o[f>>2];o[d+52>>2]=e;if(o[a+68>>2]){d=o[(o[a+28>>2]+g|0)+64>>2];l[o[o[d>>2]+8>>2]](d,c+16|0,c+128|0,c+112|0);d=o[c+140>>2];o[c+88>>2]=o[c+136>>2];o[c+92>>2]=d;d=o[c+132>>2];o[c+80>>2]=o[c+128>>2];o[c+84>>2]=d;d=o[c+124>>2];o[c+104>>2]=o[c+120>>2];o[c+108>>2]=d;d=o[c+116>>2];o[c+96>>2]=o[c+112>>2];o[c+100>>2]=d;Ld(o[a+68>>2],o[(o[a+28>>2]+g|0)+76>>2],c+80|0);}h=h+1|0;if((h|0)<o[a+20>>2]){continue}break}}d=o[b+4>>2];o[a+184>>2]=o[b>>2];o[a+188>>2]=d;d=o[b+12>>2];o[a+192>>2]=o[b+8>>2];o[a+196>>2]=d;l[o[o[a>>2]+68>>2]](a);K=c+144|0;}function Oj(a,b,c,d,e,f){var g=v(0),h=v(0),i=v(0),j=0,k=0,m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=0,w=0,x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),D=v(0),E=v(0),F=v(0),G=v(0);j=K-32|0;K=j;k=o[a+8>>2];h=s[k+60>>2];g=v(s[k+76>>2]-h);q=s[k- -64>>2];i=v(s[k+96>>2]-q);m=v(s[k+80>>2]-q);p=v(s[k+92>>2]-h);r=v(v(g*i)-v(m*p));x=m;t=s[k+68>>2];m=v(s[k+100>>2]-t);n=v(s[k+84>>2]-t);i=v(v(x*m)-v(n*i));p=v(v(n*p)-v(g*m));m=v(v(r*r)+v(v(i*i)+v(p*p)));a:{if(!(m>=v(1.4210854715202004e-14))){break a}u=o[a+4>>2];x=v(s[u+32>>2]*s[u+16>>2]);g=v(x+f);f=v(v(1)/v(C(m)));m=v(i*f);i=s[b>>2];p=v(p*f);n=s[b+4>>2];y=v(v(m*v(i-h))+v(p*v(n-q)));q=v(r*f);h=s[b+8>>2];f=v(y+v(q*v(h-t)));if(!!(f<v(0))){q=v(-q);p=v(-p);m=v(-m);f=v(-f);}if(!(f<g)){break a}u=o[b+12>>2];o[j+24>>2]=o[b+8>>2];o[j+28>>2]=u;u=o[b+4>>2];o[j+16>>2]=o[b>>2];o[j+20>>2]=u;o[j+12>>2]=0;s[j+8>>2]=q;s[j+4>>2]=p;s[j>>2]=m;b:{if(Nj(k+60|0,j,j+16|0)){z=v(h-v(f*q));A=v(n-v(f*p));B=v(i-v(f*m));y=v(g*g);break b}if((l[o[o[k>>2]+100>>2]](k)|0)<1){break a}y=v(g*g);u=0;k=0;while(1){w=o[a+8>>2];l[o[o[w>>2]+104>>2]](w,k,j+16|0,j);g=v(0);D=s[j+16>>2];f=v(s[b>>2]-D);n=v(s[j>>2]-D);E=s[j+20>>2];h=v(s[b+4>>2]-E);r=v(s[j+4>>2]-E);F=s[j+24>>2];i=v(s[b+8>>2]-F);t=v(s[j+8>>2]-F);G=v(v(v(f*n)+v(h*r))+v(i*t));c:{if(!(G>v(0))){break c}g=v(v(v(n*n)+v(r*r))+v(t*t));if(!!(G<g)){g=v(G/g);i=v(i-v(t*g));h=v(h-v(r*g));f=v(f-v(n*g));break c}i=v(i-t);h=v(h-r);f=v(f-n);g=v(1);}if(!!(v(v(v(f*f)+v(h*h))+v(i*i))<y)){B=v(D+v(n*g));A=v(E+v(r*g));u=1;z=v(F+v(t*g));}k=k+1|0;w=o[a+8>>2];if((k|0)<(l[o[o[w>>2]+100>>2]](w)|0)){continue}break}w=0;if(!u){break a}h=s[b+8>>2];n=s[b+4>>2];i=s[b>>2];}f=v(i-B);i=v(n-A);h=v(h-z);g=v(v(v(f*f)+v(i*i))+v(h*h));if(!(g<y)){break a}d:{if(!!(g>v(1.1920928955078125e-7))){o[d+12>>2]=0;m=h;g=v(C(g));h=v(v(1)/g);s[d+8>>2]=m*h;s[d+4>>2]=i*h;s[d>>2]=f*h;x=v(x-g);break d}o[d+12>>2]=0;s[d+8>>2]=q;s[d+4>>2]=p;s[d>>2]=m;}o[c+12>>2]=0;s[c+8>>2]=z;s[c+4>>2]=A;s[c>>2]=B;s[e>>2]=-x;w=1;}K=j+32|0;return w}function eh(a,b,c,d,e,f,g,h,i){var j=0,k=0,n=0,q=v(0),r=0,t=0,u=0,w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=0,C=0,D=v(0),E=0;k=K-32|0;K=k;if(a){j=o[h+4>>2];if((j|0)<=127){if(o[h+8>>2]<=127){o[6257]=o[6257]+1;r=l[o[4968]](512,16)|0;u=o[h+4>>2];if((u|0)>=1){while(1){n=t<<2;o[n+r>>2]=o[n+o[h+12>>2]>>2];t=t+1|0;if((u|0)!=(t|0)){continue}break}}t=o[h+12>>2];if(t){if(p[h+16|0]){if(t){o[6258]=o[6258]+1;l[o[4969]](t);}}o[h+12>>2]=0;}o[h+12>>2]=r;m[h+16|0]=1;o[h+8>>2]=128;}while(1){o[o[h+12>>2]+(j<<2)>>2]=0;j=j+1|0;if((j|0)!=128){continue}break}}o[h+4>>2]=128;o[o[h+12>>2]>>2]=a;j=126;t=1;while(1){u=o[h+12>>2];a=t+ -1|0;C=a<<2;r=o[u+C>>2];w=s[r>>2];x=s[r+4>>2];q=s[r+8>>2];y=s[g>>2];z=s[g+4>>2];A=s[g+8>>2];o[k+12>>2]=0;s[k+8>>2]=q-A;s[k+4>>2]=x-z;s[k>>2]=w-y;w=s[r+16>>2];x=s[r+20>>2];q=s[r+24>>2];y=s[f>>2];z=s[f+4>>2];A=s[f+8>>2];o[k+28>>2]=0;s[k+24>>2]=q-A;s[k+20>>2]=x-z;s[k+16>>2]=w-y;n=o[d+4>>2];y=s[b+4>>2];z=s[c+4>>2];w=v(v(s[((n<<4)+k|0)+4>>2]-y)*z);q=s[c>>2];B=o[d>>2];A=s[b>>2];x=v(q*v(s[(1-B<<4)+k>>2]-A));a:{if(w>x){break a}q=v(v(s[(B<<4)+k>>2]-A)*q);y=v(z*v(s[((1-n<<4)+k|0)+4>>2]-y));if(q>y){break a}n=o[d+8>>2];A=s[b+8>>2];D=s[c+8>>2];z=v(v(s[((n<<4)+k|0)+8>>2]-A)*D);x=y<x?y:x;if(z>x){break a}w=w>q?w:q;q=v(D*v(s[((1-n<<4)+k|0)+8>>2]-A));if(w>q|(z>w?z:w)<e^1|(q<x?q:x)>v(0)^1){break a}if(o[r+40>>2]){if((a|0)>(j|0)){j=o[h+4>>2];n=j<<1;if((j|0)<(n|0)){if(o[h+8>>2]<(n|0)){b:{if(!j){u=0;break b}o[6257]=o[6257]+1;u=l[o[4968]](j<<3,16)|0;a=0;B=o[h+4>>2];if((B|0)<1){break b}while(1){E=a<<2;o[E+u>>2]=o[o[h+12>>2]+E>>2];a=a+1|0;if((B|0)!=(a|0)){continue}break}}a=o[h+12>>2];if(a){if(p[h+16|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[h+12>>2]=0;}o[h+12>>2]=u;m[h+16|0]=1;o[h+8>>2]=n;}while(1){o[(j<<2)+u>>2]=0;u=o[h+12>>2];j=j+1|0;if((n|0)!=(j|0)){continue}break}}o[h+4>>2]=n;j=n+ -2|0;}o[u+C>>2]=o[r+36>>2];o[o[h+12>>2]+(t<<2)>>2]=o[r+40>>2];a=t+1|0;break a}l[o[o[i>>2]+12>>2]](i,r);}t=a;if(a){continue}break}}K=k+32|0;}function wu(a,b){var c=0,d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=0,j=0,k=0,n=0,q=v(0),r=0,t=0,u=0,w=0,x=0,y=v(0),z=0,A=v(0),B=0,D=0,E=0,F=v(0),G=0;n=o[a+4>>2];if((n|0)>=1){while(1){a:{c=u;u=c+1|0;if((u|0)>=(n|0)){break a}d=o[a+12>>2];r=d+(c<<4)|0;D=r;c=u;while(1){b:{w=c+1|0;if((w|0)>=(n|0)){break b}z=(c<<4)+d|0;E=z;x=w;while(1){e=s[r>>2];g=v(s[z>>2]-e);c=(x<<4)+d|0;f=s[r+4>>2];h=v(s[c+4>>2]-f);f=v(s[z+4>>2]-f);e=v(s[c>>2]-e);F=v(v(g*h)-v(f*e));q=s[D+8>>2];y=v(s[E+8>>2]-q);A=v(y*e);e=v(s[c+8>>2]-q);A=v(A-v(g*e));y=v(v(f*e)-v(y*h));e=v(1);d=0;while(1){G=d;g=v(F*e);f=v(y*e);h=v(A*e);e=v(v(g*g)+v(v(f*f)+v(h*h)));c:{if(!(e>v(9999999747378752e-20))){break c}q=v(v(1)/v(C(e)));e=v(g*q);g=v(h*q);f=v(f*q);i=o[b+4>>2];if((i|0)>=1){k=o[b+12>>2];c=0;while(1){d=k+(c<<4)|0;if(!!(v(v(v(f*s[d>>2])+v(g*s[d+4>>2]))+v(e*s[d+8>>2]))>v(.9990000128746033))){break c}c=c+1|0;if((i|0)!=(c|0)){continue}break}}h=v(v(v(f*s[r>>2])+v(g*s[r+4>>2]))+v(e*s[D+8>>2]));k=o[a+4>>2];if((k|0)>=1){j=o[a+12>>2];c=0;while(1){d=j+(c<<4)|0;if(!!(v(v(v(v(v(f*s[d>>2])+v(g*s[d+4>>2]))+v(e*s[d+8>>2]))-h)+v(-.009999999776482582))>v(0))){break c}c=c+1|0;if((k|0)!=(c|0)){continue}break}}h=v(-h);d:{if(o[b+8>>2]!=(i|0)){break d}c=i?i<<1:1;if((i|0)>=(c|0)){break d}d=0;k=0;if(c){o[6257]=o[6257]+1;k=l[o[4968]](c<<4,16)|0;i=o[b+4>>2];}if((i|0)>=1){while(1){j=d<<4;t=j+k|0;j=j+o[b+12>>2]|0;B=o[j+4>>2];o[t>>2]=o[j>>2];o[t+4>>2]=B;B=o[j+12>>2];o[t+8>>2]=o[j+8>>2];o[t+12>>2]=B;d=d+1|0;if((i|0)!=(d|0)){continue}break}}d=o[b+12>>2];if(d){if(p[b+16|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[b+12>>2]=0;}o[b+12>>2]=k;m[b+16|0]=1;o[b+8>>2]=c;i=o[b+4>>2];}c=o[b+12>>2]+(i<<4)|0;s[c+12>>2]=h;s[c+8>>2]=e;s[c+4>>2]=g;s[c>>2]=f;o[b+4>>2]=o[b+4>>2]+1;}e=v(-1);d=1;if(!G){continue}break}x=x+1|0;if((x|0)>=(n|0)){break b}d=o[a+12>>2];continue}}if((n|0)==(w|0)){break a}d=o[a+12>>2];c=w;continue}}if((n|0)!=(u|0)){continue}break}}}function uo(a,b,c){var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),x=v(0),y=0,z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0);y=K-16|0;K=y;f=s[b+464>>2];e=s[b+460>>2];A=s[b+396>>2];B=s[b+392>>2];i=s[b+456>>2];C=s[b+388>>2];fb(b+4|0,y);j=s[y+4>>2];k=s[y>>2];l=s[y+12>>2];m=s[y+8>>2];o[a+12>>2]=0;g=v(v(A*k)+v(v(B*l)-v(C*m)));t=v(v(v(C*k)+v(B*j))+v(A*m));n=v(v(B*m)+v(v(C*l)-v(A*j)));u=v(v(C*j)+v(v(A*l)-v(B*k)));h=v(v(v(m*g)+v(v(k*t)+v(l*n)))-v(j*u));p=v(v(v(j*n)+v(v(m*t)+v(l*u)))-v(k*g));q=v(p*v(0));r=v(h*v(0));d=e!=v(0)?v(v(1)/e):v(0);e=v(v(v(k*u)+v(v(j*t)+v(l*g)))-v(m*n));t=v(q+v(r+v(d*e)));g=i!=v(0)?v(v(1)/i):v(0);n=v(e*v(0));u=v(q+v(v(h*g)+n));i=v(v(v(h*t)-v(e*u))*c);H=v(v(v(v(v(r-v(g*e))+v(0))+t)*c)+v(0));f=f!=v(0)?v(v(1)/f):v(0);D=v(v(f*p)+v(r+n));E=v(v(v(v(n+v(v(0)-v(d*p)))+D)*c)+v(0));F=v(v(v(v(v(q+v(0))-v(f*h))+u)*c)+v(0));z=v(h*v(-0));q=v(d+v(v(z+v(v(d*v(0))+q))*c));x=v(p*v(-0));G=v(v(v(v(v(f*e)+v(x+v(0)))-t)*c)+v(0));I=v(v(E*F)-v(q*G));n=v(g+v(v(n+v(v(g*v(0))+x))*c));x=v(e*v(-0));f=v(f+v(v(v(f*v(0))+v(x+r))*c));r=v(v(v(v(v(x+v(d*h))+v(0))-u)*c)+v(0));x=v(v(q*f)-v(r*F));z=v(v(v(v(z+v(v(g*p)+v(0)))-D)*c)+v(0));J=v(v(r*G)-v(f*E));d=v(v(H*I)+v(v(n*x)+v(z*J)));g=v(w(d))>v(1.1920928955078125e-7)?v(v(1)/d):d;d=v(v(v(e*D)-v(p*t))*c);c=v(v(v(p*u)-v(h*D))*c);h=v(h-v(v(v(i*I)+v(v(d*x)+v(c*J)))*g));e=v(e-v(v(v(H*v(v(F*d)-v(G*c)))+v(v(n*v(v(f*c)-v(F*i)))+v(z*v(v(G*i)-v(f*d)))))*g));c=v(p-v(v(v(H*v(v(E*c)-v(q*d)))+v(v(n*v(v(q*i)-v(r*c)))+v(z*v(v(r*d)-v(E*i)))))*g));p=v(v(v(m*h)+v(l*e))-v(k*c));i=v(v(v(l*c)+v(k*e))-v(j*h));d=v(v(v(h*v(-k))-v(j*e))-v(m*c));c=v(v(v(l*h)+v(j*c))-v(m*e));s[a+8>>2]=v(v(k*p)+v(v(v(l*i)-v(m*d))-v(j*c)))-A;s[a+4>>2]=v(v(m*c)+v(v(v(l*p)-v(j*d))-v(k*i)))-B;s[a>>2]=v(v(j*i)+v(v(v(l*c)-v(k*d))-v(m*p)))-C;K=y+16|0;}function fn(a,b,c,d,e,f,g,h,i){var j=0,k=0,l=0,n=0,q=0,r=0,t=0,v=0,w=0,x=0,y=0;j=K-112|0;K=j;o[j+100>>2]=0;o[j+104>>2]=0;o[j+108>>2]=0;o[j+92>>2]=0;o[j+96>>2]=0;m[j+88|0]=0;o[j+84>>2]=0;m[j+80|0]=0;o[j+76>>2]=0;m[j+72|0]=0;o[j+68>>2]=0;m[j+64|0]=0;o[j+56>>2]=0;o[j+60>>2]=1036831949;m[j+52|0]=0;o[j+48>>2]=0;o[j+40>>2]=0;o[j+44>>2]=1063675494;o[j+32>>2]=0;o[j+36>>2]=1045220557;o[j+24>>2]=1065353216;o[j+28>>2]=-1082130432;w=b+4|0;x=a+680|0;while(1){n=r+x|0;q=p[n+112|0];v=r<<2;k=v+x|0;y=o[k+276>>2];a:{b:{if(y){break b}l=q;q=1;if(l){break b}q=0;if(!p[(a+r|0)+798|0]){break a}}l=o[k+32>>2];o[j+108>>2]=y;o[j+32>>2]=l;o[j+104>>2]=o[k+260>>2];o[j+96>>2]=o[k+228>>2];l=o[k+244>>2];m[j+52|0]=q;o[j+100>>2]=l;m[j+64|0]=p[n+115|0];o[j+68>>2]=o[k+124>>2];m[j+72|0]=p[n+118|0];o[j+76>>2]=o[k+140>>2];m[j+80|0]=p[n+156|0];o[j+84>>2]=o[k+160>>2];m[j+88|0]=p[n+176|0];o[j+92>>2]=o[k+180>>2];o[j+28>>2]=o[k+16>>2];o[j+24>>2]=o[k>>2];o[j+60>>2]=o[k+212>>2];o[j+56>>2]=o[k+196>>2];l=a+v|0;o[j+8>>2]=o[l+1236>>2];o[j+12>>2]=o[l+1252>>2];q=o[l+1268>>2];o[j+20>>2]=0;o[j+16>>2]=q;q=j;k=o[a+1456>>2]>>v;n=l+744|0;c:{if(k&1){break c}n=o[b+32>>2];}o[q+40>>2]=o[n>>2];o[j+36>>2]=o[(k&2?l+728|0:w)>>2];o[j+48>>2]=o[(k&4?l+776|0:o[b+32>>2])>>2];o[j+44>>2]=o[(k&8?l+760|0:w)>>2];q=1;n=((r+2&255)>>>0)%3|0;l=u(((r+1&255)>>>0)%3|0,88)+a|0;k=o[l+1052>>2]+ -1|0;d:{if(k>>>0<=3){e:{switch(k-2|0){case 0:t=+s[l+1040>>2];q=t<-.001|t>.001;break d;case 1:break e;default:break d}}if(+s[l+1040>>2]<-.001){break d}q=+s[l+1044>>2]>.001;break d}q=0;}k=1;l=u(n,88)+a|0;n=o[l+1052>>2]+ -1|0;f:{if(n>>>0>3){break f}g:{h:{switch(n-2|0){case 0:t=+s[l+1040>>2];if(t<-.001|t>.001){break g}break f;case 1:break h;default:break g}}if(+s[l+1040>>2]<-.001){break g}if(!(+s[l+1044>>2]>.001)){break f}}k=0;}c=rf(a,j+24|0,d,e,f,g,h,i,b,c,j+8|0,0,q?k:1)+c|0;}r=r+1|0;if((r|0)!=3){continue}break}K=j+112|0;}function Wu(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=v(0),n=0;g=K-32|0;K=g;d=a+4|0;Vg(d,((u(o[a+112>>2],o[a+16>>2])|0)/100|0)+1|0);if(o[a+124>>2]){c=((u(o[a+108>>2],o[a+56>>2])|0)/100|0)+1|0;Vg(a+44|0,c);c=o[a+124>>2]-c|0;o[a+124>>2]=(c|0)>0?c:0;}c=(o[a+104>>2]+1|0)%2|0;o[a+104>>2]=c;c=o[((c<<2)+a|0)+84>>2];if(c){i=a+44|0;f=g+16|0;while(1){h=o[c+56>>2];e=o[c+52>>2];a:{if(e){j=e+56|0;break a}j=((o[c+60>>2]<<2)+a|0)+84|0;}o[j>>2]=h;e=o[c+56>>2];if(e){o[e+52>>2]=o[c+52>>2];}o[c+52>>2]=0;o[c+56>>2]=o[a+92>>2];e=o[a+92>>2];if(e){o[e+52>>2]=c;}o[a+92>>2]=c;vc(d,o[c+48>>2]);e=o[c+28>>2];o[g+8>>2]=o[c+24>>2];o[g+12>>2]=e;e=o[c+20>>2];o[g>>2]=o[c+16>>2];o[g+4>>2]=e;e=o[c+44>>2];o[f+8>>2]=o[c+40>>2];o[f+12>>2]=e;e=o[c+36>>2];o[f>>2]=o[c+32>>2];o[f+4>>2]=e;e=wc(i,g,c);o[c+60>>2]=2;o[c+48>>2]=e;c=h;if(c){continue}break}m[a+154|0]=1;o[a+124>>2]=o[a+56>>2];}o[g>>2]=16056;o[g+4>>2]=a;b:{if(!p[a+153|0]){break b}Bc(d,o[a+4>>2],o[a+44>>2],g);if(!p[a+153|0]){break b}c=o[d>>2];Bc(d,c,c,g);}c:{if(!p[a+154|0]){break c}c=o[a+96>>2];i=l[o[o[c>>2]+28>>2]](c)|0;d=o[i+4>>2];if((d|0)<1){break c}j=a;c=o[a+120>>2];f=(u(o[a+116>>2],d)|0)/100|0;c=(c|0)>(f|0)?c:f;e=(d|0)<(c|0)?d:c;d:{if((e|0)>=1){c=0;while(1){f=o[i+12>>2]+((o[a+144>>2]+c|0)%(d|0)<<4)|0;h=o[f>>2];d=o[h+48>>2];n=o[f+4>>2];f=o[n+48>>2];e:{f:{if(s[d>>2]<=s[f+16>>2]^1|s[d+16>>2]>=s[f>>2]^1|(s[d+4>>2]<=s[f+20>>2]^1|s[d+20>>2]>=s[f+4>>2]^1)){break f}if(!(s[d+8>>2]<=s[f+24>>2])){break f}if(s[d+24>>2]>=s[f+8>>2]){break e}}d=o[a+96>>2];l[o[o[d>>2]+12>>2]](d,h,n,b)|0;c=c+ -1|0;e=e+ -1|0;}d=o[i+4>>2];c=c+1|0;if((c|0)<(e|0)){continue}break}b=0;if((d|0)<=0){break d}}b=(o[a+144>>2]+e|0)%(d|0)|0;}o[j+144>>2]=b;}m[a+154|0]=0;o[a+120>>2]=1;o[a+140>>2]=o[a+140>>2]+1;c=o[a+132>>2];b=a;h=o[a+128>>2];k=v(0);g:{if(!h){break g}k=v(v(c>>>0)/v(h>>>0));}s[b+136>>2]=k;o[a+132>>2]=c>>>1;o[a+128>>2]=h>>>1;K=g+32|0;}function to(a,b,c){var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0);k=s[b+396>>2];l=s[b+44>>2];x=s[b+40>>2];d=s[b+36>>2];m=s[b+12>>2];n=s[b+8>>2];p=s[b+392>>2];f=s[b+28>>2];e=s[b+464>>2];j=s[b+24>>2];q=s[b+460>>2];g=s[b+20>>2];r=s[b+388>>2];h=s[b+4>>2];y=s[b+456>>2];o[a+12>>2]=0;t=y!=v(0)?v(v(1)/y):v(0);u=v(d*t);B=q!=v(0)?v(v(1)/q):v(0);A=v(x*B);e=e!=v(0)?v(v(1)/e):v(0);C=v(l*e);q=v(v(v(h*u)+v(n*A))+v(m*C));i=v(t*g);z=v(B*j);D=v(e*f);y=v(v(v(h*i)+v(n*z))+v(m*D));E=v(r*y);F=v(t*h);G=v(B*n);H=v(e*m);h=v(v(v(h*F)+v(n*G))+v(m*H));e=v(v(v(i*g)+v(z*j))+v(D*f));t=v(v(v(i*d)+v(z*x))+v(D*l));z=v(k*t);m=v(v(E+v(p*e))+z);B=v(q+v(v(v(v(q*v(0))+v(E-v(p*h)))+m)*c));i=v(v(v(F*g)+v(G*j))+v(H*f));D=v(r*q);g=v(v(v(u*g)+v(A*j))+v(C*f));j=v(p*g);f=v(v(v(u*d)+v(A*x))+v(C*l));n=v(v(D+j)+v(k*f));j=v(i+v(v(n+v(j+v(v(i*v(0))-v(k*e))))*c));E=v(p*i);d=v(v(v(F*d)+v(G*x))+v(H*l));u=v(k*d);l=v(v(v(r*h)+E)+u);C=v(c*v(0));x=v(v(m+v(v(v(k*l)-v(r*n))*c))-v(C+m));u=v(t+v(v(l+v(v(v(t*v(0))+u)-v(r*f)))*c));i=v(e+v(v(v(v(e*v(0))+v(k*i))-v(r*g))*c));A=v(d+v(v(v(v(p*f)+v(v(d*v(0))-z))-m)*c));z=v(v(j*u)-v(i*A));q=v(h+v(v(v(p*q)+v(v(h*v(0))-v(k*y)))*c));f=v(f+v(v(v(f*v(0))+v(v(r*t)-v(p*d)))*c));g=v(g+v(v(v(v(g*v(0))+v(v(r*e)-E))-l)*c));t=v(v(i*f)-v(g*u));e=v(y+v(v(v(v(v(y*v(0))+v(k*h))-D)-n)*c));y=v(v(g*A)-v(j*f));d=v(v(B*z)+v(v(q*t)+v(e*y)));h=v(w(d))>v(1.1920928955078125e-7)?v(v(1)/d):d;d=v(v(l+v(v(v(p*n)-v(k*m))*c))-v(C+l));c=v(v(n+v(v(v(r*m)-v(p*l))*c))-v(C+n));s[a+8>>2]=v(k-v(v(v(B*v(v(j*x)-v(i*d)))+v(v(q*v(v(i*c)-v(g*x)))+v(e*v(v(g*d)-v(j*c)))))*h))-k;s[a+4>>2]=v(p-v(v(v(B*v(v(u*d)-v(A*x)))+v(v(q*v(v(f*x)-v(u*c)))+v(e*v(v(A*c)-v(f*d)))))*h))-p;s[a>>2]=v(r-v(v(v(c*z)+v(v(d*t)+v(x*y)))*h))-r;}function ur(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;c=K-320|0;K=c;o[c+316>>2]=a;o[c+312>>2]=b;a=o[c+316>>2];b=c+296|0;o[(K-16|0)+12>>2]=b;e=c+280|0;o[(K-16|0)+12>>2]=e;cg(o[c+312>>2],b,e);f=K-16|0;o[f+12>>2]=a+552;f=o[f+12>>2]+48|0;d=o[f+4>>2];g=c+264|0;o[g>>2]=o[f>>2];o[g+4>>2]=d;d=o[f+12>>2];o[g+8>>2]=o[f+8>>2];o[g+12>>2]=d;f=K-16|0;o[f+12>>2]=a+552;f=o[f+12>>2];d=K-16|0;o[d+12>>2]=b;d=o[d+12>>2];i=K-16|0;o[i+12>>2]=e;i=o[i+12>>2];j=K-16|0;o[j+12>>2]=o[c+312>>2];j=o[j+12>>2];k=K-16|0;o[k+12>>2]=b;k=o[k+12>>2]+4|0;l=K-16|0;o[l+12>>2]=e;l=o[l+12>>2]+4|0;m=K-16|0;o[m+12>>2]=o[c+312>>2];m=o[m+12>>2]+4|0;h=K-16|0;o[h+12>>2]=b;h=o[h+12>>2]+8|0;n=K-16|0;o[n+12>>2]=e;e=o[n+12>>2]+8|0;n=K-16|0;o[n+12>>2]=o[c+312>>2];cb(f,d,i,j,k,l,m,h,e,o[n+12>>2]+8|0);e=K-16|0;o[e+12>>2]=o[a+28>>2];f=K-16|0;o[f+12>>2]=o[e+12>>2]+4;e=c+248|0;Sa(e,o[f+12>>2],o[c+312>>2]);d=c+232|0;tr(d,o[c+312>>2],e);f=c+216|0;sr(f,d,b);b=c+200|0;dc(b,e,f);d=K-16|0;o[d+12>>2]=o[a+32>>2];i=c+120|0;bc(i,o[d+12>>2]+4|0);d=K-16|0;o[d+12>>2]=o[a+28>>2];j=c+104|0;Yb(j,o[d+12>>2]+4|0,g);Yb(c+184|0,i,j);g=K-16|0;o[g+12>>2]=a+616;d=o[c+188>>2];g=o[g+12>>2]+48|0;o[g>>2]=o[c+184>>2];o[g+4>>2]=d;d=o[c+196>>2];o[g+8>>2]=o[c+192>>2];o[g+12>>2]=d;g=K-16|0;o[g+12>>2]=a+616;g=o[g+12>>2];d=K-16|0;o[d+12>>2]=f;d=o[d+12>>2];i=K-16|0;o[i+12>>2]=b;i=o[i+12>>2];j=K-16|0;o[j+12>>2]=e;j=o[j+12>>2];k=K-16|0;o[k+12>>2]=f;k=o[k+12>>2]+4|0;l=K-16|0;o[l+12>>2]=b;l=o[l+12>>2]+4|0;m=K-16|0;o[m+12>>2]=e;m=o[m+12>>2]+4|0;h=K-16|0;o[h+12>>2]=f;f=o[h+12>>2]+8|0;h=K-16|0;o[h+12>>2]=b;b=o[h+12>>2]+8|0;h=K-16|0;o[h+12>>2]=e;cb(g,d,i,j,k,l,m,f,b,o[h+12>>2]+8|0);b=K-16|0;o[b+12>>2]=o[a+32>>2];e=K-16|0;o[e+12>>2]=o[b+12>>2]+4;b=c+8|0;rr(b,o[e+12>>2]);e=K-16|0;o[e+12>>2]=a+616;g=c+56|0;bg(g,b,o[e+12>>2]);b=K-16|0;o[b+12>>2]=a+616;sd(o[b+12>>2],g);K=c+320|0;}function ik(a,b,c,d){var e=0,f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=0,n=0,p=0,q=0,r=v(0),t=0,u=v(0),w=v(0),x=0,y=0,z=0,A=0,B=v(0),D=0,E=0,F=0,G=0,H=0,I=0;e=K-544|0;K=e;a:{if(!a){break a}f=s[b+8>>2];g=s[c+8>>2];i=s[b>>2];h=s[c>>2];j=s[b+4>>2];r=s[c+4>>2];o[e+32>>2]=a;k=v(g-f);u=k;f=v(h-i);g=v(r-j);h=v(v(1)/v(C(v(v(v(f*f)+v(g*g))+v(k*k)))));k=v(k*h);r=f;f=v(f*h);w=g;g=v(g*h);B=v(v(u*k)+v(v(r*f)+v(w*g)));k=k==v(0)?v(0xde0b6b000000000):v(v(1)/k);a=k<v(0);D=(a<<4)+e|8;g=g==v(0)?v(0xde0b6b000000000):v(v(1)/g);c=g<v(0);E=(c<<4)+e|4;F=((a^1)<<4)+e|8;G=((c^1)<<4)+e|4;f=f==v(0)?v(0xde0b6b000000000):v(v(1)/f);a=f<v(0);H=(a<<4)+e|0;I=((a^1)<<4)+e|0;z=126;t=128;n=e+32|0;p=128;x=1;while(1){a=x+ -1|0;A=a<<2;m=o[A+n>>2];c=o[m+4>>2];o[e>>2]=o[m>>2];o[e+4>>2]=c;c=o[m+12>>2];o[e+8>>2]=o[m+8>>2];o[e+12>>2]=c;c=o[m+28>>2];o[e+24>>2]=o[m+24>>2];o[e+28>>2]=c;c=o[m+20>>2];o[e+16>>2]=o[m+16>>2];o[e+20>>2]=c;b:{c:{d:{e:{f:{g:{h:{h=v(g*v(s[E>>2]-j));r=v(f*v(s[I>>2]-i));i:{if(h>r){break i}i=v(f*v(s[H>>2]-i));j=v(g*v(s[G>>2]-j));if(i>j){break i}w=s[b+8>>2];u=v(k*v(s[D>>2]-w));j=j<r?j:r;if(u>j){break i}i=h>i?h:i;h=v(k*v(s[F>>2]-w));if(i>h|(u>i?u:i)<B^1|(h<j?h:j)>v(0)^1){break i}if(o[m+40>>2]){if((a|0)<=(z|0)){c=n;q=p;break c}q=p<<1;if((p|0)>=(q|0)){c=n;break d}if((t|0)>=(q|0)){c=n;break e}if(!p){c=0;break h}a=0;o[6257]=o[6257]+1;c=l[o[4968]](p<<3,16)|0;if((p|0)<1){break h}while(1){t=a<<2;o[t+c>>2]=o[n+t>>2];a=a+1|0;if((p|0)!=(a|0)){continue}break}if(!y){break f}break g}l[o[o[d>>2]+12>>2]](d,m);}c=n;q=p;break b}a=y;y=1;if(!a){break f}t=q;if(!n){break e}}if(n){o[6258]=o[6258]+1;l[o[4969]](n);}}y=1;t=q;}a=p<<2;$(a+c|0,0,a);}z=q+ -2|0;}o[c+A>>2]=o[m+36>>2];o[(x<<2)+c>>2]=o[m+40>>2];a=x+1|0;}if(a){j=s[b+4>>2];i=s[b>>2];n=c;p=q;x=a;continue}break}if(!y|!c){break a}if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}K=e+544|0;}function Zm(a,b,c,d){var e=0,f=v(0),g=v(0),h=0,i=0,j=v(0),k=v(0),l=v(0),m=0,n=0,p=0,q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=0,A=0;i=o[b+8>>2];o[i>>2]=1065353216;n=o[b+24>>2];m=n<<2;z=m+4|0;o[i+z>>2]=1065353216;p=n<<3;A=p+8|0;o[i+A>>2]=1065353216;j=s[c+20>>2];q=s[c+24>>2];k=s[c+36>>2];f=s[a+304>>2];r=s[c+40>>2];g=s[a+308>>2];t=s[c+8>>2];u=s[c>>2];w=s[c+4>>2];x=s[c+16>>2];y=s[c+32>>2];l=s[a+300>>2];i=K-16|0;o[i+12>>2]=0;k=v(v(v(l*y)+v(f*k))+v(g*r));s[i+8>>2]=k;j=v(v(v(l*x)+v(f*j))+v(g*q));s[i+4>>2]=j;f=v(v(v(u*l)+v(w*f))+v(t*g));s[i>>2]=f;e=o[b+12>>2];o[e+12>>2]=0;s[e+8>>2]=-j;s[e+4>>2]=k;o[e>>2]=0;h=e+m|0;o[h+12>>2]=0;s[h+8>>2]=f;o[h+4>>2]=0;s[h>>2]=-k;e=e+p|0;o[e+8>>2]=0;o[e+12>>2]=0;s[e+4>>2]=-f;s[e>>2]=j;e=o[b+16>>2];o[e>>2]=-1082130432;o[e+z>>2]=-1082130432;o[e+A>>2]=-1082130432;j=s[d+36>>2];q=s[d+40>>2];k=s[d+20>>2];f=s[a+320>>2];r=s[d+24>>2];g=s[a+324>>2];t=s[d+8>>2];u=s[d>>2];w=s[d+4>>2];x=s[d+32>>2];y=s[d+16>>2];l=s[a+316>>2];e=o[b+20>>2];o[e+12>>2]=0;o[e>>2]=0;k=v(v(v(l*y)+v(f*k))+v(g*r));s[e+8>>2]=k;j=v(v(v(l*x)+v(f*j))+v(g*q));s[e+4>>2]=-j;h=e+m|0;o[h+12>>2]=0;f=v(v(v(u*l)+v(w*f))+v(t*g));s[h+8>>2]=-f;o[h+4>>2]=0;s[h>>2]=j;e=e+p|0;o[e+8>>2]=0;o[e+12>>2]=0;s[e+4>>2]=f;s[e>>2]=-k;e=o[b+28>>2];h=o[a+332>>2];g=v(s[(h&1?a+336|0:b+4|0)>>2]*s[b>>2]);s[e>>2]=g*v(v(v(f+s[d+48>>2])-s[i>>2])-s[c+48>>2]);s[e+m>>2]=g*v(v(v(k+s[d+52>>2])-s[i+4>>2])-s[c+52>>2]);s[e+p>>2]=g*v(v(v(j+s[d+56>>2])-s[i+8>>2])-s[c+56>>2]);c=n<<1;if(h&2){d=o[b+32>>2];o[d>>2]=o[a+340>>2];o[d+m>>2]=o[a+340>>2];o[d+(c<<2)>>2]=o[a+340>>2];}g=s[a+356>>2];l=v(-g);f=g;if(!!(g>v(0))){s[o[b+36>>2]>>2]=l;s[o[b+40>>2]>>2]=g;f=s[a+356>>2];}if(!!(f>v(0))){d=n<<2;s[d+o[b+36>>2]>>2]=l;s[d+o[b+40>>2]>>2]=g;f=s[a+356>>2];}if(!!(f>v(0))){c=c<<2;s[c+o[b+36>>2]>>2]=l;s[c+o[b+40>>2]>>2]=g;}o[b+48>>2]=o[a+352>>2];}function am(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=v(0),h=v(0),i=0,j=0;f=K-16|0;K=f;o[5383]=o[5383]+1;if(o[a+4>>2]&2){e=o[b+192>>2];g=v(l[o[o[e>>2]+20>>2]](e,s[4962]));s[f+12>>2]=g;e=o[c+192>>2];h=v(l[o[o[e>>2]+20>>2]](e,s[4962]));s[f+8>>2]=h;e=g<h?f+12|0:f+8|0;}else {e=19848;}i=o[e>>2];g=s[c+184>>2];h=s[b+184>>2];d=o[a+72>>2];e=o[d+12>>2];a:{b:{if(e){o[d+12>>2]=o[e>>2];o[d+8>>2]=o[d+8>>2]+ -1;break b}e=0;if(p[a+4|0]&4){break a}o[6257]=o[6257]+1;e=l[o[4968]](868,16)|0;}o[e>>2]=1025;o[e+168>>2]=0;d=e;o[d+160>>2]=0;o[d+164>>2]=0;o[d+152>>2]=0;o[d+156>>2]=0;o[d+144>>2]=0;o[d+148>>2]=0;o[d+136>>2]=0;o[d+140>>2]=0;o[d+128>>2]=0;o[d+132>>2]=0;o[d+120>>2]=0;o[d+124>>2]=0;o[d+328>>2]=0;o[d+332>>2]=0;o[d+336>>2]=0;o[d+340>>2]=0;o[d+344>>2]=0;o[d+348>>2]=0;o[d+352>>2]=0;o[d+356>>2]=0;o[d+360>>2]=0;o[d+364>>2]=0;o[d+368>>2]=0;o[d+372>>2]=0;o[d+376>>2]=0;o[d+536>>2]=0;o[d+540>>2]=0;o[d+544>>2]=0;o[d+548>>2]=0;o[d+552>>2]=0;o[d+556>>2]=0;o[d+560>>2]=0;o[d+564>>2]=0;o[d+568>>2]=0;o[d+572>>2]=0;o[d+576>>2]=0;o[d+580>>2]=0;o[d+584>>2]=0;o[d+792>>2]=0;o[d+784>>2]=0;o[d+788>>2]=0;o[d+776>>2]=0;o[d+780>>2]=0;o[d+768>>2]=0;o[d+772>>2]=0;o[d+760>>2]=0;o[d+764>>2]=0;o[d+752>>2]=0;o[d+756>>2]=0;o[d+744>>2]=0;o[d+748>>2]=0;o[d+836>>2]=b;o[d+840>>2]=c;o[d+844>>2]=0;o[d+848>>2]=i;s[d+852>>2]=h<g?h:g;c=o[a+12>>2];o[d+864>>2]=c;c:{if(o[a+16>>2]!=(c|0)){break c}j=c?c<<1:1;if((c|0)>=(j|0)){break c}d:{if(!j){i=0;break d}o[6257]=o[6257]+1;i=l[o[4968]](j<<2,16)|0;c=o[a+12>>2];}if((c|0)>=1){b=0;while(1){d=b<<2;o[d+i>>2]=o[o[a+20>>2]+d>>2];b=b+1|0;if((c|0)!=(b|0)){continue}break}}b=o[a+20>>2];if(b){if(p[a+24|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}c=o[a+12>>2];}o[a+20>>2]=0;}o[a+20>>2]=i;o[a+16>>2]=j;m[a+24|0]=1;}o[o[a+20>>2]+(c<<2)>>2]=e;o[a+12>>2]=c+1;}K=f+16|0;return e|0}function el(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0,q=0,r=0,s=0,t=0,u=0;s=K-16|0;K=s;fl(a,b,c);n=o[a+8>>2];l[o[4966]](6116);a:{if(!p[a+64|0]){a=l[o[o[b>>2]+44>>2]](b)|0;b=l[o[o[b>>2]+36>>2]](b)|0;l[o[o[d>>2]+8>>2]](d,o[c+16>>2],o[c+8>>2],a,b,-1);break a}j=o[a+28>>2];if((j|0)>=2){Ue(a+24|0,s,0,j+ -1|0);}if((n|0)<1){break a}h=1;while(1){b=o[a+16>>2];r=o[b+(i<<3)>>2];t=1;b:{if((i|0)>=(n|0)){break b}while(1){q=o[o[c+16>>2]+(o[((i<<3)+b|0)+4>>2]<<2)>>2];e=o[a+48>>2];c:{if((e|0)!=o[a+52>>2]){break c}g=e?e<<1:1;if((e|0)>=(g|0)){break c}b=0;f=0;if(g){o[6257]=o[6257]+1;f=l[o[4968]](g<<2,16)|0;e=o[a+48>>2];}if((e|0)>=1){while(1){u=b<<2;o[u+f>>2]=o[u+o[a+56>>2]>>2];b=b+1|0;if((e|0)!=(b|0)){continue}break}}b=o[a+56>>2];if(b){if(p[a+60|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}e=o[a+48>>2];}o[a+56>>2]=0;}o[a+56>>2]=f;m[a+60|0]=1;o[a+52>>2]=g;}o[o[a+56>>2]+(e<<2)>>2]=q;o[a+48>>2]=e+1;b=o[q+220>>2];t=((b|0)==2|(b|0)==5)&t;i=i+1|0;if((n|0)==(i|0)){i=n;break b}b=o[a+16>>2];if(o[b+(i<<3)>>2]==(r|0)){continue}break}}f=0;b=0;d:{if((k|0)>=(j|0)){break d}q=o[a+36>>2];g=q+(k<<2)|0;b=o[g>>2];e=o[o[b+836>>2]+208>>2];if((e|0)<=-1){e=o[o[b+840>>2]+208>>2];}b=0;if((e|0)!=(r|0)){break d}b=k+1|0;e=(j|0)>(b|0)?j:b;h=k;while(1){e:{h=h+1|0;if((h|0)>=(j|0)){h=e;break e}f=o[(h<<2)+q>>2];b=o[o[f+836>>2]+208>>2];if((b|0)<=-1){b=o[o[f+840>>2]+208>>2];}if((b|0)==(r|0)){continue}}break}f=h-k|0;b=g;}if(!t){l[o[o[d>>2]+8>>2]](d,o[a+56>>2],o[a+48>>2],b,f,r);}b=o[a+48>>2];if((b|0)<=-1){if(o[a+52>>2]<=-1){e=o[a+56>>2];if(e){if(p[a+60|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[a+56>>2]=0;}m[a+60|0]=1;o[a+52>>2]=0;o[a+56>>2]=0;}while(1){o[o[a+56>>2]+(b<<2)>>2]=0;e=b+1|0;g=e>>>0>=b>>>0;b=e;if(g){continue}break}}k=f?h:k;o[a+48>>2]=0;if((i|0)<(n|0)){continue}break}}l[o[4967]]();K=s+16|0;}function Gw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=0,w=0,x=v(0),y=v(0),z=v(0),A=v(0),B=0,C=0;e=K-80|0;K=e;A=v(l[o[o[a>>2]+48>>2]](a));while(1){o[e+72>>2]=0;o[e+76>>2]=0;o[e+64>>2]=0;o[e+68>>2]=0;u=w<<2;B=u+(e- -64|0)|0;o[B>>2]=1065353216;i=s[b+32>>2];j=s[b>>2];k=s[b+16>>2];m=s[b+36>>2];n=s[b+4>>2];p=s[b+20>>2];f=s[b+40>>2];g=s[b+8>>2];h=s[b+24>>2];o[e+44>>2]=0;q=g;g=s[e+64>>2];r=h;h=s[e+68>>2];t=f;f=s[e+72>>2];s[e+40>>2]=v(v(q*g)+v(r*h))+v(t*f);s[e+36>>2]=v(v(g*n)+v(h*p))+v(f*m);s[e+32>>2]=v(v(j*g)+v(k*h))+v(i*f);l[o[o[a>>2]+64>>2]](e+48|0,a,e+32|0);i=s[b+48>>2];j=s[b+8>>2];k=s[b>>2];m=s[b+4>>2];n=s[b+52>>2];p=s[b+24>>2];t=s[b+16>>2];x=s[b+20>>2];g=s[b+56>>2];f=s[b+40>>2];h=s[b+32>>2];y=s[b+36>>2];o[e+44>>2]=0;q=g;g=s[e+48>>2];z=v(h*g);h=s[e+52>>2];r=f;f=s[e+56>>2];s[e+40>>2]=q+v(v(z+v(y*h))+v(r*f));s[e+36>>2]=n+v(v(v(g*t)+v(h*x))+v(f*p));s[e+32>>2]=i+v(v(v(g*k)+v(h*m))+v(f*j));C=(e+32|0)+u|0;s[d+u>>2]=A+s[C>>2];o[B>>2]=-1082130432;i=s[b+32>>2];j=s[b>>2];k=s[b+16>>2];m=s[b+36>>2];n=s[b+4>>2];p=s[b+20>>2];f=s[b+40>>2];g=s[b+8>>2];h=s[b+24>>2];o[e+12>>2]=0;q=g;g=s[e+64>>2];r=h;h=s[e+68>>2];t=f;f=s[e+72>>2];s[e+8>>2]=v(v(q*g)+v(r*h))+v(t*f);s[e+4>>2]=v(v(g*n)+v(h*p))+v(f*m);s[e>>2]=v(v(j*g)+v(k*h))+v(i*f);l[o[o[a>>2]+64>>2]](e+16|0,a,e);i=s[b+48>>2];j=s[b+8>>2];k=s[b>>2];m=s[b+4>>2];n=s[b+52>>2];p=s[b+24>>2];t=s[b+16>>2];x=s[b+20>>2];g=s[b+56>>2];f=s[b+40>>2];h=s[b+32>>2];y=s[b+36>>2];o[e+44>>2]=0;q=g;g=s[e+16>>2];z=v(h*g);h=s[e+20>>2];r=f;f=s[e+24>>2];s[e+40>>2]=q+v(v(z+v(y*h))+v(r*f));s[e+36>>2]=n+v(v(v(g*t)+v(h*x))+v(f*p));s[e+32>>2]=i+v(v(v(g*k)+v(h*m))+v(f*j));s[c+u>>2]=s[C>>2]-A;w=w+1|0;if((w|0)!=3){continue}break}K=e+80|0;}function xc(a,b,c){var d=0,e=v(0),f=v(0),g=v(0),h=0;if(!o[a>>2]){o[a>>2]=c;o[c+32>>2]=0;return}d=o[b+40>>2];if(d){f=v(s[c>>2]+s[c+16>>2]);e=v(s[c+8>>2]+s[c+24>>2]);g=v(s[c+4>>2]+s[c+20>>2]);while(1){h=b+36|0;b=o[b+36>>2];b=o[h+((v(v(v(w(v(f-v(s[b>>2]+s[b+16>>2]))))+v(w(v(g-v(s[b+4>>2]+s[b+20>>2])))))+v(w(v(e-v(s[b+8>>2]+s[b+24>>2])))))<v(v(v(w(v(f-v(s[d>>2]+s[d+16>>2]))))+v(w(v(g-v(s[d+4>>2]+s[d+20>>2])))))+v(w(v(e-v(s[d+8>>2]+s[d+24>>2])))))^1)<<2)>>2];d=o[b+40>>2];if(d){continue}break}}h=o[b+32>>2];d=o[a+4>>2];a:{if(d){o[a+4>>2]=0;break a}o[6257]=o[6257]+1;d=l[o[4968]](44,16)|0;o[d>>2]=0;o[d+4>>2]=0;o[d+40>>2]=0;o[d+32>>2]=0;o[d+36>>2]=0;o[d+24>>2]=0;o[d+28>>2]=0;o[d+16>>2]=0;o[d+20>>2]=0;o[d+8>>2]=0;o[d+12>>2]=0;}o[d+36>>2]=0;o[d+40>>2]=0;o[d+32>>2]=h;f=s[c>>2];e=s[b>>2];s[d>>2]=f<e?f:e;f=s[c+16>>2];e=s[b+16>>2];s[d+16>>2]=f>e?f:e;f=s[c+4>>2];e=s[b+4>>2];s[d+4>>2]=f<e?f:e;f=s[c+20>>2];e=s[b+20>>2];s[d+20>>2]=f>e?f:e;f=s[c+8>>2];e=s[b+8>>2];s[d+8>>2]=f<e?f:e;f=s[c+24>>2];e=s[b+24>>2];s[d+24>>2]=f>e?f:e;b:{if(h){o[(((o[o[b+32>>2]+40>>2]==(b|0))<<2)+h|0)+36>>2]=d;o[d+36>>2]=b;o[b+32>>2]=d;o[d+40>>2]=c;o[c+32>>2]=d;f=s[d>>2];while(1){a=d;d=h;c:{if(s[d>>2]<=f^1|s[d+4>>2]<=s[a+4>>2]^1|(s[d+8>>2]<=s[a+8>>2]^1|s[d+16>>2]>=s[a+16>>2]^1)){break c}if(!(s[d+20>>2]>=s[a+20>>2])){break c}if(s[d+24>>2]>=s[a+24>>2]){break b}}a=o[d+36>>2];f=s[a>>2];b=o[d+40>>2];e=s[b>>2];f=f<e?f:e;s[d>>2]=f;e=s[a+16>>2];g=s[b+16>>2];s[d+16>>2]=e>g?e:g;e=s[a+4>>2];g=s[b+4>>2];s[d+4>>2]=e<g?e:g;e=s[a+20>>2];g=s[b+20>>2];s[d+20>>2]=e>g?e:g;e=s[a+8>>2];g=s[b+8>>2];s[d+8>>2]=e<g?e:g;e=s[a+24>>2];g=s[b+24>>2];s[d+24>>2]=e>g?e:g;h=o[d+32>>2];if(h){continue}break}break b}o[d+36>>2]=b;o[b+32>>2]=d;o[d+40>>2]=c;o[c+32>>2]=d;o[a>>2]=d;}}function Tj(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),D=v(0);c=K-96|0;K=c;e=s[a+76>>2];f=s[a+36>>2];j=s[a+32>>2];k=s[a+80>>2];p=s[a+52>>2];q=s[a+44>>2];r=s[a+48>>2];m=s[a+84>>2];n=s[a+68>>2];y=s[a+60>>2];z=s[a- -64>>2];A=s[a+28>>2];g=s[b+8>>2];h=s[b>>2];i=s[b+4>>2];o[c+92>>2]=0;u=v(m+v(v(v(h*y)+v(i*z))+v(g*n)));s[c+88>>2]=u;w=v(k+v(v(v(h*q)+v(i*r))+v(g*p)));s[c+84>>2]=w;x=v(e+v(v(v(h*A)+v(i*j))+v(g*f)));s[c+80>>2]=x;g=s[b+20>>2];h=s[b+24>>2];i=s[b+16>>2];o[c+76>>2]=0;B=v(m+v(v(v(y*i)+v(z*g))+v(n*h)));s[c+72>>2]=B;D=v(k+v(v(v(q*i)+v(r*g))+v(p*h)));s[c+68>>2]=D;t=v(e+v(v(v(A*i)+v(j*g))+v(f*h)));s[c+64>>2]=t;g=s[b+36>>2];h=s[b+40>>2];i=s[b+32>>2];o[c+60>>2]=0;m=v(m+v(v(v(y*i)+v(z*g))+v(n*h)));s[c+56>>2]=m;k=v(k+v(v(v(q*i)+v(r*g))+v(p*h)));s[c+52>>2]=k;e=v(e+v(v(v(A*i)+v(j*g))+v(f*h)));s[c+48>>2]=e;o[c+44>>2]=0;p=v(v(v(u+B)+m)*v(.3333333432674408));s[c+40>>2]=p;q=v(v(v(w+D)+k)*v(.3333333432674408));s[c+36>>2]=q;r=v(v(v(x+t)+e)*v(.3333333432674408));s[c+32>>2]=r;b=o[a+8>>2];if(l[o[o[b>>2]+56>>2]](b)&16384){f=s[c+80>>2];o[c+24>>2]=0;o[c+28>>2]=0;o[c+16>>2]=1065353216;o[c+20>>2]=1065353216;b=o[a+8>>2];o[c+12>>2]=0;j=v(t-f);k=v(k-w);n=v(D-w);f=v(e-f);e=v(v(j*k)-v(n*f));x=e;t=v(e*e);m=v(m-u);e=v(n*m);n=v(B-u);e=v(e-v(n*k));f=v(v(n*f)-v(j*m));j=v(v(1)/v(C(v(t+v(v(e*e)+v(f*f))))));s[c+8>>2]=v(x*j)+p;s[c+4>>2]=q+v(f*j);s[c>>2]=r+v(e*j);l[o[o[b>>2]+16>>2]](b,c+32|0,c,c+16|0);}d=o[a+8>>2];b=a+12|0;l[o[o[d>>2]+16>>2]](d,c+80|0,c- -64|0,b);d=o[a+8>>2];l[o[o[d>>2]+16>>2]](d,c- -64|0,c+48|0,b);a=o[a+8>>2];l[o[o[a>>2]+16>>2]](a,c+48|0,c+80|0,b);K=c+96|0;}function Yu(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),n=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=0;e=K-48|0;K=e;f=o[c+12>>2];o[e+24>>2]=o[c+8>>2];o[e+28>>2]=f;f=o[c+4>>2];o[e+16>>2]=o[c>>2];o[e+20>>2]=f;f=d;g=o[f+12>>2];o[e+40>>2]=o[f+8>>2];o[e+44>>2]=g;g=o[f+4>>2];o[e+32>>2]=o[f>>2];o[e+36>>2]=g;a:{if(o[b+60>>2]==2){vc(a+44|0,o[b+48>>2]);o[b+48>>2]=wc(a+4|0,e+16|0,b);g=1;break a}g=1;o[a+128>>2]=o[a+128>>2]+1;b:{f=o[b+48>>2];if(s[f>>2]<=s[e+32>>2]^1|s[f+16>>2]>=s[e+16>>2]^1|(s[f+4>>2]<=s[e+36>>2]^1|s[f+20>>2]>=s[e+20>>2]^1)){break b}if(s[f+8>>2]<=s[e+40>>2]^1|s[f+24>>2]>=s[e+24>>2]^1){break b}k=s[b+20>>2];l=s[b+24>>2];q=s[c>>2];r=s[c+4>>2];t=s[c+8>>2];n=s[b+16>>2];i=s[b+36>>2];j=s[b+40>>2];u=s[b+32>>2];h=s[a+100>>2];o[e+12>>2]=0;j=v(h*v(v(j-l)*v(.5)));s[e+8>>2]=j;i=v(h*v(v(i-k)*v(.5)));s[e+4>>2]=i;h=v(h*v(v(u-n)*v(.5)));s[e>>2]=h;if(!!(v(q-n)<v(0))){s[e>>2]=-h;}if(!!(v(r-k)<v(0))){s[e+4>>2]=-i;}if(!!(v(t-l)<v(0))){s[e+8>>2]=-j;}g=0;if(!Bu(a+4|0,f,e+16|0,e)){break a}g=1;o[a+132>>2]=o[a+132>>2]+1;break a}Ld(a+4|0,f,e+16|0);o[a+132>>2]=o[a+132>>2]+1;}w=o[b+56>>2];f=o[b+52>>2];c:{if(f){f=f+56|0;break c}f=((o[b+60>>2]<<2)+a|0)+84|0;}o[f>>2]=w;f=o[b+56>>2];if(f){o[f+52>>2]=o[b+52>>2];}f=o[c+4>>2];o[b+16>>2]=o[c>>2];o[b+20>>2]=f;f=o[c+12>>2];o[b+24>>2]=o[c+8>>2];o[b+28>>2]=f;c=o[d+4>>2];o[b+32>>2]=o[d>>2];o[b+36>>2]=c;c=o[d+12>>2];o[b+40>>2]=o[d+8>>2];o[b+44>>2]=c;c=o[a+104>>2];o[b+60>>2]=c;o[b+52>>2]=0;c=(c<<2)+a|0;o[b+56>>2]=o[c+84>>2];d=o[c+84>>2];if(d){o[d+52>>2]=b;}o[c+84>>2]=b;d:{if(!g){break d}m[a+154|0]=1;if(p[a+153|0]){break d}o[e>>2]=16056;o[e+4>>2]=a;Bc(a+44|0,o[a+44>>2],o[b+48>>2],e);Bc(a+4|0,o[a+4>>2],o[b+48>>2],e);}K=e+48|0;}function hf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;o[b+16>>2]=o[a+4>>2];o[b+20>>2]=o[a+8>>2];o[b+24>>2]=o[a+12>>2];o[b+28>>2]=o[a+16>>2];o[b+32>>2]=o[a+20>>2];o[b+36>>2]=o[a+24>>2];o[b+40>>2]=o[a+28>>2];o[b+44>>2]=o[a+32>>2];o[b+48>>2]=o[a+36>>2];o[b+52>>2]=o[a+40>>2];o[b+56>>2]=o[a+44>>2];o[b+60>>2]=o[a+48>>2];o[b+64>>2]=o[a+52>>2];o[b+68>>2]=o[a+56>>2];o[b+72>>2]=o[a+60>>2];o[b+76>>2]=o[a- -64>>2];o[b+80>>2]=o[a+68>>2];o[b+84>>2]=o[a+72>>2];o[b+88>>2]=o[a+76>>2];o[b+92>>2]=o[a+80>>2];o[b+96>>2]=o[a+84>>2];o[b+100>>2]=o[a+88>>2];o[b+104>>2]=o[a+92>>2];o[b+108>>2]=o[a+96>>2];o[b+112>>2]=o[a+100>>2];o[b+116>>2]=o[a+104>>2];o[b+120>>2]=o[a+108>>2];o[b+124>>2]=o[a+112>>2];o[b+128>>2]=o[a+116>>2];o[b+132>>2]=o[a+120>>2];o[b+136>>2]=o[a+124>>2];o[b+140>>2]=o[a+128>>2];o[b+144>>2]=o[a+132>>2];o[b+148>>2]=o[a+136>>2];o[b+152>>2]=o[a+140>>2];o[b+156>>2]=o[a+144>>2];o[b+160>>2]=o[a+148>>2];o[b+164>>2]=o[a+152>>2];o[b+168>>2]=o[a+156>>2];o[b+172>>2]=o[a+160>>2];o[b+176>>2]=o[a+164>>2];o[b+180>>2]=o[a+168>>2];o[b+184>>2]=o[a+172>>2];o[b+188>>2]=o[a+176>>2];o[b+232>>2]=o[a+180>>2];d=o[a+184>>2];o[b>>2]=0;o[b+192>>2]=d;d=l[o[o[c>>2]+28>>2]](c,o[a+192>>2])|0;o[b+8>>2]=0;o[b+4>>2]=d;o[b+236>>2]=o[a+204>>2];o[b+240>>2]=o[a+208>>2];o[b+244>>2]=o[a+212>>2];o[b+248>>2]=o[a+220>>2];o[b+196>>2]=o[a+224>>2];o[b+200>>2]=o[a+228>>2];o[b+204>>2]=o[a+236>>2];o[b+208>>2]=o[a+244>>2];o[b+212>>2]=o[a+248>>2];o[b+216>>2]=o[a+232>>2];o[b+252>>2]=o[a+252>>2];d=l[o[o[c>>2]+40>>2]](c,a)|0;e=l[o[o[c>>2]+28>>2]](c,d)|0;o[b+12>>2]=e;if(e){l[o[o[c>>2]+48>>2]](c,d);}o[b+220>>2]=o[a+268>>2];o[b+224>>2]=o[a+272>>2];o[b+228>>2]=o[a+276>>2];a=o[a+280>>2];o[b+260>>2]=0;o[b+256>>2]=a;return 4e3}function Iw(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),L=v(0),M=v(0),N=v(0),O=v(0),P=v(0),Q=v(0);h=K-48|0;K=h;m=s[b+36>>2];n=s[b+20>>2];p=s[b+40>>2];q=s[b+24>>2];r=s[b+4>>2];t=s[b+8>>2];i=s[c+8>>2];u=s[b+32>>2];j=s[c>>2];w=s[b>>2];k=s[c+4>>2];x=s[b+16>>2];o[h+44>>2]=0;s[h+32>>2]=v(v(w*j)+v(x*k))+v(u*i);s[h+40>>2]=v(v(j*t)+v(k*q))+v(i*p);s[h+36>>2]=v(v(j*r)+v(k*n))+v(i*m);l[o[o[a>>2]+64>>2]](h+16|0,a,h+32|0);t=s[b+56>>2];u=s[b+40>>2];w=s[b+36>>2];r=s[b+52>>2];x=s[b+24>>2];y=s[b+20>>2];z=s[b+32>>2];q=s[b+48>>2];A=s[b+8>>2];B=s[b>>2];C=s[b+4>>2];D=s[b+16>>2];i=s[h+24>>2];j=s[h+16>>2];k=s[h+20>>2];o[h+12>>2]=0;s[h+8>>2]=-s[h+40>>2];s[h+4>>2]=-s[h+36>>2];s[h>>2]=-s[h+32>>2];l[o[o[a>>2]+64>>2]](h+16|0,a,h);E=s[b+56>>2];F=s[b+40>>2];G=s[b+36>>2];H=s[b+52>>2];I=s[b+24>>2];J=s[b+20>>2];L=s[b+32>>2];M=s[b+48>>2];N=s[b+8>>2];O=s[b>>2];P=s[b+4>>2];Q=s[b+16>>2];m=s[h+24>>2];n=s[h+16>>2];p=s[h+20>>2];q=v(q+v(v(v(j*B)+v(k*C))+v(i*A)));r=v(r+v(v(v(j*D)+v(k*y))+v(i*x)));i=v(t+v(v(v(j*z)+v(k*w))+v(i*u)));s[d>>2]=v(v(q*s[c>>2])+v(r*s[c+4>>2]))+v(i*s[c+8>>2]);j=v(M+v(v(v(n*O)+v(p*P))+v(m*N)));k=v(H+v(v(v(n*Q)+v(p*J))+v(m*I)));m=v(E+v(v(v(n*L)+v(p*G))+v(m*F)));s[e>>2]=v(v(j*s[c>>2])+v(k*s[c+4>>2]))+v(m*s[c+8>>2]);o[g+12>>2]=0;s[g+8>>2]=m;s[g+4>>2]=k;s[g>>2]=j;o[f+12>>2]=0;s[f+8>>2]=i;s[f+4>>2]=r;s[f>>2]=q;n=s[d>>2];p=s[e>>2];if(!!(n>p)){s[d>>2]=p;s[e>>2]=n;o[g+12>>2]=0;s[g+8>>2]=i;s[g+4>>2]=r;s[g>>2]=q;o[f+12>>2]=0;s[f+8>>2]=m;s[f+4>>2]=k;s[f>>2]=j;}K=h+48|0;}function xi(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,s=0;a:{e=n[b>>1];i=q[b+2>>1];j=o[a+48>>2];s=e+(i<<16)&j+ -1;b:{if(s>>>0>=r[a+4>>2]){break b}d=o[o[a+12>>2]+(s<<2)>>2];if((d|0)==-1){break b}k=o[a+72>>2];h=e&65535;while(1){f=d<<2;e=f+k|0;if((i|0)==q[e+2>>1]?(h|0)==q[e>>1]:0){break a}d=o[f+o[a+32>>2]>>2];if((d|0)!=-1){continue}break}}k=o[a+44>>2];d=k;c:{if((j|0)!=(d|0)){break c}d=j;i=d?d<<1:1;if((d|0)>=(i|0)){break c}d:{if(!i){d=j;break d}o[6257]=o[6257]+1;g=l[o[4968]](i<<2,16)|0;d=o[a+44>>2];}e=d;if((e|0)>=1){d=0;while(1){f=d<<2;h=f+g|0;f=f+o[a+52>>2]|0;f=q[f>>1]|q[f+2>>1]<<16;n[h>>1]=f;n[h+2>>1]=f>>>16;d=d+1|0;if((e|0)!=(d|0)){continue}break}}e=o[a+52>>2];if(e){if(p[a+56|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[a+52>>2]=0;}o[a+52>>2]=g;o[a+48>>2]=i;m[a+56|0]=1;d=o[a+44>>2];}e=o[a+52>>2]+(d<<2)|0;c=q[c>>1]|q[c+2>>1]<<16;n[e>>1]=c;n[e+2>>1]=c>>>16;o[a+44>>2]=o[a+44>>2]+1;g=o[a- -64>>2];e:{if((g|0)!=o[a+68>>2]){break e}h=g?g<<1:1;if((g|0)>=(h|0)){break e}f:{if(!h){f=0;break f}o[6257]=o[6257]+1;f=l[o[4968]](h<<2,16)|0;g=o[a+64>>2];}if((g|0)>=1){d=0;while(1){c=d<<2;e=c+f|0;c=c+o[a+72>>2]|0;c=q[c>>1]|q[c+2>>1]<<16;n[e>>1]=c;n[e+2>>1]=c>>>16;d=d+1|0;if((g|0)!=(d|0)){continue}break}}c=o[a+72>>2];if(c){if(p[a+76|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+72>>2]=0;}o[a+72>>2]=f;o[a+68>>2]=h;m[a+76|0]=1;g=o[a+64>>2];}e=o[a+72>>2]+(g<<2)|0;c=q[b>>1]|q[b+2>>1]<<16;n[e>>1]=c;n[e+2>>1]=c>>>16;o[a+64>>2]=o[a+64>>2]+1;if((j|0)<o[a+48>>2]){wi(a);s=n[b>>1]+(q[b+2>>1]<<16)&o[a+48>>2]+ -1;}b=o[a+32>>2]+(k<<2)|0;a=o[a+12>>2]+(s<<2)|0;o[b>>2]=o[a>>2];o[a>>2]=k;return}b=o[a+52>>2]+(d<<2)|0;a=q[c>>1]|q[c+2>>1]<<16;n[b>>1]=a;n[b+2>>1]=a>>>16;}function Bj(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=v(0),g=v(0),h=v(0),i=0,j=0,k=0,l=0;a=K-608|0;K=a;g=v(s[b+116>>2]-s[b+52>>2]);f=v(g*g);g=v(s[b+120>>2]-s[b+56>>2]);f=v(f+v(g*g));g=v(s[b+124>>2]-s[b+60>>2]);f=v(f+v(g*g));g=s[b+276>>2];a:{if(!!(f<v(g*g))){g=v(1);f=v(s[c+116>>2]-s[c+52>>2]);h=v(f*f);f=v(s[c+120>>2]-s[c+56>>2]);h=v(h+v(f*f));f=v(s[c+124>>2]-s[c+60>>2]);h=v(h+v(f*f));f=s[c+276>>2];if(h<v(f*f)){break a}}g=v(1);if(p[22568]){break a}d=o[b+192>>2];e=o[c+272>>2];sa(a+552|0);o[a+580>>2]=0;o[a+584>>2]=0;o[a+576>>2]=1065353216;o[a+588>>2]=0;o[a+592>>2]=0;o[a+596>>2]=0;o[a+568>>2]=1065353216;o[a+572>>2]=1065353216;o[a+556>>2]=8;o[a+552>>2]=11388;o[a+604>>2]=0;o[a+600>>2]=e;o[a+584>>2]=e;o[a+548>>2]=0;o[a+540>>2]=1566444395;o[a+544>>2]=0;o[a+376>>2]=6980;m[a+348|0]=0;o[a+324>>2]=953267991;o[a+12>>2]=a+552;o[a+8>>2]=d;o[a+4>>2]=a+16;o[a>>2]=7232;i=b+4|0;j=b+68|0;k=c+4|0;e=c+68|0;g=v(1);b:{if(!Tc(a,i,j,k,e,a+376|0)){break b}f=s[a+540>>2];if(!!(s[b+268>>2]>f)){s[b+268>>2]=f;}if(!!(s[c+268>>2]>f)){s[c+268>>2]=f;}g=v(1);if(!(f<v(1))){break b}g=f;}d=o[c+192>>2];l=o[b+272>>2];sa(a+552|0);o[a+580>>2]=0;o[a+584>>2]=0;o[a+576>>2]=1065353216;o[a+588>>2]=0;o[a+592>>2]=0;o[a+596>>2]=0;o[a+568>>2]=1065353216;o[a+572>>2]=1065353216;o[a+556>>2]=8;o[a+552>>2]=11388;o[a+604>>2]=0;o[a+600>>2]=l;o[a+584>>2]=l;o[a+548>>2]=0;o[a+540>>2]=1566444395;o[a+544>>2]=0;o[a+376>>2]=6980;m[a+348|0]=0;o[a+324>>2]=953267991;o[a+12>>2]=d;o[a+8>>2]=a+552;o[a+4>>2]=a+16;o[a>>2]=7232;c:{if(!Tc(a,i,j,k,e,a+376|0)){break c}f=s[a+540>>2];if(!!(s[b+268>>2]>f)){s[b+268>>2]=f;}if(!!(s[c+268>>2]>f)){s[c+268>>2]=f;}if(!(g>f)){break c}g=f;}}K=a+608|0;return v(g)}function an(a){a=a|0;var b=0,c=0,d=0,e=v(0),f=v(0),g=v(0),h=0,i=v(0),j=v(0),k=v(0),l=0,m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),w=v(0),x=v(0),y=v(0),z=0;b=K-144|0;K=b;o[a+36>>2]=0;o[b+136>>2]=0;o[b+140>>2]=0;o[b+128>>2]=0;o[b+132>>2]=0;while(1){z=(b+128|0)+(l<<2)|0;o[z>>2]=1065353216;d=o[a+28>>2];o[b+80>>2]=o[d+4>>2];o[b+84>>2]=o[d+20>>2];c=o[d+36>>2];o[b+92>>2]=0;o[b+88>>2]=c;o[b+96>>2]=o[d+8>>2];o[b+100>>2]=o[d+24>>2];c=o[d+40>>2];o[b+108>>2]=0;o[b+104>>2]=c;o[b+112>>2]=o[d+12>>2];o[b+116>>2]=o[d+28>>2];c=o[d+44>>2];o[b+124>>2]=0;o[b+120>>2]=c;c=o[a+32>>2];o[b+32>>2]=o[c+4>>2];o[b+36>>2]=o[c+20>>2];h=o[c+36>>2];o[b+44>>2]=0;o[b+40>>2]=h;o[b+48>>2]=o[c+8>>2];o[b+52>>2]=o[c+24>>2];h=o[c+40>>2];o[b+60>>2]=0;o[b+56>>2]=h;o[b+64>>2]=o[c+12>>2];o[b+68>>2]=o[c+28>>2];h=o[c+44>>2];o[b+76>>2]=0;o[b+72>>2]=h;i=s[d+52>>2];m=s[d+12>>2];n=s[d+8>>2];j=s[d+56>>2];p=s[d+28>>2];q=s[d+20>>2];r=s[d+24>>2];k=s[d+60>>2];t=s[d+44>>2];w=s[d+36>>2];x=s[d+40>>2];y=s[d+4>>2];e=s[a+308>>2];f=s[a+300>>2];g=s[a+304>>2];o[b+28>>2]=0;s[b+24>>2]=v(k+v(v(v(f*w)+v(g*x))+v(e*t)))-k;s[b+20>>2]=v(j+v(v(v(f*q)+v(g*r))+v(e*p)))-j;s[b+16>>2]=v(i+v(v(v(f*y)+v(g*n))+v(e*m)))-i;i=s[c+52>>2];m=s[c+12>>2];n=s[c+8>>2];j=s[c+56>>2];p=s[c+28>>2];q=s[c+20>>2];r=s[c+24>>2];k=s[c+60>>2];t=s[c+44>>2];w=s[c+36>>2];x=s[c+40>>2];y=s[c+4>>2];e=s[a+324>>2];f=s[a+316>>2];g=s[a+320>>2];o[b+12>>2]=0;s[b+8>>2]=v(k+v(v(v(f*w)+v(g*x))+v(e*t)))-k;s[b+4>>2]=v(j+v(v(v(f*q)+v(g*r))+v(e*p)))-j;s[b>>2]=v(i+v(v(v(f*y)+v(g*n))+v(e*m)))-i;tf((u(l,84)+a|0)+48|0,b+80|0,b+32|0,b+16|0,b,b+128|0,d+456|0,s[d+404>>2],c+456|0,s[c+404>>2]);o[z>>2]=0;l=l+1|0;if((l|0)!=3){continue}break}K=b+144|0;}function _a(a,b,c,d,e){var f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=0,p=v(0),q=v(0);n=K-16|0;K=n;f=s[a+52>>2];g=s[a+56>>2];i=s[a+48>>2];h=s[b>>2];j=s[b+4>>2];k=s[b+8>>2];o[e+60>>2]=0;s[e+56>>2]=g+v(k*d);s[e+52>>2]=f+v(j*d);s[e+48>>2]=i+v(h*d);i=s[c>>2];l=s[c+4>>2];m=s[c+8>>2];f=v(v(v(i*i)+v(l*l))+v(m*m));f=f>v(1.1920928955078125e-7)?v(C(f)):v(0);g=v(f*d)>v(.7853981852531433)?v(v(.7853981852531433)/d):f;a:{if(!!(g<v(.0010000000474974513))){f=v(v(d*v(.5))+v(g*v(v(v(v(d*d)*d)*v(-.02083333395421505))*g)));break a}f=v(va(v(v(g*v(.5))*d))/g);}fb(a,n);h=s[n+4>>2];j=s[n+12>>2];g=wa(v(v(g*d)*v(.5)));k=v(i*f);p=s[n>>2];l=v(l*f);m=v(m*f);q=s[n+8>>2];f=v(v(v(v(j*g)-v(k*p))-v(h*l))-v(m*q));i=v(v(v(v(m*j)+v(g*q))+v(k*h))-v(l*p));d=v(v(v(v(g*p)+v(k*j))+v(l*q))-v(m*h));g=v(v(v(m*p)+v(v(l*j)+v(g*h)))-v(k*q));h=v(v(f*f)+v(v(i*i)+v(v(d*d)+v(g*g))));if(!!(h>v(1.1920928955078125e-7))){h=v(v(1)/v(C(h)));f=v(f*h);i=v(i*h);g=v(g*h);d=v(d*h);h=v(v(f*f)+v(v(i*i)+v(v(g*g)+v(d*d))));}b:{if(!!(h>v(1.1920928955078125e-7))){o[e+12>>2]=0;o[e+44>>2]=0;o[e+28>>2]=0;j=v(v(2)/h);h=v(i*j);k=v(g*h);p=v(d*j);l=v(f*p);s[e+36>>2]=k+l;m=v(d*h);j=v(g*j);q=v(f*j);s[e+32>>2]=m-q;s[e+24>>2]=k-l;k=v(d*j);f=v(f*h);s[e+16>>2]=k+f;s[e+8>>2]=m+q;s[e+4>>2]=k-f;d=v(d*p);f=v(g*j);s[e+40>>2]=v(1)-v(d+f);g=d;d=v(i*h);s[e+20>>2]=v(1)-v(g+d);s[e>>2]=v(1)-v(f+d);break b}b=o[a+4>>2];o[e>>2]=o[a>>2];o[e+4>>2]=b;b=o[a+12>>2];o[e+8>>2]=o[a+8>>2];o[e+12>>2]=b;b=o[a+20>>2];o[e+16>>2]=o[a+16>>2];o[e+20>>2]=b;b=o[a+28>>2];o[e+24>>2]=o[a+24>>2];o[e+28>>2]=b;b=o[a+36>>2];o[e+32>>2]=o[a+32>>2];o[e+36>>2]=b;b=o[a+44>>2];o[e+40>>2]=o[a+40>>2];o[e+44>>2]=b;}K=n+16|0;}function sj(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),q=v(0),r=v(0),t=v(0),w=v(0),x=0,y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=0,K=v(0),L=v(0),M=v(0),N=0,O=0,P=0,Q=0,R=0,S=0;J=o[a+52>>2];if((J|0)<1){return v(v(1))}f=p[a+68|0];N=f?b:c;b=f?c:b;O=o[b- -64>>2];K=s[b+60>>2];L=s[b+56>>2];M=s[b+52>>2];P=o[b+48>>2];h=s[b+44>>2];i=s[b+40>>2];j=s[b+36>>2];Q=o[b+32>>2];k=s[b+28>>2];m=s[b+24>>2];n=s[b+20>>2];R=o[b+16>>2];q=s[b+12>>2];r=s[b+8>>2];x=o[b+304>>2];t=s[b+4>>2];S=o[b+192>>2];w=v(1);f=0;while(1){c=o[S+28>>2]+u(f,80)|0;g=s[c+56>>2];y=s[c+52>>2];z=s[c+48>>2];A=s[c+36>>2];B=s[c+20>>2];C=s[c+4>>2];D=s[c+40>>2];E=s[c+24>>2];F=s[c+8>>2];G=s[c+32>>2];H=s[c>>2];I=s[c+16>>2];o[b+64>>2]=0;o[b+48>>2]=0;o[b+32>>2]=0;o[b+16>>2]=0;o[b+304>>2]=x+1;s[b+36>>2]=v(v(j*H)+v(i*I))+v(h*G);s[b+20>>2]=v(v(n*H)+v(m*I))+v(k*G);s[b+4>>2]=v(v(t*H)+v(r*I))+v(q*G);s[b+44>>2]=v(v(j*F)+v(i*E))+v(h*D);s[b+40>>2]=v(v(j*C)+v(i*B))+v(h*A);s[b+28>>2]=v(v(n*F)+v(m*E))+v(k*D);s[b+24>>2]=v(v(n*C)+v(m*B))+v(k*A);s[b+12>>2]=v(v(t*F)+v(r*E))+v(q*D);s[b+8>>2]=v(v(t*C)+v(r*B))+v(q*A);s[b+60>>2]=K+v(v(v(j*z)+v(i*y))+v(h*g));s[b+56>>2]=L+v(v(v(n*z)+v(m*y))+v(k*g));s[b+52>>2]=M+v(v(v(t*z)+v(r*y))+v(q*g));c=o[o[a+60>>2]+(f<<2)>>2];g=v(l[o[o[c>>2]+12>>2]](c,b,N,d,e));o[b+64>>2]=O;s[b+60>>2]=K;s[b+56>>2]=L;s[b+52>>2]=M;o[b+48>>2]=P;s[b+44>>2]=h;s[b+40>>2]=i;s[b+36>>2]=j;o[b+32>>2]=Q;s[b+28>>2]=k;s[b+24>>2]=m;s[b+20>>2]=n;o[b+16>>2]=R;s[b+12>>2]=q;s[b+8>>2]=r;s[b+4>>2]=t;x=o[b+304>>2]+1|0;o[b+304>>2]=x;w=g<w?g:w;f=f+1|0;if((J|0)!=(f|0)){continue}break}return v(w)}function Tg(a,b,c,d,e,f,g){var h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0,r=0,s=0,t=0,u=0;i=K-48|0;K=i;h=o[c+8>>2];if(h){q=h;while(1){if(o[q+20>>2]>o[a+100>>2]){h=o[q+12>>2];m=o[h+92>>2];n=o[h+96>>2];k=o[c+88>>2];l=o[h+88>>2];j=o[c+92>>2];h=o[c+96>>2];o[i+44>>2]=-1;p=n-h|0;o[i+40>>2]=p;j=m-j|0;o[i+36>>2]=j;h=l-k|0;o[i+32>>2]=h;n=j;s=j>>31;j=e;k=Qw(n,s,o[j+8>>2],o[j+12>>2]);l=L;m=k;k=h;t=h>>31;h=Qw(h,t,o[j>>2],o[j+4>>2]);j=m+h|0;m=L+l|0;m=j>>>0<h>>>0?m+1|0:m;l=p;u=l>>31;h=Qw(l,u,o[e+16>>2],o[e+20>>2]);p=h+j|0;j=L+m|0;j=p>>>0<h>>>0?j+1|0:j;h=p;p=f;m=Qw(o[p+8>>2],o[p+12>>2],n,s);n=L;k=Qw(o[p>>2],o[p+4>>2],k,t);p=k+m|0;n=L+n|0;n=p>>>0<k>>>0?n+1|0:n;l=Qw(o[f+16>>2],o[f+20>>2],l,u);k=l+p|0;m=L+n|0;m=k>>>0<l>>>0?m+1|0:m;l=k;k=m;a:{if((k|0)>0?1:(k|0)>=0?l>>>0<1?0:1:0){o[i+8>>2]=l;o[i+12>>2]=k;o[i+24>>2]=1;n=-1;l=-1;break a}if((k|0)<-1?1:(k|0)<=-1?l>>>0>4294967295?0:1:0){o[i+24>>2]=-1;o[i+8>>2]=0-l;o[i+12>>2]=0-((0<l>>>0)+k|0);n=1;l=-1;break a}o[i+8>>2]=0;o[i+12>>2]=0;o[i+24>>2]=0;n=0;l=0;}b:{c:{d:{k=i;p=i;if((j|0)<0?1:(j|0)<=0?h>>>0>0?0:1:0){if((j|0)>-1?1:(j|0)>=-1?h>>>0<=4294967295?0:1:0){break d}o[i+24>>2]=n;j=0-((0<h>>>0)+j|0)|0;h=0-h|0;}o[p+16>>2]=h;o[k+20>>2]=j;break c}o[i+16>>2]=0;o[i+20>>2]=0;if(!l){break b}}if(!r){h=o[i+12>>2];o[g>>2]=o[i+8>>2];o[g+4>>2]=h;o[g+16>>2]=o[i+24>>2];h=o[i+20>>2];o[g+8>>2]=o[i+16>>2];o[g+12>>2]=h;r=q;break b}h=ib(i+8|0,g);if((h|0)<=-1){h=o[i+12>>2];o[g>>2]=o[i+8>>2];o[g+4>>2]=h;o[g+16>>2]=o[i+24>>2];h=o[i+20>>2];o[g+8>>2]=o[i+16>>2];o[g+12>>2]=h;r=q;break b}if(h){break b}r=(Gd(r,q,d,i+32|0)|0)!=2^b?q:r;}h=o[c+8>>2];}q=o[q>>2];if((q|0)!=(h|0)){continue}break}}K=i+48|0;return r}function ne(a,b){var c=0,d=0,e=0,f=0;c=a;o[c+8>>2]=0;o[c+12>>2]=-1;o[c>>2]=11020;o[c+76>>2]=0;o[c+68>>2]=0;o[c+72>>2]=1;o[c+52>>2]=-581039253;o[c+56>>2]=-581039253;o[c+36>>2]=1566444395;o[c+40>>2]=1566444395;m[c+32|0]=1;o[c+28>>2]=0;m[c+96|0]=1;o[c+60>>2]=-581039253;o[c+64>>2]=0;o[c+44>>2]=1566444395;o[c+48>>2]=0;o[c+20>>2]=0;o[c+24>>2]=0;o[c+92>>2]=0;o[c+84>>2]=0;o[c+88>>2]=0;m[c+116|0]=1;o[c+112>>2]=0;m[c+136|0]=1;o[c+104>>2]=0;o[c+108>>2]=0;o[c+124>>2]=0;o[c+128>>2]=0;o[c+132>>2]=0;m[c+156|0]=1;o[c+152>>2]=0;o[c+144>>2]=0;o[c+148>>2]=0;m[c+176|0]=1;o[c+172>>2]=0;o[c+164>>2]=0;o[c+168>>2]=0;o[c+184>>2]=1065353216;o[c+188>>2]=1065353216;o[c+192>>2]=1065353216;o[c+196>>2]=0;m[c+180|0]=0;o[c+4>>2]=31;if(b){o[6257]=o[6257]+1;b=l[o[4968]](40,16)|0;o[b+16>>2]=0;o[b+8>>2]=-1;o[b+12>>2]=0;o[b>>2]=0;o[b+4>>2]=0;o[b+32>>2]=0;m[b+36|0]=1;o[b+24>>2]=0;o[b+28>>2]=0;o[a+68>>2]=b;b=o[a+24>>2];}else {b=0;}if((b|0)<0){f=o[a+20>>2];if((f|0)>=1){while(1){b=u(e,80);c=b+o[a+28>>2]|0;d=o[c+4>>2];o[b>>2]=o[c>>2];o[b+4>>2]=d;d=o[c+12>>2];o[b+8>>2]=o[c+8>>2];o[b+12>>2]=d;d=o[c+28>>2];o[b+24>>2]=o[c+24>>2];o[b+28>>2]=d;d=o[c+20>>2];o[b+16>>2]=o[c+16>>2];o[b+20>>2]=d;d=o[c+44>>2];o[b+40>>2]=o[c+40>>2];o[b+44>>2]=d;d=o[c+36>>2];o[b+32>>2]=o[c+32>>2];o[b+36>>2]=d;d=o[c+60>>2];o[b+56>>2]=o[c+56>>2];o[b+60>>2]=d;d=o[c+52>>2];o[b+48>>2]=o[c+48>>2];o[b+52>>2]=d;d=o[c+68>>2];o[b+64>>2]=o[c+64>>2];o[b+68>>2]=d;d=o[c+76>>2];o[b+72>>2]=o[c+72>>2];o[b+76>>2]=d;e=e+1|0;if((f|0)!=(e|0)){continue}break}}b=o[a+28>>2];if(b){if(p[a+32|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+28>>2]=0;}o[a+28>>2]=0;m[a+32|0]=1;o[a+24>>2]=0;}}function Xc(a,b){var c=0,d=0,e=0;a:{b:{c:{d:{e:{c=o[a>>2];f:{if((c|0)>=4){if(p[b|0]&8){e=c;break f}e=c+ -1|0;o[a>>2]=e;d=(e<<4)+a|0;c=o[d+16>>2];o[a+60>>2]=o[d+12>>2];o[a+64>>2]=c;c=o[d+8>>2];o[a+52>>2]=o[d+4>>2];o[a+56>>2]=c;c=o[d+88>>2];o[a+132>>2]=o[d+84>>2];o[a+136>>2]=c;c=o[d+96>>2];o[a+140>>2]=o[d+92>>2];o[a+144>>2]=c;c=o[d+176>>2];o[a+220>>2]=o[d+172>>2];o[a+224>>2]=c;c=o[d+168>>2];o[a+212>>2]=o[d+164>>2];o[a+216>>2]=c;break f}e=3;if((c|0)!=3){break e}}if(p[b|0]&4){break d}e=e+ -1|0;o[a>>2]=e;d=(e<<4)+a|0;c=o[d+16>>2];o[a+44>>2]=o[d+12>>2];o[a+48>>2]=c;c=o[d+8>>2];o[a+36>>2]=o[d+4>>2];o[a+40>>2]=c;c=o[d+88>>2];o[a+116>>2]=o[d+84>>2];o[a+120>>2]=c;c=o[d+96>>2];o[a+124>>2]=o[d+92>>2];o[a+128>>2]=c;c=o[d+176>>2];o[a+204>>2]=o[d+172>>2];o[a+208>>2]=c;c=o[d+168>>2];o[a+196>>2]=o[d+164>>2];o[a+200>>2]=c;break d}e=2;if((c|0)<2){break c}}if(p[b|0]&2){break b}e=e+ -1|0;o[a>>2]=e;d=(e<<4)+a|0;c=o[d+16>>2];o[a+28>>2]=o[d+12>>2];o[a+32>>2]=c;c=o[d+8>>2];o[a+20>>2]=o[d+4>>2];o[a+24>>2]=c;c=o[d+88>>2];o[a+100>>2]=o[d+84>>2];o[a+104>>2]=c;c=o[d+96>>2];o[a+108>>2]=o[d+92>>2];o[a+112>>2]=c;c=o[d+176>>2];o[a+188>>2]=o[d+172>>2];o[a+192>>2]=c;c=o[d+168>>2];o[a+180>>2]=o[d+164>>2];o[a+184>>2]=c;break b}e=1;if((c|0)!=1){break a}}if(m[b|0]&1){break a}b=e+ -1|0;o[a>>2]=b;c=b<<4;e=c+(a+4|0)|0;b=o[e+4>>2];o[a+4>>2]=o[e>>2];o[a+8>>2]=b;b=o[e+12>>2];o[a+12>>2]=o[e+8>>2];o[a+16>>2]=b;e=c+(a+84|0)|0;b=o[e+4>>2];o[a+84>>2]=o[e>>2];o[a+88>>2]=b;b=o[e+12>>2];o[a+92>>2]=o[e+8>>2];o[a+96>>2]=b;c=c+(a+164|0)|0;b=o[c+12>>2];o[a+172>>2]=o[c+8>>2];o[a+176>>2]=b;b=o[c+4>>2];o[a+164>>2]=o[c>>2];o[a+168>>2]=b;}}function Ju(a,b,c,d){var e=v(0),f=v(0),g=0,h=v(0),i=0,j=v(0),k=v(0),m=v(0),r=v(0),t=v(0),u=0,w=v(0),x=v(0),y=v(0),z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0;i=K-16|0;K=i;a:{if(p[a+60|0]){j=s[a+28>>2];h=s[a+12>>2];e=s[c+8>>2];e=e<h?h:e;w=s[a+44>>2];e=v(v((j<e?j:e)-h)*w);b:{if(e<v(4294967296)&e>=v(0)){g=~~e>>>0;break b}g=0;}x=s[a+40>>2];r=s[a+24>>2];e=s[a+8>>2];y=s[a+36>>2];t=s[a+20>>2];m=s[a+4>>2];f=s[c>>2];k=s[c+4>>2];z=g&65534;n[i+14>>1]=z;c=i;k=k<e?e:k;k=v(x*v((r<k?r:k)-e));c:{if(k<v(4294967296)&k>=v(0)){g=~~k>>>0;break c}g=0;}A=g&65534;n[c+12>>1]=A;c=i;f=f<m?m:f;f=v(v((t<f?t:f)-m)*y);d:{if(f<v(4294967296)&f>=v(0)){g=~~f>>>0;break d}g=0;}B=g&65534;n[c+10>>1]=B;f=s[d+8>>2];f=f<h?h:f;h=v(v(w*v((j<f?j:f)-h))+v(1));e:{if(h<v(4294967296)&h>=v(0)){c=~~h>>>0;break e}c=0;}h=s[d>>2];j=s[d+4>>2];C=c|1;n[i+8>>1]=C;c=i;j=j<e?e:j;e=v(v(x*v((r<j?r:j)-e))+v(1));f:{if(e<v(4294967296)&e>=v(0)){d=~~e>>>0;break f}d=0;}D=d|1;n[c+6>>1]=D;c=i;e=h<m?m:h;e=v(v(y*v((t<e?t:e)-m))+v(1));g:{if(e<v(4294967296)&e>=v(0)){d=~~e>>>0;break g}d=0;}E=d|1;n[c+4>>1]=E;c=o[a+144>>2];if(c>>>0>2){break a}h:{switch(c-1|0){default:d=0;F=o[a+56>>2];if((F|0)>=1){a=o[a+136>>2];c=0;while(1){u=o[a+12>>2];G=(u|0)<0;g=B>>>0<=q[a+6>>1]&E>>>0>=q[a>>1]&z>>>0<=q[a+10>>1]&C>>>0>=q[a+4>>1]&A>>>0<=q[a+8>>1]&D>>>0>=q[a+2>>1];if(!(G|!g)){l[o[o[b>>2]+8>>2]](b,u>>>21|0,u&2097151);}i:{if(!((g^-1)&G)){c=c+1|0;a=a+16|0;break i}g=o[a+12>>2];c=c-g|0;a=a-(g<<4)|0;}d=d+1|0;if((c|0)<(F|0)){continue}break}}if(o[5677]>=(d|0)){break a}o[5677]=d;break a;case 0:Iu(a,b,i+10|0,i+4|0);break a;case 1:break h}}$g(a,o[a+136>>2],b,i+10|0,i+4|0);break a}Hu(a,b,c,d);}K=i+16|0;}function Vk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=v(0),i=v(0),j=v(0),k=v(0),m=0,n=0;f=K-144|0;K=f;l[o[4966]](6376);h=s[b>>2];i=s[b+16>>2];k=h<i?h:i;j=s[b+32>>2];a:{if((k<j?k:j)>s[a+20>>2]){break a}e=(h>i^1)<<4;if(s[(s[b+e>>2]>j?e:32)+b>>2]<s[a+4>>2]){break a}h=s[b+8>>2];e=b+24|0;i=s[e>>2];k=h<i?h:i;g=b+40|0;j=s[g>>2];if((k<j?k:j)>s[a+28>>2]){break a}e=h>i?b+8|0:e;if(s[(s[e>>2]>j?e:g)>>2]<s[a+12>>2]){break a}h=s[b+4>>2];e=b+20|0;i=s[e>>2];k=h<i?h:i;g=b+36|0;j=s[g>>2];if((k<j?k:j)>s[a+24>>2]){break a}e=h>i?b+4|0:e;if(o[o[o[a+36>>2]+4>>2]+4>>2]>19|s[(s[e>>2]>j?e:g)>>2]<s[a+8>>2]){break a}g=o[a+48>>2];n=zb(f+24|0);o[f+24>>2]=6568;o[f+28>>2]=1;e=o[b+12>>2];o[f+92>>2]=o[b+8>>2];o[f+96>>2]=e;e=o[b+4>>2];o[f+84>>2]=o[b>>2];o[f+88>>2]=e;e=o[b+28>>2];o[f+108>>2]=o[b+24>>2];o[f+112>>2]=e;e=o[b+20>>2];o[f+100>>2]=o[b+16>>2];o[f+104>>2]=e;e=o[b+44>>2];o[f+124>>2]=o[b+40>>2];o[f+128>>2]=e;e=o[b+36>>2];o[f+116>>2]=o[b+32>>2];o[f+120>>2]=e;o[f+72>>2]=o[a+56>>2];b=o[a+40>>2];e=o[b+12>>2];m=o[b+8>>2];o[f+20>>2]=d;o[f+16>>2]=c;o[f+8>>2]=m;o[f+12>>2]=e;o[f>>2]=b;o[f+4>>2]=f+24;b=o[a+36>>2];b:{if(!!(s[o[a+44>>2]+32>>2]>v(0))){b=l[o[o[g>>2]+8>>2]](g,b,f,0,2)|0;break b}b=l[o[o[g>>2]+8>>2]](g,b,f,o[a+64>>2],1)|0;}e=o[a+44>>2];m=o[e+8>>2];c:{if(o[m+8>>2]==o[o[a+40>>2]+8>>2]){o[e+8>>2]=f;l[o[o[e>>2]+8>>2]](e,c,d);break c}m=o[e+12>>2];o[e+12>>2]=f;l[o[o[e>>2]+12>>2]](e,c,d);}l[o[o[b>>2]+8>>2]](b,o[a+36>>2],f,o[a+52>>2],o[a+44>>2]);c=o[a+44>>2];o[(o[o[c+8>>2]+8>>2]==o[o[a+40>>2]+8>>2]?8:12)+c>>2]=m;l[o[o[b>>2]>>2]](b)|0;l[o[o[g>>2]+60>>2]](g,b);kb(n);}l[o[4967]]();K=f+144|0;}function gk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=0;e=K-256|0;K=e;o[e+32>>2]=9416;f=o[b+12>>2];o[e+76>>2]=o[b+8>>2];o[e+80>>2]=f;f=o[b+4>>2];o[e+68>>2]=o[b>>2];o[e+72>>2]=f;f=o[c+12>>2];o[e+92>>2]=o[c+8>>2];o[e+96>>2]=f;f=o[c>>2];n=o[c+4>>2];o[e+104>>2]=0;o[e+108>>2]=0;o[e+112>>2]=0;o[e+116>>2]=0;o[e+124>>2]=0;o[e+128>>2]=0;o[e+120>>2]=1065353216;o[e+132>>2]=0;o[e+136>>2]=0;o[e+140>>2]=1065353216;o[e+144>>2]=0;o[e+84>>2]=f;o[e+88>>2]=n;o[e+248>>2]=d;o[e+100>>2]=1065353216;o[e+244>>2]=a;d=o[e+72>>2];o[e+148>>2]=o[e+68>>2];o[e+152>>2]=d;d=o[e+80>>2];o[e+156>>2]=o[e+76>>2];o[e+160>>2]=d;o[e+164>>2]=1065353216;o[e+176>>2]=0;o[e+180>>2]=0;o[e+168>>2]=0;o[e+172>>2]=0;o[e+184>>2]=1065353216;o[e+196>>2]=0;o[e+200>>2]=0;o[e+188>>2]=0;o[e+192>>2]=0;o[e+204>>2]=1065353216;o[e+208>>2]=0;d=o[c+12>>2];o[e+220>>2]=o[c+8>>2];o[e+224>>2]=d;d=o[c+4>>2];o[e+212>>2]=o[c>>2];o[e+216>>2]=d;j=v(s[c>>2]-s[b>>2]);g=v(s[c+4>>2]-s[b+4>>2]);h=v(s[c+8>>2]-s[b+8>>2]);i=v(v(1)/v(C(v(v(v(j*j)+v(g*g))+v(h*h)))));h=v(h*i);k=h==v(0)?v(0xde0b6b000000000):v(v(1)/h);s[e+44>>2]=k;g=v(g*i);m=g==v(0)?v(0xde0b6b000000000):v(v(1)/g);s[e+40>>2]=m;o[e+60>>2]=k<v(0);o[e+56>>2]=m<v(0);i=v(j*i);j=i==v(0)?v(0xde0b6b000000000):v(v(1)/i);s[e+36>>2]=j;o[e+52>>2]=j<v(0);s[e+64>>2]=v(v(i*v(s[e+84>>2]-s[e+68>>2]))+v(g*v(s[e+88>>2]-s[e+72>>2])))+v(h*v(s[e+92>>2]-s[e+76>>2]));a=o[a+68>>2];o[e+24>>2]=0;o[e+28>>2]=0;o[e+16>>2]=0;o[e+20>>2]=0;o[e+8>>2]=0;o[e+12>>2]=0;o[e>>2]=0;o[e+4>>2]=0;l[o[o[a>>2]+24>>2]](a,b,c,e+32|0,e+16|0,e);K=e+256|0;}function ek(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0;a:{h=o[a+48>>2];d=o[b>>2];e=(d<<15^-1)+d|0;e=u(e>>>10^e,9);e=e>>>6^e;e=(e<<11^-1)+e|0;j=h+ -1&(e>>>16^e);b:{if(j>>>0>=r[a+4>>2]){break b}e=o[o[a+12>>2]+(j<<2)>>2];if((e|0)==-1){break b}f=o[a+72>>2];while(1){if((d|0)==o[f+(e<<3)>>2]){break a}e=o[o[a+32>>2]+(e<<2)>>2];if((e|0)!=-1){continue}break}}k=o[a+44>>2];d=k;c:{if((h|0)!=(d|0)){break c}d=h;f=d?d<<1:1;if((d|0)>=(f|0)){break c}if(f){o[6257]=o[6257]+1;g=l[o[4968]](f<<2,16)|0;d=o[a+44>>2];}else {d=h;}if((d|0)>=1){e=0;while(1){i=e<<2;o[i+g>>2]=o[i+o[a+52>>2]>>2];e=e+1|0;if((e|0)!=(d|0)){continue}break}}e=o[a+52>>2];if(e){if(p[a+56|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}d=o[a+44>>2];}o[a+52>>2]=0;}o[a+52>>2]=g;o[a+48>>2]=f;m[a+56|0]=1;}o[o[a+52>>2]+(d<<2)>>2]=o[c>>2];o[a+44>>2]=d+1;d=o[a- -64>>2];d:{if((d|0)!=o[a+68>>2]){break d}c=d?d<<1:1;if((d|0)>=(c|0)){break d}e:{if(!c){g=0;break e}o[6257]=o[6257]+1;g=l[o[4968]](c<<3,16)|0;d=o[a+64>>2];}if((d|0)>=1){e=0;while(1){f=e<<3;i=f+g|0;f=f+o[a+72>>2]|0;n=o[f+4>>2];o[i>>2]=o[f>>2];o[i+4>>2]=n;e=e+1|0;if((e|0)!=(d|0)){continue}break}}d=o[a+72>>2];if(d){if(p[a+76|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+72>>2]=0;}o[a+72>>2]=g;o[a+68>>2]=c;m[a+76|0]=1;d=o[a+64>>2];}c=o[a+72>>2]+(d<<3)|0;d=o[b+4>>2];o[c>>2]=o[b>>2];o[c+4>>2]=d;o[a+64>>2]=o[a+64>>2]+1;if((h|0)<o[a+48>>2]){dk(a);b=o[b>>2];b=(b<<15^-1)+b|0;b=u(b>>>10^b,9);b=b>>>6^b;b=(b<<11^-1)+b|0;j=o[a+48>>2]+ -1&(b>>>16^b);}b=o[a+32>>2]+(k<<2)|0;a=o[a+12>>2]+(j<<2)|0;o[b>>2]=o[a>>2];o[a>>2]=k;return}o[o[a+52>>2]+(e<<2)>>2]=o[c>>2];}function Lu(a,b,c){var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0);f=s[b>>2];g=s[b+4>>2];h=s[b+8>>2];o[a+16>>2]=0;i=v(h-v(1));s[a+12>>2]=i;g=v(g-v(1));s[a+8>>2]=g;h=v(f-v(1));s[a+4>>2]=h;e=s[c>>2];d=s[c+4>>2];f=s[c+8>>2];m[a+60|0]=1;o[a+48>>2]=0;o[a+32>>2]=0;p=v(f+v(1));s[a+28>>2]=p;q=v(d+v(1));s[a+24>>2]=q;f=v(e+v(1));s[a+20>>2]=f;l=v(v(65533)/v(p-i));s[a+44>>2]=l;k=v(v(65533)/v(q-g));s[a+40>>2]=k;j=v(v(65533)/v(f-h));s[a+36>>2]=j;d=v(v(i-i)*l);a:{if(d<v(4294967296)&d>=v(0)){b=~~d>>>0;break a}b=0;}n=v((b&65534)>>>0);d=g;r=d;e=v(v(d-d)*k);b:{if(e<v(4294967296)&e>=v(0)){b=~~e>>>0;break b}b=0;}e=v(r+v(v((b&65534)>>>0)/k));d=h;r=d;k=v(v(d-d)*j);c:{if(k<v(4294967296)&k>=v(0)){b=~~k>>>0;break c}b=0;}d=v(v(r+v(v((b&65534)>>>0)/j))-v(1));if(!!(d<h)){s[a+4>>2]=d;h=d;}d=v(e-v(1));if(!!(d<g)){s[a+8>>2]=d;g=d;}d=v(v(i+v(n/l))-v(1));if(!!(d<i)){s[a+12>>2]=d;i=d;}o[a+48>>2]=0;d=v(p-i);t=v(v(65533)/d);s[a+44>>2]=t;e=v(q-g);n=v(v(65533)/e);s[a+40>>2]=n;j=v(f-h);l=v(v(65533)/j);s[a+36>>2]=l;d=v(v(t*d)+v(1));d:{if(d<v(4294967296)&d>=v(0)){b=~~d>>>0;break d}b=0;}k=v((b|1)>>>0);d=g;e=v(v(n*e)+v(1));e:{if(e<v(4294967296)&e>=v(0)){b=~~e>>>0;break e}b=0;}n=v(d+v(v((b|1)>>>0)/n));r=f;d=h;j=v(v(l*j)+v(1));f:{if(j<v(4294967296)&j>=v(0)){b=~~j>>>0;break f}b=0;}d=v(v(d+v(v((b|1)>>>0)/l))+v(1));if(!!(r<d)){s[a+20>>2]=d;f=d;}d=v(n+v(1));if(!!(q<d)){s[a+24>>2]=d;q=d;}d=v(v(i+v(k/t))+v(1));if(!!(p<d)){s[a+28>>2]=d;p=d;}o[a+48>>2]=0;s[a+44>>2]=v(65533)/v(p-i);s[a+40>>2]=v(65533)/v(q-g);s[a+36>>2]=v(65533)/v(f-h);}function _b(a,b,c,d){var e=v(0),f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),A=v(0),B=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0);f=K+ -64|0;K=f;q=s[b+24>>2];r=s[b+20>>2];t=s[b+40>>2];u=s[b+36>>2];j=s[a+40>>2];k=s[a+20>>2];n=s[a+36>>2];l=s[a+24>>2];w=s[b+8>>2];x=s[b>>2];A=s[b+4>>2];B=s[b+16>>2];D=s[b+32>>2];g=s[a+8>>2];h=s[a+4>>2];p=s[a+32>>2];m=s[a+16>>2];i=s[a>>2];o[f+60>>2]=0;o[f+44>>2]=0;F=v(v(k*j)-v(l*n));G=v(v(l*p)-v(j*m));H=v(v(n*m)-v(k*p));e=v(v(1)/v(v(v(i*F)+v(h*G))+v(g*H)));E=v(v(v(l*h)-v(k*g))*e);l=v(v(v(m*g)-v(l*i))*e);k=v(v(v(k*i)-v(m*h))*e);s[f+56>>2]=v(v(D*E)+v(u*l))+v(t*k);m=v(v(v(n*g)-v(j*h))*e);g=v(v(v(j*i)-v(p*g))*e);h=v(v(v(p*h)-v(n*i))*e);s[f+52>>2]=v(v(D*m)+v(u*g))+v(t*h);s[f+40>>2]=v(v(E*B)+v(l*r))+v(k*q);s[f+36>>2]=v(v(m*B)+v(g*r))+v(h*q);o[f+28>>2]=0;i=v(F*e);j=v(G*e);e=v(H*e);s[f+48>>2]=v(v(D*i)+v(u*j))+v(t*e);s[f+32>>2]=v(v(i*B)+v(j*r))+v(e*q);s[f+24>>2]=v(w*k)+v(v(x*E)+v(A*l));s[f+20>>2]=v(w*h)+v(v(x*m)+v(A*g));s[f+16>>2]=v(w*e)+v(v(x*i)+v(A*j));fb(f+16|0,f);i=s[f>>2];h=s[f+4>>2];g=s[f+8>>2];j=s[f+12>>2];e=v(v(1)/v(C(v(v(v(v(i*i)+v(h*h))+v(g*g))+v(j*j)))));g=v(g*e);s[f+8>>2]=g;h=v(h*e);s[f+4>>2]=h;i=v(i*e);s[f>>2]=i;e=v(j*e);s[f+12>>2]=e;e=ku(v(y(v(z(e,v(-1))),v(1))));s[d>>2]=e+e;o[c+12>>2]=0;s[c+8>>2]=g;s[c+4>>2]=h;s[c>>2]=i;e=v(v(v(i*i)+v(h*h))+v(g*g));a:{if(!!(e<v(1.4210854715202004e-14))){o[c+8>>2]=0;o[c+12>>2]=0;o[c>>2]=1065353216;o[c+4>>2]=0;break a}e=v(v(1)/v(C(e)));s[c+8>>2]=g*e;s[c+4>>2]=h*e;s[c>>2]=i*e;}K=f- -64|0;}function sk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=v(0),f=v(0),g=v(0),h=0,i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),D=v(0),E=v(0);h=K-32|0;K=h;r=s[b+24>>2];E=s[b+40>>2];t=s[b+36>>2];k=s[b+20>>2];m=s[b+8>>2];u=s[b+16>>2];p=s[b+4>>2];w=s[b+32>>2];q=s[b>>2];o[h+28>>2]=0;f=v(u-q);i=v(t-p);g=v(k-p);n=v(w-q);e=v(v(f*i)-v(g*n));s[h+24>>2]=e;j=v(r-m);x=v(j*n);n=v(E-m);f=v(x-v(f*n));s[h+20>>2]=f;i=v(v(g*n)-v(j*i));s[h+16>>2]=i;y=s[a+4>>2];j=s[a+8>>2];z=s[a+12>>2];g=v(v(m*e)+v(v(q*i)+v(p*f)));n=v(v(v(v(i*y)+v(f*j))+v(e*z))-g);B=s[a+20>>2];A=s[a+24>>2];D=s[a+28>>2];g=v(v(v(v(i*B)+v(f*A))+v(e*D))-g);a:{if(v(n*g)>=v(0)){break a}b=o[a+36>>2];if(b&1?!!(n<=v(0)):0){break a}g=v(n/v(n-g));if(!(g<s[a+40>>2])){break a}x=j;j=v(v(1)-g);A=v(v(A*g)+v(x*j));k=v(k-A);y=v(v(B*g)+v(y*j));q=v(q-y);p=v(p-A);u=v(u-y);j=v(v(D*g)+v(z*j));r=v(r-j);m=v(m-j);B=v(v(e*e)+v(v(i*i)+v(f*f)));z=v(B*v(-9999999747378752e-20));if(!(v(v(e*v(v(k*q)-v(p*u)))+v(v(i*v(v(p*r)-v(m*k)))+v(f*v(v(m*u)-v(r*q)))))>=z)){break a}t=v(t-A);w=v(w-y);D=v(e*v(v(t*u)-v(k*w)));x=k;k=v(E-j);if(v(D+v(v(i*v(v(x*k)-v(r*t)))+v(f*v(v(r*w)-v(k*u)))))>=z^1|v(v(e*v(v(p*w)-v(t*q)))+v(v(i*v(v(t*m)-v(k*p)))+v(f*v(v(k*q)-v(m*w)))))>=z^1){break a}x=e;e=v(v(1)/v(C(B)));m=v(x*e);s[h+24>>2]=m;f=v(f*e);s[h+20>>2]=f;e=v(i*e);s[h+16>>2]=e;if(!(b&2|n<=v(0)^1)){o[h+12>>2]=0;s[h+8>>2]=-m;s[h+4>>2]=-f;s[h>>2]=-e;s[a+40>>2]=l[o[o[a>>2]+12>>2]](a,h,g,c,d);break a}s[a+40>>2]=l[o[o[a>>2]+12>>2]](a,h+16|0,g,c,d);}K=h+32|0;}function Bf(a,b,c,d){var e=0;qk(a,b,c);c=a;o[c+100>>2]=1050253722;o[c+104>>2]=1015580809;o[c+92>>2]=1058642330;o[c+96>>2]=1065353216;o[c+88>>2]=0;o[c+80>>2]=0;o[c+84>>2]=0;o[c+132>>2]=0;o[c+136>>2]=1045220557;o[c+124>>2]=1045220557;o[c+128>>2]=1045220557;o[c+108>>2]=0;o[c+112>>2]=10;o[c+184>>2]=0;o[c+188>>2]=1045220557;o[c+176>>2]=1120403456;o[c+180>>2]=1900671690;o[c+172>>2]=128;o[c+164>>2]=260;o[c+168>>2]=2;o[c+156>>2]=0;o[c+160>>2]=1062836634;o[c+148>>2]=-1121724662;o[c+152>>2]=1036831949;o[c+140>>2]=0;o[c+144>>2]=1;o[c+116>>2]=1101004800;o[c+120>>2]=1065353216;o[c>>2]=2328;m[c+208|0]=1;o[c+204>>2]=0;m[c+240|0]=1;o[c+216>>2]=d;o[c+212>>2]=0;o[c+196>>2]=0;o[c+200>>2]=0;o[c+236>>2]=0;o[c+228>>2]=0;o[c+232>>2]=0;m[c+260|0]=1;n[c+290>>1]=0;o[c+256>>2]=0;o[c+248>>2]=0;o[c+252>>2]=0;o[c+264>>2]=0;o[c+268>>2]=-1054867456;o[c+272>>2]=0;o[c+276>>2]=0;o[c+280>>2]=0;o[c+284>>2]=0;m[c+308|0]=1;o[c+312>>2]=0;o[c+304>>2]=0;o[c+296>>2]=0;o[c+300>>2]=0;m[c+336|0]=1;m[c+316|0]=1;o[c+324>>2]=0;o[c+328>>2]=0;o[c+332>>2]=0;o[c+340>>2]=0;e=c;if(d){c=0;}else {o[6257]=o[6257]+1;c=l[o[4968]](236,16)|0;mf(c);o[a+216>>2]=c;c=1;}m[e+289|0]=c;o[6257]=o[6257]+1;c=l[o[4968]](68,16)|0;ll(c);m[a+288|0]=1;o[a+220>>2]=c;o[6257]=o[6257]+1;c=l[o[4968]](88,16)|0;d=o[a+216>>2];m[c+44|0]=1;o[c+24>>2]=b;o[c+20>>2]=0;o[c+12>>2]=0;o[c+16>>2]=0;o[c+8>>2]=d;o[c+4>>2]=0;o[c>>2]=2936;o[c+40>>2]=0;m[c+64|0]=1;o[c+32>>2]=0;o[c+36>>2]=0;o[c+60>>2]=0;m[c+84|0]=1;o[c+52>>2]=0;o[c+56>>2]=0;o[c+80>>2]=0;o[c+72>>2]=0;o[c+76>>2]=0;o[a+212>>2]=c;}function Ye(a){a=a|0;var b=0;o[a>>2]=5096;if(p[a+20|0]){b=o[o[a+16>>2]+16>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+16>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}if(p[a+12|0]){b=o[o[a+8>>2]+16>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+8>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}b=o[a+28>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+28>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+32>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+32>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+36>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+36>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+40>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+40>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+44>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+44>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+48>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+48>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+52>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+52>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+56>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+56>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+72>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+72>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+76>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+76>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+68>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+68>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+84>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+84>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+80>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+80>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+24>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+24>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}return a|0}function He(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;c=K-96|0;K=c;m[c+92|0]=1;o[c+60>>2]=0;o[c+64>>2]=0;m[c+52|0]=1;o[c+48>>2]=0;m[c+72|0]=1;o[c+40>>2]=0;o[c+44>>2]=0;o[c+68>>2]=0;o[c+88>>2]=0;o[c+80>>2]=0;o[c+84>>2]=0;o[c+28>>2]=0;m[c+32|0]=1;o[c+20>>2]=0;o[c+24>>2]=0;g=o[a+8>>2];a:{if((g|0)<1){break a}while(1){f=o[o[o[a+16>>2]+(h<<2)>>2]+192>>2];o[c+12>>2]=f;i=d+ -1|0;d=f+(f<<15^-1)|0;d=u(d>>>10^d,9);d=d>>>6^d;d=(d<<11^-1)+d|0;d=i&(d>>>16^d);b:{c:{if(d>>>0>=e>>>0){break c}e=o[o[c+28>>2]+(d<<2)>>2];if((e|0)==-1){break c}d=o[c+48>>2];i=o[c+88>>2];while(1){if((f|0)!=o[(e<<3)+i>>2]){e=o[d+(e<<2)>>2];if((e|0)!=-1){continue}break c}break}if(o[c+68>>2]){break b}}o[c>>2]=f;ek(c+16|0,c,c+12|0);e=o[c+12>>2];l[o[o[e>>2]+60>>2]](e,b);g=o[a+8>>2];}h=h+1|0;if((h|0)<(g|0)){e=o[c+20>>2];d=o[c+64>>2];continue}break}e=0;if((g|0)<=0){break a}while(1){f=o[o[a+16>>2]+(e<<2)>>2];h=o[f+252>>2];if(!((h|0)!=1?(h|0)!=64:0)){l[o[o[f>>2]+24>>2]](f,b);g=o[a+8>>2];}e=e+1|0;if((e|0)<(g|0)){continue}break}}a=o[c+88>>2];if(a){if(p[c+92|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+88>>2]=0;}o[c+88>>2]=0;m[c+92|0]=1;o[c+80>>2]=0;o[c+84>>2]=0;a=o[c+68>>2];if(a){if(p[c+72|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+68>>2]=0;}o[c+68>>2]=0;m[c+72|0]=1;o[c+60>>2]=0;o[c+64>>2]=0;a=o[c+48>>2];if(a){if(p[c+52|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+48>>2]=0;}o[c+48>>2]=0;m[c+52|0]=1;o[c+40>>2]=0;o[c+44>>2]=0;a=o[c+28>>2];if(a){if(p[c+32|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+28>>2]=0;}K=c+96|0;}function Fo(a,b,c){var d=0,e=v(0),f=v(0);d=K-32|0;K=d;o[d+28>>2]=b;o[d+24>>2]=c;b=K-16|0;o[b+12>>2]=o[d+28>>2];e=s[o[b+12>>2]+12>>2];b=K-16|0;o[b+12>>2]=o[d+24>>2];e=v(e*s[o[b+12>>2]>>2]);b=K-16|0;o[b+12>>2]=o[d+28>>2];f=s[o[b+12>>2]+4>>2];b=K-16|0;o[b+12>>2]=o[d+24>>2];e=v(e+v(f*s[o[b+12>>2]+8>>2]));b=K-16|0;o[b+12>>2]=o[d+28>>2];f=s[o[b+12>>2]+8>>2];b=K-16|0;o[b+12>>2]=o[d+24>>2];s[d+20>>2]=e-v(f*s[o[b+12>>2]+4>>2]);b=K-16|0;o[b+12>>2]=o[d+28>>2];e=s[o[b+12>>2]+12>>2];b=K-16|0;o[b+12>>2]=o[d+24>>2];e=v(e*s[o[b+12>>2]+4>>2]);b=K-16|0;o[b+12>>2]=o[d+28>>2];f=s[o[b+12>>2]+8>>2];b=K-16|0;o[b+12>>2]=o[d+24>>2];e=v(e+v(f*s[o[b+12>>2]>>2]));b=K-16|0;o[b+12>>2]=o[d+28>>2];f=s[o[b+12>>2]>>2];b=K-16|0;o[b+12>>2]=o[d+24>>2];s[d+16>>2]=e-v(f*s[o[b+12>>2]+8>>2]);b=K-16|0;o[b+12>>2]=o[d+28>>2];e=s[o[b+12>>2]+12>>2];b=K-16|0;o[b+12>>2]=o[d+24>>2];e=v(e*s[o[b+12>>2]+8>>2]);b=K-16|0;o[b+12>>2]=o[d+28>>2];f=s[o[b+12>>2]>>2];b=K-16|0;o[b+12>>2]=o[d+24>>2];e=v(e+v(f*s[o[b+12>>2]+4>>2]));b=K-16|0;o[b+12>>2]=o[d+28>>2];f=s[o[b+12>>2]+4>>2];b=K-16|0;o[b+12>>2]=o[d+24>>2];s[d+12>>2]=e-v(f*s[o[b+12>>2]>>2]);b=K-16|0;o[b+12>>2]=o[d+28>>2];e=v(-s[o[b+12>>2]>>2]);b=K-16|0;o[b+12>>2]=o[d+24>>2];e=v(e*s[o[b+12>>2]>>2]);b=K-16|0;o[b+12>>2]=o[d+28>>2];f=s[o[b+12>>2]+4>>2];b=K-16|0;o[b+12>>2]=o[d+24>>2];e=v(e-v(f*s[o[b+12>>2]+4>>2]));b=K-16|0;o[b+12>>2]=o[d+28>>2];f=s[o[b+12>>2]+8>>2];b=K-16|0;o[b+12>>2]=o[d+24>>2];s[d+8>>2]=e-v(f*s[o[b+12>>2]+8>>2]);vb(a,d+20|0,d+16|0,d+12|0,d+8|0);K=d+32|0;}function Pn(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;j=K-16|0;K=j;l[o[4966]](2613);b=o[a+220>>2];l[o[o[b>>2]+8>>2]](b,a,o[a+24>>2]);h=o[a+324>>2];if((h|0)>=1){i=o[a+332>>2];while(1){b=o[i+(g<<2)>>2];c=o[b+836>>2];a:{if(!c){break a}b=o[b+840>>2];if(!b|o[c+204>>2]&3|p[b+204|0]&3){break a}b=o[b+208>>2];d=o[o[a+220>>2]+16>>2];e=o[c+208>>2];f=d+(e<<3)|0;c=o[f>>2];if((c|0)!=(e|0)){while(1){c=d+(c<<3)|0;o[f>>2]=o[c>>2];e=o[c>>2];f=d+(e<<3)|0;c=o[f>>2];if((c|0)!=(e|0)){continue}break}}f=d+(b<<3)|0;c=o[f>>2];if((c|0)!=(b|0)){while(1){b=d+(c<<3)|0;o[f>>2]=o[b>>2];b=o[b>>2];f=d+(b<<3)|0;c=o[f>>2];if((b|0)!=(c|0)){continue}break}}if((b|0)==(e|0)){break a}c=d+(e<<3)|0;o[c>>2]=b;b=d+(b<<3)|0;o[b+4>>2]=o[b+4>>2]+o[c+4>>2];}g=g+1|0;if((h|0)!=(g|0)){continue}break}}h=o[a+228>>2];if((h|0)>=1){i=o[a+236>>2];f=0;while(1){b=o[i+(f<<2)>>2];b:{if(!p[b+20|0]){break b}c=o[b+28>>2];if(p[c+204|0]&3){break b}b=o[b+32>>2];if(p[b+204|0]&3){break b}b=o[b+208>>2];d=o[o[a+220>>2]+16>>2];e=o[c+208>>2];c=d+(e<<3)|0;g=o[c>>2];if((g|0)!=(e|0)){while(1){e=c;c=d+(g<<3)|0;o[e>>2]=o[c>>2];e=o[c>>2];c=d+(e<<3)|0;g=o[c>>2];if((g|0)!=(e|0)){continue}break}}c=d+(b<<3)|0;g=o[c>>2];if((g|0)!=(b|0)){while(1){b=d+(g<<3)|0;o[c>>2]=o[b>>2];b=o[b>>2];c=d+(b<<3)|0;g=o[c>>2];if((b|0)!=(g|0)){continue}break}}if((b|0)==(e|0)){break b}c=d+(e<<3)|0;o[c>>2]=b;b=d+(b<<3)|0;o[b+4>>2]=o[b+4>>2]+o[c+4>>2];}f=f+1|0;if((h|0)!=(f|0)){continue}break}}b=o[a+220>>2];l[o[o[b>>2]+12>>2]](b,a);l[o[4967]]();K=j+16|0;}function ov(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0;o[5674]=o[5674]+1;e=o[b+12>>2]>o[c+12>>2];i=e?b:c;f=o[i+12>>2];j=e?c:b;g=o[j+12>>2];b=f<<16|g;b=(b<<15^-1)+b|0;b=u(b>>>10^b,9);b=b>>>6^b;b=(b<<11^-1)+b|0;h=o[a+12>>2]+ -1&(b>>>16^b);b=o[o[a+40>>2]+(h<<2)>>2];a:{if((b|0)==-1){break a}e=o[a+16>>2];while(1){c=e+(b<<4)|0;if(!((f|0)==o[o[c+4>>2]+12>>2]?(g|0)==o[o[c>>2]+12>>2]:0)){b=o[o[a+60>>2]+(b<<2)>>2];if((b|0)!=-1){continue}break a}break}l[o[o[a>>2]+32>>2]](a,c,d);k=o[(e+(b<<4)|0)+12>>2];f=o[a+60>>2];b:{c:{g=o[a+40>>2]+(h<<2)|0;b=o[g>>2];e=c-o[a+16>>2]>>4;if((b|0)==(e|0)){b=o[f+(e<<2)>>2];break c}while(1){c=b;h=f+(b<<2)|0;b=o[h>>2];if((e|0)!=(b|0)){continue}break}b=o[f+(e<<2)>>2];if((c|0)==-1){break c}o[h>>2]=b;break b}o[g>>2]=b;}f=o[a+8>>2]+ -1|0;b=o[a+68>>2];if(b){l[o[o[b>>2]+12>>2]](b,j,i,d)|0;}if((e|0)==(f|0)){o[a+8>>2]=o[a+8>>2]+ -1;return k|0}i=o[a+60>>2];d:{e:{j=o[a+16>>2];d=j+(f<<4)|0;b=o[o[d+4>>2]+12>>2]<<16|o[o[d>>2]+12>>2];b=(b<<15^-1)+b|0;b=u(b>>>10^b,9);b=b>>>6^b;b=(b<<11^-1)+b|0;g=o[a+12>>2]+ -1&(b>>>16^b);h=o[a+40>>2]+(g<<2)|0;b=o[h>>2];if((f|0)==(b|0)){b=o[i+(f<<2)>>2];break e}while(1){c=b;m=i+(b<<2)|0;b=o[m>>2];if((f|0)!=(b|0)){continue}break}b=o[i+(f<<2)>>2];if((c|0)==-1){break e}o[m>>2]=b;break d}o[h>>2]=b;}c=o[d+4>>2];b=j+(e<<4)|0;o[b>>2]=o[d>>2];o[b+4>>2]=c;c=o[d+12>>2];o[b+8>>2]=o[d+8>>2];o[b+12>>2]=c;b=o[a+40>>2]+(g<<2)|0;o[o[a+60>>2]+(e<<2)>>2]=o[b>>2];o[b>>2]=e;o[a+8>>2]=o[a+8>>2]+ -1;}return k|0}function rb(a,b,c,d,e){var f=0,g=0,h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),n=v(0),p=v(0),q=v(0),r=0,t=v(0);f=o[a+18504>>2];if(f){g=o[f+48>>2];if(g){o[g+44>>2]=o[f+44>>2];}g=o[f+44>>2];if(g){o[g+48>>2]=o[f+48>>2];}if(o[a+18504>>2]==(f|0)){o[a+18504>>2]=o[f+48>>2];}g=a+18508|0;o[g>>2]=o[g>>2]+ -1;o[f+44>>2]=0;o[f+48>>2]=o[a+18496>>2];g=o[a+18496>>2];if(g){o[g+44>>2]=f;}o[a+18496>>2]=f;g=a+18500|0;o[g>>2]=o[g>>2]+1;o[f+28>>2]=d;o[f+24>>2]=c;o[f+20>>2]=b;m[f+55|0]=0;k=s[c+24>>2];t=s[d+24>>2];h=s[b+24>>2];l=s[d+20>>2];j=s[b+20>>2];n=s[c+20>>2];p=s[c+16>>2];q=s[d+16>>2];i=s[b+16>>2];o[f+12>>2]=0;p=v(p-i);l=v(l-j);n=v(n-j);i=v(q-i);j=v(v(p*l)-v(n*i));s[f+8>>2]=j;k=v(k-h);q=v(k*i);i=v(t-h);h=v(q-v(p*i));s[f+4>>2]=h;i=v(v(n*i)-v(k*l));s[f>>2]=i;r=2;a:{h=v(C(v(v(v(i*i)+v(h*h))+v(j*j))));if(!(h>v(9999999747378752e-20))){break a}g=f+16|0;b:{if(Yc(f,b,c,g)){break b}if(Yc(f,c,d,g)){break b}if(Yc(f,d,b,g)){break b}s[f+16>>2]=v(v(v(s[b+16>>2]*s[f>>2])+v(s[b+20>>2]*s[f+4>>2]))+v(s[b+24>>2]*s[f+8>>2]))/h;}h=v(v(1)/h);s[f>>2]=h*s[f>>2];s[f+4>>2]=h*s[f+4>>2];s[f+8>>2]=h*s[f+8>>2];if(e){return f}r=3;if(!(s[g>>2]>=v(-9999999747378752e-21))){break a}return f}o[a>>2]=r;b=o[f+48>>2];if(b){o[b+44>>2]=o[f+44>>2];}b=o[f+44>>2];if(b){o[b+48>>2]=o[f+48>>2];}if(o[a+18496>>2]==(f|0)){o[a+18496>>2]=o[f+48>>2];}o[a+18500>>2]=o[a+18500>>2]+ -1;o[f+44>>2]=0;o[f+48>>2]=o[a+18504>>2];b=o[a+18504>>2];if(b){o[b+44>>2]=f;}o[a+18504>>2]=f;o[a+18508>>2]=o[a+18508>>2]+1;return 0}o[a>>2]=5;return 0}function aj(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;a:{b:{c:{d:{e=o[a+96>>2]+ -2|0;e:{if(e>>>0>2){break e}f:{switch(e-1|0){case 0:if(b>>>0>2){break e}g:{switch(b-1|0){case 0:break c;case 1:break g;default:break d}}break b;case 1:break f;default:break d}}if(b>>>0>5){break e}h:{switch(b-1|0){case 2:b=o[a+104>>2];o[c>>2]=o[a+100>>2];o[c+4>>2]=b;b=o[a+112>>2];o[c+8>>2]=o[a+108>>2];o[c+12>>2]=b;break a;case 3:b=o[a+128>>2];o[c+8>>2]=o[a+124>>2];o[c+12>>2]=b;b=o[a+120>>2];o[c>>2]=o[a+116>>2];o[c+4>>2]=b;break a;case 1:break b;case 0:break c;case 4:break h;default:break d}}b=o[a+144>>2];o[c+8>>2]=o[a+140>>2];o[c+12>>2]=b;b=o[a+136>>2];o[c>>2]=o[a+132>>2];o[c+4>>2]=b;b=o[a+160>>2];o[d+8>>2]=o[a+156>>2];o[d+12>>2]=b;b=o[a+152>>2];o[d>>2]=o[a+148>>2];o[d+4>>2]=b;}return}b=o[a+104>>2];o[c>>2]=o[a+100>>2];o[c+4>>2]=b;b=o[a+112>>2];o[c+8>>2]=o[a+108>>2];o[c+12>>2]=b;b=o[a+128>>2];o[d+8>>2]=o[a+124>>2];o[d+12>>2]=b;b=o[a+120>>2];o[d>>2]=o[a+116>>2];o[d+4>>2]=b;return}b=o[a+128>>2];o[c+8>>2]=o[a+124>>2];o[c+12>>2]=b;b=o[a+120>>2];o[c>>2]=o[a+116>>2];o[c+4>>2]=b;b=o[a+144>>2];o[d+8>>2]=o[a+140>>2];o[d+12>>2]=b;b=o[a+136>>2];o[d>>2]=o[a+132>>2];o[d+4>>2]=b;return}b=o[a+144>>2];o[c+8>>2]=o[a+140>>2];o[c+12>>2]=b;b=o[a+136>>2];o[c>>2]=o[a+132>>2];o[c+4>>2]=b;b=o[a+112>>2];o[d+8>>2]=o[a+108>>2];o[d+12>>2]=b;b=o[a+104>>2];o[d>>2]=o[a+100>>2];o[d+4>>2]=b;return}b=o[a+160>>2];o[d+8>>2]=o[a+156>>2];o[d+12>>2]=b;b=o[a+152>>2];o[d>>2]=o[a+148>>2];o[d+4>>2]=b;}function qo(a,b,c){a=a|0;b=b|0;c=c|0;hf(a,b,c);o[b+264>>2]=o[a+324>>2];o[b+268>>2]=o[a+328>>2];o[b+272>>2]=o[a+332>>2];o[b+276>>2]=o[a+336>>2];o[b+280>>2]=o[a+340>>2];o[b+284>>2]=o[a+344>>2];o[b+288>>2]=o[a+348>>2];o[b+292>>2]=o[a+352>>2];o[b+296>>2]=o[a+356>>2];o[b+300>>2]=o[a+360>>2];o[b+304>>2]=o[a+364>>2];o[b+308>>2]=o[a+368>>2];o[b+312>>2]=o[a+372>>2];o[b+316>>2]=o[a+376>>2];o[b+320>>2]=o[a+380>>2];o[b+324>>2]=o[a+384>>2];o[b+328>>2]=o[a+388>>2];o[b+332>>2]=o[a+392>>2];o[b+336>>2]=o[a+396>>2];o[b+340>>2]=o[a+400>>2];o[b+456>>2]=o[a+404>>2];o[b+344>>2]=o[a+604>>2];o[b+348>>2]=o[a+608>>2];o[b+352>>2]=o[a+612>>2];o[b+356>>2]=o[a+616>>2];o[b+360>>2]=o[a+408>>2];o[b+364>>2]=o[a+412>>2];o[b+368>>2]=o[a+416>>2];o[b+372>>2]=o[a+420>>2];o[b+376>>2]=o[a+424>>2];o[b+380>>2]=o[a+428>>2];o[b+384>>2]=o[a+432>>2];o[b+388>>2]=o[a+436>>2];o[b+392>>2]=o[a+440>>2];o[b+396>>2]=o[a+444>>2];o[b+400>>2]=o[a+448>>2];o[b+404>>2]=o[a+452>>2];o[b+408>>2]=o[a+456>>2];o[b+412>>2]=o[a+460>>2];o[b+416>>2]=o[a+464>>2];o[b+420>>2]=o[a+468>>2];o[b+424>>2]=o[a+472>>2];o[b+428>>2]=o[a+476>>2];o[b+432>>2]=o[a+480>>2];o[b+436>>2]=o[a+484>>2];o[b+440>>2]=o[a+488>>2];o[b+444>>2]=o[a+492>>2];o[b+448>>2]=o[a+496>>2];o[b+452>>2]=o[a+500>>2];o[b+460>>2]=o[a+504>>2];o[b+464>>2]=o[a+508>>2];o[b+492>>2]=p[a+512|0];o[b+468>>2]=o[a+516>>2];o[b+472>>2]=o[a+520>>2];o[b+476>>2]=o[a+524>>2];o[b+480>>2]=o[a+528>>2];o[b+484>>2]=o[a+532>>2];o[b+488>>2]=o[a+536>>2];return 2272}function lf(a){a=a|0;var b=0;o[a>>2]=3756;b=o[a+204>>2];if(b){if(p[a+208|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+204>>2]=0;}o[a+204>>2]=0;o[a+196>>2]=0;o[a+200>>2]=0;m[a+208|0]=1;b=o[a+176>>2];if(b){if(p[a+180|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+176>>2]=0;}o[a+176>>2]=0;o[a+168>>2]=0;o[a+172>>2]=0;m[a+180|0]=1;b=o[a+156>>2];if(b){if(p[a+160|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+156>>2]=0;}o[a+156>>2]=0;o[a+148>>2]=0;o[a+152>>2]=0;m[a+160|0]=1;b=o[a+136>>2];if(b){if(p[a+140|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+136>>2]=0;}o[a+136>>2]=0;o[a+128>>2]=0;o[a+132>>2]=0;m[a+140|0]=1;b=o[a+116>>2];if(b){if(p[a+120|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+116>>2]=0;}o[a+116>>2]=0;o[a+108>>2]=0;o[a+112>>2]=0;m[a+120|0]=1;b=o[a+96>>2];if(b){if(p[a+100|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+96>>2]=0;}o[a+96>>2]=0;o[a+88>>2]=0;o[a+92>>2]=0;m[a+100|0]=1;b=o[a+76>>2];if(b){if(p[a+80|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+76>>2]=0;}o[a+76>>2]=0;o[a+68>>2]=0;o[a+72>>2]=0;m[a+80|0]=1;b=o[a+56>>2];if(b){if(p[a+60|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+56>>2]=0;}o[a+56>>2]=0;o[a+48>>2]=0;o[a+52>>2]=0;m[a+60|0]=1;b=o[a+36>>2];if(b){if(p[a+40|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+36>>2]=0;}o[a+36>>2]=0;o[a+28>>2]=0;o[a+32>>2]=0;m[a+40|0]=1;b=o[a+16>>2];if(b){if(p[a+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+16>>2]=0;}o[a+16>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;m[a+20|0]=1;return a|0}function Ck(a,b,c,d,e){var f=0,g=v(0),h=v(0),i=0,j=0,k=v(0),l=v(0),m=0,n=v(0),p=v(0),q=v(0),r=0,t=v(0),u=v(0);j=K+ -64|0;K=j;a:{b:{c:{d:{f=a+ -1|0;if(f>>>0<=1){if(f-1){break d}break c}if((a|0)>=2){r=a+ -1|0;f=0;while(1){m=f<<3;i=m+b|0;l=s[i>>2];n=s[i+12>>2];p=s[i+8>>2];q=s[(m|4)+b>>2];k=v(v(l*n)-v(p*q));g=v(g+k);h=v(h+v(v(n+q)*k));t=v(t+v(v(l+p)*k));f=f+1|0;if((r|0)!=(f|0)){continue}break}}k=v(0xde0b6b000000000);u=g;f=(a<<3)+b|0;l=s[f+ -8>>2];n=s[b+4>>2];p=s[b>>2];q=s[f+ -4>>2];g=v(v(l*n)-v(p*q));u=v(u+g);if(!!(v(w(u))>v(1.1920928955078125e-7))){k=v(v(1)/v(u*v(3)));}r=0;if((a|0)<=0){break a}h=v(v(h+v(v(n+q)*g))*k);g=v(v(t+v(v(l+p)*g))*k);break b}h=s[b+4>>2];g=s[b>>2];break b}h=v(v(s[b+4>>2]+s[b+12>>2])*v(.5));g=v(v(s[b>>2]+s[b+8>>2])*v(.5));}f=0;while(1){i=f<<3;s[(j+32|0)+(f<<2)>>2]=ba(v(s[(i|4)+b>>2]-h),v(s[b+i>>2]-g));f=f+1|0;if((f|0)!=(a|0)){continue}break}f=0;while(1){r=1;o[(f<<2)+j>>2]=1;f=f+1|0;if((f|0)!=(a|0)){continue}break}}b=d<<2;o[b+j>>2]=0;o[e>>2]=d;if((c|0)>=2){k=v(v(6.2831854820251465)/v(c|0));t=s[b+(j+32|0)>>2];i=1;while(1){o[e+4>>2]=d;e=e+4|0;b=d;if(r){g=v(v(k*v(i|0))+t);l=g>v(3.1415927410125732)?v(g+v(-6.2831854820251465)):g;f=0;g=v(1e9);while(1){m=f<<2;e:{if(!o[m+j>>2]){break e}h=v(w(v(s[m+(j+32|0)>>2]-l)));h=h>v(3.1415927410125732)?v(v(6.2831854820251465)-h):h;if(!(h<g)){break e}o[e>>2]=f;b=f;g=h;}f=f+1|0;if((f|0)!=(a|0)){continue}break}}o[(b<<2)+j>>2]=0;i=i+1|0;if((i|0)!=(c|0)){continue}break}}K=j- -64|0;}function nk(a,b){var c=0,d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=0;c=K+ -64|0;K=c;k=o[b+192>>2];l[o[o[k>>2]+8>>2]](k,b+4|0,c+48|0,c+32|0);d=s[4962];f=v(s[c+48>>2]-d);s[c+48>>2]=f;g=v(s[c+52>>2]-d);s[c+52>>2]=g;h=v(s[c+56>>2]-d);s[c+56>>2]=h;e=v(d+s[c+32>>2]);s[c+32>>2]=e;i=v(d+s[c+36>>2]);s[c+36>>2]=i;j=v(d+s[c+40>>2]);s[c+40>>2]=j;a:{if(p[b+204|0]&3|(!p[a+44|0]|o[b+252>>2]!=2)){break a}k=o[b+192>>2];l[o[o[k>>2]+8>>2]](k,b+68|0,c+16|0,c);g=v(s[c+16>>2]-d);s[c+16>>2]=g;h=v(s[c+20>>2]-d);s[c+20>>2]=h;e=v(s[c+24>>2]-d);s[c+24>>2]=e;i=v(d+s[c>>2]);s[c>>2]=i;j=v(d+s[c+4>>2]);s[c+4>>2]=j;d=v(d+s[c+8>>2]);s[c+8>>2]=d;f=s[c+48>>2];if(!!(g<f)){s[c+48>>2]=g;f=g;}g=s[c+52>>2];if(!!(h<g)){s[c+52>>2]=h;g=h;}h=s[c+56>>2];if(!!(e<h)){s[c+56>>2]=e;h=e;}e=s[c+28>>2];if(!!(e<s[c+60>>2])){s[c+60>>2]=e;}e=s[c+32>>2];if(!!(e<i)){s[c+32>>2]=i;e=i;}i=s[c+36>>2];if(!!(i<j)){s[c+36>>2]=j;i=j;}j=s[c+40>>2];if(!!(j<d)){s[c+40>>2]=d;j=d;}d=s[c+12>>2];if(!(s[c+44>>2]<d)){break a}s[c+44>>2]=d;}k=o[a+68>>2];b:{c:{if(!(m[b+204|0]&1)){f=v(e-f);e=v(f*f);f=v(i-g);e=v(e+v(f*f));f=v(j-h);if(!(v(e+v(f*f))<v(999999995904))){break c}}l[o[o[k>>2]+16>>2]](k,o[b+188>>2],c+48|0,c+32|0,o[a+24>>2]);break b}if((o[b+220>>2]&-2)!=4){o[b+220>>2]=5;}if(p[22552]){break b}b=o[a+72>>2];if(!b){break b}m[22552]=1;l[o[o[b>>2]+44>>2]](b,7592);b=o[a+72>>2];l[o[o[b>>2]+44>>2]](b,7641);b=o[a+72>>2];l[o[o[b>>2]+44>>2]](b,7709);a=o[a+72>>2];l[o[o[a>>2]+44>>2]](a,7774);}K=c- -64|0;}function Am(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=0;e=s[c+128>>2];a:{if(e==v(0)){break a}o[5378]=o[5378]+1;d=s[c+96>>2];f=v(e-v(d*s[c+116>>2]));g=s[c+16>>2];h=s[c+20>>2];i=s[c+24>>2];e=s[c+108>>2];e=v(v(f-v(v(v(v(v(g*s[a+144>>2])+v(h*s[a+148>>2]))+v(i*s[a+152>>2]))+v(v(v(s[c>>2]*s[a+160>>2])+v(s[c+4>>2]*s[a+164>>2]))+v(s[c+8>>2]*s[a+168>>2])))*e))-v(e*v(v(v(v(s[c+48>>2]*s[b+144>>2])+v(s[c+52>>2]*s[b+148>>2]))+v(s[c+56>>2]*s[b+152>>2]))+v(v(v(s[c+32>>2]*s[b+160>>2])+v(s[c+36>>2]*s[b+164>>2]))+v(s[c+40>>2]*s[b+168>>2])))));j=v(d+e);f=s[c+120>>2];k=j<f;s[c+96>>2]=k?f:j;d=k?v(f-d):e;if(o[a+240>>2]){s[a+144>>2]=v(s[a+112>>2]*v(d*v(g*s[a+128>>2])))+s[a+144>>2];s[a+148>>2]=v(v(d*v(h*s[a+132>>2]))*s[a+116>>2])+s[a+148>>2];s[a+152>>2]=v(v(d*v(i*s[a+136>>2]))*s[a+120>>2])+s[a+152>>2];e=s[c+72>>2];f=s[c+68>>2];s[a+160>>2]=v(v(d*s[a+96>>2])*s[c+64>>2])+s[a+160>>2];g=s[a+104>>2];s[a+164>>2]=v(f*v(d*s[a+100>>2]))+s[a+164>>2];s[a+168>>2]=v(e*v(d*g))+s[a+168>>2];}if(!o[b+240>>2]){break a}e=s[c+56>>2];f=s[c+52>>2];s[b+144>>2]=v(s[b+112>>2]*v(d*v(s[c+48>>2]*s[b+128>>2])))+s[b+144>>2];s[b+148>>2]=v(v(d*v(f*s[b+132>>2]))*s[b+116>>2])+s[b+148>>2];s[b+152>>2]=v(v(d*v(e*s[b+136>>2]))*s[b+120>>2])+s[b+152>>2];e=s[c+88>>2];f=s[c+84>>2];s[b+160>>2]=v(v(d*s[b+96>>2])*s[c+80>>2])+s[b+160>>2];g=s[b+104>>2];s[b+164>>2]=v(f*v(d*s[b+100>>2]))+s[b+164>>2];s[b+168>>2]=v(e*v(d*g))+s[b+168>>2];}return v(d)}function hd(a,b){var c=0,d=0;a:{if(p[a+204|0]&2){c=o[a+8>>2];o[a+68>>2]=o[a+4>>2];o[a+72>>2]=c;c=o[a+16>>2];o[a+76>>2]=o[a+12>>2];o[a+80>>2]=c;c=o[a+24>>2];o[a+84>>2]=o[a+20>>2];o[a+88>>2]=c;c=o[a+32>>2];o[a+92>>2]=o[a+28>>2];o[a+96>>2]=c;c=o[a+40>>2];o[a+100>>2]=o[a+36>>2];o[a+104>>2]=c;c=o[a+48>>2];o[a+108>>2]=o[a+44>>2];o[a+112>>2]=c;c=o[a+56>>2];o[a+116>>2]=o[a+52>>2];o[a+120>>2]=c;c=o[a+64>>2];o[a+124>>2]=o[a+60>>2];o[a+128>>2]=c;break a}c=b;d=o[c+4>>2];o[a+68>>2]=o[c>>2];o[a+72>>2]=d;d=o[c+12>>2];o[a+76>>2]=o[c+8>>2];o[a+80>>2]=d;d=o[c+28>>2];o[a+92>>2]=o[c+24>>2];o[a+96>>2]=d;d=o[c+20>>2];o[a+84>>2]=o[c+16>>2];o[a+88>>2]=d;d=o[c+36>>2];o[a+100>>2]=o[c+32>>2];o[a+104>>2]=d;d=o[c+44>>2];o[a+108>>2]=o[c+40>>2];o[a+112>>2]=d;d=o[c+60>>2];o[a+124>>2]=o[c+56>>2];o[a+128>>2]=d;d=o[c+52>>2];o[a+116>>2]=o[c+48>>2];o[a+120>>2]=d;}c=o[a+392>>2];o[a+148>>2]=o[a+388>>2];o[a+152>>2]=c;c=o[a+376>>2];o[a+132>>2]=o[a+372>>2];o[a+136>>2]=c;c=o[a+400>>2];o[a+156>>2]=o[a+396>>2];o[a+160>>2]=c;c=o[a+384>>2];o[a+140>>2]=o[a+380>>2];o[a+144>>2]=c;c=o[b+12>>2];o[a+12>>2]=o[b+8>>2];o[a+16>>2]=c;c=o[b+4>>2];o[a+4>>2]=o[b>>2];o[a+8>>2]=c;c=o[b+28>>2];o[a+28>>2]=o[b+24>>2];o[a+32>>2]=c;c=o[b+20>>2];o[a+20>>2]=o[b+16>>2];o[a+24>>2]=c;c=o[b+44>>2];o[a+44>>2]=o[b+40>>2];o[a+48>>2]=c;c=o[b+36>>2];o[a+36>>2]=o[b+32>>2];o[a+40>>2]=c;c=o[b+60>>2];o[a+60>>2]=o[b+56>>2];o[a+64>>2]=c;c=o[b+52>>2];o[a+52>>2]=o[b+48>>2];o[a+56>>2]=c;jd(a);}function Nu(a,b,c,d){var e=v(0),f=v(0),g=0,h=v(0),i=0,j=v(0),k=v(0),l=0,m=0,r=0,t=0,u=0,w=0;a:{if(p[a+60|0]){k=s[a+12>>2];f=s[a+44>>2];e=v(v(s[c+8>>2]-k)*f);b:{if(e<v(4294967296)&e>=v(0)){l=~~e>>>0;break b}l=0;}h=s[a+8>>2];e=s[a+40>>2];j=v(v(s[c+4>>2]-h)*e);c:{if(j<v(4294967296)&j>=v(0)){m=~~j>>>0;break c}m=0;}f=v(v(f*v(s[d+8>>2]-k))+v(1));d:{if(f<v(4294967296)&f>=v(0)){r=~~f>>>0;break d}r=0;}e=v(v(e*v(s[d+4>>2]-h))+v(1));e:{if(e<v(4294967296)&e>=v(0)){g=~~e>>>0;break e}g=0;}i=o[a+136>>2];t=i+(b<<4)|0;w=q[t>>1];h=s[a+4>>2];e=s[a+36>>2];f=v(v(s[c>>2]-h)*e);f:{if(f<v(4294967296)&f>=v(0)){a=~~f>>>0;break f}a=0;}u=a&65534;c=w>>>0<=u>>>0;e=v(v(e*v(s[d>>2]-h))+v(1));g:{if(e<v(4294967296)&e>=v(0)){a=~~e>>>0;break g}a=0;}if(!c){n[t>>1]=u;}c=i+(b<<4)|0;a=a|1;if(q[c+6>>1]<a>>>0){n[c+6>>1]=a;}a=m&65534;if(q[c+2>>1]>a>>>0){n[c+2>>1]=a;}d=i+(b<<4)|0;c=d;a=g|1;if(q[c+8>>1]<a>>>0){n[c+8>>1]=a;}a=l&65534;if(q[d+4>>1]>a>>>0){n[d+4>>1]=a;}b=i+(b<<4)|0;a=r|1;if(q[b+10>>1]>=a>>>0){break a}n[b+10>>1]=a;return}e=s[c>>2];g=o[a+96>>2];a=g+(b<<6)|0;if(!!(e<s[a>>2])){s[a>>2]=e;}e=s[c+4>>2];if(!!(e<s[a+4>>2])){s[a+4>>2]=e;}e=s[c+8>>2];a=g+(b<<6)|0;if(!!(e<s[a+8>>2])){s[a+8>>2]=e;}e=s[c+12>>2];if(!!(e<s[a+12>>2])){s[a+12>>2]=e;}a=g+(b<<6)|0;e=s[d>>2];if(!!(s[a+16>>2]<e)){s[a+16>>2]=e;}e=s[d+4>>2];if(!!(s[a+20>>2]<e)){s[a+20>>2]=e;}b=g+(b<<6)|0;a=b;e=s[d+8>>2];if(!!(s[a+24>>2]<e)){s[a+24>>2]=e;}e=s[d+12>>2];if(!(s[b+28>>2]<e)){break a}s[b+28>>2]=e;}}function jn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0;sf(a,o[a+28>>2]+4|0,o[a+32>>2]+4|0);o[b>>2]=0;o[b+4>>2]=0;a:{b:{c:{c=o[a+956>>2];if(c>>>0>4){break c}d=2;switch(c-1|0){case 3:break b;case 0:case 1:case 2:break c;default:break a}}d=1;}o[b>>2]=d;c=d;}if(p[a+792|0]){c=c+1|0;o[b>>2]=c;}if(p[a+798|0]){c=c+1|0;o[b>>2]=c;}e=b;d:{e:{f:{d=o[a+960>>2];if(d>>>0>4){break f}g:{switch(d-1|0){case 0:case 1:case 2:break f;case 3:break g;default:break d}}c=c+2|0;break e}c=c+1|0;}o[e>>2]=c;}if(p[a+793|0]){c=c+1|0;o[b>>2]=c;}if(p[a+799|0]){c=c+1|0;o[b>>2]=c;}e=b;h:{i:{j:{d=o[a+964>>2];if(d>>>0>4){break j}k:{switch(d-1|0){case 0:case 1:case 2:break j;case 3:break k;default:break h}}c=c+2|0;break i}c=c+1|0;}o[e>>2]=c;}if(p[a+794|0]){c=c+1|0;o[b>>2]=c;}if(p[a+800|0]){o[b>>2]=c+1;}ed(a,0);l:{m:{n:{d=o[a+1052>>2];if(d>>>0>4){break n}c=2;switch(d-1|0){case 3:break m;case 0:case 1:case 2:break n;default:break l}}c=1;}o[b>>2]=o[b>>2]+c;}if(p[a+996|0]){o[b>>2]=o[b>>2]+1;}if(p[a+1016|0]){o[b>>2]=o[b>>2]+1;}ed(a,1);o:{p:{q:{d=o[a+1140>>2];if(d>>>0>4){break q}c=2;switch(d-1|0){case 3:break p;case 0:case 1:case 2:break q;default:break o}}c=1;}o[b>>2]=o[b>>2]+c;}if(p[a+1084|0]){o[b>>2]=o[b>>2]+1;}if(p[a+1104|0]){o[b>>2]=o[b>>2]+1;}c=2;ed(a,2);r:{s:{t:{d=o[a+1228>>2];if(d>>>0>4){break t}switch(d-1|0){case 3:break s;case 0:case 1:case 2:break t;default:break r}}c=1;}o[b>>2]=o[b>>2]+c;}if(p[a+1172|0]){o[b>>2]=o[b>>2]+1;}if(p[a+1192|0]){o[b>>2]=o[b>>2]+1;}}function Vi(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;f=o[a+4>>2];a:{if((f|0)!=o[a+8>>2]){break a}g=f?f<<1:1;if((f|0)>=(g|0)){break a}if(g){o[6257]=o[6257]+1;i=l[o[4968]](u(g,80),16)|0;f=o[a+4>>2];}if((f|0)>=1){while(1){c=u(h,80);d=c+i|0;c=c+o[a+12>>2]|0;e=o[c+4>>2];o[d>>2]=o[c>>2];o[d+4>>2]=e;e=o[c+12>>2];o[d+8>>2]=o[c+8>>2];o[d+12>>2]=e;e=o[c+28>>2];o[d+24>>2]=o[c+24>>2];o[d+28>>2]=e;e=o[c+20>>2];o[d+16>>2]=o[c+16>>2];o[d+20>>2]=e;e=o[c+44>>2];o[d+40>>2]=o[c+40>>2];o[d+44>>2]=e;e=o[c+36>>2];o[d+32>>2]=o[c+32>>2];o[d+36>>2]=e;e=o[c+60>>2];o[d+56>>2]=o[c+56>>2];o[d+60>>2]=e;e=o[c+52>>2];o[d+48>>2]=o[c+48>>2];o[d+52>>2]=e;e=o[c+68>>2];o[d+64>>2]=o[c+64>>2];o[d+68>>2]=e;e=o[c+76>>2];o[d+72>>2]=o[c+72>>2];o[d+76>>2]=e;h=h+1|0;if((h|0)!=(f|0)){continue}break}}c=o[a+12>>2];if(c){if(p[a+16|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+12>>2]=0;}o[a+12>>2]=i;m[a+16|0]=1;o[a+8>>2]=g;f=o[a+4>>2];}c=o[a+12>>2]+u(f,80)|0;f=o[b+4>>2];o[c>>2]=o[b>>2];o[c+4>>2]=f;d=o[b+12>>2];o[c+8>>2]=o[b+8>>2];o[c+12>>2]=d;d=o[b+28>>2];o[c+24>>2]=o[b+24>>2];o[c+28>>2]=d;d=o[b+20>>2];o[c+16>>2]=o[b+16>>2];o[c+20>>2]=d;d=o[b+44>>2];o[c+40>>2]=o[b+40>>2];o[c+44>>2]=d;d=o[b+36>>2];o[c+32>>2]=o[b+32>>2];o[c+36>>2]=d;d=o[b+60>>2];o[c+56>>2]=o[b+56>>2];o[c+60>>2]=d;d=o[b+52>>2];o[c+48>>2]=o[b+48>>2];o[c+52>>2]=d;d=o[b+76>>2];o[c+72>>2]=o[b+72>>2];o[c+76>>2]=d;d=o[b+68>>2];o[c+64>>2]=o[b+64>>2];o[c+68>>2]=d;o[a+4>>2]=o[a+4>>2]+1;}function Yf(a,b){var c=0;c=K-112|0;K=c;o[c+108>>2]=a;o[c+104>>2]=b;a=o[c+108>>2];s[c+100>>2]=Co(o[c+104>>2]);s[c+96>>2]=v(2)/s[c+100>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+92>>2]=s[o[b+12>>2]>>2]*s[c+96>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+88>>2]=s[o[b+12>>2]+4>>2]*s[c+96>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+84>>2]=s[o[b+12>>2]+8>>2]*s[c+96>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+80>>2]=s[o[b+12>>2]+12>>2]*s[c+92>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+76>>2]=s[o[b+12>>2]+12>>2]*s[c+88>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+72>>2]=s[o[b+12>>2]+12>>2]*s[c+84>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+68>>2]=s[o[b+12>>2]>>2]*s[c+92>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+64>>2]=s[o[b+12>>2]>>2]*s[c+88>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+60>>2]=s[o[b+12>>2]>>2]*s[c+84>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+56>>2]=s[o[b+12>>2]+4>>2]*s[c+88>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+52>>2]=s[o[b+12>>2]+4>>2]*s[c+84>>2];b=K-16|0;o[b+12>>2]=o[c+104>>2];s[c+48>>2]=s[o[b+12>>2]+8>>2]*s[c+84>>2];s[c+44>>2]=v(1)-v(s[c+56>>2]+s[c+48>>2]);s[c+40>>2]=s[c+64>>2]-s[c+72>>2];s[c+36>>2]=s[c+60>>2]+s[c+76>>2];s[c+32>>2]=s[c+64>>2]+s[c+72>>2];s[c+28>>2]=v(1)-v(s[c+68>>2]+s[c+48>>2]);s[c+24>>2]=s[c+52>>2]-s[c+80>>2];s[c+20>>2]=s[c+60>>2]-s[c+76>>2];s[c+16>>2]=s[c+52>>2]+s[c+80>>2];s[c+12>>2]=v(1)-v(s[c+68>>2]+s[c+56>>2]);cb(a,c+44|0,c+40|0,c+36|0,c+32|0,c+28|0,c+24|0,c+20|0,c+16|0,c+12|0);K=c+112|0;}function ak(a,b){a=a|0;b=b|0;var c=0,d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=0,n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=0,E=v(0),F=v(0),G=v(0);c=K-128|0;K=c;m=o[b+36>>2];b=o[o[a+8>>2]+28>>2]+u(m,80)|0;D=o[b+64>>2];n=s[b+32>>2];p=s[b>>2];q=s[b+16>>2];r=s[b+56>>2];t=s[b+52>>2];w=s[b+48>>2];x=s[b+36>>2];y=s[b+20>>2];z=s[b+4>>2];A=s[b+40>>2];B=s[b+24>>2];C=s[b+8>>2];b=o[a+12>>2];E=s[b+52>>2];F=s[b+56>>2];d=s[b+24>>2];e=s[b+20>>2];f=s[b+40>>2];g=s[b+36>>2];G=s[b+48>>2];h=s[b+8>>2];i=s[b>>2];j=s[b+4>>2];k=s[b+16>>2];l=s[b+32>>2];o[c+124>>2]=0;o[c+108>>2]=0;o[c+92>>2]=0;s[c+104>>2]=v(v(C*l)+v(B*g))+v(A*f);s[c+100>>2]=v(v(z*l)+v(y*g))+v(x*f);s[c+88>>2]=v(v(C*k)+v(B*e))+v(A*d);s[c+84>>2]=v(v(z*k)+v(y*e))+v(x*d);s[c+120>>2]=F+v(v(v(l*w)+v(g*t))+v(f*r));s[c+116>>2]=E+v(v(v(k*w)+v(e*t))+v(d*r));o[c+76>>2]=0;s[c+72>>2]=v(v(i*C)+v(j*B))+v(h*A);s[c+68>>2]=v(v(i*z)+v(j*y))+v(h*x);s[c+64>>2]=v(v(p*i)+v(q*j))+v(n*h);s[c+112>>2]=G+v(v(v(i*w)+v(j*t))+v(h*r));s[c+96>>2]=v(v(p*l)+v(q*g))+v(n*f);s[c+80>>2]=v(v(p*k)+v(q*e))+v(n*d);b=o[a+4>>2];o[c+60>>2]=m;o[c+56>>2]=-1;o[c+48>>2]=b;o[c+44>>2]=D;o[c+40>>2]=0;o[c+52>>2]=c- -64;b=o[a+24>>2];o[c+20>>2]=-65535;o[c+24>>2]=0;o[c+12>>2]=1065353216;o[c+16>>2]=0;o[c+32>>2]=m;o[c+28>>2]=b;o[c+8>>2]=8340;o[c+12>>2]=o[b+4>>2];o[c+24>>2]=o[b+16>>2];Db(o[a+16>>2],o[a+20>>2],c+40|0,c+8|0);K=c+128|0;}function Cm(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0);g=s[c+100>>2];h=s[c+16>>2];i=s[c+20>>2];j=s[c+24>>2];e=s[c+108>>2];d=v(v(v(s[c+112>>2]-v(g*s[c+116>>2]))-v(v(v(v(v(h*s[a+64>>2])+v(i*s[a+68>>2]))+v(j*s[a+72>>2]))+v(v(v(s[c>>2]*s[a+80>>2])+v(s[c+4>>2]*s[a+84>>2]))+v(s[c+8>>2]*s[a+88>>2])))*e))-v(e*v(v(v(v(s[c+48>>2]*s[b+64>>2])+v(s[c+52>>2]*s[b+68>>2]))+v(s[c+56>>2]*s[b+72>>2]))+v(v(v(s[c+32>>2]*s[b+80>>2])+v(s[c+36>>2]*s[b+84>>2]))+v(s[c+40>>2]*s[b+88>>2])))));e=v(g+d);f=s[c+120>>2];a:{if(!!(e<f)){d=v(f-g);e=f;break a}f=s[c+124>>2];if(!(e>f)){break a}d=v(f-g);e=f;}s[c+100>>2]=e;if(o[a+240>>2]){s[a+64>>2]=v(s[a+112>>2]*v(d*v(h*s[a+128>>2])))+s[a+64>>2];s[a+68>>2]=v(v(d*v(i*s[a+132>>2]))*s[a+116>>2])+s[a+68>>2];s[a+72>>2]=v(v(d*v(j*s[a+136>>2]))*s[a+120>>2])+s[a+72>>2];e=s[c+72>>2];f=s[c+68>>2];s[a+80>>2]=v(v(d*s[a+96>>2])*s[c+64>>2])+s[a+80>>2];g=s[a+104>>2];s[a+84>>2]=v(f*v(d*s[a+100>>2]))+s[a+84>>2];s[a+88>>2]=v(e*v(d*g))+s[a+88>>2];}if(o[b+240>>2]){e=s[c+56>>2];f=s[c+52>>2];s[b+64>>2]=v(s[b+112>>2]*v(d*v(s[c+48>>2]*s[b+128>>2])))+s[b+64>>2];s[b+68>>2]=v(v(d*v(f*s[b+132>>2]))*s[b+116>>2])+s[b+68>>2];s[b+72>>2]=v(v(d*v(e*s[b+136>>2]))*s[b+120>>2])+s[b+72>>2];e=s[c+88>>2];f=s[c+84>>2];s[b+80>>2]=v(v(d*s[b+96>>2])*s[c+80>>2])+s[b+80>>2];g=s[b+104>>2];s[b+84>>2]=v(f*v(d*s[b+100>>2]))+s[b+84>>2];s[b+88>>2]=v(e*v(d*g))+s[b+88>>2];}return v(d)}function Gc(a,b,c,d){var e=v(0),f=0,g=0,h=0,i=0,j=0,k=v(0),l=0,m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=0,w=0,x=v(0),y=v(0),z=v(0);j=K-32|0;K=j;g=o[a+12>>2];h=g+u((c+d|0)/2|0,24)|0;t=o[h+20>>2];n=s[h+16>>2];x=s[h+8>>2];y=s[h+4>>2];z=s[h>>2];h=c;l=d;while(1){p=s[b>>2];k=v(z-p);e=v(k*k);q=s[b+4>>2];k=v(y-q);e=v(e+v(k*k));r=s[b+8>>2];k=v(x-r);k=v(e+v(k*k));while(1){a:{f=u(h,24)+g|0;e=s[f+16>>2];b:{if(e!=n){if(e<n){break b}break a}e=v(s[f>>2]-p);m=v(e*e);e=v(s[f+4>>2]-q);m=v(m+v(e*e));e=v(s[f+8>>2]-r);e=v(m+v(e*e));if(((e!=k?e<k:o[f+20>>2]<(t|0))|0)!=1){break a}}h=h+1|0;continue}break}while(1){c:{w=u(l,24);i=w+g|0;e=s[i+16>>2];d:{if(n!=e){if(n<e){break d}break c}e=v(s[i>>2]-p);m=v(e*e);e=v(s[i+4>>2]-q);m=v(m+v(e*e));e=v(s[i+8>>2]-r);e=v(m+v(e*e));if(((k!=e?k<e:(t|0)<o[i+20>>2])|0)!=1){break c}}l=l+ -1|0;continue}break}if((h|0)<=(l|0)){g=o[f+20>>2];o[j+24>>2]=o[f+16>>2];o[j+28>>2]=g;g=o[f+12>>2];o[j+16>>2]=o[f+8>>2];o[j+20>>2]=g;g=o[f+4>>2];o[j+8>>2]=o[f>>2];o[j+12>>2]=g;g=o[i+4>>2];o[f>>2]=o[i>>2];o[f+4>>2]=g;g=o[i+12>>2];o[f+8>>2]=o[i+8>>2];o[f+12>>2]=g;g=o[i+20>>2];o[f+16>>2]=o[i+16>>2];o[f+20>>2]=g;g=o[j+12>>2];f=o[a+12>>2]+w|0;o[f>>2]=o[j+8>>2];o[f+4>>2]=g;i=o[j+28>>2];o[f+16>>2]=o[j+24>>2];o[f+20>>2]=i;i=o[j+20>>2];o[f+8>>2]=o[j+16>>2];o[f+12>>2]=i;l=l+ -1|0;h=h+1|0;}if((h|0)<=(l|0)){g=o[a+12>>2];continue}break}if((l|0)>(c|0)){Gc(a,b,c,l);}if((h|0)<(d|0)){Gc(a,b,h,d);}K=j+32|0;}function Uk(a,b,c,d,e,f){var g=0,h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0);g=K+ -64|0;K=g;s[a+56>>2]=b;o[a+52>>2]=c;o[a+40>>2]=e;o[a+36>>2]=d;o[a+44>>2]=f;c=o[e+12>>2];h=s[c+52>>2];u=s[c+56>>2];e=o[d+12>>2];w=s[e+52>>2];x=s[e+56>>2];i=s[c+20>>2];j=s[c+36>>2];y=s[e+20>>2];z=s[e+36>>2];A=s[e+24>>2];k=s[c+24>>2];B=s[e+40>>2];m=s[c+40>>2];C=s[e+32>>2];n=s[c+32>>2];D=s[e>>2];p=s[c>>2];E=s[e+16>>2];q=s[c+16>>2];F=s[c+48>>2];G=s[e+48>>2];r=s[c+4>>2];H=s[e+4>>2];I=s[e+8>>2];t=s[c+8>>2];o[g+60>>2]=0;o[g+44>>2]=0;o[g+28>>2]=0;s[g+40>>2]=v(v(t*I)+v(k*A))+v(m*B);s[g+36>>2]=v(v(t*H)+v(k*y))+v(m*z);s[g+24>>2]=v(v(r*I)+v(i*A))+v(j*B);s[g+20>>2]=v(v(r*H)+v(i*y))+v(j*z);h=v(-h);s[g+56>>2]=v(v(v(k*h)-v(t*F))-v(m*u))+v(v(v(t*G)+v(k*w))+v(m*x));s[g+52>>2]=v(v(v(i*h)-v(r*F))-v(j*u))+v(v(v(r*G)+v(i*w))+v(j*x));o[g+12>>2]=0;s[g>>2]=v(v(p*D)+v(q*E))+v(n*C);s[g+32>>2]=v(v(t*D)+v(k*E))+v(m*C);s[g+16>>2]=v(v(r*D)+v(i*E))+v(j*C);s[g+8>>2]=v(v(p*I)+v(q*A))+v(n*B);s[g+4>>2]=v(v(p*H)+v(q*y))+v(n*z);s[g+48>>2]=v(v(v(q*h)-v(p*F))-v(n*u))+v(v(v(p*G)+v(q*w))+v(n*x));c=o[d+4>>2];l[o[o[c>>2]+8>>2]](c,g,a+4|0,a+20|0);b=v(s[f+32>>2]+b);s[a+20>>2]=b+s[a+20>>2];s[a+24>>2]=b+s[a+24>>2];s[a+28>>2]=b+s[a+28>>2];s[a+4>>2]=s[a+4>>2]-b;s[a+8>>2]=s[a+8>>2]-b;s[a+12>>2]=s[a+12>>2]-b;K=g- -64|0;}function bi(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=v(0),m=v(0),n=v(0),r=v(0),w=0,x=0,y=0,z=0;f=K-32|0;K=f;o[a+60>>2]=o[a+60>>2]+1;h=o[a+4>>2];l[o[o[h>>2]+16>>2]](h,f+28|0,f+24|0,f+20|0,f+16|0,f+12|0,f+8|0,f+4|0,f,b);j=o[f+12>>2]+u(o[f+8>>2],c)|0;x=o[f+20>>2];g=o[a+4>>2];h=g+12|0;i=o[f+28>>2];e=i;y=o[f>>2];d=y+ -2|0;a:{if(d>>>0<=1){w=q[j+4>>1];if(!(d-1)){break a}w=o[j+8>>2];break a}w=p[j+2|0];}z=o[f+16>>2];d=e+u(w,z)|0;b:{if(!x){k=v(s[d+4>>2]*s[g+8>>2]);m=v(s[d>>2]*s[g+4>>2]);n=s[g+12>>2];e=d+8|0;break b}k=v(s[g+8>>2]*v(t[d+8>>3]));m=v(s[g+4>>2]*v(t[d>>3]));n=v(t[d+16>>3]);e=h;}r=s[e>>2];o[a+56>>2]=0;s[a+48>>2]=k;s[a+44>>2]=m;s[a+52>>2]=r*n;d=y+ -2|0;c:{if(d>>>0<=1){e=o[j+4>>2];if(d-1){break c}e=q[j+2>>1];break c}e=p[j+1|0];}d=u(e,z)+i|0;d:{if(x){k=v(s[g+8>>2]*v(t[d+8>>3]));m=v(s[g+4>>2]*v(t[d>>3]));n=v(t[d+16>>3]);e=h;break d}k=v(s[d+4>>2]*s[g+8>>2]);m=v(s[d>>2]*s[g+4>>2]);n=s[g+12>>2];e=d+8|0;}r=s[e>>2];o[a+40>>2]=0;s[a+32>>2]=k;s[a+28>>2]=m;s[a+36>>2]=r*n;d=y+ -2|0;e:{if(d>>>0<=1){e=o[j>>2];if(d-1){break e}e=q[j>>1];break e}e=p[j|0];}i=u(e,z)+i|0;f:{if(x){n=v(t[i+16>>3]);k=v(s[g+8>>2]*v(t[i+8>>3]));m=v(s[g+4>>2]*v(t[i>>3]));break f}h=i+8|0;n=s[g+12>>2];k=v(s[i+4>>2]*s[g+8>>2]);m=v(s[i>>2]*s[g+4>>2]);}r=s[h>>2];o[a+24>>2]=0;s[a+16>>2]=k;s[a+12>>2]=m;s[a+20>>2]=r*n;h=o[a+8>>2];l[o[o[h>>2]+8>>2]](h,a+12|0,b,c);a=o[a+4>>2];l[o[o[a>>2]+24>>2]](a,b);K=f+32|0;}function Yj(a,b){a=a|0;b=b|0;var c=0,d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=0,n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=0,E=v(0),F=v(0),G=v(0),H=0;c=K-112|0;K=c;m=o[b+36>>2];b=o[o[a+24>>2]+28>>2]+u(m,80)|0;D=o[b+64>>2];n=s[b+32>>2];p=s[b>>2];q=s[b+16>>2];r=s[b+56>>2];t=s[b+52>>2];w=s[b+48>>2];x=s[b+36>>2];y=s[b+20>>2];z=s[b+4>>2];A=s[b+40>>2];B=s[b+24>>2];C=s[b+8>>2];b=o[a+28>>2];E=s[b+52>>2];F=s[b+56>>2];d=s[b+24>>2];e=s[b+20>>2];f=s[b+40>>2];g=s[b+36>>2];G=s[b+48>>2];h=s[b+8>>2];i=s[b>>2];j=s[b+4>>2];k=s[b+16>>2];l=s[b+32>>2];o[c+108>>2]=0;o[c+92>>2]=0;o[c+76>>2]=0;s[c+88>>2]=v(v(C*l)+v(B*g))+v(A*f);s[c+84>>2]=v(v(z*l)+v(y*g))+v(x*f);s[c+72>>2]=v(v(C*k)+v(B*e))+v(A*d);s[c+68>>2]=v(v(z*k)+v(y*e))+v(x*d);s[c+104>>2]=F+v(v(v(w*l)+v(t*g))+v(r*f));s[c+100>>2]=E+v(v(v(w*k)+v(t*e))+v(r*d));o[c+60>>2]=0;s[c+56>>2]=v(v(C*i)+v(B*j))+v(A*h);s[c+52>>2]=v(v(z*i)+v(y*j))+v(x*h);s[c+48>>2]=v(v(p*i)+v(q*j))+v(n*h);s[c+96>>2]=G+v(v(v(w*i)+v(t*j))+v(r*h));s[c+80>>2]=v(v(p*l)+v(q*g))+v(n*f);s[c+64>>2]=v(v(p*k)+v(q*e))+v(n*d);b=o[a+32>>2];o[c+36>>2]=-1;o[c+28>>2]=1065353216;o[c+32>>2]=1;o[c+44>>2]=m;o[c+40>>2]=b;o[c+24>>2]=9156;o[c+28>>2]=o[b+4>>2];b=o[a+4>>2];H=o[b+8>>2];o[c+20>>2]=m;o[c+16>>2]=-1;o[c+8>>2]=H;o[c+4>>2]=D;o[c>>2]=b;o[c+12>>2]=c+48;Qc(o[a+8>>2],o[a+12>>2],o[a+16>>2],c,c+24|0,s[a+20>>2]);K=c+112|0;}function Nc(a,b,c,d,e,f,g,h,i,j,k){var l=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),D=v(0);h=(h<<2)+j|0;t=s[h>>2];u=v(s[j+48>>2]-s[i+48>>2]);z=s[h+16>>2];A=v(s[j+52>>2]-s[i+52>>2]);B=s[h+32>>2];D=v(s[j+56>>2]-s[i+56>>2]);n=v(v(v(t*u)+v(z*A))+v(B*D));g=(g<<2)+i|0;x=s[g>>2];p=s[g+16>>2];r=s[g+32>>2];y=v(v(v(x*u)+v(p*A))+v(r*D));q=v(v(v(x*t)+v(p*z))+v(r*B));m=v(v(1)-v(q*q));a:{if(m==v(0)){break a}m=v(v(y-v(q*n))/m);l=v(-c);if(m<l){break a}l=m;if(!(l>c)){break a}l=c;}m=v(v(q*l)-n);n=v(-e);b:{c:{if(!!(m<n)){e=v(y-v(q*e));l=v(-c);if(e<l){m=n;break b}if(!(e>c)){m=n;l=e;break b}e=n;break c}if(!(m>e)){break b}n=v(v(q*e)+y);l=v(-c);if(n<l){m=e;break b}if(!(n>c)){m=e;l=n;break b}}m=e;l=c;}n=v(B*m);c=v(n+v(D-v(r*l)));q=v(t*m);e=v(q+v(u-v(x*l)));m=v(z*m);l=v(m+v(A-v(p*l)));y=v(v(c*c)+v(v(e*e)+v(l*l)));t=v(C(y));u=v(v(t-d)-f);if(!(u>k)){d:{if(!!(y<=v(1.4210854715202004e-14))){if(!!(v(w(r))>v(.7071067690849304))){o[a>>2]=0;d=v(v(1)/v(C(v(v(p*p)+v(r*r)))));c=v(p*d);s[a+8>>2]=c;l=v(d*v(-r));s[a+4>>2]=l;d=v(0);break d}o[a+8>>2]=0;c=v(v(1)/v(C(v(v(x*x)+v(p*p)))));l=v(x*c);s[a+4>>2]=l;d=v(c*v(-p));s[a>>2]=d;c=v(0);break d}o[a+12>>2]=0;d=v(v(-1)/t);c=v(c*d);s[a+8>>2]=c;l=v(l*d);s[a+4>>2]=l;d=v(e*d);s[a>>2]=d;}e=s[j+48>>2];k=s[j+52>>2];p=s[j+56>>2];o[b+12>>2]=0;s[b+8>>2]=v(n+p)+v(c*f);s[b+4>>2]=v(m+k)+v(l*f);s[b>>2]=v(q+e)+v(d*f);}return u}function Pu(a,b,c){var d=0,e=0,f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=0,y=v(0),z=v(0),A=0,B=v(0);x=c-b|0;a:{if((c|0)<=(b|0)){l=v(x|0);break a}A=p[a+60|0];d=b;while(1){b:{if(A){e=o[a+116>>2]+(d<<4)|0;j=s[a+44>>2];k=s[a+12>>2];f=v(v(v(q[e+4>>1])/j)+k);l=s[a+40>>2];m=s[a+8>>2];r=v(v(v(q[e+2>>1])/l)+m);u=s[a+36>>2];w=s[a+4>>2];t=v(v(v(q[e>>1])/u)+w);j=v(v(v(q[e+10>>1])/j)+k);k=v(v(v(q[e+8>>1])/l)+m);l=v(v(v(q[e+6>>1])/u)+w);break b}e=o[a+76>>2]+(d<<6)|0;f=s[e+8>>2];r=s[e+4>>2];t=s[e>>2];j=s[e+24>>2];k=s[e+20>>2];l=s[e+16>>2];}g=v(g+v(v(j+f)*v(.5)));h=v(h+v(v(k+r)*v(.5)));i=v(i+v(v(l+t)*v(.5)));d=d+1|0;if((d|0)!=(c|0)){continue}break}l=v(x|0);f=v(v(1)/l);u=v(f*g);w=v(f*h);B=v(f*i);i=v(0);e=p[a+60|0];h=v(0);g=v(0);while(1){c:{if(e){d=o[a+116>>2]+(b<<4)|0;j=s[a+44>>2];k=s[a+12>>2];f=v(v(v(q[d+4>>1])/j)+k);m=s[a+40>>2];n=s[a+8>>2];r=v(v(v(q[d+2>>1])/m)+n);y=s[a+36>>2];z=s[a+4>>2];t=v(v(v(q[d>>1])/y)+z);j=v(v(v(q[d+10>>1])/j)+k);k=v(v(v(q[d+8>>1])/m)+n);m=v(v(v(q[d+6>>1])/y)+z);break c}d=o[a+76>>2]+(b<<6)|0;f=s[d+8>>2];r=s[d+4>>2];t=s[d>>2];j=s[d+24>>2];k=s[d+20>>2];m=s[d+16>>2];}n=i;i=v(v(v(j+f)*v(.5))-u);i=v(n+v(i*i));n=h;h=v(v(v(k+r)*v(.5))-w);h=v(n+v(h*h));n=g;g=v(v(v(m+t)*v(.5))-B);g=v(n+v(g*g));b=b+1|0;if((c|0)!=(b|0)){continue}break}}f=v(v(1)/v(l+v(-1)));h=v(f*h);i=v(f*i);g=v(f*g);return g<h?h<i?2:1:(g<i)<<1}function lv(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;c=K-32|0;K=c;o[c+20>>2]=0;o[c+12>>2]=0;o[c+16>>2]=0;m[c+24|0]=1;a:{if(o[a+8>>2]<1){break a}while(1){f=o[a+16>>2]+(k<<4)|0;b:{if((d|0)!=(e|0)){break b}e=d?d<<1:1;if((d|0)>=(e|0)){e=d;break b}i=0;g=0;if(e){o[6257]=o[6257]+1;g=l[o[4968]](e<<4,16)|0;}if((d|0)>=1){while(1){h=i<<4;j=h+g|0;h=h+o[c+20>>2]|0;o[j>>2]=o[h>>2];o[j+4>>2]=o[h+4>>2];o[j+8>>2]=o[h+8>>2];o[j+12>>2]=o[h+12>>2];i=i+1|0;if((i|0)!=(d|0)){continue}break}}d=o[c+20>>2];if(d){if(p[c+24|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[c+20>>2]=0;}o[c+20>>2]=g;m[c+24|0]=1;o[c+16>>2]=e;e=o[c+12>>2];}d=o[c+20>>2]+(e<<4)|0;o[d>>2]=o[f>>2];o[d+4>>2]=o[f+4>>2];o[d+8>>2]=o[f+8>>2];o[d+12>>2]=o[f+12>>2];f=o[c+12>>2];e=f+1|0;o[c+12>>2]=e;k=k+1|0;if((k|0)<o[a+8>>2]){d=o[c+16>>2];continue}break}d=0;if((f|0)<0){break a}i=o[c+20>>2];while(1){g=i+(d<<4)|0;l[o[o[a>>2]+12>>2]](a,o[g>>2],o[g+4>>2],b)|0;g=(d|0)==(f|0);d=d+1|0;if(!g){continue}break}}if(o[a+52>>2]>=1){b=o[a+60>>2];e=0;while(1){o[b+(e<<2)>>2]=-1;e=e+1|0;if((e|0)<o[a+52>>2]){continue}break}e=o[c+12>>2];}if((e|0)>=2){Cc(c+8|0,c,0,e+ -1|0);e=o[c+12>>2];}d=o[c+20>>2];if((e|0)>=1){e=0;while(1){b=(e<<4)+d|0;l[o[o[a>>2]+8>>2]](a,o[b>>2],o[b+4>>2])|0;d=o[c+20>>2];e=e+1|0;if((e|0)<o[c+12>>2]){continue}break}}if(d){if(p[c+24|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[c+20>>2]=0;}K=c+32|0;}function Vg(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;f=K-32|0;K=f;a:{b=(b|0)<=-1?o[a+12>>2]:b;if((b|0)<1){break a}d=o[a>>2];if(!d){break a}while(1){j=0;g=d+40|0;if(o[g>>2]){while(1){e=o[d+32>>2];b:{if(e>>>0<=d>>>0){e=d;break b}c=o[e+40>>2];h=(c|0)==(d|0);k=((d|0)!=(c|0))<<2;l=o[(k+e|0)+36>>2];c=o[e+32>>2];i=a;c:{if(!c){break c}i=(c+((o[c+40>>2]==(e|0))<<2)|0)+36|0;}o[i>>2]=d;o[l+32>>2]=d;o[e+32>>2]=d;o[d+32>>2]=c;o[e+36>>2]=o[d+36>>2];o[e+40>>2]=o[g>>2];o[o[d+36>>2]+32>>2]=e;o[o[g>>2]+32>>2]=e;c=d+36|0;o[c+(h<<2)>>2]=e;o[c+k>>2]=l;c=e+24|0;g=o[c+4>>2];o[f+24>>2]=o[c>>2];o[f+28>>2]=g;c=e+16|0;g=o[c+4>>2];o[f+16>>2]=o[c>>2];o[f+20>>2]=g;c=e+8|0;g=o[c+4>>2];o[f+8>>2]=o[c>>2];o[f+12>>2]=g;c=o[e+4>>2];o[f>>2]=o[e>>2];o[f+4>>2]=c;c=d+24|0;g=o[c+4>>2];o[e+24>>2]=o[c>>2];o[e+28>>2]=g;c=d+16|0;g=o[c+4>>2];o[e+16>>2]=o[c>>2];o[e+20>>2]=g;c=d+8|0;g=o[c+4>>2];o[e+8>>2]=o[c>>2];o[e+12>>2]=g;c=o[d+4>>2];o[e>>2]=o[d>>2];o[e+4>>2]=c;c=o[f+28>>2];o[d+24>>2]=o[f+24>>2];o[d+28>>2]=c;c=o[f+20>>2];o[d+16>>2]=o[f+16>>2];o[d+20>>2]=c;c=o[f+12>>2];o[d+8>>2]=o[f+8>>2];o[d+12>>2]=c;c=o[f+4>>2];o[d>>2]=o[f>>2];o[d+4>>2]=c;}d=o[a+16>>2]>>>j|0;j=j+1&31;d=o[(((d&1)<<2)+e|0)+36>>2];g=d+40|0;if(o[g>>2]){continue}break}}e=a;i=e;h=0;d:{if(!yc(e,d)){break d}h=o[a>>2];}xc(i,h,d);o[a+16>>2]=o[a+16>>2]+1;b=b+ -1|0;if(!b){break a}d=o[a>>2];continue}}K=f+32|0;}function Hd(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=K-16|0;K=i;e=c-b|0;a:{if(e>>>0<=2){b:{switch(e-1|0){default:o[d>>2]=0;o[d+4>>2]=0;o[d+8>>2]=0;o[d+12>>2]=0;break a;case 1:e=o[o[a+92>>2]+(b<<2)>>2];b=o[e+204>>2];c:{h=o[e+88>>2];g=o[e+200>>2];f=o[e+92>>2];if(!((h|0)!=(g|0)|(f|0)!=(b|0))){b=f;if(o[e+96>>2]==o[e+208>>2]){break c}}c=e+112|0;b=f-b|0;f=h-g|0;d:{if(!(b|f)){f=o[e+96>>2]>o[e+208>>2];b=f?c:e;o[b+4>>2]=b;o[b>>2]=b;o[d+8>>2]=b;o[d+4>>2]=b;o[d>>2]=b;c=f?e:c;e=b;break d}o[e+4>>2]=c;o[e>>2]=c;o[e+116>>2]=e;o[e+112>>2]=e;h=(b|0)<0;g=h&!f;f=(f|0)<0;g=g|f;o[d+4>>2]=g?c:e;o[d>>2]=g?e:c;if(!(f&!b?0:!h)){o[d+8>>2]=e;b=c;break d}o[d+8>>2]=c;b=e;}o[d+12>>2]=b;a=Id(a,e,c);o[a+4>>2]=a;o[a>>2]=a;o[e+8>>2]=a;a=o[a+8>>2];o[a+4>>2]=a;o[a>>2]=a;o[c+8>>2]=a;break a}o[e+8>>2]=0;o[e+4>>2]=e;o[e>>2]=e;o[d+12>>2]=e;o[d+8>>2]=e;o[d+4>>2]=e;o[d>>2]=e;break a;case 0:break b}}a=o[o[a+92>>2]+(b<<2)>>2];o[a+8>>2]=0;o[a+4>>2]=a;o[a>>2]=a;o[d+12>>2]=a;o[d+8>>2]=a;o[d+4>>2]=a;o[d>>2]=a;break a}f=((e|0)/2|0)+b|0;e=f;e:{if((e|0)>=(c|0)){break e}g=o[a+92>>2];e=o[(g+(f<<2)|0)+ -4>>2];j=o[e+88>>2];k=o[e+96>>2];l=o[e+92>>2];e=f;while(1){h=o[(e<<2)+g>>2];if((j|0)!=o[h+88>>2]|(l|0)!=o[h+92>>2]|(k|0)!=o[h+96>>2]){break e}e=e+1|0;if((e|0)<(c|0)){continue}break}e=c;}Hd(a,b,f,d);o[i+8>>2]=0;o[i+12>>2]=0;o[i>>2]=0;o[i+4>>2]=0;Hd(a,e,c,i);pu(a,d,i);}K=i+16|0;}function Bm(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=0;d=s[c+100>>2];g=s[c+16>>2];h=s[c+20>>2];i=s[c+24>>2];e=s[c+108>>2];e=v(v(v(s[c+112>>2]-v(d*s[c+116>>2]))-v(v(v(v(v(g*s[a+64>>2])+v(h*s[a+68>>2]))+v(i*s[a+72>>2]))+v(v(v(s[c>>2]*s[a+80>>2])+v(s[c+4>>2]*s[a+84>>2]))+v(s[c+8>>2]*s[a+88>>2])))*e))-v(e*v(v(v(v(s[c+48>>2]*s[b+64>>2])+v(s[c+52>>2]*s[b+68>>2]))+v(s[c+56>>2]*s[b+72>>2]))+v(v(v(s[c+32>>2]*s[b+80>>2])+v(s[c+36>>2]*s[b+84>>2]))+v(s[c+40>>2]*s[b+88>>2])))));j=v(d+e);f=s[c+120>>2];k=j<f;s[c+100>>2]=k?f:j;d=k?v(f-d):e;if(o[a+240>>2]){s[a+64>>2]=v(s[a+112>>2]*v(d*v(g*s[a+128>>2])))+s[a+64>>2];s[a+68>>2]=v(v(d*v(h*s[a+132>>2]))*s[a+116>>2])+s[a+68>>2];s[a+72>>2]=v(v(d*v(i*s[a+136>>2]))*s[a+120>>2])+s[a+72>>2];e=s[c+72>>2];f=s[c+68>>2];s[a+80>>2]=v(v(d*s[a+96>>2])*s[c+64>>2])+s[a+80>>2];g=s[a+104>>2];s[a+84>>2]=v(f*v(d*s[a+100>>2]))+s[a+84>>2];s[a+88>>2]=v(e*v(d*g))+s[a+88>>2];}if(o[b+240>>2]){e=s[c+56>>2];f=s[c+52>>2];s[b+64>>2]=v(s[b+112>>2]*v(d*v(s[c+48>>2]*s[b+128>>2])))+s[b+64>>2];s[b+68>>2]=v(v(d*v(f*s[b+132>>2]))*s[b+116>>2])+s[b+68>>2];s[b+72>>2]=v(v(d*v(e*s[b+136>>2]))*s[b+120>>2])+s[b+72>>2];e=s[c+88>>2];f=s[c+84>>2];s[b+80>>2]=v(v(d*s[b+96>>2])*s[c+80>>2])+s[b+80>>2];g=s[b+104>>2];s[b+84>>2]=v(f*v(d*s[b+100>>2]))+s[b+84>>2];s[b+88>>2]=v(e*v(d*g))+s[b+88>>2];}return v(d)}function Sh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),x=v(0),y=v(0),z=v(0);e=K-48|0;K=e;k=s[d>>2];i=s[c>>2];h=v(v(k-i)*v(.5));j=v(h*h);g=s[d+4>>2];f=s[c+4>>2];h=v(v(g-f)*v(.5));p=v(j+v(h*h));j=s[d+8>>2];m=s[c+8>>2];h=v(v(j-m)*v(.5));h=v(C(v(p+v(h*h))));j=v(v(j+m)*v(.5));m=v(v(g+f)*v(.5));q=v(v(k+i)*v(.5));k=s[a+60>>2];a:{if(!!(v(w(k))>v(.7071067690849304))){i=s[a+56>>2];g=v(v(k*k)+v(i*i));f=v(v(1)/v(C(g)));r=v(g*f);n=v(i*f);g=s[a+52>>2];t=v(n*v(-g));f=v(f*v(-k));u=v(g*f);break a}g=s[a+52>>2];i=s[a+56>>2];r=v(v(g*g)+v(i*i));f=v(v(1)/v(C(r)));u=v(r*f);y=v(f*v(-i));t=v(k*y);f=v(g*f);r=v(f*v(-k));}x=s[a+68>>2];o[e+44>>2]=0;o[e+28>>2]=0;p=j;j=v(v(v(k*j)+v(v(q*g)+v(m*i)))-x);x=v(p-v(k*j));n=v(h*n);p=v(x-n);k=v(h*u);u=v(p-k);s[e+40>>2]=u;m=v(m-v(i*j));f=v(h*f);z=v(m-f);i=v(h*t);t=v(z-i);s[e+36>>2]=t;n=v(n+x);s[e+24>>2]=n-k;f=v(f+m);s[e+20>>2]=f-i;o[e+12>>2]=0;g=v(q-v(g*j));j=v(h*y);m=v(g-j);h=v(h*r);q=v(m-h);s[e+32>>2]=q;g=v(j+g);s[e+16>>2]=g-h;j=v(k+n);s[e+8>>2]=j;f=v(i+f);s[e+4>>2]=f;g=v(h+g);s[e>>2]=g;l[o[o[b>>2]+8>>2]](b,e,0,0);o[e+44>>2]=0;s[e+40>>2]=j;s[e+36>>2]=f;o[e+28>>2]=0;s[e+24>>2]=k+p;s[e+20>>2]=i+z;s[e+32>>2]=g;s[e+16>>2]=h+m;o[e+12>>2]=0;s[e+8>>2]=u;s[e+4>>2]=t;s[e>>2]=q;l[o[o[b>>2]+8>>2]](b,e,0,1);K=e+48|0;}function kh(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;a:{h=o[a+32>>2];c=o[a+12>>2];if((h|0)>=(c|0)){break a}b:{if(o[a+36>>2]>=(c|0)){b=o[a+40>>2];break b}d=h;if(c){o[6257]=o[6257]+1;b=l[o[4968]](c<<2,16)|0;d=o[a+32>>2];}f=o[a+40>>2];c:{if((d|0)>=1){while(1){g=e<<2;o[g+b>>2]=o[f+g>>2];e=e+1|0;if((e|0)!=(d|0)){continue}break c}}if(f){break c}o[a+40>>2]=b;o[a+36>>2]=c;m[a+44|0]=1;break b}if(p[a+44|0]){if(f){o[6258]=o[6258]+1;l[o[4969]](f);}}o[a+40>>2]=b;m[a+44|0]=1;o[a+36>>2]=c;}d=h<<2;g=c<<2;$(d+b|0,0,g-d|0);o[a+32>>2]=c;f=o[a+52>>2];if((f|0)<(c|0)){d:{if(o[a+56>>2]>=(c|0)){b=o[a+60>>2];break d}e=0;d=f;b=0;if(c){o[6257]=o[6257]+1;b=l[o[4968]](g,16)|0;d=o[a+52>>2];}i=o[a+60>>2];e:{if((d|0)>=1){while(1){j=e<<2;o[j+b>>2]=o[i+j>>2];e=e+1|0;if((e|0)!=(d|0)){continue}break e}}if(i){break e}o[a+60>>2]=b;o[a+56>>2]=c;m[a- -64|0]=1;break d}if(p[a- -64|0]){if(i){o[6258]=o[6258]+1;l[o[4969]](i);}}o[a+60>>2]=b;m[a+64|0]=1;o[a+56>>2]=c;}d=f<<2;$(d+b|0,0,g-d|0);}o[a+52>>2]=c;if((c|0)>=1){$(o[a+40>>2],255,g);$(o[a+60>>2],255,g);}if((h|0)<1){break a}d=o[a+60>>2];f=o[a+16>>2];c=o[a+40>>2];e=0;while(1){b=f+(e<<4)|0;b=o[o[b+4>>2]+12>>2]<<16|o[o[b>>2]+12>>2];b=(b<<15^-1)+b|0;b=u(b>>>10^b,9);b=b>>>6^b;b=(b<<11^-1)+b|0;b=c+((o[a+12>>2]+ -1&(b>>>16^b))<<2)|0;o[d+(e<<2)>>2]=o[b>>2];o[b>>2]=e;e=e+1|0;if((h|0)!=(e|0)){continue}break}}}function Ij(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=K-160|0;K=f;g=o[a+12>>2];a:{if(!g){break a}h=p[a+16|0];i=h?b:c;j=o[i+4>>2];b=h?c:b;h=o[b+4>>2];o[e+4>>2]=g;c=f+144|0;s[c+12>>2]=s[g+848>>2]+s[e+32>>2];o[c+8>>2]=j;o[c+4>>2]=h;o[c>>2]=9696;o[f+136>>2]=1566444395;b=o[b+12>>2];g=o[b+12>>2];o[f+16>>2]=o[b+8>>2];o[f+20>>2]=g;g=o[b+4>>2];o[f+8>>2]=o[b>>2];o[f+12>>2]=g;g=o[b+28>>2];o[f+32>>2]=o[b+24>>2];o[f+36>>2]=g;g=o[b+20>>2];o[f+24>>2]=o[b+16>>2];o[f+28>>2]=g;g=o[b+44>>2];o[f+48>>2]=o[b+40>>2];o[f+52>>2]=g;g=o[b+36>>2];o[f+40>>2]=o[b+32>>2];o[f+44>>2]=g;h=o[b+60>>2];g=f- -64|0;o[g>>2]=o[b+56>>2];o[g+4>>2]=h;g=o[b+52>>2];o[f+56>>2]=o[b+48>>2];o[f+60>>2]=g;b=o[i+12>>2];g=o[b+12>>2];o[f+80>>2]=o[b+8>>2];o[f+84>>2]=g;g=o[b+4>>2];o[f+72>>2]=o[b>>2];o[f+76>>2]=g;g=o[b+20>>2];o[f+88>>2]=o[b+16>>2];o[f+92>>2]=g;g=o[b+28>>2];o[f+96>>2]=o[b+24>>2];o[f+100>>2]=g;g=o[b+36>>2];o[f+104>>2]=o[b+32>>2];o[f+108>>2]=g;g=o[b+44>>2];o[f+112>>2]=o[b+40>>2];o[f+116>>2]=g;g=o[b+52>>2];o[f+120>>2]=o[b+48>>2];o[f+124>>2]=g;g=o[b+60>>2];o[f+128>>2]=o[b+56>>2];o[f+132>>2]=g;De(c,f+8|0,e,o[d+20>>2],p[a+16|0]);if(!p[a+8|0]){break a}a=o[e+4>>2];if(!o[a+844>>2]){break a}b=o[a+836>>2];c=o[o[e+8>>2]+8>>2];if((b|0)!=(c|0)){da(a,o[o[e+12>>2]+8>>2]+4|0,c+4|0);break a}da(a,b+4|0,o[o[e+12>>2]+8>>2]+4|0);}K=f+160|0;}function kf(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;d=o[a+4>>2];g=d;a:{if((d|0)!=o[a+8>>2]){break a}g=d;h=d?d<<1:1;if((d|0)>=(h|0)){break a}if(h){o[6257]=o[6257]+1;j=l[o[4968]](u(h,244),16)|0;g=o[a+4>>2];}else {g=d;}if((g|0)>=1){while(1){c=u(i,244);e=c+j|0;c=c+o[a+12>>2]|0;f=o[c+4>>2];o[e>>2]=o[c>>2];o[e+4>>2]=f;f=o[c+12>>2];o[e+8>>2]=o[c+8>>2];o[e+12>>2]=f;f=o[c+28>>2];o[e+24>>2]=o[c+24>>2];o[e+28>>2]=f;f=o[c+20>>2];o[e+16>>2]=o[c+16>>2];o[e+20>>2]=f;f=o[c+44>>2];o[e+40>>2]=o[c+40>>2];o[e+44>>2]=f;f=o[c+36>>2];o[e+32>>2]=o[c+32>>2];o[e+36>>2]=f;f=o[c+52>>2];o[e+48>>2]=o[c+48>>2];o[e+52>>2]=f;f=o[c+60>>2];o[e+56>>2]=o[c+56>>2];o[e+60>>2]=f;ra(e- -64|0,c- -64|0,180);i=i+1|0;if((g|0)!=(i|0)){continue}break}}g=o[a+12>>2];if(g){if(p[a+16|0]){if(g){o[6258]=o[6258]+1;l[o[4969]](g);}}o[a+12>>2]=0;}o[a+12>>2]=j;m[a+16|0]=1;o[a+8>>2]=h;g=o[a+4>>2];}o[a+4>>2]=g+1;e=o[b+12>>2];g=u(d,244);d=g+o[a+12>>2]|0;c=d;o[c+8>>2]=o[b+8>>2];o[c+12>>2]=e;c=o[b+4>>2];o[d>>2]=o[b>>2];o[d+4>>2]=c;c=o[b+28>>2];o[d+24>>2]=o[b+24>>2];o[d+28>>2]=c;c=o[b+20>>2];o[d+16>>2]=o[b+16>>2];o[d+20>>2]=c;c=o[b+36>>2];o[d+32>>2]=o[b+32>>2];o[d+36>>2]=c;c=o[b+44>>2];o[d+40>>2]=o[b+40>>2];o[d+44>>2]=c;c=o[b+52>>2];o[d+48>>2]=o[b+48>>2];o[d+52>>2]=c;c=o[b+60>>2];o[d+56>>2]=o[b+56>>2];o[d+60>>2]=c;ra(d- -64|0,b- -64|0,180);return g+o[a+12>>2]|0}function Kc(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;a:{h=o[a+28>>2];c=o[a+12>>2];if((h|0)>=(c|0)){break a}b:{if(o[a+32>>2]>=(c|0)){b=o[a+36>>2];break b}d=h;if(c){o[6257]=o[6257]+1;b=l[o[4968]](c<<2,16)|0;d=o[a+28>>2];}f=o[a+36>>2];c:{if((d|0)>=1){while(1){g=e<<2;o[g+b>>2]=o[f+g>>2];e=e+1|0;if((e|0)!=(d|0)){continue}break c}}if(f){break c}o[a+36>>2]=b;o[a+32>>2]=c;m[a+40|0]=1;break b}if(p[a+40|0]){if(f){o[6258]=o[6258]+1;l[o[4969]](f);}}o[a+36>>2]=b;m[a+40|0]=1;o[a+32>>2]=c;}d=h<<2;g=c<<2;$(d+b|0,0,g-d|0);o[a+28>>2]=c;f=o[a+48>>2];if((f|0)<(c|0)){d:{if(o[a+52>>2]>=(c|0)){b=o[a+56>>2];break d}e=0;d=f;b=0;if(c){o[6257]=o[6257]+1;b=l[o[4968]](g,16)|0;d=o[a+48>>2];}i=o[a+56>>2];e:{if((d|0)>=1){while(1){j=e<<2;o[j+b>>2]=o[i+j>>2];e=e+1|0;if((e|0)!=(d|0)){continue}break e}}if(i){break e}o[a+56>>2]=b;o[a+52>>2]=c;m[a+60|0]=1;break d}if(p[a+60|0]){if(i){o[6258]=o[6258]+1;l[o[4969]](i);}}o[a+56>>2]=b;m[a+60|0]=1;o[a+52>>2]=c;}d=f<<2;$(d+b|0,0,g-d|0);}o[a+48>>2]=c;if((c|0)>=1){$(o[a+36>>2],255,g);$(o[a+56>>2],255,g);}if((h|0)<1){break a}d=o[a+56>>2];f=o[a+16>>2];c=o[a+36>>2];e=0;while(1){b=f+u(e,12)|0;b=o[b+4>>2]<<16|o[b>>2];b=(b<<15^-1)+b|0;b=u(b>>>10^b,9);b=b>>>6^b;b=(b<<11^-1)+b|0;b=c+((o[a+12>>2]+ -1&(b>>>16^b))<<2)|0;o[d+(e<<2)>>2]=o[b>>2];o[b>>2]=e;e=e+1|0;if((h|0)!=(e|0)){continue}break}}}function tf(a,b,c,d,e,f,g,h,i,j){var k=v(0),l=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=0,A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0);z=o[f+4>>2];o[a>>2]=o[f>>2];o[a+4>>2]=z;z=o[f+12>>2];o[a+8>>2]=o[f+8>>2];o[a+12>>2]=z;y=s[b+24>>2];t=s[b+20>>2];n=s[b+40>>2];l=s[b+36>>2];u=s[b+8>>2];w=s[b>>2];A=s[b+4>>2];B=s[b+16>>2];k=s[b+32>>2];q=s[d+4>>2];p=s[d+8>>2];x=s[d>>2];o[a+28>>2]=0;C=k;k=s[a+8>>2];m=s[a+4>>2];r=v(v(q*k)-v(p*m));D=l;E=p;p=s[a>>2];l=v(v(E*p)-v(k*x));q=v(v(m*x)-v(q*p));x=v(v(v(C*r)+v(D*l))+v(n*q));s[a+24>>2]=x;y=v(v(v(r*B)+v(l*t))+v(q*y));s[a+20>>2]=y;q=v(v(v(r*w)+v(A*l))+v(q*u));s[a+16>>2]=q;u=s[c+24>>2];w=s[c+20>>2];A=s[c+40>>2];B=s[c+36>>2];F=s[c+8>>2];G=s[c>>2];C=s[c+4>>2];D=s[c+16>>2];n=s[c+32>>2];r=s[e+4>>2];l=s[e>>2];t=s[e+8>>2];o[a+44>>2]=0;E=n;n=v(v(m*t)-v(k*r));k=v(v(k*l)-v(p*t));m=v(v(p*r)-v(m*l));p=v(v(v(E*n)+v(B*k))+v(A*m));s[a+40>>2]=p;r=v(v(v(n*D)+v(k*w))+v(m*u));s[a+36>>2]=r;k=v(v(v(G*n)+v(C*k))+v(m*F));s[a+32>>2]=k;m=s[g+8>>2];l=s[g+4>>2];t=s[g>>2];o[a+60>>2]=0;t=v(t*q);s[a+48>>2]=t;l=v(l*y);s[a+52>>2]=l;m=v(m*x);s[a+56>>2]=m;n=s[i+8>>2];u=s[i+4>>2];w=s[i>>2];o[a+76>>2]=0;w=v(w*k);s[a+64>>2]=w;u=v(u*r);s[a+68>>2]=u;n=v(n*p);s[a+72>>2]=n;s[a+80>>2]=v(v(v(v(v(q*t)+v(y*l))+v(x*m))+h)+j)+v(v(v(k*w)+v(r*u))+v(p*n));}function Ra(a,b,c){var d=0,e=0;e=K-256|0;K=e;d=o[b+212>>2];a:{if((d|0)>-1){break a}b:{d=o[b+252>>2];if(!(d&2)){break b}d=d<<30>>31&b;if(p[d+204|0]&2?0:s[d+404>>2]==v(0)){break b}d=o[a+8>>2];$(e+8|0,0,244);ym(kf(a+4|0,e+8|0),b,c);o[b+212>>2]=d;break a}d=o[a+188>>2];if((d|0)>-1){break a}o[a+188>>2]=o[a+8>>2];$(e+8|0,0,244);b=kf(a+4|0,e+8|0);o[b+88>>2]=0;o[b+92>>2]=0;o[b+80>>2]=0;o[b+84>>2]=0;o[b+72>>2]=0;o[b+76>>2]=0;o[b+64>>2]=0;o[b+68>>2]=0;o[b+144>>2]=0;o[b+148>>2]=0;o[b+152>>2]=0;o[b+156>>2]=0;o[b+160>>2]=0;o[b+164>>2]=0;o[b+168>>2]=0;o[b+172>>2]=0;o[b+4>>2]=0;o[b+8>>2]=0;o[b>>2]=1065353216;o[b+12>>2]=0;o[b+16>>2]=0;o[b+24>>2]=0;o[b+28>>2]=0;o[b+20>>2]=1065353216;o[b+32>>2]=0;o[b+36>>2]=0;o[b+44>>2]=0;o[b+48>>2]=0;o[b+40>>2]=1065353216;o[b+52>>2]=0;o[b+56>>2]=0;o[b+60>>2]=0;o[b+136>>2]=0;o[b+140>>2]=0;o[b+240>>2]=0;o[b+128>>2]=0;o[b+132>>2]=0;o[b+120>>2]=1065353216;o[b+124>>2]=0;o[b+112>>2]=1065353216;o[b+116>>2]=1065353216;o[b+104>>2]=1065353216;o[b+108>>2]=0;o[b+96>>2]=1065353216;o[b+100>>2]=1065353216;o[b+232>>2]=0;o[b+236>>2]=0;o[b+224>>2]=0;o[b+228>>2]=0;o[b+216>>2]=0;o[b+220>>2]=0;o[b+208>>2]=0;o[b+212>>2]=0;o[b+200>>2]=0;o[b+204>>2]=0;o[b+192>>2]=0;o[b+196>>2]=0;o[b+184>>2]=0;o[b+188>>2]=0;o[b+176>>2]=0;o[b+180>>2]=0;d=o[a+188>>2];}K=e+256|0;return d}function Ke(a,b,c,d,e,f){var g=0;o[a+4>>2]=b;o[a>>2]=7432;b=o[c+12>>2];o[a+16>>2]=o[c+8>>2];o[a+20>>2]=b;b=o[c+4>>2];o[a+8>>2]=o[c>>2];o[a+12>>2]=b;b=o[c+28>>2];o[a+32>>2]=o[c+24>>2];o[a+36>>2]=b;b=o[c+20>>2];o[a+24>>2]=o[c+16>>2];o[a+28>>2]=b;b=o[c+44>>2];o[a+48>>2]=o[c+40>>2];o[a+52>>2]=b;b=o[c+36>>2];o[a+40>>2]=o[c+32>>2];o[a+44>>2]=b;g=o[c+60>>2];b=a- -64|0;o[b>>2]=o[c+56>>2];o[b+4>>2]=g;b=o[c+52>>2];o[a+56>>2]=o[c+48>>2];o[a+60>>2]=b;b=o[d+12>>2];o[a+80>>2]=o[d+8>>2];o[a+84>>2]=b;b=o[d+4>>2];o[a+72>>2]=o[d>>2];o[a+76>>2]=b;b=o[d+28>>2];o[a+96>>2]=o[d+24>>2];o[a+100>>2]=b;b=o[d+20>>2];o[a+88>>2]=o[d+16>>2];o[a+92>>2]=b;b=o[d+44>>2];o[a+112>>2]=o[d+40>>2];o[a+116>>2]=b;b=o[d+36>>2];o[a+104>>2]=o[d+32>>2];o[a+108>>2]=b;b=o[d+60>>2];o[a+128>>2]=o[d+56>>2];o[a+132>>2]=b;b=o[d+52>>2];o[a+120>>2]=o[d+48>>2];o[a+124>>2]=b;b=o[e+12>>2];o[a+144>>2]=o[e+8>>2];o[a+148>>2]=b;b=o[e+4>>2];o[a+136>>2]=o[e>>2];o[a+140>>2]=b;b=o[e+28>>2];o[a+160>>2]=o[e+24>>2];o[a+164>>2]=b;b=o[e+20>>2];o[a+152>>2]=o[e+16>>2];o[a+156>>2]=b;b=o[e+44>>2];o[a+176>>2]=o[e+40>>2];o[a+180>>2]=b;b=o[e+36>>2];o[a+168>>2]=o[e+32>>2];o[a+172>>2]=b;b=o[e+60>>2];o[a+192>>2]=o[e+56>>2];o[a+196>>2]=b;b=o[e+52>>2];o[a+184>>2]=o[e+48>>2];o[a+188>>2]=b;o[a+208>>2]=0;s[a+204>>2]=f;o[a+200>>2]=1065353216;}function Pd(a,b,c){var d=0,e=0,f=0,g=0;o[a+4>>2]=1065353216;o[a+8>>2]=1065353216;o[a+48>>2]=0;o[a>>2]=15268;m[a+36|0]=1;o[a+12>>2]=1065353216;o[a+16>>2]=0;o[a+32>>2]=0;o[a+24>>2]=0;o[a+28>>2]=0;m[a+100|0]=1;o[a+96>>2]=0;m[a+120|0]=1;o[a+88>>2]=0;o[a+92>>2]=0;o[a+116>>2]=0;m[a+140|0]=1;o[a+108>>2]=0;o[a+112>>2]=0;o[a+136>>2]=0;m[a+160|0]=1;o[a+128>>2]=0;o[a+132>>2]=0;o[a+168>>2]=0;m[a+164|0]=b;o[a+148>>2]=0;o[a+152>>2]=0;o[a+156>>2]=0;m[a+165|0]=c;o[6257]=o[6257]+1;f=l[o[4968]](32,16)|0;g=o[a+24>>2];if((g|0)>=1){while(1){b=e<<5;c=b+f|0;b=b+o[a+32>>2]|0;d=o[b+4>>2];o[c>>2]=o[b>>2];o[c+4>>2]=d;d=o[b+28>>2];o[c+24>>2]=o[b+24>>2];o[c+28>>2]=d;d=o[b+20>>2];o[c+16>>2]=o[b+16>>2];o[c+20>>2]=d;d=o[b+12>>2];o[c+8>>2]=o[b+8>>2];o[c+12>>2]=d;e=e+1|0;if((g|0)!=(e|0)){continue}break}}b=o[a+32>>2];if(b){if(p[a+36|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+32>>2]=0;}o[a+32>>2]=f;m[a+36|0]=1;o[a+28>>2]=1;b=f+(o[a+24>>2]<<5)|0;o[b+24>>2]=2;o[b+28>>2]=0;o[b+16>>2]=0;o[b+20>>2]=16;o[b+8>>2]=12;o[b+12>>2]=0;o[b>>2]=0;o[b+4>>2]=0;o[a+24>>2]=o[a+24>>2]+1;c=p[a+164|0];f=o[(c?128:148)+a>>2];b=o[a+32>>2];o[b+24>>2]=c?2:3;o[b+4>>2]=0;e=12;o[b+8>>2]=c?12:6;o[b>>2]=(f|0)/3;a:{if(p[a+165|0]){e=16;a=o[a+88>>2];break a}a=o[a+108>>2]/3|0;}o[b+20>>2]=e;o[b+16>>2]=0;o[b+12>>2]=a;}function xk(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=K-160|0;K=f;g=o[a+12>>2];a:{if(!g){break a}h=o[c+4>>2];i=o[b+4>>2];o[e+4>>2]=g;o[f+152>>2]=1566444395;b=o[b+12>>2];g=o[b+12>>2];o[f+32>>2]=o[b+8>>2];o[f+36>>2]=g;g=o[b+4>>2];o[f+24>>2]=o[b>>2];o[f+28>>2]=g;g=o[b+28>>2];o[f+48>>2]=o[b+24>>2];o[f+52>>2]=g;g=o[b+20>>2];o[f+40>>2]=o[b+16>>2];o[f+44>>2]=g;j=o[b+44>>2];g=f- -64|0;o[g>>2]=o[b+40>>2];o[g+4>>2]=j;g=o[b+36>>2];o[f+56>>2]=o[b+32>>2];o[f+60>>2]=g;g=o[b+60>>2];o[f+80>>2]=o[b+56>>2];o[f+84>>2]=g;g=o[b+52>>2];o[f+72>>2]=o[b+48>>2];o[f+76>>2]=g;b=o[c+12>>2];c=o[b+12>>2];o[f+96>>2]=o[b+8>>2];o[f+100>>2]=c;c=o[b+4>>2];o[f+88>>2]=o[b>>2];o[f+92>>2]=c;c=o[b+20>>2];o[f+104>>2]=o[b+16>>2];o[f+108>>2]=c;c=o[b+28>>2];o[f+112>>2]=o[b+24>>2];o[f+116>>2]=c;c=o[b+36>>2];o[f+120>>2]=o[b+32>>2];o[f+124>>2]=c;c=o[b+44>>2];o[f+128>>2]=o[b+40>>2];o[f+132>>2]=c;c=o[b+52>>2];o[f+136>>2]=o[b+48>>2];o[f+140>>2]=c;c=o[b+60>>2];o[f+144>>2]=o[b+56>>2];o[f+148>>2]=c;b=f+8|0;o[b+8>>2]=h;o[b+4>>2]=i;o[b>>2]=7048;Oe(b,f+24|0,e,o[d+20>>2],0);if(!p[a+8|0]){break a}a=o[e+4>>2];if(!o[a+844>>2]){break a}b=o[a+836>>2];c=o[o[e+8>>2]+8>>2];if((b|0)!=(c|0)){da(a,o[o[e+12>>2]+8>>2]+4|0,c+4|0);break a}da(a,b+4|0,o[o[e+12>>2]+8>>2]+4|0);}K=f+160|0;}function Vu(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0;k=K-16|0;K=k;c=o[a+96>>2];if(l[o[o[c>>2]+56>>2]](c)){c=o[a+96>>2];d=l[o[o[c>>2]+28>>2]](c)|0;c=o[d+4>>2];if((c|0)>=2){Cc(d,k+8|0,0,c+ -1|0);c=o[d+4>>2];}if((c|0)>=1){while(1){j=o[d+12>>2]+(n<<4)|0;f=o[j+4>>2];g=h;h=o[j>>2];a:{b:{if((e|0)==(f|0)?(g|0)==(h|0):0){break b}e=o[h+48>>2];g=o[f+48>>2];if(s[e>>2]<=s[g+16>>2]^1|s[e+16>>2]>=s[g>>2]^1|(s[e+4>>2]<=s[g+20>>2]^1|s[e+20>>2]>=s[g+4>>2]^1)){break b}if(!(s[e+8>>2]<=s[g+24>>2])){break b}if(s[e+24>>2]>=s[g+8>>2]){break a}}c=o[a+96>>2];l[o[o[c>>2]+32>>2]](c,j,b);o[j>>2]=0;o[j+4>>2]=0;i=i+1|0;c=o[d+4>>2];}e=f;n=n+1|0;if((n|0)<(c|0)){continue}break}if((c|0)>=2){Cc(d,k,0,c+ -1|0);c=o[d+4>>2];}a=c-i|0;if((i|0)<=-1){if(o[d+8>>2]<(a|0)){b=0;i=c;h=0;if(a){o[6257]=o[6257]+1;h=l[o[4968]](a<<4,16)|0;i=o[d+4>>2];}if((i|0)>=1){while(1){e=b<<4;f=e+h|0;e=e+o[d+12>>2]|0;o[f>>2]=o[e>>2];o[f+4>>2]=o[e+4>>2];o[f+8>>2]=o[e+8>>2];o[f+12>>2]=o[e+12>>2];b=b+1|0;if((i|0)!=(b|0)){continue}break}}b=o[d+12>>2];if(b){if(p[d+16|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[d+12>>2]=0;}o[d+12>>2]=h;m[d+16|0]=1;o[d+8>>2]=a;}while(1){b=o[d+12>>2]+(c<<4)|0;o[b>>2]=0;o[b+4>>2]=0;o[b+8>>2]=0;o[b+12>>2]=0;c=c+1|0;if((a|0)!=(c|0)){continue}break}}c=a;}o[d+4>>2]=c;}K=k+16|0;}function Wd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0,q=0,r=0;if(o[a+8>>2]<(b|0)){if(b){o[6257]=o[6257]+1;j=l[o[4968]](u(b,36),16)|0;}else {j=0;}n=o[a+4>>2];a:{if((n|0)<1){break a}while(1){d=o[a+12>>2];e=u(k,36);c=e+j|0;o[c+12>>2]=0;m[c+16|0]=1;o[c+4>>2]=0;o[c+8>>2]=0;e=d+e|0;f=o[e+4>>2];b:{if((f|0)>=1){o[6257]=o[6257]+1;h=f<<2;i=l[o[4968]](h,16)|0;g=o[c+12>>2];d=0;q=o[c+4>>2];c:{d:{if((q|0)>=1){while(1){r=d<<2;o[i+r>>2]=o[g+r>>2];d=d+1|0;if((q|0)!=(d|0)){continue}break d}}if(!g){break c}}if(!p[c+16|0]){break c}if(g){o[6258]=o[6258]+1;l[o[4969]](g);}}m[c+16|0]=1;o[c+12>>2]=i;o[c+8>>2]=f;d=0;$(i,0,h);o[c+4>>2]=f;g=o[e+12>>2];i=o[c+12>>2];while(1){h=d<<2;o[h+i>>2]=o[g+h>>2];d=d+1|0;if((f|0)!=(d|0)){continue}break}break b}o[c+4>>2]=f;}d=o[e+24>>2];o[c+20>>2]=o[e+20>>2];o[c+24>>2]=d;d=o[e+32>>2];o[c+28>>2]=o[e+28>>2];o[c+32>>2]=d;k=k+1|0;if((n|0)!=(k|0)){continue}break}g=o[a+4>>2];if((g|0)<1){break a}d=0;while(1){c=o[a+12>>2]+u(d,36)|0;e=c;f=o[c+12>>2];if(f){if(p[c+16|0]){if(f){o[6258]=o[6258]+1;l[o[4969]](f);}}o[e+12>>2]=0;}m[c+16|0]=1;o[e+12>>2]=0;o[c+4>>2]=0;o[c+8>>2]=0;d=d+1|0;if((g|0)!=(d|0)){continue}break}}c=o[a+12>>2];if(c){if(p[a+16|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+12>>2]=0;}o[a+12>>2]=j;m[a+16|0]=1;o[a+8>>2]=b;}}function dk(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;a:{h=o[a+4>>2];c=o[a+48>>2];if((h|0)>=(c|0)){break a}b:{if(o[a+8>>2]>=(c|0)){b=o[a+12>>2];break b}d=h;if(c){o[6257]=o[6257]+1;b=l[o[4968]](c<<2,16)|0;d=o[a+4>>2];}f=o[a+12>>2];c:{d:{if((d|0)>=1){while(1){g=e<<2;o[g+b>>2]=o[f+g>>2];e=e+1|0;if((e|0)!=(d|0)){continue}break d}}if(f){break d}break c}if(p[a+16|0]){if(f){o[6258]=o[6258]+1;l[o[4969]](f);}}}o[a+12>>2]=b;m[a+16|0]=1;o[a+8>>2]=c;}d=h<<2;g=c<<2;$(d+b|0,0,g-d|0);o[a+4>>2]=c;f=o[a+24>>2];if((f|0)<(c|0)){e:{if(o[a+28>>2]>=(c|0)){b=o[a+32>>2];break e}e=0;d=f;b=0;if(c){o[6257]=o[6257]+1;b=l[o[4968]](g,16)|0;d=o[a+24>>2];}i=o[a+32>>2];f:{if((d|0)>=1){while(1){j=e<<2;o[j+b>>2]=o[i+j>>2];e=e+1|0;if((e|0)!=(d|0)){continue}break f}}if(i){break f}o[a+32>>2]=b;o[a+28>>2]=c;m[a+36|0]=1;break e}if(p[a+36|0]){if(i){o[6258]=o[6258]+1;l[o[4969]](i);}}o[a+32>>2]=b;m[a+36|0]=1;o[a+28>>2]=c;}d=f<<2;$(d+b|0,0,g-d|0);}o[a+24>>2]=c;if((c|0)>=1){$(o[a+12>>2],255,g);$(o[a+32>>2],255,g);}if((h|0)<1){break a}d=o[a+32>>2];f=o[a+72>>2];c=o[a+12>>2];e=0;while(1){b=o[f+(e<<3)>>2];b=(b<<15^-1)+b|0;b=u(b>>>10^b,9);b=b>>>6^b;b=(b<<11^-1)+b|0;b=c+((o[a+48>>2]+ -1&(b>>>16^b))<<2)|0;o[d+(e<<2)>>2]=o[b>>2];o[b>>2]=e;e=e+1|0;if((h|0)!=(e|0)){continue}break}}}function pv(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0,q=0;d=o[b+12>>2]>o[c+12>>2];i=d?b:c;j=o[i+12>>2];k=d?c:b;f=o[k+12>>2];b=j<<16|f;b=(b<<15^-1)+b|0;b=u(b>>>10^b,9);b=b>>>6^b;b=(b<<11^-1)+b|0;q=b>>>16^b;d=o[a+12>>2];n=q&d+ -1;b=o[o[a+40>>2]+(n<<2)>>2];a:{if((b|0)!=-1){e=o[a+16>>2];while(1){g=b<<4;c=g+e|0;if((j|0)==o[o[(e+g|0)+4>>2]+12>>2]?(f|0)==o[o[c>>2]+12>>2]:0){break a}b=o[o[a+60>>2]+(b<<2)>>2];if((b|0)!=-1){continue}break}}b=d;f=o[a+8>>2];c=f;b:{if((b|0)!=(c|0)){break b}c=d;e=b?b<<1:1;if((b|0)>=(e|0)){break b}c:{if(!e){c=0;b=d;break c}o[6257]=o[6257]+1;c=l[o[4968]](e<<4,16)|0;b=o[a+8>>2];}j=b;if((j|0)>=1){b=0;while(1){h=b<<4;g=h+c|0;h=h+o[a+16>>2]|0;o[g>>2]=o[h>>2];o[g+4>>2]=o[h+4>>2];o[g+8>>2]=o[h+8>>2];o[g+12>>2]=o[h+12>>2];b=b+1|0;if((j|0)!=(b|0)){continue}break}}b=o[a+16>>2];if(b){if(p[a+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+16>>2]=0;}o[a+16>>2]=c;o[a+12>>2]=e;m[a+20|0]=1;c=o[a+8>>2];b=e;}o[a+8>>2]=c+1;e=o[a+16>>2];c=o[a+68>>2];if(c){l[o[o[c>>2]+8>>2]](c,k,i)|0;b=o[a+12>>2];}c=e+(f<<4)|0;if((d|0)<(b|0)){kh(a);n=o[a+12>>2]+ -1&q;}d=o[k+12>>2]<o[i+12>>2];o[c>>2]=d?k:i;b=e+(f<<4)|0;o[b+8>>2]=0;o[b+12>>2]=0;o[b+4>>2]=d?i:k;b=o[a+60>>2]+(f<<2)|0;a=o[a+40>>2]+(n<<2)|0;o[b>>2]=o[a>>2];o[a>>2]=f;}return c}function Dk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=v(0);c=K-800|0;K=c;l[o[4966]](6956);o[c+740>>2]=0;o[c+744>>2]=0;o[c+752>>2]=0;o[c+756>>2]=0;o[c+748>>2]=1065353216;o[c+772>>2]=0;o[c+776>>2]=0;o[c+768>>2]=1065353216;o[c+780>>2]=0;o[c+784>>2]=0;o[c+788>>2]=0;o[c+732>>2]=0;o[c+736>>2]=0;o[c+728>>2]=1065353216;o[c+760>>2]=0;o[c+764>>2]=0;o[c+720>>2]=0;o[c+724>>2]=0;o[c+552>>2]=6980;o[c+716>>2]=o[a+200>>2];d=o[a+196>>2];sa(c+496|0);o[c+524>>2]=0;o[c+528>>2]=0;o[c+520>>2]=1065353216;o[c+532>>2]=0;o[c+536>>2]=0;o[c+540>>2]=0;o[c+512>>2]=1065353216;o[c+516>>2]=1065353216;o[c+496>>2]=11388;o[c+548>>2]=0;o[c+544>>2]=d;o[c+528>>2]=d;o[c+500>>2]=8;d=zb(c+384|0);o[c+388>>2]=1;o[c+384>>2]=6568;e=o[b+12>>2];o[c+452>>2]=o[b+8>>2];o[c+456>>2]=e;e=o[b+4>>2];o[c+444>>2]=o[b>>2];o[c+448>>2]=e;e=o[b+20>>2];o[c+460>>2]=o[b+16>>2];o[c+464>>2]=e;e=o[b+28>>2];o[c+468>>2]=o[b+24>>2];o[c+472>>2]=e;e=o[b+36>>2];o[c+476>>2]=o[b+32>>2];o[c+480>>2]=e;e=o[b+44>>2];o[c+484>>2]=o[b+40>>2];o[c+488>>2]=e;m[c+356|0]=0;o[c+332>>2]=953267991;b=c+8|0;o[b+12>>2]=c+384;o[b+8>>2]=c+496;o[b+4>>2]=c+24;o[b>>2]=6276;a:{if(!Te(b,a+4|0,a+68|0,c+728|0,c+728|0,c+552|0)){break a}f=s[c+716>>2];if(!(s[a+200>>2]>f)){break a}s[a+200>>2]=f;}kb(d);l[o[4967]]();K=c+800|0;}function $d(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=v(0),j=v(0),k=v(0),m=0,n=v(0),p=0,r=0,w=0,x=0;d=K-80|0;K=d;g=o[a+4>>2];l[o[o[g>>2]+16>>2]](g,d+28|0,d+24|0,d+20|0,d+16|0,d+12|0,d+8|0,d+4|0,d,b);m=o[d+12>>2]+u(o[d+8>>2],c)|0;p=o[d+20>>2];f=o[a+4>>2];g=f+12|0;h=o[d+28>>2];e=h;r=o[d>>2];w=q[m+4>>1];a:{if((r|0)==3){break a}w=o[m+8>>2];}x=o[d+16>>2];e=e+u(w,x)|0;b:{if(!p){i=v(s[e+4>>2]*s[f+8>>2]);j=v(s[e>>2]*s[f+4>>2]);k=s[f+12>>2];e=e+8|0;break b}i=v(s[f+8>>2]*v(t[e+8>>3]));j=v(s[f+4>>2]*v(t[e>>3]));k=v(t[e+16>>3]);e=g;}n=s[e>>2];o[d+76>>2]=0;s[d+68>>2]=i;s[d+72>>2]=n*k;s[d+64>>2]=j;if((r|0)!=3){e=o[m+4>>2];}else {e=q[m+2>>1];}e=u(e,x)+h|0;c:{if(p){i=v(s[f+8>>2]*v(t[e+8>>3]));j=v(s[f+4>>2]*v(t[e>>3]));k=v(t[e+16>>3]);e=g;break c}i=v(s[e+4>>2]*s[f+8>>2]);j=v(s[e>>2]*s[f+4>>2]);k=s[f+12>>2];e=e+8|0;}n=s[e>>2];o[d+60>>2]=0;s[d+52>>2]=i;s[d+56>>2]=n*k;s[d+48>>2]=j;if((r|0)!=3){e=o[m>>2];}else {e=q[m>>1];}h=u(e,x)+h|0;d:{if(p){k=v(t[h+16>>3]);i=v(s[f+8>>2]*v(t[h+8>>3]));j=v(s[f+4>>2]*v(t[h>>3]));break d}g=h+8|0;k=s[f+12>>2];i=v(s[h+4>>2]*s[f+8>>2]);j=v(s[h>>2]*s[f+4>>2]);}n=s[g>>2];o[d+44>>2]=0;s[d+36>>2]=i;s[d+32>>2]=j;s[d+40>>2]=n*k;g=o[a+8>>2];l[o[o[g>>2]+8>>2]](g,d+32|0,b,c);a=o[a+4>>2];l[o[o[a>>2]+24>>2]](a,b);K=d+80|0;}function nb(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0);j=K-256|0;K=j;a:{if(!a){break a}m=s[b+24>>2];n=s[b+20>>2];p=s[b+16>>2];q=s[b+8>>2];r=s[b+4>>2];t=s[b>>2];o[j>>2]=a;f=64;e=j;b=1;while(1){a=b+ -1|0;g=o[(a<<2)+e>>2];b:{if(s[g>>2]<=p^1|s[g+16>>2]>=t^1|(s[g+4>>2]<=n^1|s[g+20>>2]>=r^1)){break b}if(s[g+8>>2]<=m^1|s[g+24>>2]>=q^1){break b}c:{d:{if(o[g+40>>2]){if((a|0)!=(f|0)){d=f;h=e;break c}d=f?f<<1:1;if((b|0)>(d|0)){h=e;d=f;a=d;break c}a=0;h=0;if(d){o[6257]=o[6257]+1;h=l[o[4968]](d<<2,16)|0;}if((b|0)>=2){while(1){b=a<<2;o[b+h>>2]=o[b+e>>2];a=a+1|0;if((f|0)!=(a|0)){continue}break d}}if(e){break d}i=1;break c}l[o[o[c>>2]+12>>2]](c,g);break b}a=i;i=1;if(a){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}a=f;}o[(a<<2)+h>>2]=o[g+36>>2];e:{f:{k=a+1|0;if((k|0)!=(d|0)){break f}f=d?d<<1:1;if((d|0)>=(f|0)){break f}b=0;e=0;if(f){o[6257]=o[6257]+1;e=l[o[4968]](f<<2,16)|0;}g:{h:{if((a|0)>=0){while(1){d=b<<2;o[d+e>>2]=o[d+h>>2];d=(a|0)==(b|0);b=b+1|0;if(!d){continue}break}if(i){break h}break g}if(!h|!i){break g}}if(h){o[6258]=o[6258]+1;l[o[4969]](h);}}i=1;break e}f=d;e=h;}o[(k<<2)+e>>2]=o[g+40>>2];a=a+2|0;}b=a;if((b|0)>0){continue}break}if(!e|!i){break a}if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}K=j+256|0;}function wo(a,b){var c=v(0),d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0);c=s[a+372>>2];i=s[a+504>>2];d=Og(v(v(1)-i),b);c=v(c*d);s[a+372>>2]=c;g=v(d*s[a+376>>2]);s[a+376>>2]=g;d=v(d*s[a+380>>2]);s[a+380>>2]=d;f=s[a+388>>2];j=s[a+508>>2];e=Og(v(v(1)-j),b);b=v(f*e);s[a+388>>2]=b;f=v(e*s[a+392>>2]);s[a+392>>2]=f;e=v(e*s[a+396>>2]);s[a+396>>2]=e;a:{if(!p[a+512|0]){break a}if(!(v(v(v(b*b)+v(f*f))+v(e*e))<s[a+524>>2]^1|v(v(v(c*c)+v(g*g))+v(d*d))<s[a+520>>2]^1)){h=s[a+516>>2];e=v(e*h);s[a+396>>2]=e;f=v(f*h);s[a+392>>2]=f;b=v(b*h);s[a+388>>2]=b;d=v(d*h);s[a+380>>2]=d;g=v(g*h);s[a+376>>2]=g;c=v(c*h);s[a+372>>2]=c;}h=v(C(v(v(v(c*c)+v(g*g))+v(d*d))));b:{if(!(h<i)){break b}if(!!(h>v(.004999999888241291))){i=d;d=v(v(1)/h);s[a+380>>2]=i-v(v(i*d)*v(.004999999888241291));s[a+376>>2]=g-v(v(g*d)*v(.004999999888241291));s[a+372>>2]=c-v(v(c*d)*v(.004999999888241291));break b}o[a+372>>2]=0;o[a+376>>2]=0;o[a+380>>2]=0;o[a+384>>2]=0;}c=v(C(v(v(v(b*b)+v(f*f))+v(e*e))));if(!(c<j)){break a}if(!!(c>v(.004999999888241291))){c=v(v(1)/c);s[a+396>>2]=e-v(v(e*c)*v(.004999999888241291));s[a+392>>2]=f-v(v(f*c)*v(.004999999888241291));s[a+388>>2]=b-v(v(b*c)*v(.004999999888241291));return}o[a+388>>2]=0;o[a+392>>2]=0;o[a+396>>2]=0;o[a+400>>2]=0;}}function ib(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0,r=0,s=0;p=o[a+16>>2];d=o[b+16>>2];if((p|0)!=(d|0)){return p-d|0}if(!p){return 0}g=o[a+4>>2];i=o[b+8>>2];j=o[b+12>>2];n=o[a>>2];k=Qw(j,0,n,0);h=L;j=Qw(j,e,g,0);c=j+h|0;d=L+f|0;f=c;c=c>>>0<j>>>0?d+1|0:d;j=0;g=Qw(i,j,g,e);d=f;f=L;e=d+f|0;if(e>>>0<f>>>0){c=c+1|0;}d=e;f=c;e=0;c=g+k|0;if(c>>>0<g>>>0){e=e+1|0;}k=e;e=e+d|0;d=f;d=e>>>0<k>>>0?d+1|0:d;f=e;e=c;k=0;i=Qw(n,l,i,j);g=k+i|0;c=L+c|0;c=g>>>0<i>>>0?c+1|0:c;q=g;i=g;g=c;e=(e|0)==(c|0)&i>>>0<k>>>0|c>>>0<e>>>0;c=f+e|0;if(c>>>0<e>>>0){d=d+1|0;}k=c;i=d;j=c;n=d;e=o[a+8>>2];a=o[a+12>>2];c=o[b>>2];h=o[b+4>>2];d=0;l=e;f=Qw(h,d,e,0);b=L;m=a;e=0;h=Qw(h,d,a,e);a=b+h|0;d=L;d=a>>>0<h>>>0?d+1|0:d;b=a;h=c;a=Qw(c,0,m,e);m=L;b=m+b|0;c=d;c=b>>>0<m>>>0?c+1|0:c;e=c;d=0;c=a+f|0;if(c>>>0<a>>>0){d=d+1|0;}m=d;f=d+b|0;d=e;d=f>>>0<m>>>0?d+1|0:d;b=f;f=-1;e=d;m=b;b=0;l=Qw(h,r,l,s);a=b+l|0;d=c;c=c+L|0;c=a>>>0<l>>>0?c+1|0:c;l=a;h=a;a=c;b=(d|0)==(c|0)&h>>>0<b>>>0|c>>>0<d>>>0;d=m+b|0;if(d>>>0<b>>>0){e=e+1|0;}c=d;b=e;a:{if((e|0)==(n|0)&j>>>0<c>>>0|n>>>0<e>>>0){break a}f=1;if((b|0)==(i|0)&k>>>0>d>>>0|i>>>0>b>>>0){break a}f=-1;if((a|0)==(g|0)&q>>>0<l>>>0|g>>>0<a>>>0){break a}f=(a|0)==(g|0)&q>>>0>l>>>0|g>>>0>a>>>0;}return u(f,p)}function kn(a){var b=v(0),c=v(0),d=v(0),e=v(0),f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=0,p=v(0),q=v(0),r=v(0),t=v(0),u=v(0);o[a+1440>>2]=0;h=s[a+1256>>2];i=s[a+1276>>2];j=s[a+1260>>2];k=s[a+1272>>2];t=v(v(h*i)-v(j*k));c=s[a+1236>>2];d=s[a+1240>>2];l=s[a+1268>>2];m=s[a+1252>>2];u=v(v(j*l)-v(i*m));g=v(v(k*m)-v(h*l));e=s[a+1244>>2];b=v(v(1)/v(v(v(t*c)+v(d*u))+v(g*e)));p=v(s[a+1356>>2]-s[a+1292>>2]);q=v(s[a+1348>>2]-s[a+1284>>2]);r=v(s[a+1352>>2]-s[a+1288>>2]);g=v(v(p*v(v(v(h*c)-v(m*d))*b))+v(v(q*v(g*b))+v(r*v(v(v(l*d)-v(k*c))*b))));s[a+1436>>2]=g;c=v(v(p*v(v(v(m*e)-v(j*c))*b))+v(v(q*v(u*b))+v(r*v(v(v(i*c)-v(l*e))*b))));s[a+1432>>2]=c;b=v(v(p*v(v(v(j*d)-v(h*e))*b))+v(v(q*v(t*b))+v(r*v(v(v(k*e)-v(i*d))*b))));s[a+1428>>2]=b;s[a+940>>2]=b;d=s[a+680>>2];e=s[a+696>>2];a:{if(!!(d>e)){o[a+908>>2]=0;break a}s[a+908>>2]=b-d;f=3;if(d==e){break a}s[a+924>>2]=b-e;f=4;}s[a+944>>2]=c;o[a+956>>2]=f;b=s[a+684>>2];d=s[a+700>>2];b:{if(!(b>d)){s[a+912>>2]=c-b;f=3;if(b==d){break b}s[a+928>>2]=c-d;f=4;break b}o[a+912>>2]=0;f=0;}s[a+948>>2]=g;o[a+960>>2]=f;f=a;b=s[a+688>>2];c=s[a+704>>2];c:{if(!(b>c)){s[a+916>>2]=g-b;n=3;if(b==c){break c}s[a+932>>2]=g-c;n=4;break c}o[a+916>>2]=0;n=0;}o[f+964>>2]=n;}function _c(a){var b=0;o[a+132>>2]=0;o[a+136>>2]=0;o[a>>2]=3972;o[a+188>>2]=0;o[a+192>>2]=0;o[a+180>>2]=0;o[a+184>>2]=1566444395;o[a+164>>2]=1065353216;o[a+168>>2]=1065353216;o[a+276>>2]=0;o[a+280>>2]=0;o[a+268>>2]=1065353216;o[a+272>>2]=0;o[a+260>>2]=-1;o[a+264>>2]=-1;o[a+252>>2]=1;o[a+256>>2]=0;o[a+244>>2]=1036831949;o[a+248>>2]=1176256512;o[a+236>>2]=0;o[a+240>>2]=0;o[a+228>>2]=1056964608;o[a+232>>2]=0;o[a+220>>2]=1;o[a+224>>2]=0;o[a+212>>2]=-1;o[a+216>>2]=-1;o[a+204>>2]=1;o[a+208>>2]=-1;o[a+140>>2]=0;o[a+144>>2]=0;o[a+148>>2]=0;o[a+152>>2]=0;o[a+156>>2]=0;o[a+160>>2]=0;o[a+172>>2]=1065353216;o[a+176>>2]=0;o[a+196>>2]=0;o[a+200>>2]=0;m[a+300|0]=1;o[a+304>>2]=0;o[a+296>>2]=0;o[a+288>>2]=0;o[a+292>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;o[a+4>>2]=1065353216;o[a+16>>2]=0;o[a+20>>2]=0;o[a+28>>2]=0;o[a+32>>2]=0;o[a+24>>2]=1065353216;o[a+36>>2]=0;o[a+40>>2]=0;o[a+48>>2]=0;o[a+52>>2]=0;o[a+44>>2]=1065353216;o[a+56>>2]=0;o[a+60>>2]=0;o[a+72>>2]=0;o[a+76>>2]=0;b=a- -64|0;o[b>>2]=0;o[b+4>>2]=1065353216;o[a+80>>2]=0;o[a+84>>2]=0;o[a+88>>2]=1065353216;o[a+100>>2]=0;o[a+104>>2]=0;o[a+92>>2]=0;o[a+96>>2]=0;o[a+128>>2]=0;o[a+108>>2]=1065353216;o[a+120>>2]=0;o[a+124>>2]=0;o[a+112>>2]=0;o[a+116>>2]=0;}function ev(a){var b=0,c=0,d=0,e=0,f=0,g=0;c=K-32|0;K=c;o[a>>2]=15928;o[a+20>>2]=0;o[a+12>>2]=-1;o[a+16>>2]=0;o[a+4>>2]=0;o[a+8>>2]=0;o[a+36>>2]=0;m[a+40|0]=1;o[a+28>>2]=0;o[a+32>>2]=0;o[a+60>>2]=0;o[a+52>>2]=-1;o[a+56>>2]=0;o[a+44>>2]=0;o[a+48>>2]=0;o[a+76>>2]=0;m[a+80|0]=1;o[a+68>>2]=0;o[a+72>>2]=0;o[a+168>>2]=0;e=1;m[a+172|0]=1;o[a+160>>2]=0;o[a+164>>2]=0;m[a+153|0]=256;m[a+154|0]=1;m[a+152|0]=1;o[a+124>>2]=0;o[a+100>>2]=0;o[a+104>>2]=0;o[a+136>>2]=0;o[a+128>>2]=0;o[a+132>>2]=0;o[a+116>>2]=10;o[a+120>>2]=1;o[a+108>>2]=1;o[a+112>>2]=0;o[6257]=o[6257]+1;b=l[o[4968]](72,16)|0;vv(b);d=o[a+160>>2];o[a+148>>2]=0;o[a+96>>2]=b;o[a+140>>2]=0;o[a+144>>2]=0;o[a+84>>2]=0;o[a+88>>2]=0;o[a+92>>2]=0;o[c+20>>2]=0;m[c+24|0]=1;o[c+12>>2]=0;o[c+16>>2]=0;a:{if((d|0)>=2){while(1){b=o[a+168>>2]+u(e,20)|0;g=b;f=o[b+12>>2];if(f){if(p[b+16|0]){if(f){o[6258]=o[6258]+1;l[o[4969]](f);}}o[g+12>>2]=0;}m[b+16|0]=1;o[g+12>>2]=0;o[b+4>>2]=0;o[b+8>>2]=0;e=e+1|0;if((e|0)!=(d|0)){continue}break a}}if((d|0)==1){break a}dv(a+156|0);while(1){b=d;gh(o[a+168>>2]+u(b,20)|0,c+8|0);d=b+1|0;if(b){continue}break}}o[a+160>>2]=1;a=o[c+20>>2];if(a){if(p[c+24|0]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[c+20>>2]=0;}K=c+32|0;}function Zt(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;if(pa(a,o[b+8>>2],e)){if(!(o[b+28>>2]==1|o[b+4>>2]!=(c|0))){o[b+28>>2]=d;}return}a:{if(pa(a,o[b>>2],e)){if(!(o[b+20>>2]!=(c|0)?o[b+16>>2]!=(c|0):0)){if((d|0)!=1){break a}o[b+32>>2]=1;return}o[b+32>>2]=d;if(o[b+44>>2]!=4){f=a+16|0;i=f+(o[a+12>>2]<<3)|0;j=b;b:{c:{while(1){d:{if(f>>>0>=i>>>0){break d}n[b+52>>1]=0;Cd(f,b,c,c,1,e);if(p[b+54|0]){break d}e:{if(!p[b+53|0]){break e}if(p[b+52|0]){d=1;if(o[b+24>>2]==1){break c}h=1;g=1;if(p[a+8|0]&2){break e}break c}h=1;d=g;if(!(m[a+8|0]&1)){break c}}f=f+8|0;continue}break}d=g;a=4;if(!h){break b}}a=3;}o[j+44>>2]=a;if(d&1){break a}}o[b+20>>2]=c;o[b+40>>2]=o[b+40>>2]+1;if(o[b+36>>2]!=1|o[b+24>>2]!=2){break a}m[b+54|0]=1;return}g=o[a+12>>2];f=a+16|0;uc(f,b,c,d,e);if((g|0)<2){break a}g=f+(g<<3)|0;f=a+24|0;a=o[a+8>>2];if(!(o[b+36>>2]!=1?!(a&2):0)){while(1){if(p[b+54|0]){break a}uc(f,b,c,d,e);f=f+8|0;if(f>>>0<g>>>0){continue}break}break a}if(!(a&1)){while(1){if(p[b+54|0]|o[b+36>>2]==1){break a}uc(f,b,c,d,e);f=f+8|0;if(f>>>0<g>>>0){continue}break a}}while(1){if(p[b+54|0]|(o[b+24>>2]==1?o[b+36>>2]==1:0)){break a}uc(f,b,c,d,e);f=f+8|0;if(f>>>0<g>>>0){continue}break}}}function wi(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;a:{h=o[a+4>>2];c=o[a+48>>2];if((h|0)>=(c|0)){break a}b:{if(o[a+8>>2]>=(c|0)){e=o[a+12>>2];break b}b=h;if(c){o[6257]=o[6257]+1;e=l[o[4968]](c<<2,16)|0;b=o[a+4>>2];}g=o[a+12>>2];c:{d:{if((b|0)>=1){while(1){f=d<<2;o[f+e>>2]=o[g+f>>2];d=d+1|0;if((d|0)!=(b|0)){continue}break d}}if(g){break d}break c}if(p[a+16|0]){if(g){o[6258]=o[6258]+1;l[o[4969]](g);}}}o[a+12>>2]=e;m[a+16|0]=1;o[a+8>>2]=c;}b=h<<2;f=c<<2;$(b+e|0,0,f-b|0);o[a+4>>2]=c;g=o[a+24>>2];if((g|0)<(c|0)){e:{if(o[a+28>>2]>=(c|0)){e=o[a+32>>2];break e}d=0;b=g;e=0;if(c){o[6257]=o[6257]+1;e=l[o[4968]](f,16)|0;b=o[a+24>>2];}i=o[a+32>>2];f:{if((b|0)>=1){while(1){j=d<<2;o[j+e>>2]=o[i+j>>2];d=d+1|0;if((d|0)!=(b|0)){continue}break f}}if(i){break f}o[a+32>>2]=e;o[a+28>>2]=c;m[a+36|0]=1;break e}if(p[a+36|0]){if(i){o[6258]=o[6258]+1;l[o[4969]](i);}}o[a+32>>2]=e;m[a+36|0]=1;o[a+28>>2]=c;}b=g<<2;$(b+e|0,0,f-b|0);}o[a+24>>2]=c;if((c|0)>=1){$(o[a+12>>2],255,f);$(o[a+32>>2],255,f);}if((h|0)<1){break a}g=o[a+32>>2];c=o[a+72>>2];e=o[a+12>>2];d=0;while(1){f=d<<2;b=f+c|0;b=e+(((q[b+2>>1]<<16)+n[b>>1]&o[a+48>>2]+ -1)<<2)|0;o[g+f>>2]=o[b>>2];o[b>>2]=d;d=d+1|0;if((h|0)!=(d|0)){continue}break}}}function Pi(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,p=0,q=0;Na(a,b,c);o[b+20>>2]=o[a+76>>2];d=o[a+20>>2];o[b+12>>2]=0;o[b+16>>2]=d;if(d){g=l[o[o[c>>2]+16>>2]](c,76,d)|0;d=o[g+8>>2];o[b+12>>2]=l[o[o[c>>2]+28>>2]](c,d);if(o[b+16>>2]>0){while(1){e=u(h,80);f=e+o[a+28>>2]|0;o[d+72>>2]=o[f+72>>2];o[d+64>>2]=l[o[o[c>>2]+28>>2]](c,o[f+64>>2]);if(!l[o[o[c>>2]+24>>2]](c,o[(e+o[a+28>>2]|0)+64>>2])){f=o[(e+o[a+28>>2]|0)+64>>2];f=(k=c,m=l[o[o[f>>2]+52>>2]](f)|0,n=1,j=o[o[c>>2]+16>>2],l[j](k|0,m|0,n|0)|0);i=o[(e+o[a+28>>2]|0)+64>>2];n=c,m=f,k=l[o[o[i>>2]+56>>2]](i,o[f+8>>2],c)|0,p=1346455635,q=o[(e+o[a+28>>2]|0)+64>>2],j=o[o[c>>2]+20>>2],l[j](n|0,m|0,k|0,p|0,q|0);}e=e+o[a+28>>2]|0;o[d+68>>2]=o[e+68>>2];o[d>>2]=o[e>>2];o[d+4>>2]=o[e+4>>2];o[d+8>>2]=o[e+8>>2];o[d+12>>2]=o[e+12>>2];o[d+16>>2]=o[e+16>>2];o[d+20>>2]=o[e+20>>2];o[d+24>>2]=o[e+24>>2];o[d+28>>2]=o[e+28>>2];o[d+32>>2]=o[e+32>>2];o[d+36>>2]=o[e+36>>2];o[d+40>>2]=o[e+40>>2];o[d+44>>2]=o[e+44>>2];o[d+48>>2]=o[e+48>>2];o[d+52>>2]=o[e+52>>2];o[d+56>>2]=o[e+56>>2];o[d+60>>2]=o[e+60>>2];d=d+76|0;h=h+1|0;if((h|0)<o[b+16>>2]){continue}break}}l[o[o[c>>2]+20>>2]](c,g,11092,1497453121,o[g+8>>2]);}return 11117}function Jn(a,b){a=a|0;b=v(b);var c=0,d=0,e=v(0),f=0,g=0,h=0,i=v(0),j=v(0),k=v(0),m=0,n=0,q=v(0),r=v(0),t=v(0),w=v(0);c=K-80|0;K=c;l[o[4966]](2749);d=o[a+248>>2];if((d|0)>=1){Ln(a,o[a+256>>2],d,b);}if(p[a+291|0]){l[o[4966]](2769);d=o[a+324>>2];if((d|0)>=1){while(1){g=o[o[a+332>>2]+(n<<2)>>2];if(o[g+844>>2]>=1){d=o[g+840>>2];h=o[d+252>>2]<<30>>31&d;d=o[g+836>>2];f=o[d+252>>2]<<30>>31&d;m=0;while(1){b=v(s[f+232>>2]*s[h+232>>2]);a:{if(!(b>v(0))){break a}d=u(m,208)+g|0;e=s[d+136>>2];if(e==v(0)){break a}i=s[d+68>>2];j=s[d+72>>2];k=s[d+76>>2];o[c+60>>2]=0;k=v(b*v(e*v(-k)));s[c+56>>2]=k;j=v(b*v(e*v(-j)));s[c+52>>2]=j;b=v(b*v(e*v(-i)));s[c+48>>2]=b;e=s[d+52>>2];i=s[d+56>>2];q=s[d+60>>2];r=s[f+52>>2];t=s[f+56>>2];w=s[f+60>>2];o[c+44>>2]=0;s[c+40>>2]=q-w;s[c+36>>2]=i-t;s[c+32>>2]=e-r;e=s[d+36>>2];i=s[d+40>>2];q=s[d+44>>2];r=s[h+52>>2];t=s[h+56>>2];w=s[h+60>>2];o[c+28>>2]=0;s[c+24>>2]=q-w;s[c+20>>2]=i-t;s[c+16>>2]=e-r;if(f){nd(f,c+48|0,c+32|0);k=s[c+56>>2];j=s[c+52>>2];b=s[c+48>>2];}o[c+12>>2]=0;s[c+8>>2]=-k;s[c+4>>2]=-j;s[c>>2]=-b;nd(h,c,c+16|0);}m=m+1|0;if((m|0)<o[g+844>>2]){continue}break}d=o[a+324>>2];}n=n+1|0;if((n|0)<(d|0)){continue}break}}l[o[4967]]();}l[o[4967]]();K=c+80|0;}function lj(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;o[5644]=o[5644]+1;i=o[a+36>>2];d=c<<16|b;d=(d<<15^-1)+d|0;d=u(d>>>10^d,9);d=d>>>6^d;d=(d<<11^-1)+d|0;f=i+((o[a+12>>2]+ -1&(d>>>16^d))<<2)|0;d=o[f>>2];a:{if((d|0)==-1){break a}g=o[a+16>>2];e=d;while(1){j=g+u(e,12)|0;if(!(o[j+4>>2]==(c|0)?o[j>>2]==(b|0):0)){e=o[o[a+56>>2]+(e<<2)>>2];if((e|0)!=-1){continue}break a}break}l=o[(g+u(e,12)|0)+8>>2];h=o[a+56>>2];b:{c:{if((d|0)!=(e|0)){while(1){b=d;k=(d<<2)+h|0;d=o[k>>2];if((e|0)!=(d|0)){continue}break}d=o[(e<<2)+h>>2];c=d;if((b|0)==-1){break c}o[k>>2]=d;break b}c=o[(e<<2)+h>>2];}o[f>>2]=c;}b=o[a+8>>2]+ -1|0;if((b|0)==(e|0)){o[a+8>>2]=e;return l|0}d:{e:{f=g+u(b,12)|0;c=o[f+4>>2]<<16|o[f>>2];c=(c<<15^-1)+c|0;c=u(c>>>10^c,9);c=c>>>6^c;c=(c<<11^-1)+c|0;g=o[a+12>>2]+ -1&(c>>>16^c);i=i+(g<<2)|0;d=o[i>>2];if((b|0)==(d|0)){b=o[(b<<2)+h>>2];break e}while(1){c=d;k=(d<<2)+h|0;d=o[k>>2];if((b|0)!=(d|0)){continue}break}b=o[(b<<2)+h>>2];if((c|0)==-1){break e}o[k>>2]=b;break d}o[i>>2]=b;}b=o[f+4>>2];o[j>>2]=o[f>>2];o[j+4>>2]=b;o[j+8>>2]=o[f+8>>2];b=o[a+36>>2]+(g<<2)|0;o[o[a+56>>2]+(e<<2)>>2]=o[b>>2];o[b>>2]=e;o[a+8>>2]=o[a+8>>2]+ -1;}return l|0}function Do(a,b){var c=0,d=v(0),e=v(0);c=K-32|0;K=c;o[c+28>>2]=a;o[c+24>>2]=b;a=o[c+28>>2];d=s[a+12>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];d=v(v(d*s[o[b+12>>2]>>2])+v(s[a>>2]*s[o[c+24>>2]+12>>2]));e=s[a+4>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];d=v(d+v(e*s[o[b+12>>2]+8>>2]));e=s[a+8>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];s[c+20>>2]=d-v(e*s[o[b+12>>2]+4>>2]);d=s[a+12>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];d=v(v(d*s[o[b+12>>2]+4>>2])+v(s[a+4>>2]*s[o[c+24>>2]+12>>2]));e=s[a+8>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];d=v(d+v(e*s[o[b+12>>2]>>2]));e=s[a>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];s[c+16>>2]=d-v(e*s[o[b+12>>2]+8>>2]);d=s[a+12>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];d=v(v(d*s[o[b+12>>2]+8>>2])+v(s[a+8>>2]*s[o[c+24>>2]+12>>2]));e=s[a>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];d=v(d+v(e*s[o[b+12>>2]+4>>2]));e=s[a+4>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];s[c+12>>2]=d-v(e*s[o[b+12>>2]>>2]);d=v(s[a+12>>2]*s[o[c+24>>2]+12>>2]);e=s[a>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];d=v(d-v(e*s[o[b+12>>2]>>2]));e=s[a+4>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];d=v(d-v(e*s[o[b+12>>2]+4>>2]));e=s[a+8>>2];b=K-16|0;o[b+12>>2]=o[c+24>>2];s[c+8>>2]=d-v(e*s[o[b+12>>2]+8>>2]);mc(a,c+20|0,c+16|0,c+12|0,c+8|0);K=c+32|0;}function Hc(a){var b=v(0),c=v(0),d=v(0),e=0,f=0,g=0,h=0,i=0,j=0,k=0;h=o[a+28>>2];j=(h|0)<1;while(1){a:{if(e>>>0>7){break a}b:{switch(e-1|0){default:b=v(s[a+88>>2]+s[a+72>>2]);c=v(s[a+84>>2]+s[a+68>>2]);d=v(s[a+80>>2]+s[a+64>>2]);break a;case 0:b=v(s[a+72>>2]-s[a+88>>2]);c=v(s[a+84>>2]+s[a+68>>2]);d=v(s[a+80>>2]+s[a+64>>2]);break a;case 1:b=v(s[a+88>>2]+s[a+72>>2]);c=v(s[a+68>>2]-s[a+84>>2]);d=v(s[a+80>>2]+s[a+64>>2]);break a;case 2:b=v(s[a+72>>2]-s[a+88>>2]);c=v(s[a+68>>2]-s[a+84>>2]);d=v(s[a+80>>2]+s[a+64>>2]);break a;case 3:b=v(s[a+88>>2]+s[a+72>>2]);c=v(s[a+84>>2]+s[a+68>>2]);d=v(s[a+64>>2]-s[a+80>>2]);break a;case 4:b=v(s[a+72>>2]-s[a+88>>2]);c=v(s[a+84>>2]+s[a+68>>2]);d=v(s[a+64>>2]-s[a+80>>2]);break a;case 5:b=v(s[a+88>>2]+s[a+72>>2]);c=v(s[a+68>>2]-s[a+84>>2]);d=v(s[a+64>>2]-s[a+80>>2]);break a;case 6:break b}}b=v(s[a+72>>2]-s[a+88>>2]);c=v(s[a+68>>2]-s[a+84>>2]);d=v(s[a+64>>2]-s[a+80>>2]);}c:{if(!j){k=o[a+36>>2];i=0;f=0;while(1){g=u(f,36)+k|0;if(!!(v(s[g+32>>2]+v(v(v(d*s[g+20>>2])+v(c*s[g+24>>2]))+v(b*s[g+28>>2])))>v(0))){break c}f=f+1|0;if((f|0)<(h|0)){continue}break}}i=1;e=e+1|0;if((e|0)!=8){continue}}break}return i}function Id(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0;f=o[a+56>>2];a:{if(f){break a}d=o[a+52>>2];b:{if(d){o[a+52>>2]=o[d+8>>2];break b}o[6257]=o[6257]+1;d=l[o[4968]](12,16)|0;e=o[a+60>>2];o[d+8>>2]=0;o[d+4>>2]=e;o[6257]=o[6257]+1;o[d>>2]=l[o[4968]](u(e,24),16);o[d+8>>2]=o[a+48>>2];o[a+48>>2]=d;}f=o[d>>2];g=o[d+4>>2];if((g|0)<1){break a}d=0;e=f;while(1){h=e;e=e+24|0;d=d+1|0;o[h>>2]=(d|0)<(g|0)?e:0;if((d|0)!=(g|0)){continue}break}}o[a+56>>2]=o[f>>2];o[f+16>>2]=0;o[f+20>>2]=0;o[f+8>>2]=0;o[f+12>>2]=0;o[f>>2]=0;o[f+4>>2]=0;g=o[a+56>>2];c:{if(g){break c}d=o[a+52>>2];d:{if(d){o[a+52>>2]=o[d+8>>2];break d}o[6257]=o[6257]+1;d=l[o[4968]](12,16)|0;e=o[a+60>>2];o[d+8>>2]=0;o[d+4>>2]=e;o[6257]=o[6257]+1;o[d>>2]=l[o[4968]](u(e,24),16);o[d+8>>2]=o[a+48>>2];o[a+48>>2]=d;}g=o[d>>2];i=o[d+4>>2];if((i|0)<1){break c}d=0;e=g;while(1){h=e;e=e+24|0;d=d+1|0;o[h>>2]=(d|0)<(i|0)?e:0;if((d|0)!=(i|0)){continue}break}}o[a+56>>2]=o[g>>2];o[g>>2]=0;o[g+4>>2]=0;o[f+8>>2]=g;o[g+8>>2]=f;e=o[a+100>>2];o[f+20>>2]=e;o[g+20>>2]=e;o[f+12>>2]=c;o[g+12>>2]=b;o[f+16>>2]=0;o[g+16>>2]=0;b=o[a+116>>2];c=b+1|0;o[a+116>>2]=c;if((b|0)>=o[a+120>>2]){o[a+120>>2]=c;}return f}function Cc(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0,s=0,t=0,u=0,v=0,w=0;while(1){u=c;n=o[a+12>>2];f=n+((c+d|0)/2<<4)|0;v=o[f+8>>2];l=o[f+4>>2];k=o[f>>2];f=d;while(1){g=-1;i=-1;e=(c<<4)+n|0;m=o[e>>2];if(m){i=o[m+12>>2];}g=k?o[k+12>>2]:g;h=-1;j=-1;p=o[e+4>>2];if(p){j=o[p+12>>2];}h=l?o[l+12>>2]:h;a:{b:{if((i|0)>(g|0)){break b}if(!((k|0)!=(m|0)|(j|0)>(h|0))){if((l|0)!=(p|0)){break a}if(r[e+8>>2]>v>>>0){break b}break a}if((k|0)!=(m|0)|(j|0)<=(h|0)){break a}}c=c+1|0;continue}while(1){w=f<<4;g=w+n|0;i=-1;h=-1;h=k?o[k+12>>2]:h;q=o[g>>2];if(q){i=o[q+12>>2];}j=-1;s=-1;s=l?o[l+12>>2]:s;t=o[g+4>>2];if(t){j=o[t+12>>2];}c:{d:{if((h|0)>(i|0)){break d}if(!((k|0)!=(q|0)|(s|0)>(j|0))){if((l|0)!=(t|0)){break c}if(r[g+8>>2]<v>>>0){break d}break c}if((k|0)!=(q|0)|(s|0)<=(j|0)){break c}}f=f+ -1|0;continue}break}if((c|0)<=(f|0)){j=o[e+8>>2];h=o[e+12>>2];i=o[g+4>>2];o[e>>2]=o[g>>2];o[e+4>>2]=i;i=o[g+12>>2];o[e+8>>2]=o[g+8>>2];o[e+12>>2]=i;e=o[a+12>>2]+w|0;o[e+4>>2]=p;o[e+8>>2]=j;o[e+12>>2]=h;o[e>>2]=m;f=f+ -1|0;c=c+1|0;}if((c|0)<=(f|0)){n=o[a+12>>2];continue}break}if((f|0)>(u|0)){Cc(a,b,u,f);}if((c|0)<(d|0)){continue}break}}function zl(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=0,m=v(0),n=v(0),p=v(0),q=v(0),r=0;d=K-32|0;K=d;a=o[a+12>>2];a:{if(!a){break a}o[e+4>>2]=a;f=o[b+12>>2];k=o[c+12>>2];n=v(s[f+48>>2]-s[k+48>>2]);i=v(s[f+52>>2]-s[k+52>>2]);j=v(s[f+56>>2]-s[k+56>>2]);g=v(v(v(n*n)+v(i*i))+v(j*j));f=o[c+4>>2];m=s[f+16>>2];h=s[f+32>>2];b=o[b+4>>2];p=s[b+16>>2];q=s[b+32>>2];f=o[a+844>>2];if((f|0)>=1){b=0;while(1){f=a+u(b,208)|0;k=o[f+120>>2];b:{if(!k){break b}r=o[5379];if(!r){break b}l[r](k)|0;o[f+120>>2]=0;}b=b+1|0;f=o[a+844>>2];if((b|0)<(f|0)){continue}break}}g=v(C(g));m=v(h*m);h=v(q*p);c:{if(!f){break c}b=o[5382];if(!b){break c}o[d+16>>2]=a;l[b](d+16|0);}o[a+844>>2]=0;h=v(h+m);if(g>v(h+s[e+32>>2])){break a}o[d+24>>2]=0;o[d+28>>2]=0;o[d+16>>2]=1065353216;o[d+20>>2]=0;h=v(g-h);d:{if(!(g>v(1.1920928955078125e-7))){g=v(1);j=v(0);i=v(0);break d}o[d+28>>2]=0;g=v(v(1)/g);j=v(j*g);s[d+24>>2]=j;i=v(i*g);s[d+20>>2]=i;g=v(n*g);s[d+16>>2]=g;}a=o[c+12>>2];n=s[a+52>>2];p=s[a+56>>2];q=s[a+48>>2];o[d+12>>2]=0;s[d>>2]=q+v(m*g);s[d+8>>2]=p+v(m*j);s[d+4>>2]=n+v(m*i);l[o[o[e>>2]+16>>2]](e,d+16|0,d,h);}K=d+32|0;}function Rn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0,q=0;f=K-16|0;K=f;l[o[4966]](2596);d=o[a+196>>2];e=o[a+228>>2];if((d|0)<(e|0)){if(o[a+200>>2]<(e|0)){if(e){o[6257]=o[6257]+1;h=l[o[4968]](e<<2,16)|0;c=o[a+196>>2];}else {c=d;}if((c|0)>=1){while(1){i=g<<2;o[i+h>>2]=o[o[a+204>>2]+i>>2];g=g+1|0;if((c|0)!=(g|0)){continue}break}}c=o[a+204>>2];if(c){if(p[a+208|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+204>>2]=0;}o[a+204>>2]=h;o[a+200>>2]=e;m[a+208|0]=1;}while(1){o[o[a+204>>2]+(d<<2)>>2]=0;d=d+1|0;if((e|0)!=(d|0)){continue}break}}o[a+196>>2]=e;if((l[o[o[a>>2]+104>>2]](a)|0)>=1){d=0;while(1){c=d<<2;o[c+o[a+204>>2]>>2]=o[c+o[a+236>>2]>>2];d=d+1|0;if((d|0)<(l[o[o[a>>2]+104>>2]](a)|0)){continue}break}}c=o[a+196>>2];if((c|0)>=2){yf(a+192|0,f,0,c+ -1|0);}c=0;a:{if(!l[o[o[a>>2]+104>>2]](a)){break a}c=o[a+204>>2];}Qn(o[a+212>>2],b,c,o[a+196>>2],l[o[o[a>>2]+20>>2]](a)|0);c=o[a+216>>2];d=o[a+24>>2];k=c,n=o[a+8>>2],q=l[o[o[d>>2]+36>>2]](d)|0,j=o[o[c>>2]+8>>2],l[j](k|0,n|0,q|0);el(o[a+220>>2],o[a+24>>2],a,o[a+212>>2]);xf(o[a+212>>2]);c=o[a+216>>2];l[o[o[c>>2]+16>>2]](c,b,o[a+72>>2]);l[o[4967]]();K=f+16|0;}function $h(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0),I=v(0),J=v(0),K=v(0);q=s[a+28>>2];z=s[a+44>>2];A=s[a+24>>2];B=s[a+40>>2];g=s[a+20>>2];C=s[a+36>>2];D=v(l[o[o[a>>2]+48>>2]](a));E=v(l[o[o[a>>2]+48>>2]](a));F=v(l[o[o[a>>2]+48>>2]](a));G=s[b+52>>2];h=s[b+24>>2];i=s[b+20>>2];j=s[b+56>>2];k=s[a+24>>2];m=s[a+40>>2];r=s[a+28>>2];H=s[a+44>>2];n=s[b+40>>2];e=s[b+36>>2];I=s[b+48>>2];t=s[b+8>>2];u=s[b>>2];x=s[b+4>>2];y=s[b+16>>2];J=s[a+20>>2];K=s[a+36>>2];f=s[b+32>>2];o[c+12>>2]=0;p=j;j=v(v(K+J)*v(.5));k=v(v(m+k)*v(.5));m=v(v(H+r)*v(.5));r=v(p+v(v(v(f*j)+v(e*k))+v(n*m)));g=v(D+v(v(C-g)*v(.5)));p=v(g*v(w(f)));f=v(E+v(v(B-A)*v(.5)));p=v(p+v(f*v(w(e))));e=v(F+v(v(z-q)*v(.5)));n=v(p+v(e*v(w(n))));s[c+8>>2]=r-n;q=v(G+v(v(v(j*y)+v(k*i))+v(m*h)));h=v(v(v(g*v(w(y)))+v(f*v(w(i))))+v(e*v(w(h))));s[c+4>>2]=q-h;i=v(I+v(v(v(j*u)+v(k*x))+v(m*t)));e=v(v(v(g*v(w(u)))+v(f*v(w(x))))+v(e*v(w(t))));s[c>>2]=i-e;o[d+12>>2]=0;s[d+8>>2]=n+r;s[d+4>>2]=h+q;s[d>>2]=e+i;}function nf(a,b,c,d,e,f){dd(a,4,b,c);o[a>>2]=3640;b=o[d+12>>2];o[a+560>>2]=o[d+8>>2];o[a+564>>2]=b;b=o[d+4>>2];o[a+552>>2]=o[d>>2];o[a+556>>2]=b;b=o[d+28>>2];o[a+576>>2]=o[d+24>>2];o[a+580>>2]=b;b=o[d+20>>2];o[a+568>>2]=o[d+16>>2];o[a+572>>2]=b;b=o[d+44>>2];o[a+592>>2]=o[d+40>>2];o[a+596>>2]=b;b=o[d+36>>2];o[a+584>>2]=o[d+32>>2];o[a+588>>2]=b;b=o[d+60>>2];o[a+608>>2]=o[d+56>>2];o[a+612>>2]=b;b=o[d+52>>2];o[a+600>>2]=o[d+48>>2];o[a+604>>2]=b;b=o[e+12>>2];o[a+624>>2]=o[e+8>>2];o[a+628>>2]=b;b=o[e+4>>2];o[a+616>>2]=o[e>>2];o[a+620>>2]=b;b=o[e+20>>2];o[a+632>>2]=o[e+16>>2];o[a+636>>2]=b;b=o[e+28>>2];o[a+640>>2]=o[e+24>>2];o[a+644>>2]=b;b=o[e+36>>2];o[a+648>>2]=o[e+32>>2];o[a+652>>2]=b;b=o[e+44>>2];o[a+656>>2]=o[e+40>>2];o[a+660>>2]=b;b=o[e+52>>2];o[a+664>>2]=o[e+48>>2];o[a+668>>2]=b;b=o[e+60>>2];o[a+672>>2]=o[e+56>>2];o[a+676>>2]=b;o[a+688>>2]=0;o[a+692>>2]=-1082130432;o[a+696>>2]=1063675494;o[a+700>>2]=1050253722;o[a+704>>2]=1065353216;o[a+708>>2]=0;o[a+712>>2]=0;m[a+716|0]=0;m[a+740|0]=f;o[a+736>>2]=16777216;o[a+764>>2]=0;o[a+756>>2]=0;o[a+760>>2]=0;o[a+748>>2]=0;o[a+752>>2]=0;s[a+732>>2]=f?v(-1):v(1);}function ra(a,b,c){var d=0,e=0;if(c>>>0>=512){H(a|0,b|0,c|0)|0;return}d=a+c|0;a:{if(!((a^b)&3)){b:{if((c|0)<1){c=a;break b}if(!(a&3)){c=a;break b}c=a;while(1){m[c|0]=p[b|0];b=b+1|0;c=c+1|0;if(c>>>0>=d>>>0){break b}if(c&3){continue}break}}a=d&-4;c:{if(a>>>0<64){break c}e=a+ -64|0;if(c>>>0>e>>>0){break c}while(1){o[c>>2]=o[b>>2];o[c+4>>2]=o[b+4>>2];o[c+8>>2]=o[b+8>>2];o[c+12>>2]=o[b+12>>2];o[c+16>>2]=o[b+16>>2];o[c+20>>2]=o[b+20>>2];o[c+24>>2]=o[b+24>>2];o[c+28>>2]=o[b+28>>2];o[c+32>>2]=o[b+32>>2];o[c+36>>2]=o[b+36>>2];o[c+40>>2]=o[b+40>>2];o[c+44>>2]=o[b+44>>2];o[c+48>>2]=o[b+48>>2];o[c+52>>2]=o[b+52>>2];o[c+56>>2]=o[b+56>>2];o[c+60>>2]=o[b+60>>2];b=b- -64|0;c=c- -64|0;if(c>>>0<=e>>>0){continue}break}}if(c>>>0>=a>>>0){break a}while(1){o[c>>2]=o[b>>2];b=b+4|0;c=c+4|0;if(c>>>0<a>>>0){continue}break}break a}if(d>>>0<4){c=a;break a}e=d+ -4|0;if(e>>>0<a>>>0){c=a;break a}c=a;while(1){m[c|0]=p[b|0];m[c+1|0]=p[b+1|0];m[c+2|0]=p[b+2|0];m[c+3|0]=p[b+3|0];b=b+4|0;c=c+4|0;if(c>>>0<=e>>>0){continue}break}}if(c>>>0<d>>>0){while(1){m[c|0]=p[b|0];b=b+1|0;c=c+1|0;if((d|0)!=(c|0)){continue}break}}}function Bu(a,b,c,d){var e=0,f=v(0),g=v(0),h=0,i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=0;g=s[c>>2];a:{b:{if(!(s[b>>2]<=g)){f=s[c+4>>2];break b}f=s[c+4>>2];if(s[b+4>>2]<=f^1|s[b+8>>2]<=s[c+8>>2]^1|(s[b+16>>2]>=s[c+16>>2]^1|s[b+20>>2]>=s[c+20>>2]^1)){break b}e=0;if(s[b+24>>2]>=s[c+24>>2]){break a}}f=v(f-v(.05000000074505806));s[c+4>>2]=f;g=v(g-v(.05000000074505806));s[c>>2]=g;i=v(s[c+8>>2]-v(.05000000074505806));s[c+8>>2]=i;j=v(s[c+16>>2]+v(.05000000074505806));s[c+16>>2]=j;k=v(s[c+20>>2]+v(.05000000074505806));s[c+20>>2]=k;l=v(s[c+24>>2]+v(.05000000074505806));s[c+24>>2]=l;m=s[d>>2];e=m>v(0);s[(e<<4)+c>>2]=(e?j:g)+m;g=s[d+4>>2];e=g>v(0);s[(e?20:4)+c>>2]=(e?k:f)+g;f=s[d+8>>2];d=f>v(0);s[(d?24:8)+c>>2]=(d?l:i)+f;d=yc(a,b);c:{if(!d){d=0;break c}h=o[a+8>>2];if((h|0)>=0){if(!h){break c}while(1){e=o[d+32>>2];if(!e){break c}d=e;n=n+1|0;if((n|0)!=(h|0)){continue}break}break c}d=o[a>>2];}e=o[c+4>>2];o[b>>2]=o[c>>2];o[b+4>>2]=e;e=o[c+28>>2];o[b+24>>2]=o[c+24>>2];o[b+28>>2]=e;e=o[c+20>>2];o[b+16>>2]=o[c+16>>2];o[b+20>>2]=e;e=o[c+12>>2];o[b+8>>2]=o[c+8>>2];o[b+12>>2]=e;xc(a,d,b);e=1;}return e}function ed(a,b){var c=v(0),d=v(0),e=v(0),f=v(0),g=0,h=v(0);d=s[((b<<2)+a|0)+1364>>2];g=u(b,88)+a|0;e=s[g+968>>2];f=s[g+972>>2];a:{if(e>=f){break a}if(!!(d<e)){c=ua(v(e-d));b:{if(!!(c<v(-3.1415927410125732))){c=v(c+v(6.2831854820251465));break b}if(!(c>v(3.1415927410125732))){break b}c=v(c+v(-6.2831854820251465));}h=v(w(c));c=ua(v(f-d));c:{if(!!(c<v(-3.1415927410125732))){c=v(c+v(6.2831854820251465));break c}if(!(c>v(3.1415927410125732))){break c}c=v(c+v(-6.2831854820251465));}d=h<v(w(c))?d:v(d+v(6.2831854820251465));break a}if(!(d>f)){break a}c=ua(v(d-f));d:{if(!!(c<v(-3.1415927410125732))){c=v(c+v(6.2831854820251465));break d}if(!(c>v(3.1415927410125732))){break d}c=v(c+v(-6.2831854820251465));}h=v(w(c));c=ua(v(d-e));e:{if(!!(c<v(-3.1415927410125732))){c=v(c+v(6.2831854820251465));break e}if(!(c>v(3.1415927410125732))){break e}c=v(c+v(-6.2831854820251465));}d=v(w(c))<h?v(d+v(-6.2831854820251465)):d;}s[g+1048>>2]=d;if(!!(e>f)){a=u(b,88)+a|0;o[a+1040>>2]=0;o[a+1052>>2]=0;return}a=u(b,88)+a|0;s[a+1040>>2]=d-e;if(e==f){o[a+1052>>2]=3;return}o[a+1052>>2]=4;s[a+1044>>2]=d-f;}function xf(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0;f=o[a+8>>2];g=f;d=o[a+32>>2];if(d){c=o[a+40>>2];}else {c=0;}h=c;c=o[a+52>>2];if(c){b=o[a+60>>2];}else {b=0;}i=b;b=o[a+72>>2];e=0;a:{if(!b){break a}e=o[a+80>>2];}v(l[o[o[f>>2]+12>>2]](g,h,d,i,c,e,b,o[a+4>>2],o[a+20>>2],o[a+24>>2]));c=o[a+32>>2];if((c|0)<=-1){if(o[a+36>>2]<=-1){b=o[a+40>>2];if(b){if(p[a+44|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+40>>2]=0;}o[a+36>>2]=0;o[a+40>>2]=0;m[a+44|0]=1;}while(1){o[o[a+40>>2]+(c<<2)>>2]=0;b=c+1|0;d=b>>>0>=c>>>0;c=b;if(d){continue}break}}o[a+32>>2]=0;c=o[a+52>>2];if((c|0)<=-1){if(o[a+56>>2]<=-1){b=o[a+60>>2];if(b){if(p[a- -64|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+60>>2]=0;}o[a+56>>2]=0;o[a+60>>2]=0;m[a- -64|0]=1;}while(1){o[o[a+60>>2]+(c<<2)>>2]=0;b=c+1|0;d=b>>>0>=c>>>0;c=b;if(d){continue}break}}o[a+52>>2]=0;c=o[a+72>>2];if((c|0)<=-1){if(o[a+76>>2]<=-1){b=o[a+80>>2];if(b){if(p[a+84|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+80>>2]=0;}o[a+76>>2]=0;o[a+80>>2]=0;m[a+84|0]=1;}while(1){o[o[a+80>>2]+(c<<2)>>2]=0;b=c+1|0;d=b>>>0>=c>>>0;c=b;if(d){continue}break}}o[a+72>>2]=0;}function gd(a){a=a|0;var b=0;o[a>>2]=2328;if(p[a+288|0]){b=o[a+220>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+220>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}b=o[a+212>>2];if(b){l[o[o[b>>2]>>2]](b)|0;b=o[a+212>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}if(p[a+289|0]){b=o[a+216>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+216>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}b=o[a+332>>2];if(b){if(p[a+336|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+332>>2]=0;}o[a+332>>2]=0;o[a+324>>2]=0;o[a+328>>2]=0;m[a+336|0]=1;b=o[a+304>>2];if(b){if(p[a+308|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+304>>2]=0;}o[a+304>>2]=0;o[a+296>>2]=0;o[a+300>>2]=0;m[a+308|0]=1;b=o[a+256>>2];if(b){if(p[a+260|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+256>>2]=0;}o[a+256>>2]=0;o[a+248>>2]=0;o[a+252>>2]=0;m[a+260|0]=1;b=o[a+236>>2];if(b){if(p[a+240|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+236>>2]=0;}o[a+236>>2]=0;o[a+228>>2]=0;o[a+232>>2]=0;m[a+240|0]=1;b=o[a+204>>2];if(b){if(p[a+208|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+204>>2]=0;}o[a+204>>2]=0;o[a+196>>2]=0;o[a+200>>2]=0;m[a+208|0]=1;Sc(a);return a|0}function Si(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=v(0),f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0),H=v(0);e=s[a+44>>2];i=s[a+60>>2];f=o[a+20>>2];g=s[a+40>>2];j=s[a+56>>2];h=s[a+36>>2];k=s[a+52>>2];D=v(l[o[o[a>>2]+48>>2]](a));E=v(l[o[o[a>>2]+48>>2]](a));F=v(l[o[o[a>>2]+48>>2]](a));G=s[b+52>>2];m=s[b+24>>2];t=s[b+20>>2];n=s[b+56>>2];u=s[b+40>>2];x=s[b+36>>2];H=s[b+48>>2];y=s[b+8>>2];z=s[b>>2];A=s[b+4>>2];B=s[b+16>>2];C=s[b+32>>2];o[c+12>>2]=0;p=n;n=f?v(v(k+h)*v(.5)):v(0);q=f?v(v(j+g)*v(.5)):v(0);r=f?v(v(i+e)*v(.5)):v(0);p=v(p+v(v(v(C*n)+v(x*q))+v(u*r)));h=v(D+(f?v(v(k-h)*v(.5)):v(0)));g=v(E+(f?v(v(j-g)*v(.5)):v(0)));e=v(F+(f?v(v(i-e)*v(.5)):v(0)));i=v(v(v(h*v(w(C)))+v(g*v(w(x))))+v(e*v(w(u))));s[c+8>>2]=p-i;j=v(G+v(v(v(n*B)+v(q*t))+v(r*m)));k=v(v(v(h*v(w(B)))+v(g*v(w(t))))+v(e*v(w(m))));s[c+4>>2]=j-k;m=v(H+v(v(v(n*z)+v(q*A))+v(r*y)));e=v(v(v(h*v(w(z)))+v(g*v(w(A))))+v(e*v(w(y))));s[c>>2]=m-e;o[d+12>>2]=0;s[d+8>>2]=i+p;s[d+4>>2]=k+j;s[d>>2]=e+m;}function Ya(a,b,c,d,e,f,g,h){var i=v(0),j=0,k=v(0),l=v(0),m=v(0),n=0,q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0),z=v(0),A=0,B=0,C=0,D=0,E=0,F=0,G=v(0),H=v(0),I=v(0);j=K-16|0;A=o[(g?20:16)+d>>2];n=o[(g?12:8)+d>>2];B=e<<2;o[n+B>>2]=o[f>>2];C=e+1|0;D=C<<2;o[D+n>>2]=o[f+4>>2];F=n;n=e+2|0;E=n<<2;o[F+E>>2]=o[f+8>>2];s[A+B>>2]=-s[f>>2];s[A+D>>2]=-s[f+4>>2];s[A+E>>2]=-s[f+8>>2];if(!g){r=s[a+1348>>2];q=s[c+52>>2];t=s[a+1352>>2];u=s[c+56>>2];G=s[a+1356>>2];m=s[b+56>>2];w=s[a+1292>>2];x=s[a+1284>>2];y=s[b+52>>2];z=s[a+1288>>2];H=s[c+48>>2];k=s[f+8>>2];l=s[f+4>>2];I=s[b+48>>2];i=s[f>>2];o[j+12>>2]=0;x=v(x-I);y=v(z-y);z=v(v(l*x)-v(i*y));s[j+8>>2]=z;m=v(w-m);w=v(v(i*m)-v(x*k));s[j+4>>2]=w;m=v(v(y*k)-v(m*l));s[j>>2]=m;t=v(t-q);u=v(G-u);q=v(v(k*t)-v(l*u));r=v(r-H);l=v(v(l*r)-v(t*i));k=v(v(u*i)-v(r*k));if(!(!p[a+1452|0]|h)){i=s[a+1444>>2];s[j+8>>2]=z*i;s[j+4>>2]=w*i;s[j>>2]=m*i;i=s[a+1448>>2];l=v(l*i);q=v(q*i);k=v(k*i);}c=o[j+4>>2];b=e<<2;a=b+o[d+12>>2]|0;o[a>>2]=o[j>>2];o[a+4>>2]=c;o[a+8>>2]=o[j+8>>2];a=o[d+20>>2];s[a+b>>2]=-q;s[a+(C<<2)>>2]=-k;s[a+(n<<2)>>2]=-l;}}function rk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),n=0,p=v(0);e=K-688|0;K=e;n=zb(e+576|0);o[e+580>>2]=1;o[e+576>>2]=6568;f=o[b+12>>2];o[e+644>>2]=o[b+8>>2];o[e+648>>2]=f;f=o[b+4>>2];o[e+636>>2]=o[b>>2];o[e+640>>2]=f;f=o[b+28>>2];o[e+660>>2]=o[b+24>>2];o[e+664>>2]=f;f=o[b+20>>2];o[e+652>>2]=o[b+16>>2];o[e+656>>2]=f;f=o[b+44>>2];o[e+676>>2]=o[b+40>>2];o[e+680>>2]=f;f=o[b+36>>2];o[e+668>>2]=o[b+32>>2];o[e+672>>2]=f;o[e+624>>2]=o[a+204>>2];m[e+548|0]=0;o[e+524>>2]=953267991;o[e+208>>2]=4308;f=o[a+4>>2];b=e+184|0;o[b+20>>2]=0;o[b+16>>2]=e+576;o[b+12>>2]=f;o[b+8>>2]=e+208;o[b+4>>2]=e+216;o[b>>2]=7344;o[e+8>>2]=6980;o[e+172>>2]=1065353216;o[e+176>>2]=0;o[e+180>>2]=o[a+208>>2];f=b;b=a+136|0;a:{if(!Me(f,a+8|0,a+72|0,b,b,e+8|0)){break a}h=s[e+140>>2];i=s[e+144>>2];g=s[e+148>>2];j=v(v(v(h*h)+v(i*i))+v(g*g));if(!(j>v(9999999747378752e-20))){break a}k=s[e+172>>2];if(!(k<s[a+200>>2])){break a}p=g;g=v(v(1)/v(C(j)));s[e+148>>2]=p*g;s[e+144>>2]=i*g;s[e+140>>2]=h*g;v(l[o[o[a>>2]+12>>2]](a,e+140|0,e+156|0,k,c,d));}kb(n);K=e+688|0;}function Wn(a,b){a=a|0;b=v(b);var c=0,d=v(0),e=v(0),f=0,g=0,h=0,i=0;h=K-16|0;K=h;l[o[4966]](2574);if(o[a+248>>2]>=1){while(1){c=o[o[a+256>>2]+(g<<2)>>2];a:{if(!c){break a}f=o[c+220>>2];i=f+ -2|0;b:{if(!(i-1|0?i>>>0<=2:0)){c:{d=s[c+372>>2];e=v(d*d);d=s[c+376>>2];e=v(e+v(d*d));d=s[c+380>>2];e=v(e+v(d*d));d=s[c+532>>2];if(!(e<v(d*d))){break c}d=s[c+388>>2];e=v(d*d);d=s[c+392>>2];e=v(e+v(d*d));d=s[c+396>>2];e=v(e+v(d*d));d=s[c+536>>2];if(!(e<v(d*d))){break c}s[c+224>>2]=s[c+224>>2]+b;break b}o[c+224>>2]=0;if((o[c+220>>2]&-2)!=4){o[c+220>>2]=0;}f=o[c+220>>2];}if((f|0)==4){break a}}d:{if(p[20820]){break d}d=s[4961];if(d==v(0)|(s[c+224>>2]>d^1?(f&-2)!=2:0)){break d}if(p[c+204|0]&3){if((o[c+220>>2]&-2)!=4){o[c+220>>2]=2;}break a}if((f|0)==1){if((o[c+220>>2]&-2)!=4){o[c+220>>2]=3;}f=o[c+220>>2];}if((f|0)!=2){break a}o[c+388>>2]=0;o[c+392>>2]=0;o[c+372>>2]=0;o[c+376>>2]=0;o[c+396>>2]=0;o[c+400>>2]=0;o[c+380>>2]=0;o[c+384>>2]=0;o[c+304>>2]=o[c+304>>2]+2;break a}if((o[c+220>>2]&-2)!=4){o[c+220>>2]=1;}}g=g+1|0;if((g|0)<o[a+248>>2]){continue}break}}l[o[4967]]();K=h+16|0;}function hp(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=K-48|0;K=d;o[d+40>>2]=a;o[d+36>>2]=b;m[d+35|0]=c;a=o[d+40>>2];b=K-16|0;o[b+12>>2]=o[o[d+36>>2]>>2];a:{if(o[o[b+12>>2]+204>>2]&4){b=K-16|0;o[b+12>>2]=o[a+88>>2];o[d+28>>2]=o[b+12>>2]+348;b:{if(!o[a+92>>2]){b=K-16|0;o[b+12>>2]=o[d+28>>2];o[a+96>>2]=o[o[b+12>>2]+4>>2];b=o[d+28>>2];o[d+24>>2]=1;Ka(b,d+24|0);b=o[d+28>>2];c=K-16|0;o[c+12>>2]=o[a+84>>2];e=K-16|0;o[e+12>>2]=o[o[c+12>>2]+192>>2];o[d+20>>2]=o[o[e+12>>2]+8>>2];Ka(b,d+20|0);break b}c=o[a+92>>2]+1|0;e=o[a+96>>2];b=K-16|0;o[b+12>>2]=o[d+28>>2];o[b+8>>2]=e;o[o[o[b+12>>2]+12>>2]+(o[b+8>>2]<<2)>>2]=c;}b=K-16|0;o[b+12>>2]=o[o[d+36>>2]>>2];o[d+16>>2]=o[o[b+12>>2]+192>>2];c:{if(Sb(o[d+16>>2])&1){o[d+12>>2]=o[d+16>>2];o[d+8>>2]=o[o[o[d+36>>2]+4>>2]+4>>2];b=o[d+28>>2];c=fc(o[d+12>>2],o[d+8>>2]);e=K-16|0;o[e+12>>2]=c;o[d+4>>2]=o[o[e+12>>2]+8>>2];Ka(b,d+4|0);break c}b=o[d+28>>2];c=K-16|0;o[c+12>>2]=o[d+16>>2];o[d>>2]=o[o[c+12>>2]+8>>2];Ka(b,d);}o[a+92>>2]=o[a+92>>2]+1;s[d+44>>2]=1;break a}s[d+44>>2]=Qf(a,o[d+36>>2],m[d+35|0]&1);}K=d+48|0;return v(s[d+44>>2])}function ii(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;Na(a,b,c);d=o[a+52>>2];l[o[o[d>>2]+56>>2]](d,b+12|0,c)|0;o[b+52>>2]=o[a+16>>2];a:{b:{if(!o[a+56>>2]){break b}if(l[o[o[c>>2]+52>>2]](c)&1){break b}d=l[o[o[c>>2]+24>>2]](c,o[a+56>>2])|0;if(d){o[b+44>>2]=0;o[b+40>>2]=d;break a}d=l[o[o[c>>2]+28>>2]](c,o[a+56>>2])|0;o[b+44>>2]=0;o[b+40>>2]=d;d=o[a+56>>2];d=(g=c,h=l[o[o[d>>2]+12>>2]](d)|0,i=1,f=o[o[c>>2]+16>>2],l[f](g|0,h|0,i|0)|0);e=o[a+56>>2];i=c,h=d,g=l[o[o[e>>2]+16>>2]](e,o[d+8>>2],c)|0,j=1213612625,k=o[a+56>>2],f=o[o[c>>2]+20>>2],l[f](i|0,h|0,g|0,j|0,k|0);break a}o[b+40>>2]=0;o[b+44>>2]=0;}c:{d:{if(!o[a+60>>2]){break d}if(l[o[o[c>>2]+52>>2]](c)&2){break d}d=l[o[o[c>>2]+24>>2]](c,o[a+60>>2])|0;if(d){o[b+48>>2]=d;break c}o[b+48>>2]=l[o[o[c>>2]+28>>2]](c,o[a+60>>2]);d=o[a+60>>2];d=(k=c,j=l[o[o[d>>2]+8>>2]](d)|0,g=1,f=o[o[c>>2]+16>>2],l[f](k|0,j|0,g|0)|0);e=o[a+60>>2];g=c,j=d,k=l[o[o[e>>2]+12>>2]](e,o[d+8>>2],c)|0,h=1346456916,i=o[a+60>>2],f=o[o[c>>2]+20>>2],l[f](g|0,j|0,k|0,h|0,i|0);break c}o[b+48>>2]=0;}o[b+56>>2]=0;return 11608}function bg(a,b,c){var d=0;d=K-48|0;K=d;o[d+44>>2]=a;o[d+40>>2]=b;o[d+36>>2]=c;c=o[d+36>>2];b=K-16|0;o[b+12>>2]=o[d+40>>2];o[b+8>>2]=0;s[d+32>>2]=bb(c,o[b+12>>2]+(o[b+8>>2]<<4)|0);c=o[d+36>>2];b=K-16|0;o[b+12>>2]=o[d+40>>2];o[b+8>>2]=0;s[d+28>>2]=ab(c,o[b+12>>2]+(o[b+8>>2]<<4)|0);c=o[d+36>>2];b=K-16|0;o[b+12>>2]=o[d+40>>2];o[b+8>>2]=0;s[d+24>>2]=$a(c,o[b+12>>2]+(o[b+8>>2]<<4)|0);c=o[d+36>>2];b=K-16|0;o[b+12>>2]=o[d+40>>2];o[b+8>>2]=1;s[d+20>>2]=bb(c,o[b+12>>2]+(o[b+8>>2]<<4)|0);c=o[d+36>>2];b=K-16|0;o[b+12>>2]=o[d+40>>2];o[b+8>>2]=1;s[d+16>>2]=ab(c,o[b+12>>2]+(o[b+8>>2]<<4)|0);c=o[d+36>>2];b=K-16|0;o[b+12>>2]=o[d+40>>2];o[b+8>>2]=1;s[d+12>>2]=$a(c,o[b+12>>2]+(o[b+8>>2]<<4)|0);c=o[d+36>>2];b=K-16|0;o[b+12>>2]=o[d+40>>2];o[b+8>>2]=2;s[d+8>>2]=bb(c,o[b+12>>2]+(o[b+8>>2]<<4)|0);c=o[d+36>>2];b=K-16|0;o[b+12>>2]=o[d+40>>2];o[b+8>>2]=2;s[d+4>>2]=ab(c,o[b+12>>2]+(o[b+8>>2]<<4)|0);c=o[d+36>>2];b=K-16|0;o[b+12>>2]=o[d+40>>2];o[b+8>>2]=2;s[d>>2]=$a(c,o[b+12>>2]+(o[b+8>>2]<<4)|0);ac(a,d+32|0,d+28|0,d+24|0,d+20|0,d+16|0,d+12|0,d+8|0,d+4|0,d);K=d+48|0;}function Je(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;f=K-96|0;K=f;e=o[a+8>>2];o[b+216>>2]=e;a:{if(o[a+12>>2]!=(e|0)){break a}h=e?e<<1:1;if((e|0)>=(h|0)){break a}if(h){o[6257]=o[6257]+1;i=l[o[4968]](h<<2,16)|0;e=o[a+8>>2];}if((e|0)>=1){while(1){j=g<<2;o[j+i>>2]=o[o[a+16>>2]+j>>2];g=g+1|0;if((g|0)!=(e|0)){continue}break}}g=o[a+16>>2];if(g){if(p[a+20|0]){if(g){o[6258]=o[6258]+1;l[o[4969]](g);}e=o[a+8>>2];}o[a+16>>2]=0;}o[a+16>>2]=i;o[a+12>>2]=h;m[a+20|0]=1;}o[o[a+16>>2]+(e<<2)>>2]=b;o[a+8>>2]=e+1;e=o[b+16>>2];o[f+40>>2]=o[b+12>>2];o[f+44>>2]=e;e=o[b+8>>2];o[f+32>>2]=o[b+4>>2];o[f+36>>2]=e;e=o[b+32>>2];o[f+56>>2]=o[b+28>>2];o[f+60>>2]=e;e=o[b+24>>2];o[f+48>>2]=o[b+20>>2];o[f+52>>2]=e;e=o[b+48>>2];o[f+72>>2]=o[b+44>>2];o[f+76>>2]=e;e=o[b+40>>2];o[f+64>>2]=o[b+36>>2];o[f+68>>2]=e;e=o[b+64>>2];o[f+88>>2]=o[b+60>>2];o[f+92>>2]=e;e=o[b+56>>2];o[f+80>>2]=o[b+52>>2];o[f+84>>2]=e;e=o[b+192>>2];l[o[o[e>>2]+8>>2]](e,f+32|0,f+16|0,f);e=o[a+68>>2];o[b+188>>2]=l[o[o[e>>2]+8>>2]](e,f+16|0,f,o[o[b+192>>2]+4>>2],b,c,d,o[a+24>>2]);K=f+96|0;}function Em(a,b,c){a=a|0;b=b|0;c=c|0;Vb(a,b,c);o[b+52>>2]=o[a+552>>2];o[b+56>>2]=o[a+556>>2];o[b+60>>2]=o[a+560>>2];o[b+64>>2]=o[a+564>>2];o[b+68>>2]=o[a+568>>2];o[b+72>>2]=o[a+572>>2];o[b+76>>2]=o[a+576>>2];o[b+80>>2]=o[a+580>>2];o[b+84>>2]=o[a+584>>2];o[b+88>>2]=o[a+588>>2];o[b+92>>2]=o[a+592>>2];o[b+96>>2]=o[a+596>>2];o[b+100>>2]=o[a+600>>2];o[b+104>>2]=o[a+604>>2];o[b+108>>2]=o[a+608>>2];o[b+112>>2]=o[a+612>>2];o[b+116>>2]=o[a+616>>2];o[b+120>>2]=o[a+620>>2];o[b+124>>2]=o[a+624>>2];o[b+128>>2]=o[a+628>>2];o[b+132>>2]=o[a+632>>2];o[b+136>>2]=o[a+636>>2];o[b+140>>2]=o[a+640>>2];o[b+144>>2]=o[a+644>>2];o[b+148>>2]=o[a+648>>2];o[b+152>>2]=o[a+652>>2];o[b+156>>2]=o[a+656>>2];o[b+160>>2]=o[a+660>>2];o[b+164>>2]=o[a+664>>2];o[b+168>>2]=o[a+668>>2];o[b+172>>2]=o[a+672>>2];o[b+176>>2]=o[a+676>>2];o[b+184>>2]=p[a+736|0];o[b+188>>2]=p[a+737|0];o[b+196>>2]=o[a+684>>2];o[b+192>>2]=o[a+680>>2];o[b+180>>2]=p[a+740|0];c=a+688|0;s[b+200>>2]=Tb(c);s[b+204>>2]=Ub(c);o[b+208>>2]=o[a+696>>2];o[b+212>>2]=o[a+700>>2];o[b+216>>2]=o[a+704>>2];return 3720}function vo(a,b,c){var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0),y=v(0);f=s[b+396>>2];n=s[b+44>>2];p=s[b+40>>2];q=s[b+36>>2];i=s[b+392>>2];r=s[b+28>>2];j=s[b+12>>2];d=s[b+464>>2];t=s[b+24>>2];k=s[b+8>>2];l=s[b+460>>2];u=s[b+20>>2];e=s[b+388>>2];w=s[b+4>>2];m=s[b+456>>2];o[a+12>>2]=0;m=m!=v(0)?v(v(1)/m):v(0);g=v(u*m);l=l!=v(0)?v(v(1)/l):v(0);h=v(t*l);x=d!=v(0)?v(v(1)/d):v(0);d=v(r*x);y=v(v(v(e*v(v(v(w*g)+v(k*h))+v(j*d)))+v(i*v(v(v(g*u)+v(h*t))+v(d*r))))+v(f*v(v(v(g*q)+v(h*p))+v(d*n))));d=v(m*w);g=v(l*k);h=v(x*j);g=v(v(v(e*v(v(v(w*d)+v(k*g))+v(j*h)))+v(i*v(v(v(d*u)+v(g*t))+v(h*r))))+v(f*v(v(v(d*q)+v(g*p))+v(h*n))));d=v(v(e*y)-v(i*g));s[a+8>>2]=d;h=e;e=v(m*q);m=k;k=v(l*p);l=j;j=v(x*n);n=v(v(v(h*v(v(v(w*e)+v(m*k))+v(l*j)))+v(i*v(v(v(e*u)+v(k*t))+v(j*r))))+v(f*v(v(v(e*q)+v(k*p))+v(j*n))));e=v(v(f*g)-v(h*n));s[a+4>>2]=e;f=v(v(i*n)-v(f*y));s[a>>2]=f;i=v(v(d*d)+v(v(f*f)+v(e*e)));if(!!(i>v(c*c))){c=v(v(v(1)/v(C(i)))*c);s[a+8>>2]=d*c;s[a+4>>2]=e*c;s[a>>2]=f*c;}}function yo(a,b){var c=0,d=0,e=v(0),f=v(0),g=v(0),h=v(0);d=K-32|0;K=d;if(b!=v(0)){c=o[a+540>>2];if(c){l[o[o[c>>2]+8>>2]](c,a+4|0);}o[a+384>>2]=0;b=v(v(1)/b);s[a+380>>2]=b*v(s[a+60>>2]-s[a+124>>2]);s[a+376>>2]=b*v(s[a+56>>2]-s[a+120>>2]);s[a+372>>2]=b*v(s[a+52>>2]-s[a+116>>2]);_b(a+68|0,a+4|0,d+16|0,d+12|0);f=s[d+16>>2];g=s[d+20>>2];h=s[d+24>>2];e=s[d+12>>2];o[a+400>>2]=0;s[a+396>>2]=b*v(e*h);s[a+392>>2]=b*v(e*g);s[a+388>>2]=b*v(f*e);c=o[a+384>>2];o[a+140>>2]=o[a+380>>2];o[a+144>>2]=c;c=o[a+376>>2];o[a+132>>2]=o[a+372>>2];o[a+136>>2]=c;c=o[a+392>>2];o[a+148>>2]=o[a+388>>2];o[a+152>>2]=c;c=o[a+400>>2];o[a+156>>2]=o[a+396>>2];o[a+160>>2]=c;c=o[a+8>>2];o[a+68>>2]=o[a+4>>2];o[a+72>>2]=c;c=o[a+16>>2];o[a+76>>2]=o[a+12>>2];o[a+80>>2]=c;c=o[a+24>>2];o[a+84>>2]=o[a+20>>2];o[a+88>>2]=c;c=o[a+32>>2];o[a+92>>2]=o[a+28>>2];o[a+96>>2]=c;c=o[a+48>>2];o[a+108>>2]=o[a+44>>2];o[a+112>>2]=c;c=o[a+40>>2];o[a+100>>2]=o[a+36>>2];o[a+104>>2]=c;c=o[a+64>>2];o[a+124>>2]=o[a+60>>2];o[a+128>>2]=c;c=o[a+56>>2];o[a+116>>2]=o[a+52>>2];o[a+120>>2]=c;}K=d+32|0;}function Oe(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0);d=K-160|0;K=d;o[d+112>>2]=o[b>>2];o[d+64>>2]=o[b+64>>2];o[d+116>>2]=o[b+4>>2];o[d+68>>2]=o[b+68>>2];o[d+120>>2]=o[b+8>>2];o[d+72>>2]=o[b+72>>2];o[d+128>>2]=o[b+16>>2];o[d+80>>2]=o[b+80>>2];o[d+132>>2]=o[b+20>>2];o[d+84>>2]=o[b+84>>2];o[d+136>>2]=o[b+24>>2];o[d+88>>2]=o[b+88>>2];o[d+144>>2]=o[b+32>>2];o[d+96>>2]=o[b+96>>2];o[d+148>>2]=o[b+36>>2];o[d+100>>2]=o[b+100>>2];o[d+152>>2]=o[b+40>>2];o[d+104>>2]=o[b+104>>2];e=o[a+4>>2];g=s[e+40>>2];f=s[e+36>>2];h=s[e+32>>2];i=v(l[o[o[e>>2]+48>>2]](e));j=v(l[o[o[e>>2]+48>>2]](e));k=v(l[o[o[e>>2]+48>>2]](e));o[d+36>>2]=0;f=v(f+j);s[d+28>>2]=f+f;f=v(h+i);s[d+24>>2]=f+f;g=v(g+k);s[d+32>>2]=g+g;a=o[a+8>>2];g=s[a+40>>2];f=s[a+36>>2];h=s[a+32>>2];i=v(l[o[o[a>>2]+48>>2]](a));j=v(l[o[o[a>>2]+48>>2]](a));k=v(l[o[o[a>>2]+48>>2]](a));o[d+20>>2]=0;f=v(f+j);s[d+12>>2]=f+f;f=v(h+i);s[d+8>>2]=f+f;g=v(g+k);s[d+16>>2]=g+g;Bk(b+48|0,d+112|0,d+24|0,b+112|0,d- -64|0,d+8|0,d+48|0,d+44|0,d+40|0,c);K=d+160|0;}function Wa(a,b,c,d,e,f,g){var h=v(0),i=v(0),j=0,k=0,l=0,m=v(0),n=v(0),p=v(0),q=0;j=K-16|0;o[d>>2]=2139095039;k=-8388609;o[e>>2]=-8388609;q=o[a+8>>2];h=v(-3.4028234663852886e+38);a:{if((q|0)<1){break a}k=0;while(1){l=o[a+16>>2]+(k<<4)|0;h=s[l>>2];i=s[l+4>>2];m=s[l+8>>2];n=v(v(v(v(h*s[b>>2])+v(i*s[b+4>>2]))+v(m*s[b+8>>2]))+s[b+48>>2]);p=v(v(v(v(h*s[b+16>>2])+v(i*s[b+20>>2]))+v(m*s[b+24>>2]))+s[b+52>>2]);i=v(v(v(v(h*s[b+32>>2])+v(i*s[b+36>>2]))+v(m*s[b+40>>2]))+s[b+56>>2]);h=v(v(v(n*s[c>>2])+v(p*s[c+4>>2]))+v(i*s[c+8>>2]));if(!!(h<s[d>>2])){s[d>>2]=h;o[f+12>>2]=0;s[f+8>>2]=i;s[f+4>>2]=p;s[f>>2]=n;}if(!!(h>s[e>>2])){s[e>>2]=h;o[g+12>>2]=0;s[g+8>>2]=i;s[g+4>>2]=p;s[g>>2]=n;}k=k+1|0;if((q|0)!=(k|0)){continue}break}k=o[e>>2];h=s[e>>2];}i=s[d>>2];if(i>h){o[d>>2]=k;s[e>>2]=i;a=o[f+12>>2];o[j+8>>2]=o[f+8>>2];o[j+12>>2]=a;a=o[f+4>>2];o[j>>2]=o[f>>2];o[j+4>>2]=a;a=o[g+12>>2];o[f+8>>2]=o[g+8>>2];o[f+12>>2]=a;a=o[g+4>>2];o[f>>2]=o[g>>2];o[f+4>>2]=a;a=o[j+12>>2];o[g+8>>2]=o[j+8>>2];o[g+12>>2]=a;a=o[j+4>>2];o[g>>2]=o[j>>2];o[g+4>>2]=a;}}function Jh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=v(0),h=0,i=0,j=0,k=0,m=0,n=0,p=0,q=0,r=v(0),t=0,u=v(0),w=v(0),x=v(0);i=K-2048|0;K=i;if((d|0)>0){while(1){o[((e<<4)+c|0)+12>>2]=-581039253;e=e+1|0;if((e|0)!=(d|0)){continue}break}while(1){if((l[o[o[a>>2]+96>>2]](a)|0)>=1){e=n<<4;j=e+c|0;q=j;p=b+e|0;t=p;k=0;while(1){m=128;a:{b:{if(((l[o[o[a>>2]+96>>2]](a)|0)-k|0)>127){break b}m=(l[o[o[a>>2]+96>>2]](a)|0)-k|0;if((m|0)>=1){break b}g=v(-3.4028234663852886e+38);f=-1;break a}e=0;while(1){l[o[o[a>>2]+108>>2]](a,e,(e<<4)+i|0);e=e+1|0;if((m|0)!=(e|0)){continue}break}u=s[t+8>>2];w=s[p+4>>2];x=s[p>>2];e=0;f=-1;g=v(-3.4028234663852886e+38);while(1){h=(e<<4)+i|0;r=v(v(v(x*s[h>>2])+v(w*s[h+4>>2]))+v(u*s[h+8>>2]));h=r>g;g=h?r:g;f=h?e:f;e=e+1|0;if((m|0)!=(e|0)){continue}break}}if(!!(g>s[q+12>>2])){e=(f<<4)+i|0;f=o[e+12>>2];o[j+8>>2]=o[e+8>>2];o[j+12>>2]=f;f=o[e+4>>2];o[j>>2]=o[e>>2];o[j+4>>2]=f;s[q+12>>2]=g;}k=k+128|0;if((k|0)<(l[o[o[a>>2]+96>>2]](a)|0)){continue}break}}n=n+1|0;if((n|0)!=(d|0)){continue}break}}K=i+2048|0;}function Kh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=0,j=0,k=0,m=0,n=v(0),p=v(0),q=v(0);i=K-2048|0;K=i;o[a>>2]=0;o[a+4>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;g=s[c>>2];e=s[c+4>>2];h=s[c+8>>2];f=v(v(v(g*g)+v(e*e))+v(h*h));n=v(1);a:{if(f<v(9999999747378752e-20)){break a}f=v(v(1)/v(C(f)));p=v(h*f);q=v(e*f);n=v(g*f);}f=n;if((l[o[o[b>>2]+96>>2]](b)|0)>=1){h=v(-0xde0b6b000000000);while(1){j=128;b:{c:{if(((l[o[o[b>>2]+96>>2]](b)|0)-k|0)>127){break c}j=(l[o[o[b>>2]+96>>2]](b)|0)-k|0;if((j|0)>=1){break c}e=v(-3.4028234663852886e+38);m=-1;break b}c=0;d=0;while(1){l[o[o[b>>2]+108>>2]](b,d,(d<<4)+i|0);d=d+1|0;if((j|0)!=(d|0)){continue}break}m=-1;e=v(-3.4028234663852886e+38);while(1){d=(c<<4)+i|0;g=v(v(v(f*s[d>>2])+v(q*s[d+4>>2]))+v(p*s[d+8>>2]));d=g>e;e=d?g:e;m=d?c:m;c=c+1|0;if((j|0)!=(c|0)){continue}break}}if(!!(e>h)){d=(m<<4)+i|0;c=o[d+12>>2];o[a+8>>2]=o[d+8>>2];o[a+12>>2]=c;c=o[d+4>>2];o[a>>2]=o[d>>2];o[a+4>>2]=c;h=e;}k=k+128|0;if((k|0)<(l[o[o[b>>2]+96>>2]](b)|0)){continue}break}}K=i+2048|0;}function jb(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;if(p[a+164|0]){c=o[a+128>>2];a:{if((c|0)!=o[a+132>>2]){break a}d=c?c<<1:1;if((c|0)>=(d|0)){break a}if(d){o[6257]=o[6257]+1;f=l[o[4968]](d<<2,16)|0;c=o[a+128>>2];}e=o[a+136>>2];b:{c:{if((c|0)>=1){while(1){h=g<<2;o[h+f>>2]=o[e+h>>2];g=g+1|0;if((g|0)!=(c|0)){continue}break c}}if(!e){break b}}if(p[a+140|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[a+136>>2]=0;c=o[a+128>>2];}o[a+136>>2]=f;o[a+132>>2]=d;m[a+140|0]=1;}d=c<<2;c=o[a+136>>2];o[d+c>>2]=b;o[a+128>>2]=o[a+128>>2]+1;o[o[a+32>>2]+4>>2]=c;return}c=o[a+148>>2];d:{if((c|0)!=o[a+152>>2]){break d}d=c?c<<1:1;if((c|0)>=(d|0)){break d}if(d){o[6257]=o[6257]+1;f=l[o[4968]](d<<1,16)|0;c=o[a+148>>2];}e=o[a+156>>2];e:{f:{if((c|0)>=1){while(1){h=g<<1;n[h+f>>1]=q[e+h>>1];g=g+1|0;if((g|0)!=(c|0)){continue}break f}}if(!e){break e}}if(p[a+160|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}c=o[a+148>>2];}o[a+156>>2]=0;}o[a+156>>2]=f;o[a+152>>2]=d;m[a+160|0]=1;}f=o[a+156>>2];n[f+(c<<1)>>1]=b;o[a+148>>2]=c+1;o[o[a+32>>2]+4>>2]=f;}function _d(a){var b=0,c=0;b=K-48|0;K=b;o[b+44>>2]=0;o[b+36>>2]=0;o[b+40>>2]=0;o[b+32>>2]=1065353216;l[o[o[a>>2]+68>>2]](b+16|0,a,b+32|0);s[a+36>>2]=s[b+16>>2]+s[a+16>>2];o[b+32>>2]=-1082130432;l[o[o[a>>2]+68>>2]](b,a,b+32|0);c=o[b+12>>2];o[b+24>>2]=o[b+8>>2];o[b+28>>2]=c;c=o[b+4>>2];o[b+16>>2]=o[b>>2];o[b+20>>2]=c;s[a+20>>2]=s[b+16>>2]-s[a+16>>2];o[b+32>>2]=0;o[b+36>>2]=0;o[b+40>>2]=0;o[b+44>>2]=0;o[b+36>>2]=1065353216;l[o[o[a>>2]+68>>2]](b+16|0,a,b+32|0);s[a+40>>2]=s[b+20>>2]+s[a+16>>2];o[b+36>>2]=-1082130432;l[o[o[a>>2]+68>>2]](b,a,b+32|0);c=o[b+12>>2];o[b+24>>2]=o[b+8>>2];o[b+28>>2]=c;c=o[b+4>>2];o[b+16>>2]=o[b>>2];o[b+20>>2]=c;s[a+24>>2]=s[b+20>>2]-s[a+16>>2];o[b+40>>2]=0;o[b+44>>2]=0;o[b+32>>2]=0;o[b+36>>2]=0;o[b+40>>2]=1065353216;l[o[o[a>>2]+68>>2]](b+16|0,a,b+32|0);s[a+44>>2]=s[b+24>>2]+s[a+16>>2];o[b+40>>2]=-1082130432;l[o[o[a>>2]+68>>2]](b,a,b+32|0);c=o[b+12>>2];o[b+24>>2]=o[b+8>>2];o[b+28>>2]=c;c=o[b+4>>2];o[b+16>>2]=o[b>>2];o[b+20>>2]=c;s[a+28>>2]=s[b+24>>2]-s[a+16>>2];K=b+48|0;}function Yh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=v(0),g=v(0),h=v(0),i=v(0);d=K-160|0;K=d;o[d+152>>2]=0;o[d+144>>2]=0;o[d+148>>2]=0;o[d+136>>2]=0;o[d+140>>2]=0;o[d+44>>2]=0;o[d+48>>2]=0;o[d+56>>2]=0;o[d+60>>2]=0;e=d- -64|0;o[e>>2]=0;o[e+4>>2]=0;o[d+76>>2]=0;o[d+80>>2]=0;o[d+72>>2]=1065353216;o[d+84>>2]=0;o[d+88>>2]=0;o[d+92>>2]=1065353216;o[d+96>>2]=0;e=o[d+144>>2];o[d+100>>2]=o[d+140>>2];o[d+104>>2]=e;e=o[d+152>>2];o[d+108>>2]=o[d+148>>2];o[d+112>>2]=e;o[d+36>>2]=0;o[d+40>>2]=0;o[d+32>>2]=12412;o[d+52>>2]=1065353216;o[d+116>>2]=-581039253;f=s[c+4>>2];g=s[c>>2];h=s[c+8>>2];o[d+132>>2]=0;i=v(h*v(0));s[d+124>>2]=v(f+v(g*s[d+56>>2]))+i;f=v(f*v(0));s[d+128>>2]=h+v(v(g*s[d+60>>2])+f);s[d+120>>2]=v(g+f)+i;o[d+24>>2]=1566444395;o[d+28>>2]=0;o[d+16>>2]=1566444395;o[d+20>>2]=1566444395;o[d+8>>2]=-581039253;o[d+12>>2]=0;o[d>>2]=-581039253;o[d+4>>2]=-581039253;l[o[o[b>>2]+64>>2]](b,d+32|0,d,d+16|0);b=o[d+48>>2];o[a+8>>2]=o[d+44>>2];o[a+12>>2]=b;b=o[d+40>>2];o[a>>2]=o[d+36>>2];o[a+4>>2]=b;K=d+160|0;}function Yv(a,b,c,d,e,f,g,h,i,j){var k=v(0),l=v(0),n=v(0),p=v(0);o[a+112>>2]=1065353216;o[a+116>>2]=1065353216;o[a+108>>2]=h;m[a+105|0]=0;m[a+106|0]=0;m[a+104|0]=j;o[a+100>>2]=i;o[a+96>>2]=d;s[a+92>>2]=e;s[a+80>>2]=g;s[a+76>>2]=f;o[a+72>>2]=c;o[a+68>>2]=b;o[a+4>>2]=24;o[a+120>>2]=1065353216;o[a+124>>2]=0;e=v(c+ -1|0);s[a+88>>2]=e;k=v(b+ -1|0);s[a+84>>2]=k;a:{b:{c:{d:{e:{if(h>>>0<=2){switch(h-1|0){case 1:break c;case 0:break d;default:break e}}l=s[a+44>>2];n=s[a+28>>2];e=s[a+40>>2];p=s[a+24>>2];g=s[a+36>>2];f=s[a+20>>2];break a}s[a+36>>2]=g;s[a+20>>2]=f;o[a+48>>2]=0;s[a+44>>2]=e;s[a+40>>2]=k;o[a+32>>2]=0;o[a+24>>2]=0;o[a+28>>2]=0;l=e;e=k;break a}s[a+36>>2]=k;o[a+20>>2]=0;o[a+48>>2]=0;s[a+44>>2]=e;s[a+40>>2]=g;o[a+28>>2]=0;o[a+32>>2]=0;s[a+24>>2]=f;l=e;e=g;p=f;f=v(0);break b}s[a+36>>2]=k;o[a+20>>2]=0;o[a+24>>2]=0;o[a+48>>2]=0;s[a+44>>2]=g;s[a+40>>2]=e;o[a+32>>2]=0;s[a+28>>2]=f;l=g;}n=f;g=k;f=v(0);}o[a- -64>>2]=0;s[a+60>>2]=v(n+l)*v(.5);s[a+56>>2]=v(p+e)*v(.5);s[a+52>>2]=v(f+g)*v(.5);}function Fk(a,b,c){a=a|0;b=b|0;c=v(c);var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=0,j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=0,t=0;i=K-32|0;K=i;d=s[a+60>>2];f=v(s[a+76>>2]-d);e=s[a- -64>>2];g=v(s[a+96>>2]-e);j=v(s[a+80>>2]-e);k=v(s[a+92>>2]-d);h=v(v(f*g)-v(j*k));m=h;q=v(h*h);p=j;j=s[a+68>>2];h=v(s[a+100>>2]-j);n=v(s[a+84>>2]-j);g=v(v(p*h)-v(n*g));f=v(v(n*k)-v(f*h));k=v(v(1)/v(C(v(q+v(v(g*g)+v(f*f))))));h=v(m*k);g=v(g*k);f=v(f*k);d=v(v(v(s[b+8>>2]*h)+v(v(s[b>>2]*g)+v(s[b+4>>2]*f)))-v(v(j*h)+v(v(d*g)+v(e*f))));j=v(-c);a:{if(d>=j^1|d<=c^1){break a}while(1){b:{l[o[o[a>>2]+104>>2]](a,r,i+16|0,i);k=s[i+16>>2];d=v(s[i>>2]-k);n=s[i+20>>2];e=v(s[i+4>>2]-n);c=v(v(f*d)-v(g*e));m=c;q=v(c*c);c=v(h*e);p=s[i+24>>2];e=v(s[i+8>>2]-p);c=v(c-v(f*e));d=v(v(g*e)-v(h*d));e=v(v(1)/v(C(v(q+v(v(c*c)+v(d*d))))));m=v(m*e);c=v(c*e);d=v(d*e);if(!!(v(v(v(s[b+8>>2]*m)+v(v(s[b>>2]*c)+v(s[b+4>>2]*d)))-v(v(p*m)+v(v(k*c)+v(n*d))))<j)){break b}t=1;r=r+1|0;if((r|0)!=3){continue}break a}break}t=0;}K=i+32|0;return t|0}function mj(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0;d=c<<16|b;d=(d<<15^-1)+d|0;d=u(d>>>10^d,9);d=d>>>6^d;d=(d<<11^-1)+d|0;k=d>>>16^d;d=o[a+12>>2];g=k&d+ -1;f=o[o[a+36>>2]+(g<<2)>>2];a:{if((f|0)!=-1){h=o[a+16>>2];while(1){e=h+u(f,12)|0;if(o[e+4>>2]==(c|0)?o[e>>2]==(b|0):0){break a}f=o[o[a+56>>2]+(f<<2)>>2];if((f|0)!=-1){continue}break}}f=a;b:{c:{h=o[a+8>>2];e=h;if((e|0)==(d|0)){e=d?d<<1:1;if((d|0)<(e|0)){break c}}else {d=e;}o[f+8>>2]=d+1;j=o[a+16>>2];break b}if(e){o[6257]=o[6257]+1;j=l[o[4968]](u(e,12),16)|0;d=o[a+8>>2];}if((d|0)>=1){f=0;while(1){i=u(f,12);g=i+o[a+16>>2]|0;n=o[g+4>>2];i=j+i|0;o[i>>2]=o[g>>2];o[i+4>>2]=n;o[i+8>>2]=o[g+8>>2];f=f+1|0;if((f|0)!=(d|0)){continue}break}}d=o[a+16>>2];if(d){if(p[a+20|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[a+16>>2]=0;}o[a+16>>2]=j;o[a+12>>2]=e;m[a+20|0]=1;o[a+8>>2]=o[a+8>>2]+1;Kc(a);g=o[a+12>>2]+ -1&k;}e=u(h,12)+j|0;o[e+8>>2]=0;o[e+4>>2]=c;o[e>>2]=b;b=o[a+56>>2]+(h<<2)|0;a=o[a+36>>2]+(g<<2)|0;o[b>>2]=o[a>>2];o[a>>2]=h;}return e}function me(a){a=a|0;var b=0;o[a>>2]=11020;b=o[a+68>>2];if(b){Md(b);b=o[a+68>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}b=o[a+172>>2];if(b){if(p[a+176|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+172>>2]=0;}o[a+172>>2]=0;o[a+164>>2]=0;o[a+168>>2]=0;m[a+176|0]=1;b=o[a+152>>2];if(b){if(p[a+156|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+152>>2]=0;}o[a+152>>2]=0;o[a+144>>2]=0;o[a+148>>2]=0;m[a+156|0]=1;b=o[a+132>>2];if(b){if(p[a+136|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+132>>2]=0;}o[a+132>>2]=0;o[a+124>>2]=0;o[a+128>>2]=0;m[a+136|0]=1;b=o[a+112>>2];if(b){if(p[a+116|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+112>>2]=0;}o[a+112>>2]=0;o[a+104>>2]=0;o[a+108>>2]=0;m[a+116|0]=1;b=o[a+92>>2];if(b){if(p[a+96|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+92>>2]=0;}o[a+92>>2]=0;o[a+84>>2]=0;o[a+88>>2]=0;m[a+96|0]=1;b=o[a+28>>2];if(b){if(p[a+32|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+28>>2]=0;}o[a+28>>2]=0;o[a+20>>2]=0;o[a+24>>2]=0;m[a+32|0]=1;return a|0}function Cf(a,b){var c=0,d=0,e=0,f=0;a:{d=o[a+548>>2];if((d|0)<1){break a}e=o[a+556>>2];while(1){if(o[e+(c<<2)>>2]!=(b|0)){c=c+1|0;if((d|0)!=(c|0)){continue}break a}break}if((c|0)>=(d|0)){break a}c=0;b:{while(1){f=e+(c<<2)|0;if(o[f>>2]!=(b|0)){c=c+1|0;if((d|0)!=(c|0)){continue}break b}break}if((d|0)<=(c|0)){break b}c=d+ -1|0;d=c<<2;o[f>>2]=o[d+e>>2];o[d+o[a+556>>2]>>2]=b;o[a+548>>2]=c;}d=o[b+32>>2];e=o[b+28>>2];if((e|0)==(a|0)){b=o[a+288>>2];c:{if((b|0)<1){break c}e=o[a+296>>2];c=0;while(1){f=e+(c<<2)|0;if((d|0)!=o[f>>2]){c=c+1|0;if((c|0)!=(b|0)){continue}break c}break}if((b|0)<=(c|0)){break c}b=b+ -1|0;c=b<<2;o[f>>2]=o[c+e>>2];o[c+o[a+296>>2]>>2]=d;o[a+288>>2]=b;}o[a+280>>2]=(b|0)>0;return}b=o[d+288>>2];d:{if((b|0)<1){break d}a=o[d+296>>2];c=0;while(1){f=a+(c<<2)|0;if((e|0)!=o[f>>2]){c=c+1|0;if((c|0)!=(b|0)){continue}break d}break}if((b|0)<=(c|0)){break d}c=a;b=b+ -1|0;a=b<<2;o[f>>2]=o[c+a>>2];o[a+o[d+296>>2]>>2]=e;o[d+288>>2]=b;}o[d+280>>2]=(b|0)>0;}}function mm(a,b,c){var d=0,e=0,f=v(0),g=v(0),h=v(0);d=K-80|0;K=d;a:{if(!o[a+240>>2]){break a}s[a+176>>2]=s[a+64>>2]+s[a+176>>2];s[a+192>>2]=s[a+80>>2]+s[a+192>>2];s[a+180>>2]=s[a+68>>2]+s[a+180>>2];s[a+184>>2]=s[a+72>>2]+s[a+184>>2];s[a+196>>2]=s[a+84>>2]+s[a+196>>2];s[a+200>>2]=s[a+88>>2]+s[a+200>>2];b:{if(s[a+144>>2]!=v(0)|s[a+148>>2]!=v(0)|(s[a+152>>2]!=v(0)|s[a+160>>2]!=v(0))){break b}if(s[a+164>>2]!=v(0)){break b}if(s[a+168>>2]==v(0)){break a}}f=s[a+164>>2];g=s[a+168>>2];h=s[a+160>>2];o[d+12>>2]=0;s[d>>2]=h*c;s[d+8>>2]=g*c;s[d+4>>2]=f*c;_a(a,a+144|0,d,b,d+16|0);e=o[d+28>>2];o[a+8>>2]=o[d+24>>2];o[a+12>>2]=e;e=o[d+20>>2];o[a>>2]=o[d+16>>2];o[a+4>>2]=e;e=o[d+44>>2];o[a+24>>2]=o[d+40>>2];o[a+28>>2]=e;e=o[d+36>>2];o[a+16>>2]=o[d+32>>2];o[a+20>>2]=e;e=o[d+52>>2];o[a+32>>2]=o[d+48>>2];o[a+36>>2]=e;e=o[d+60>>2];o[a+40>>2]=o[d+56>>2];o[a+44>>2]=e;e=o[d+68>>2];o[a+48>>2]=o[d+64>>2];o[a+52>>2]=e;e=o[d+76>>2];o[a+56>>2]=o[d+72>>2];o[a+60>>2]=e;}K=d+80|0;}function yc(a,b){var c=0,d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0);if(o[a>>2]==(b|0)){o[a>>2]=0;return 0}d=o[b+32>>2];c=o[(((o[d+40>>2]!=(b|0))<<2)+d|0)+36>>2];b=o[d+32>>2];a:{b:{if(b){o[((((d|0)==o[b+40>>2])<<2)+b|0)+36>>2]=c;o[c+32>>2]=b;c=o[a+4>>2];if(c){o[6258]=o[6258]+1;l[o[4969]](c);}o[a+4>>2]=d;while(1){t=s[b>>2];d=o[b+36>>2];e=s[d>>2];c=o[b+40>>2];k=s[c>>2];e=e<k?e:k;s[b>>2]=e;k=s[b+16>>2];f=s[d+16>>2];m=s[c+16>>2];f=f>m?f:m;s[b+16>>2]=f;m=s[b+4>>2];g=s[d+4>>2];n=s[c+4>>2];g=g<n?g:n;s[b+4>>2]=g;n=s[b+20>>2];h=s[d+20>>2];p=s[c+20>>2];h=h>p?h:p;s[b+20>>2]=h;p=s[b+8>>2];i=s[d+8>>2];q=s[c+8>>2];i=i<q?i:q;s[b+8>>2]=i;q=s[b+24>>2];j=s[d+24>>2];r=s[c+24>>2];j=j>r?j:r;s[b+24>>2]=j;c:{if(n!=h|k!=f|(t!=e|m!=g)){break c}if(p!=i){break c}if(q==j){break a}}b=o[b+32>>2];if(b){continue}break}break b}o[a>>2]=c;o[c+32>>2]=0;b=o[a+4>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}o[a+4>>2]=d;}b=o[a>>2];}return b}function Fd(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0;i=K-16|0;K=i;g=o[a+12>>2];h=g+((c+d|0)/2<<4)|0;n=o[h+8>>2];l=o[h+4>>2];m=o[h>>2];h=c;j=d;while(1){a:{e=(h<<4)+g|0;f=o[e+4>>2];b:{if((f|0)<(l|0)){break b}if((f|0)!=(l|0)){break a}f=o[e>>2];if((f|0)<(m|0)){break b}if((f|0)!=(m|0)|o[e+8>>2]>=(n|0)){break a}}h=h+1|0;continue}while(1){c:{p=j<<4;f=p+g|0;k=o[f+4>>2];d:{if((l|0)<(k|0)){break d}if((l|0)!=(k|0)){break c}k=o[f>>2];if((m|0)<(k|0)){break d}if((m|0)!=(k|0)|(n|0)>=o[f+8>>2]){break c}}j=j+ -1|0;continue}break}if((h|0)<=(j|0)){g=o[e+12>>2];o[i+8>>2]=o[e+8>>2];o[i+12>>2]=g;g=o[e+4>>2];o[i>>2]=o[e>>2];o[i+4>>2]=g;g=o[f+4>>2];o[e>>2]=o[f>>2];o[e+4>>2]=g;g=o[f+12>>2];o[e+8>>2]=o[f+8>>2];o[e+12>>2]=g;g=o[i+4>>2];e=o[a+12>>2]+p|0;o[e>>2]=o[i>>2];o[e+4>>2]=g;f=o[i+12>>2];o[e+8>>2]=o[i+8>>2];o[e+12>>2]=f;j=j+ -1|0;h=h+1|0;}if((h|0)<=(j|0)){g=o[a+12>>2];continue}break}if((j|0)>(c|0)){Fd(a,b,c,j);}if((h|0)<(d|0)){Fd(a,b,h,d);}K=i+16|0;}function ku(a){var b=v(0),c=0,d=0,f=v(0);d=(g(a),h(0));c=d&2147483647;if(c>>>0>=1065353216){if((c|0)==1065353216){return (d|0)<0?v(3.141592502593994):v(0)}return v(v(0)/v(a-a))}a:{if(c>>>0<=1056964607){b=v(1.570796251296997);if(c>>>0<847249409){break a}b=v(a*a);return v(v(v(v(7.549789415861596e-8)-v(v(v(b*v(v(b*v(v(b*v(-.008656363002955914))+v(-.04274342209100723)))+v(.16666586697101593)))/v(v(b*v(-.7066296339035034))+v(1)))*a))-a)+v(1.570796251296997))}if((d|0)<=-1){a=v(v(a+v(1))*v(.5));b=v(C(a));a=v(v(1.570796251296997)-v(b+v(v(b*v(v(a*v(v(a*v(v(a*v(-.008656363002955914))+v(-.04274342209100723)))+v(.16666586697101593)))/v(v(a*v(-.7066296339035034))+v(1))))+v(-7.549789415861596e-8))));return v(a+a)}a=v(v(v(1)-a)*v(.5));f=v(C(a));b=(e(0,(g(f),h(0))&-4096),i());a=v(v(v(v(v(a*v(v(a*v(v(a*v(-.008656363002955914))+v(-.04274342209100723)))+v(.16666586697101593)))/v(v(a*v(-.7066296339035034))+v(1)))*f)+v(v(a-v(b*b))/v(f+b)))+b);b=v(a+a);}return b}function go(a){a=a|0;var b=0,c=0,d=v(0),e=0,f=0,g=0,h=0;f=K+ -64|0;K=f;a:{if(p[a+290|0]){c=o[a+8>>2];if((c|0)<1){break a}while(1){b=o[o[a+16>>2]+(e<<2)>>2];if(!(!b|!(o[b+252>>2]&2)|(!o[b+540>>2]|p[b+204|0]&3))){c=b+68|0;g=b+132|0;h=b+148|0;b:{c:{if(!p[a+316|0]){break c}d=s[a+284>>2];if(d==v(0)){break c}d=v(s[a+280>>2]-d);break b}d=v(s[a+280>>2]*s[b+268>>2]);}_a(c,g,h,d,f);b=o[b+540>>2];l[o[o[b>>2]+12>>2]](b,f);c=o[a+8>>2];}e=e+1|0;if((e|0)<(c|0)){continue}break}break a}c=o[a+248>>2];if((c|0)<1){break a}while(1){d:{e:{b=o[o[a+256>>2]+(e<<2)>>2];g=o[b+220>>2]+ -2|0;if(g>>>0>3){break e}switch(g-1|0){case 0:case 1:break e;default:break d}}if(!o[b+540>>2]|p[b+204|0]&3){break d}c=b+68|0;g=b+132|0;h=b+148|0;f:{g:{if(!p[a+316|0]){break g}d=s[a+284>>2];if(d==v(0)){break g}d=v(s[a+280>>2]-d);break f}d=v(s[a+280>>2]*s[b+268>>2]);}_a(c,g,h,d,f);b=o[b+540>>2];l[o[o[b>>2]+12>>2]](b,f);c=o[a+248>>2];}e=e+1|0;if((e|0)<(c|0)){continue}break}}K=f- -64|0;}function Sd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0);e=v(l[o[o[a>>2]+48>>2]](a));D=s[b+52>>2];h=s[b+24>>2];i=s[b+20>>2];j=s[b+56>>2];k=s[b+40>>2];m=s[a+68>>2];r=s[a+84>>2];t=s[b+36>>2];f=s[a- -64>>2];u=s[a+80>>2];E=s[b+48>>2];x=s[b+8>>2];y=s[b>>2];z=s[b+4>>2];A=s[b+16>>2];B=s[b+32>>2];g=s[a+60>>2];C=s[a+76>>2];o[c+12>>2]=0;n=j;j=v(v(C+g)*v(.5));p=v(v(u+f)*v(.5));q=v(v(r+m)*v(.5));n=v(n+v(v(v(B*j)+v(t*p))+v(k*q)));g=v(e+v(v(C-g)*v(.5)));f=v(e+v(v(u-f)*v(.5)));e=v(e+v(v(r-m)*v(.5)));k=v(v(v(g*v(w(B)))+v(f*v(w(t))))+v(e*v(w(k))));s[c+8>>2]=n-k;m=v(D+v(v(v(j*A)+v(p*i))+v(q*h)));h=v(v(v(g*v(w(A)))+v(f*v(w(i))))+v(e*v(w(h))));s[c+4>>2]=m-h;i=v(E+v(v(v(j*y)+v(p*z))+v(q*x)));e=v(v(v(g*v(w(y)))+v(f*v(w(z))))+v(e*v(w(x))));s[c>>2]=i-e;o[d+12>>2]=0;s[d+8>>2]=k+n;s[d+4>>2]=h+m;s[d>>2]=e+i;}function Zc(a,b,c,d,e,f){var g=0,h=0,i=0;a:{if(p[d+55|0]==(b|0)){break a}g=e<<2;h=o[g+4276>>2];if(!!(v(v(v(v(s[d>>2]*s[c+16>>2])+v(s[d+4>>2]*s[c+20>>2]))+v(s[d+8>>2]*s[c+24>>2]))-s[d+16>>2])<v(-9999999747378752e-21))){b=a;a=d+20|0;a=rb(b,o[a+(h<<2)>>2],o[a+g>>2],c,0);if(!a){break a}o[a+32>>2]=d;m[a+52|0]=e;m[(d+e|0)+52|0]=0;o[((e<<2)+d|0)+32>>2]=a;b=o[f>>2];b:{if(b){o[b+36>>2]=a;m[b+53|0]=2;o[a+40>>2]=b;m[a+54|0]=1;break b}o[f+4>>2]=a;}o[f>>2]=a;o[f+8>>2]=o[f+8>>2]+1;return 1}m[d+55|0]=b;if(!Zc(a,b,c,o[((h<<2)+d|0)+32>>2],p[(d+h|0)+52|0],f)){break a}e=b;b=o[g+4288>>2];if(!Zc(a,e,c,o[((b<<2)+d|0)+32>>2],p[(b+d|0)+52|0],f)){break a}b=o[d+48>>2];if(b){o[b+44>>2]=o[d+44>>2];}b=o[d+44>>2];if(b){o[b+48>>2]=o[d+48>>2];}if(o[a+18496>>2]==(d|0)){o[a+18496>>2]=o[d+48>>2];}b=a+18500|0;o[b>>2]=o[b>>2]+ -1;o[d+44>>2]=0;o[d+48>>2]=o[a+18504>>2];b=o[a+18504>>2];if(b){o[b+44>>2]=d;}o[a+18504>>2]=d;i=1;a=a+18508|0;o[a>>2]=o[a>>2]+1;}return i}function gn(a,b,c,d,e,f,g,h){var i=0,j=0,k=0,l=0,m=0,n=0,q=0,r=0;i=K-32|0;K=i;o[i+24>>2]=o[825];j=o[824];o[i+16>>2]=o[823];o[i+20>>2]=j;j=o[a+1232>>2];if(j>>>0<=5){a:{b:{c:{switch(j-1|0){default:o[i+16>>2]=0;l=2;k=0;break b;case 0:o[i+16>>2]=0;l=1;j=2;break a;case 1:k=1;o[i+16>>2]=1;l=2;j=0;break a;case 2:k=1;o[i+16>>2]=1;j=2;break a;case 3:k=2;o[i+16>>2]=2;l=1;j=0;break a;case 4:break c}}o[i+16>>2]=2;k=2;}j=1;}o[i+24>>2]=l;o[i+20>>2]=j;}l=0;while(1){j=u(k,88)+a|0;if(!(p[j+1016|0]?0:!(o[j+1052>>2]|p[j+996|0]))){m=(k<<4)+a|0;n=m+1388|0;r=o[n+4>>2];o[i+8>>2]=o[n>>2];o[i+12>>2]=r;m=m+1380|0;n=o[m+4>>2];o[i>>2]=o[m>>2];o[i+4>>2]=n;k=o[a+1456>>2]>>(k<<2)+12;if(!(k&1)){o[j+984>>2]=o[o[b+32>>2]>>2];}if(!(k&2)){o[j+980>>2]=o[b+4>>2];}if(!(k&4)){o[j+992>>2]=o[o[b+32>>2]>>2];}if(!(k&8)){o[j+988>>2]=o[b+4>>2];}q=rf(a,j+968|0,c,d,e,f,g,h,b,q,i,1,0)+q|0;}l=l+1|0;if((l|0)!=3){k=o[(i+16|0)+(l<<2)>>2];continue}break}K=i+32|0;return q}function ye(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0,q=0;e=K-32|0;K=e;d=o[a+52>>2];k=p[a+68|0];h=k?c:b;i=o[h+4>>2];f=o[i+20>>2];if((d|0)<(f|0)){if(o[a+56>>2]<(f|0)){if(f){o[6257]=o[6257]+1;n=l[o[4968]](f<<2,16)|0;g=o[a+52>>2];}else {g=d;}if((g|0)>=1){while(1){q=j<<2;o[q+n>>2]=o[o[a+60>>2]+q>>2];j=j+1|0;if((g|0)!=(j|0)){continue}break}}g=o[a+60>>2];if(g){if(p[a- -64|0]){if(g){o[6258]=o[6258]+1;l[o[4969]](g);}}o[a+60>>2]=0;}o[a+60>>2]=n;o[a+56>>2]=f;m[a- -64|0]=1;}while(1){o[o[a+60>>2]+(d<<2)>>2]=0;d=d+1|0;if((f|0)!=(d|0)){continue}break}}o[a+52>>2]=f;if((f|0)>=1){b=k?b:c;d=0;while(1){a:{if(o[i+68>>2]){o[o[a+60>>2]+(d<<2)>>2]=0;break a}c=o[h+12>>2];g=o[h+8>>2];o[e+12>>2]=o[(o[i+28>>2]+u(d,80)|0)+64>>2];o[e+16>>2]=g;o[e+20>>2]=c;o[e+28>>2]=d;o[e+24>>2]=-1;o[e+8>>2]=h;c=o[a+4>>2];c=l[o[o[c>>2]+8>>2]](c,e+8|0,b,o[a+72>>2],1)|0;o[o[a+60>>2]+(d<<2)>>2]=c;}d=d+1|0;if((f|0)!=(d|0)){continue}break}}K=e+32|0;}function Vv(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),x=v(0),y=v(0),z=v(0),A=v(0),B=v(0),C=v(0),D=v(0),E=v(0),F=v(0),G=v(0);j=s[b+56>>2];n=s[b+36>>2];p=s[b+40>>2];k=s[b+52>>2];g=s[b+20>>2];h=s[a+116>>2];f=s[a+24>>2];i=s[a+40>>2];q=s[b+24>>2];r=s[a+120>>2];t=s[a+28>>2];u=s[a+44>>2];x=s[b+32>>2];m=s[b+48>>2];y=s[b>>2];z=s[b+4>>2];A=s[b+8>>2];B=s[b+16>>2];e=s[a+112>>2];C=s[a+20>>2];D=s[a+36>>2];E=v(l[o[o[a>>2]+48>>2]](a));F=v(l[o[o[a>>2]+48>>2]](a));G=v(l[o[o[a>>2]+48>>2]](a));o[c+12>>2]=0;e=v(v(e*v(D-C))*v(.5));h=v(v(h*v(i-f))*v(.5));f=v(v(e*v(w(B)))+v(h*v(w(g))));g=v(v(r*v(u-t))*v(.5));f=v(F+v(f+v(g*v(w(q)))));s[c+4>>2]=k-f;i=v(E+v(v(v(e*v(w(y)))+v(h*v(w(z))))+v(g*v(w(A)))));s[c>>2]=m-i;e=v(G+v(v(v(e*v(w(x)))+v(h*v(w(n))))+v(g*v(w(p)))));s[c+8>>2]=j-e;o[d+12>>2]=0;s[d+8>>2]=j+e;s[d+4>>2]=k+f;s[d>>2]=m+i;}function Iu(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0,n=0,p=0,r=0;if(o[a+152>>2]>=1){while(1){m=q[c>>1];f=o[a+160>>2]+(n<<5)|0;a:{if(m>>>0>q[f+6>>1]){break a}p=q[d>>1];if(p>>>0<q[f>>1]){break a}r=q[c+4>>1];if(r>>>0>q[f+10>>1]){break a}j=q[d+4>>1];if(j>>>0<q[f+4>>1]){break a}h=q[c+2>>1];if(h>>>0>q[f+8>>1]){break a}g=q[d+2>>1];if(g>>>0<q[f+2>>1]){break a}b:{e=o[f+16>>2];if((e|0)<1){k=0;break b}i=o[f+12>>2];f=e+i|0;e=o[a+136>>2]+(i<<4)|0;k=0;while(1){j=m>>>0<=q[e+6>>1]&p>>>0>=q[e>>1]&r>>>0<=q[e+10>>1]&j>>>0>=q[e+4>>1]&h>>>0<=q[e+8>>1]&g>>>0>=q[e+2>>1];h=o[e+12>>2];g=(h|0)<0;if(!(g|!j)){l[o[o[b>>2]+8>>2]](b,h>>>21|0,h&2097151);}c:{if(!(g&(j^-1))){i=i+1|0;e=e+16|0;break c}g=o[e+12>>2];i=i-g|0;e=e-(g<<4)|0;}k=k+1|0;if((i|0)>=(f|0)){break b}g=q[d+2>>1];h=q[c+2>>1];j=q[d+4>>1];r=q[c+4>>1];p=q[d>>1];m=q[c>>1];continue}}if(o[5677]>=(k|0)){break a}o[5677]=k;}n=n+1|0;if((n|0)<o[a+152>>2]){continue}break}}}function bv(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;h=K-48|0;K=h;o[6257]=o[6257]+1;d=l[o[4968]](64,16)|0;o[d+8>>2]=g;o[d+4>>2]=f;o[d>>2]=e;e=o[b+4>>2];o[d+16>>2]=o[b>>2];o[d+20>>2]=e;e=o[b+12>>2];o[d+24>>2]=o[b+8>>2];o[d+28>>2]=e;e=o[c+4>>2];o[d+32>>2]=o[c>>2];o[d+36>>2]=e;e=o[c+12>>2];o[d+40>>2]=o[c+8>>2];o[d+44>>2]=e;o[d+52>>2]=0;o[d+56>>2]=0;e=o[b+12>>2];o[h+24>>2]=o[b+8>>2];o[h+28>>2]=e;e=o[b+4>>2];o[h+16>>2]=o[b>>2];o[h+20>>2]=e;b=o[c+12>>2];o[h+40>>2]=o[c+8>>2];o[h+44>>2]=b;b=o[c+4>>2];o[h+32>>2]=o[c>>2];o[h+36>>2]=b;o[d+60>>2]=o[a+104>>2];b=o[a+148>>2]+1|0;o[a+148>>2]=b;o[d+12>>2]=b;o[d+48>>2]=wc(a+4|0,h+16|0,d);b=o[a+104>>2];o[d+52>>2]=0;b=(b<<2)+a|0;o[d+56>>2]=o[b+84>>2];c=o[b+84>>2];if(c){o[c+52>>2]=d;}o[b+84>>2]=d;if(!p[a+153|0]){o[h+8>>2]=d;o[h>>2]=16056;o[h+4>>2]=a;nb(o[a+4>>2],h+16|0,h);nb(o[a+44>>2],h+16|0,h);}K=h+48|0;return d|0}function Hw(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0),f=v(0),g=v(0),h=0,i=v(0),j=v(0),k=v(0),m=v(0);d=K-32|0;K=d;h=o[c+12>>2];o[d+24>>2]=o[c+8>>2];o[d+28>>2]=h;h=o[c+4>>2];o[d+16>>2]=o[c>>2];o[d+20>>2]=h;e=s[d+16>>2];g=s[d+20>>2];f=s[d+24>>2];if(!!(v(v(v(e*e)+v(g*g))+v(f*f))<v(1.4210854715202004e-14))){o[d+24>>2]=-1082130432;o[d+28>>2]=0;o[d+16>>2]=-1082130432;o[d+20>>2]=-1082130432;f=v(-1);g=v(-1);e=v(-1);}i=f;f=v(v(1)/v(C(v(v(v(e*e)+v(g*g))+v(f*f)))));s[d+24>>2]=i*f;s[d+20>>2]=g*f;s[d+16>>2]=e*f;Ma(d,b,d+16|0);a:{b:{c=o[b+4>>2];if(c>>>0>13){break b}c:{switch(c-2|0){case 6:e=v(s[b+32>>2]*s[b+16>>2]);break a;case 0:case 1:case 4:case 5:case 7:case 10:break b;default:break c}}e=s[b+48>>2];break a}e=v(l[o[o[b>>2]+48>>2]](b));}g=s[d>>2];f=s[d+16>>2];i=s[d+4>>2];j=s[d+20>>2];k=s[d+8>>2];m=s[d+24>>2];o[a+12>>2]=0;s[a+8>>2]=k+v(e*m);s[a+4>>2]=i+v(e*j);s[a>>2]=g+v(e*f);K=d+32|0;}function ba(a,b){var c=0,d=0,f=0,j=0,k=v(0),l=0;a:{c=(g(b),h(0));f=c&2147483647;if(f>>>0<=2139095040){j=(g(a),h(0));d=j&2147483647;if(d>>>0<2139095041){break a}}return v(a+b)}if((c|0)==1065353216){return Pg(a)}l=j>>>31|0;j=c>>>30&2;c=l|j;b:{c:{d:{e:{if(!d){f:{switch(c-2|0){case 0:break e;case 1:break f;default:break d}}return v(-3.1415927410125732)}if((f|0)!=2139095040){if(!f|!(f+218103808>>>0>=d>>>0?(d|0)!=2139095040:0)){break b}g:{if(d+218103808>>>0<f>>>0){k=v(0);if(j){break g}}k=Pg(v(w(v(a/b))));}a=k;if(c>>>0<=2){h:{switch(c-1|0){case 0:return v(-a);case 1:break h;default:break d}}return v(v(3.1415927410125732)-v(a+v(8.742277657347586e-8)))}return v(v(a+v(8.742277657347586e-8))+v(-3.1415927410125732))}if((d|0)==2139095040){break c}return s[(c<<2)+19376>>2]}a=v(3.1415927410125732);}return a}return s[(c<<2)+19360>>2]}return e(0,(g(a),h(0))&-2147483648|1070141403),i()}function Qn(a,b,c,d,e){o[a+20>>2]=e;o[a+16>>2]=d;o[a+12>>2]=c;o[a+4>>2]=b;b=o[a+32>>2];if((b|0)<=-1){if(o[a+36>>2]<=-1){c=o[a+40>>2];if(c){if(p[a+44|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+40>>2]=0;}o[a+36>>2]=0;o[a+40>>2]=0;m[a+44|0]=1;}while(1){o[o[a+40>>2]+(b<<2)>>2]=0;c=b+1|0;d=c>>>0>=b>>>0;b=c;if(d){continue}break}}o[a+32>>2]=0;b=o[a+52>>2];if((b|0)<=-1){if(o[a+56>>2]<=-1){c=o[a+60>>2];if(c){if(p[a- -64|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+60>>2]=0;}o[a+56>>2]=0;o[a+60>>2]=0;m[a- -64|0]=1;}while(1){o[o[a+60>>2]+(b<<2)>>2]=0;c=b+1|0;d=c>>>0>=b>>>0;b=c;if(d){continue}break}}o[a+52>>2]=0;b=o[a+72>>2];if((b|0)<=-1){if(o[a+76>>2]<=-1){c=o[a+80>>2];if(c){if(p[a+84|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+80>>2]=0;}o[a+76>>2]=0;o[a+80>>2]=0;m[a+84|0]=1;}while(1){o[o[a+80>>2]+(b<<2)>>2]=0;c=b+1|0;d=c>>>0>=b>>>0;b=c;if(d){continue}break}}o[a+72>>2]=0;}function xn(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0),f=v(0),g=v(0),h=0,i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),q=v(0),r=v(0),t=v(0);e=v(1);d=o[b>>2];if(!((d|0)==o[a+84>>2]|p[d+204|0]&4|v(v(v(v(s[a+32>>2]-s[a+16>>2])*s[b+8>>2])+v(v(s[a+36>>2]-s[a+20>>2])*s[b+12>>2]))+v(v(s[a+40>>2]-s[a+24>>2])*s[b+16>>2]))>=v(-s[a+88>>2]))){h=o[b+40>>2];o[a+80>>2]=d;o[a+4>>2]=h;a:{if(c){c=b+8|0;d=o[c+4>>2];o[a+48>>2]=o[c>>2];o[a+52>>2]=d;d=o[c+12>>2];o[a+56>>2]=o[c+8>>2];o[a+60>>2]=d;break a}i=s[d+12>>2];j=s[d+8>>2];k=s[d+28>>2];l=s[d+20>>2];m=s[d+24>>2];n=s[d+44>>2];q=s[d+36>>2];r=s[d+40>>2];t=s[d+4>>2];e=s[b+16>>2];f=s[b+8>>2];g=s[b+12>>2];o[a+60>>2]=0;s[a+56>>2]=v(v(f*q)+v(g*r))+v(e*n);s[a+52>>2]=v(v(f*l)+v(g*m))+v(e*k);s[a+48>>2]=v(v(t*f)+v(j*g))+v(i*e);}c=o[b+28>>2];o[a+64>>2]=o[b+24>>2];o[a+68>>2]=c;c=o[b+36>>2];o[a+72>>2]=o[b+32>>2];o[a+76>>2]=c;e=s[b+40>>2];}return v(e)}function Kl(a,b,c){var d=0,e=v(0),f=v(0),g=v(0),h=0,i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=0,w=0,x=v(0),y=v(0),z=v(0);d=K-32|0;K=d;u=o[b+124>>2];w=o[b+4>>2]+(u>>1)|0;h=o[b+120>>2];h=u&1?o[o[w>>2]+h>>2]:h;i=s[b+16>>2];j=s[b+12>>2];k=s[b+32>>2];m=s[b+24>>2];n=s[b+28>>2];p=s[b+48>>2];q=s[b+40>>2];r=s[b+44>>2];t=s[b+8>>2];e=s[c+8>>2];f=s[c>>2];g=s[c+4>>2];o[d+12>>2]=0;s[d+8>>2]=v(v(f*q)+v(g*r))+v(e*p);s[d+4>>2]=v(v(f*m)+v(g*n))+v(e*k);s[d>>2]=v(v(t*f)+v(j*g))+v(i*e);l[h](d+16|0,w,d);i=s[b+104>>2];j=s[b- -64>>2];k=s[b+60>>2];m=s[b+108>>2];n=s[b+80>>2];p=s[b+72>>2];q=s[b+76>>2];r=s[b+112>>2];t=s[b+96>>2];x=s[b+88>>2];y=s[b+92>>2];z=s[b+56>>2];e=s[d+24>>2];f=s[d+16>>2];g=s[d+20>>2];o[a+12>>2]=0;s[a+8>>2]=r+v(v(v(f*x)+v(g*y))+v(e*t));s[a+4>>2]=m+v(v(v(f*p)+v(g*q))+v(e*n));s[a>>2]=i+v(v(v(f*z)+v(g*k))+v(e*j));K=d+32|0;}function Dw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=v(0),i=0,j=v(0),k=v(0),l=v(0),m=v(0),n=0,p=v(0),q=v(0),r=v(0),t=v(0);e=K-16|0;if((d|0)>=1){while(1){o[e+8>>2]=0;o[e+12>>2]=0;o[e>>2]=0;o[e+4>>2]=0;g=o[a+56>>2];f=g<<2;i=f+e|0;f=a+f|0;j=s[f+32>>2];o[i>>2]=o[f+32>>2];m=s[e>>2];i=n<<4;f=i+b|0;h=s[f>>2];r=s[e+4>>2];p=s[f+4>>2];t=s[e+8>>2];q=s[f+8>>2];k=v(v(v(m*h)+v(r*p))+v(t*q));l=v(-0xde0b6b000000000);a:{if(!(k>v(-0xde0b6b000000000))){break a}g=c+i|0;o[g+12>>2]=o[e+12>>2];s[g+8>>2]=t;s[g+4>>2]=r;s[g>>2]=m;q=s[f+8>>2];p=s[f+4>>2];h=s[f>>2];g=o[a+56>>2];j=s[((g<<2)+a|0)+32>>2];l=k;}m=l;o[e+8>>2]=0;o[e+12>>2]=0;o[e>>2]=0;o[e+4>>2]=0;s[(g<<2)+e>>2]=-j;j=s[e>>2];k=s[e+4>>2];l=v(v(j*h)+v(k*p));h=s[e+8>>2];if(!!(v(l+v(h*q))>m)){f=c+i|0;o[f+12>>2]=o[e+12>>2];s[f+8>>2]=h;s[f+4>>2]=k;s[f>>2]=j;}n=n+1|0;if((n|0)!=(d|0)){continue}break}}}function Jm(a,b,c){var d=0;d=o[b+4>>2];o[a+552>>2]=o[b>>2];o[a+556>>2]=d;d=o[b+12>>2];o[a+560>>2]=o[b+8>>2];o[a+564>>2]=d;d=o[b+28>>2];o[a+576>>2]=o[b+24>>2];o[a+580>>2]=d;d=o[b+20>>2];o[a+568>>2]=o[b+16>>2];o[a+572>>2]=d;d=o[b+44>>2];o[a+592>>2]=o[b+40>>2];o[a+596>>2]=d;d=o[b+36>>2];o[a+584>>2]=o[b+32>>2];o[a+588>>2]=d;d=o[b+60>>2];o[a+608>>2]=o[b+56>>2];o[a+612>>2]=d;d=o[b+52>>2];o[a+600>>2]=o[b+48>>2];o[a+604>>2]=d;b=o[c+12>>2];o[a+624>>2]=o[c+8>>2];o[a+628>>2]=b;b=o[c+4>>2];o[a+616>>2]=o[c>>2];o[a+620>>2]=b;b=o[c+20>>2];o[a+632>>2]=o[c+16>>2];o[a+636>>2]=b;b=o[c+28>>2];o[a+640>>2]=o[c+24>>2];o[a+644>>2]=b;b=o[c+36>>2];o[a+648>>2]=o[c+32>>2];o[a+652>>2]=b;b=o[c+44>>2];o[a+656>>2]=o[c+40>>2];o[a+660>>2]=b;b=o[c+60>>2];o[a+672>>2]=o[c+56>>2];o[a+676>>2]=b;b=o[c+52>>2];o[a+664>>2]=o[c+48>>2];o[a+668>>2]=b;l[o[o[a>>2]+8>>2]](a);}function Oc(a,b,c,d,e,f,g){var h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),o=v(0);h=s[d>>2];k=s[d+4>>2];l=s[d+8>>2];n=v(v(v(s[c>>2]*h)+v(s[c+4>>2]*k))+v(s[c+8>>2]*l));i=v(v(v(h*s[a>>2])+v(k*s[a+16>>2]))+v(l*s[a+32>>2]));j=s[e+80>>2];m=v(i*(i<v(0)?v(-j):j));i=v(v(v(h*s[a+4>>2])+v(k*s[a+20>>2]))+v(l*s[a+36>>2]));j=s[e+84>>2];m=v(m+v(i*(i<v(0)?v(-j):j)));i=v(v(v(h*s[a+8>>2])+v(k*s[a+24>>2]))+v(l*s[a+40>>2]));j=s[e+88>>2];i=v(m+v(i*(i<v(0)?v(-j):j)));j=s[e+96>>2];m=i>j?i:j;i=v(v(v(h*s[b>>2])+v(k*s[b+16>>2]))+v(l*s[b+32>>2]));j=s[f+80>>2];o=v(i*(i<v(0)?v(-j):j));i=v(v(v(h*s[b+4>>2])+v(k*s[b+20>>2]))+v(l*s[b+36>>2]));j=s[f+84>>2];h=v(v(v(h*s[b+8>>2])+v(k*s[b+24>>2]))+v(l*s[b+40>>2]));k=s[f+88>>2];h=v(v(o+v(i*(i<v(0)?v(-j):j)))+v(h*(h<v(0)?v(-k):k)));k=s[f+96>>2];h=v(m+(h>k?h:k));k=v(n+h);h=v(h-n);return (k<h?k:h)>g^1}function Kw(a,b,c,d,e,f){var i=v(0),j=v(0),k=v(0),m=v(0),n=0,p=0,q=0,r=0,t=0,u=v(0),w=v(0),x=v(0),y=v(0),z=v(0);l[o[o[a>>2]+8>>2]](a,b,e,f);i=s[c+8>>2];j=s[c+4>>2];m=s[e+8>>2];b=o[e+8>>2];u=s[e+4>>2];n=o[e+4>>2];w=s[e>>2];p=o[e>>2];x=s[f+8>>2];q=o[f+8>>2];y=s[f+4>>2];r=o[f+4>>2];z=s[f>>2];t=o[f>>2];k=s[c>>2];a:{if(!!(k>v(0))){t=(g(v(k+z)),h(0));break a}p=(g(v(k+w)),h(0));}b:{if(!!(j>v(0))){r=(g(v(j+y)),h(0));break b}n=(g(v(j+u)),h(0));}c:{if(!!(i>v(0))){q=(g(v(i+x)),h(0));break c}b=(g(v(i+m)),h(0));}i=s[d+8>>2];j=s[d>>2];k=s[d+4>>2];m=v(l[o[o[a>>2]+16>>2]](a));o[e+12>>2]=0;o[e+8>>2]=b;o[e+4>>2]=n;o[e>>2]=p;o[f+12>>2]=0;o[f+8>>2]=q;o[f+4>>2]=r;o[f>>2]=t;i=v(m*v(C(v(v(v(j*j)+v(k*k))+v(i*i)))));s[e>>2]=s[e>>2]-i;s[e+4>>2]=s[e+4>>2]-i;s[e+8>>2]=s[e+8>>2]-i;s[f>>2]=i+s[f>>2];s[f+4>>2]=i+s[f+4>>2];s[f+8>>2]=i+s[f+8>>2];}function le(a,b,c,d){var e=0,f=0,g=0,h=0;g=K+ -64|0;K=g;h=u(b,80);e=h+o[a+28>>2]|0;b=c;f=o[b+4>>2];o[e>>2]=o[b>>2];o[e+4>>2]=f;f=o[b+12>>2];o[e+8>>2]=o[b+8>>2];o[e+12>>2]=f;f=o[b+28>>2];o[e+24>>2]=o[b+24>>2];o[e+28>>2]=f;f=o[b+20>>2];o[e+16>>2]=o[b+16>>2];o[e+20>>2]=f;f=o[b+44>>2];o[e+40>>2]=o[b+40>>2];o[e+44>>2]=f;f=o[b+36>>2];o[e+32>>2]=o[b+32>>2];o[e+36>>2]=f;f=o[b+60>>2];o[e+56>>2]=o[b+56>>2];o[e+60>>2]=f;f=o[b+52>>2];o[e+48>>2]=o[b+48>>2];o[e+52>>2]=f;if(o[a+68>>2]){b=o[(o[a+28>>2]+h|0)+64>>2];l[o[o[b>>2]+8>>2]](b,c,g+48|0,g+32|0);b=g;c=o[b+60>>2];e=o[b+56>>2];o[b+8>>2]=e;o[b+12>>2]=c;c=o[b+44>>2];o[b+24>>2]=o[b+40>>2];o[b+28>>2]=c;c=o[b+36>>2];o[b+16>>2]=o[b+32>>2];o[b+20>>2]=c;c=o[b+52>>2];o[b>>2]=o[b+48>>2];o[b+4>>2]=c;Ld(o[a+68>>2],o[(o[a+28>>2]+h|0)+76>>2],b);}if(d){l[o[o[a>>2]+68>>2]](a);}K=g- -64|0;}function Av(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;a:{if(p[a+165|0]){if(o[a+92>>2]>=(b|0)){break a}if(b){o[6257]=o[6257]+1;e=l[o[4968]](b<<4,16)|0;}else {e=0;}g=o[a+88>>2];if((g|0)>=1){while(1){d=c<<4;f=d+e|0;d=d+o[a+96>>2]|0;h=o[d+4>>2];o[f>>2]=o[d>>2];o[f+4>>2]=h;h=o[d+12>>2];o[f+8>>2]=o[d+8>>2];o[f+12>>2]=h;c=c+1|0;if((g|0)!=(c|0)){continue}break}}c=o[a+96>>2];if(c){if(p[a+100|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+96>>2]=0;}o[a+96>>2]=e;o[a+92>>2]=b;m[a+100|0]=1;return}if(o[a+112>>2]>=(b|0)){break a}if(b){o[6257]=o[6257]+1;d=l[o[4968]](b<<2,16)|0;}e=o[a+116>>2];f=o[a+108>>2];b:{c:{if((f|0)>=1){while(1){g=c<<2;o[g+d>>2]=o[e+g>>2];c=c+1|0;if((f|0)!=(c|0)){continue}break c}}if(!e){break b}}if(p[a+120|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[a+116>>2]=0;}o[a+116>>2]=d;o[a+112>>2]=b;m[a+120|0]=1;}}function bd(a,b,c){var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),o=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0),x=v(0);d=s[a+552>>2];e=s[b>>2];f=s[a+568>>2];g=s[b+4>>2];h=s[a+584>>2];i=s[b+8>>2];k=s[a+620>>2];l=s[a+636>>2];j=s[a+652>>2];m=v(v(v(k*s[c>>2])+v(l*s[c+4>>2]))+v(j*s[c+8>>2]));n=s[b+16>>2];o=s[b+20>>2];p=s[b+24>>2];q=v(v(v(k*s[c+16>>2])+v(l*s[c+20>>2]))+v(j*s[c+24>>2]));r=v(v(v(v(v(d*e)+v(f*g))+v(h*i))*m)+v(v(v(v(d*n)+v(f*o))+v(h*p))*q));t=d;d=s[b+32>>2];u=f;f=s[b+36>>2];w=h;h=s[b+40>>2];j=v(v(v(k*s[c+32>>2])+v(l*s[c+36>>2]))+v(j*s[c+40>>2]));k=e;e=s[a+556>>2];l=g;g=s[a+572>>2];x=i;i=s[a+588>>2];return v(ba(v(r+v(v(v(v(t*d)+v(u*f))+v(w*h))*j)),v(v(v(v(v(v(k*e)+v(l*g))+v(x*i))*m)+v(v(v(v(n*e)+v(o*g))+v(p*i))*q))+v(v(v(v(d*e)+v(f*g))+v(h*i))*j)))*s[a+732>>2])}function ww(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0),f=v(0),i=v(0),j=v(0),k=0,m=0,n=0;d=K-80|0;K=d;o[a>>2]=0;o[a+4>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;f=s[c>>2];i=s[c+4>>2];j=s[c+8>>2];e=v(v(v(f*f)+v(i*i))+v(j*j));a:{if(e<v(9999999747378752e-20)){k=1065353216;e=v(0);break a}e=v(v(1)/v(C(e)));m=(g(v(j*e)),h(0));n=(g(v(i*e)),h(0));k=(g(v(f*e)),h(0));e=s[c+12>>2];}o[d+52>>2]=0;o[d+56>>2]=0;s[d+76>>2]=e;o[d+72>>2]=m;o[d+68>>2]=n;o[d+44>>2]=0;o[d+48>>2]=0;o[d+40>>2]=13824;o[d+64>>2]=k;o[d+60>>2]=-581039253;o[d+32>>2]=1566444395;o[d+36>>2]=0;o[d+24>>2]=1566444395;o[d+28>>2]=1566444395;b=o[b+96>>2];o[d+16>>2]=-581039253;o[d+20>>2]=0;o[d+8>>2]=-581039253;o[d+12>>2]=-581039253;l[o[o[b>>2]+8>>2]](b,d+40|0,d+8|0,d+24|0);b=o[d+56>>2];o[a+8>>2]=o[d+52>>2];o[a+12>>2]=b;b=o[d+48>>2];o[a>>2]=o[d+44>>2];o[a+4>>2]=b;K=d+80|0;}function sb(a){o[a>>2]=1025;o[a+120>>2]=0;o[a+124>>2]=0;o[a+128>>2]=0;o[a+132>>2]=0;o[a+136>>2]=0;o[a+140>>2]=0;o[a+144>>2]=0;o[a+148>>2]=0;o[a+152>>2]=0;o[a+156>>2]=0;o[a+160>>2]=0;o[a+164>>2]=0;o[a+168>>2]=0;o[a+328>>2]=0;o[a+332>>2]=0;o[a+336>>2]=0;o[a+340>>2]=0;o[a+344>>2]=0;o[a+348>>2]=0;o[a+352>>2]=0;o[a+356>>2]=0;o[a+360>>2]=0;o[a+364>>2]=0;o[a+368>>2]=0;o[a+372>>2]=0;o[a+376>>2]=0;o[a+536>>2]=0;o[a+540>>2]=0;o[a+544>>2]=0;o[a+548>>2]=0;o[a+552>>2]=0;o[a+556>>2]=0;o[a+560>>2]=0;o[a+564>>2]=0;o[a+568>>2]=0;o[a+572>>2]=0;o[a+576>>2]=0;o[a+580>>2]=0;o[a+584>>2]=0;o[a+792>>2]=0;o[a+784>>2]=0;o[a+788>>2]=0;o[a+776>>2]=0;o[a+780>>2]=0;o[a+768>>2]=0;o[a+772>>2]=0;o[a+760>>2]=0;o[a+764>>2]=0;o[a+752>>2]=0;o[a+756>>2]=0;o[a+744>>2]=0;o[a+748>>2]=0;o[a+836>>2]=0;o[a+840>>2]=0;o[a+864>>2]=0;o[a+844>>2]=0;}function jo(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0;d=K-16|0;K=d;l[o[4966]](2516);Ie(a);a:{if(!l[o[o[a>>2]+20>>2]](a)){break a}b=l[o[o[a>>2]+20>>2]](a)|0;if(!(l[o[o[b>>2]+56>>2]](b)&6144)){break a}c=l[o[o[a>>2]+104>>2]](a)|0;if((c|0)<1){break a}while(1){b=c+ -1|0;g=a,h=l[o[o[a>>2]+108>>2]](a,b)|0,f=o[o[a>>2]+172>>2],l[f](g|0,h|0);e=(c|0)>1;c=b;if(e){continue}break}}b:{if(!l[o[o[a>>2]+20>>2]](a)){break b}b=l[o[o[a>>2]+20>>2]](a)|0;if(!(l[o[o[b>>2]+56>>2]](b)&16387)){break b}if(!l[o[o[a>>2]+20>>2]](a)){break b}b=l[o[o[a>>2]+20>>2]](a)|0;if(!l[o[o[b>>2]+56>>2]](b)|o[a+296>>2]<1){break b}c=0;while(1){b=o[o[a+304>>2]+(c<<2)>>2];l[o[o[b>>2]+12>>2]](b,o[a+72>>2]);c=c+1|0;if((c|0)<o[a+296>>2]){continue}break}}if(l[o[o[a>>2]+20>>2]](a)){a=l[o[o[a>>2]+20>>2]](a)|0;l[o[o[a>>2]+104>>2]](a);}l[o[4967]]();K=d+16|0;}function te(a){var b=0,c=0,d=0,e=0,f=0,g=0;b=o[a+16>>2];if(b){if(p[a+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+16>>2]=0;}o[a+16>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;m[a+20|0]=1;b=o[a+36>>2];if(b){if(p[a+40|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+36>>2]=0;}o[a+36>>2]=0;o[a+28>>2]=0;o[a+32>>2]=0;m[a+40|0]=1;b=o[a+56>>2];if(b){if(p[a+60|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+56>>2]=0;}b=0;o[a+56>>2]=0;o[a+48>>2]=0;o[a+52>>2]=0;m[a+60|0]=1;if(o[a+12>>2]<=1){o[6257]=o[6257]+1;e=l[o[4968]](24,16)|0;f=o[a+8>>2];if((f|0)>=1){while(1){c=u(b,12);d=c+o[a+16>>2]|0;g=o[d+4>>2];c=c+e|0;o[c>>2]=o[d>>2];o[c+4>>2]=g;o[c+8>>2]=o[d+8>>2];b=b+1|0;if((f|0)!=(b|0)){continue}break}}b=o[a+16>>2];if(b){if(p[a+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+16>>2]=0;}o[a+16>>2]=e;m[a+20|0]=1;o[a+12>>2]=2;}Kc(a);}function Ew(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=0,l=v(0),m=v(0),n=v(0);d=K-16|0;o[a>>2]=0;o[a+4>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;f=s[c>>2];i=s[c+4>>2];e=s[c+8>>2];g=v(v(v(f*f)+v(i*i))+v(e*e));a:{if(g<v(9999999747378752e-20)){g=v(0);f=v(1);break a}h=e;e=v(v(1)/v(C(g)));j=v(h*e);g=v(i*e);f=v(f*e);}o[d+8>>2]=0;o[d+12>>2]=0;o[d>>2]=0;o[d+4>>2]=0;c=o[b+56>>2]<<2;k=c+d|0;l=s[(b+c|0)+32>>2];s[k>>2]=l;i=v(-0xde0b6b000000000);m=s[d>>2];n=s[d+4>>2];h=s[d+8>>2];e=v(v(v(f*m)+v(g*n))+v(j*h));if(!!(e>v(-0xde0b6b000000000))){o[a+12>>2]=o[d+12>>2];s[a+8>>2]=h;s[a+4>>2]=n;s[a>>2]=m;i=e;}o[d+8>>2]=0;o[d+12>>2]=0;o[d>>2]=0;o[d+4>>2]=0;s[k>>2]=-l;h=f;f=s[d>>2];e=s[d+4>>2];h=v(v(h*f)+v(g*e));g=s[d+8>>2];if(!!(v(h+v(j*g))>i)){o[a+12>>2]=o[d+12>>2];s[a+8>>2]=g;s[a+4>>2]=e;s[a>>2]=f;}}function en(a,b,c,d){a=a|0;b=b|0;c=v(c);d=d|0;var e=0;a:{if(d>>>0<=2){b=b+ -1|0;if(b>>>0>3){break a}b:{switch(b-1|0){case 0:b=d<<2;s[(b+a|0)+728>>2]=c;o[a+1456>>2]=o[a+1456>>2]|2<<b;return;case 2:b=d<<2;s[(b+a|0)+744>>2]=c;o[a+1456>>2]=o[a+1456>>2]|1<<b;return;default:b=d<<2;s[(b+a|0)+760>>2]=c;o[a+1456>>2]=o[a+1456>>2]|8<<b;return;case 1:break b}}b=d<<2;s[(b+a|0)+776>>2]=c;o[a+1456>>2]=o[a+1456>>2]|4<<b;return}e=d+ -3|0;if(e>>>0>2){break a}b=b+ -1|0;if(b>>>0>3){break a}c:{switch(b-1|0){case 0:s[(u(e,88)+a|0)+980>>2]=c;o[a+1456>>2]=o[a+1456>>2]|2<<(d<<2);return;case 2:s[(u(e,88)+a|0)+984>>2]=c;o[a+1456>>2]=o[a+1456>>2]|1<<(d<<2);return;default:s[(u(e,88)+a|0)+988>>2]=c;o[a+1456>>2]=o[a+1456>>2]|8<<(d<<2);return;case 1:break c}}s[(u(e,88)+a|0)+992>>2]=c;o[a+1456>>2]=o[a+1456>>2]|4<<(d<<2);}}function Cn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0;l[o[o[b>>2]+32>>2]](b);d=l[o[o[b>>2]+16>>2]](b,104,1)|0;c=$(o[d+8>>2],0,104);o[c+88>>2]=o[a+264>>2];o[c+92>>2]=o[a+268>>2];o[c+96>>2]=o[a+272>>2];o[c+100>>2]=o[a+276>>2];o[c>>2]=o[a+92>>2];o[c+4>>2]=o[a+96>>2];o[c+8>>2]=o[a+100>>2];o[c+12>>2]=o[a+104>>2];o[c+16>>2]=o[a+108>>2];o[c+20>>2]=o[a+116>>2];o[c+24>>2]=o[a+120>>2];o[c+28>>2]=o[a+124>>2];o[c+32>>2]=o[a+128>>2];o[c+36>>2]=o[a+132>>2];o[c+40>>2]=o[a+148>>2];o[c+44>>2]=o[a+152>>2];o[c+48>>2]=o[a+156>>2];o[c+52>>2]=o[a+160>>2];o[c+56>>2]=o[a+176>>2];o[c+60>>2]=o[a+180>>2];o[c+64>>2]=o[a+112>>2];o[c+68>>2]=o[a+164>>2];o[c+72>>2]=o[a+168>>2];o[c+76>>2]=o[a+172>>2];e=o[a+144>>2];o[c+84>>2]=0;o[c+80>>2]=e;l[o[o[b>>2]+20>>2]](b,d,2833,1145853764,c);He(a,b);Dn(a,b);l[o[o[b>>2]+36>>2]](b);}function Vd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,n=0;e=o[a+4>>2];if((e|0)==o[a+8>>2]){Wd(a,e?e<<1:1);e=o[a+4>>2];}i=o[a+12>>2];c=i+u(e,36)|0;o[c+12>>2]=0;m[c+16|0]=1;o[c+4>>2]=0;o[c+8>>2]=0;f=o[b+4>>2];a:{if((f|0)>=1){o[6257]=o[6257]+1;j=f<<2;g=l[o[4968]](j,16)|0;h=o[c+12>>2];k=o[c+4>>2];b:{c:{if((k|0)>=1){while(1){n=d<<2;o[g+n>>2]=o[h+n>>2];d=d+1|0;if((k|0)!=(d|0)){continue}break c}}if(!h){break b}}if(!p[c+16|0]){break b}if(h){o[6258]=o[6258]+1;l[o[4969]](h);}}m[c+16|0]=1;o[c+12>>2]=g;o[c+8>>2]=f;d=0;$(g,0,j);o[c+4>>2]=f;h=o[b+12>>2];c=o[c+12>>2];while(1){g=d<<2;o[g+c>>2]=o[h+g>>2];d=d+1|0;if((f|0)!=(d|0)){continue}break}break a}o[c+4>>2]=f;}d=o[b+24>>2];c=u(e,36)+i|0;o[c+20>>2]=o[b+20>>2];o[c+24>>2]=d;d=o[b+32>>2];o[c+28>>2]=o[b+28>>2];o[c+32>>2]=d;o[a+4>>2]=o[a+4>>2]+1;}function Ro(a,b,c,d,e){var f=0;f=K-32|0;K=f;o[f+28>>2]=a;o[f+24>>2]=b;o[f+20>>2]=c;o[f+16>>2]=d;s[f+12>>2]=e;b=o[f+24>>2];c=o[b+4>>2];a=o[f+28>>2];o[a>>2]=o[b>>2];o[a+4>>2]=c;c=o[b+12>>2];o[a+8>>2]=o[b+8>>2];o[a+12>>2]=c;b=o[f+20>>2];c=o[b+4>>2];o[a+16>>2]=o[b>>2];o[a+20>>2]=c;c=o[b+12>>2];o[a+24>>2]=o[b+8>>2];o[a+28>>2]=c;o[(K-16|0)+12>>2]=a+32;o[(K-16|0)+12>>2]=a+48;b=o[f+16>>2];c=o[b+4>>2];o[a+64>>2]=o[b>>2];o[a+68>>2]=c;c=o[b+12>>2];o[a+72>>2]=o[b+8>>2];o[a+76>>2]=c;s[a+80>>2]=s[f+12>>2];s[a+84>>2]=0;s[a+88>>2]=0;s[a+92>>2]=0;s[a+96>>2]=0;o[a+116>>2]=0;o[a+120>>2]=0;o[a+124>>2]=0;o[a+128>>2]=0;s[a+132>>2]=0;s[a+136>>2]=0;s[a+140>>2]=0;s[a+144>>2]=0;s[a+148>>2]=0;s[a+152>>2]=0;s[a+156>>2]=0;s[a+160>>2]=0;o[a+164>>2]=0;o[(K-16|0)+12>>2]=a+168;o[(K-16|0)+12>>2]=a+184;K=f+32|0;}function wa(a){var b=v(0),c=0,d=0,e=0,f=0;d=K-16|0;K=d;e=(g(a),h(0));c=e&2147483647;a:{if(c>>>0<=1061752794){b=v(1);if(c>>>0<964689920){break a}b=ya(+a);break a}if(c>>>0<=1081824209){f=+a;if(c>>>0>=1075235812){b=v(-ya(((e|0)<0?3.141592653589793:-3.141592653589793)+f));break a}if((e|0)<=-1){b=xa(f+1.5707963267948966);break a}b=xa(1.5707963267948966-f);break a}if(c>>>0<=1088565717){if(c>>>0>=1085271520){b=ya(((e|0)<0?6.283185307179586:-6.283185307179586)+ +a);break a}if((e|0)<=-1){b=xa(-4.71238898038469- +a);break a}b=xa(+a+ -4.71238898038469);break a}b=v(a-a);if(c>>>0>=2139095040){break a}c=Rg(a,d+8|0)&3;if(c>>>0<=2){b:{switch(c-1|0){default:b=ya(t[d+8>>3]);break a;case 0:b=xa(-t[d+8>>3]);break a;case 1:break b}}b=v(-ya(t[d+8>>3]));break a}b=xa(t[d+8>>3]);}a=b;K=d+16|0;return a}function va(a){var b=0,c=0,d=0,e=0;c=K-16|0;K=c;e=(g(a),h(0));b=e&2147483647;a:{if(b>>>0<=1061752794){if(b>>>0<964689920){break a}a=xa(+a);break a}if(b>>>0<=1081824209){d=+a;if(b>>>0<=1075235811){if((e|0)<=-1){a=v(-ya(d+1.5707963267948966));break a}a=ya(d+ -1.5707963267948966);break a}a=xa(-(((e|0)<0?3.141592653589793:-3.141592653589793)+d));break a}if(b>>>0<=1088565717){d=+a;if(b>>>0<=1085271519){if((e|0)<=-1){a=ya(d+4.71238898038469);break a}a=v(-ya(d+ -4.71238898038469));break a}a=xa(((e|0)<0?6.283185307179586:-6.283185307179586)+d);break a}if(b>>>0>=2139095040){a=v(a-a);break a}b=Rg(a,c+8|0)&3;if(b>>>0<=2){b:{switch(b-1|0){default:a=xa(t[c+8>>3]);break a;case 0:a=ya(t[c+8>>3]);break a;case 1:break b}}a=xa(-t[c+8>>3]);break a}a=v(-ya(t[c+8>>3]));}K=c+16|0;return a}function Ov(a,b,c){a=a|0;b=v(b);c=c|0;var d=v(0),e=0,f=v(0),g=v(0),h=v(0),i=0;e=K-16|0;K=e;i=o[a+44>>2];o[e+8>>2]=o[a+40>>2];o[e+12>>2]=i;i=o[a+36>>2];o[e>>2]=o[a+32>>2];o[e+4>>2]=i;d=v(l[o[o[a>>2]+48>>2]](a));h=v(l[o[o[a>>2]+48>>2]](a));f=v(v(l[o[o[a>>2]+48>>2]](a))+s[e+8>>2]);s[e+8>>2]=f;s[e>>2]=d+s[e>>2];s[e+4>>2]=h+s[e+4>>2];d=v(b*v(.5));h=v(b*v(.25));b=v(b/v(12));a:{b:{a=o[a+56>>2];if(a>>>0>2){break b}c:{switch(a-1|0){default:g=d;d=s[e+4>>2];f=v(d*d);d=v(g*f);g=b;b=s[e>>2];f=v(v(h*f)+v(g*v(b*v(b*v(4)))));g=f;break a;case 0:break b;case 1:break c}}g=d;d=s[e>>2];d=v(d*d);g=v(g*d);d=v(v(h*d)+v(b*v(f*v(f*v(4)))));f=d;break a}f=d;d=s[e>>2];d=v(d*d);f=v(f*d);g=b;b=s[e+4>>2];d=v(v(h*d)+v(g*v(b*v(b*v(4)))));g=d;}o[c+12>>2]=0;s[c+8>>2]=g;s[c+4>>2]=f;s[c>>2]=d;K=e+16|0;}function tr(a,b,c){var d=0,e=0,f=0;d=K-96|0;K=d;o[d+92>>2]=b;o[d+88>>2]=c;dc(d+72|0,o[d+92>>2],o[d+88>>2]);s[d+68>>2]=Ga(o[d+92>>2],o[d+88>>2]);a:{if(+s[d+68>>2]<-.9999998807907104){b=d+48|0;o[(K-16|0)+12>>2]=b;e=d+32|0;o[(K-16|0)+12>>2]=e;cg(o[d+92>>2],b,e);c=K-16|0;o[c+12>>2]=b;c=o[c+12>>2];e=K-16|0;o[e+12>>2]=b;e=o[e+12>>2]+4|0;f=K-16|0;o[f+12>>2]=b;b=o[f+12>>2]+8|0;s[d+28>>2]=0;vb(a,c,e,b,d+28|0);break a}b=K-16|0;s[b+12>>2]=v(v(1)+s[d+68>>2])*v(2);s[d+24>>2]=C(s[b+12>>2]);s[d+20>>2]=v(1)/s[d+24>>2];c=K-16|0;b=d+72|0;o[c+12>>2]=b;s[d+16>>2]=s[o[c+12>>2]>>2]*s[d+20>>2];c=K-16|0;o[c+12>>2]=b;s[d+12>>2]=s[o[c+12>>2]+4>>2]*s[d+20>>2];c=K-16|0;o[c+12>>2]=b;s[d+8>>2]=s[o[c+12>>2]+8>>2]*s[d+20>>2];s[d+4>>2]=s[d+24>>2]*v(.5);vb(a,d+16|0,d+12|0,d+8|0,d+4|0);}K=d+96|0;}function rr(a,b){var c=0,d=0,e=0;c=K-80|0;K=c;o[c+76>>2]=a;o[c+72>>2]=b;b=o[c+72>>2];s[c+52>>2]=Ja(b,1,1,2,2);s[c+48>>2]=Ja(b,1,2,2,0);s[c+44>>2]=Ja(b,1,0,2,1);e=c+56|0;Z(e,c+52|0,c+48|0,c+44|0);d=K-16|0;o[d+12>>2]=b;o[d+8>>2]=0;s[c+40>>2]=Ga(o[d+12>>2]+(o[d+8>>2]<<4)|0,e);s[c+36>>2]=v(1)/s[c+40>>2];d=K-16|0;o[d+12>>2]=e;s[c+32>>2]=s[o[d+12>>2]>>2]*s[c+36>>2];s[c+28>>2]=Ja(b,0,2,2,1)*s[c+36>>2];s[c+24>>2]=Ja(b,0,1,1,2)*s[c+36>>2];d=K-16|0;o[d+12>>2]=e;s[c+20>>2]=s[o[d+12>>2]+4>>2]*s[c+36>>2];s[c+16>>2]=Ja(b,0,0,2,2)*s[c+36>>2];s[c+12>>2]=Ja(b,0,2,1,0)*s[c+36>>2];d=K-16|0;o[d+12>>2]=e;s[c+8>>2]=s[o[d+12>>2]+8>>2]*s[c+36>>2];s[c+4>>2]=Ja(b,0,1,2,0)*s[c+36>>2];s[c>>2]=Ja(b,0,0,1,1)*s[c+36>>2];ac(a,c+32|0,c+28|0,c+24|0,c+20|0,c+16|0,c+12|0,c+8|0,c+4|0,c);K=c+80|0;}function vw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,m=0;h=K-80|0;K=h;if((d|0)>0){while(1){o[((e<<4)+c|0)+12>>2]=-581039253;e=e+1|0;if((e|0)!=(d|0)){continue}break}i=h- -64|0;m=h+40|4;while(1){o[h+40>>2]=13824;f=m;o[f+8>>2]=0;o[f+12>>2]=0;o[f>>2]=0;o[f+4>>2]=0;o[h+60>>2]=-581039253;j=k<<4;e=j+b|0;g=o[e+12>>2];o[i+8>>2]=o[e+8>>2];o[i+12>>2]=g;g=o[e+4>>2];o[i>>2]=o[e>>2];o[i+4>>2]=g;e=h;o[e+32>>2]=1566444395;o[e+36>>2]=0;o[e+24>>2]=1566444395;o[e+28>>2]=1566444395;g=o[a+96>>2];o[e+16>>2]=-581039253;o[e+20>>2]=0;o[e+8>>2]=-581039253;o[e+12>>2]=-581039253;l[o[o[g>>2]+8>>2]](g,e+40|0,e+8|0,e+24|0);e=c+j|0;j=o[f+12>>2];o[e+8>>2]=o[f+8>>2];o[e+12>>2]=j;g=o[f+4>>2];o[e>>2]=o[f>>2];o[e+4>>2]=g;k=k+1|0;if((k|0)!=(d|0)){continue}break}}K=h+80|0;}function Nj(a,b,c){var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),o=v(0),p=v(0),q=v(0),r=v(0),t=v(0);k=s[a+40>>2];i=s[a+24>>2];n=v(k-i);l=s[c+8>>2];p=s[a+32>>2];e=s[a+16>>2];h=v(p-e);f=s[b+4>>2];q=s[a+36>>2];j=s[a+20>>2];g=v(q-j);m=s[b>>2];o=v(v(l-i)*v(v(h*f)-v(g*m)));r=s[c>>2];d=g;g=s[b+8>>2];t=s[c+4>>2];n=v(o+v(v(v(r-e)*v(v(d*g)-v(n*f)))+v(v(t-j)*v(v(n*m)-v(h*g)))));d=i;i=s[a+8>>2];h=v(d-i);d=e;e=s[a>>2];o=v(d-e);d=j;j=s[a+4>>2];d=v(d-j);h=v(v(v(l-i)*v(v(o*f)-v(d*m)))+v(v(v(r-e)*v(v(d*g)-v(h*f)))+v(v(t-j)*v(v(h*m)-v(o*g)))));a=1;d=v(l-k);l=v(e-p);e=v(j-q);k=v(i-k);f=v(v(d*v(v(l*f)-v(e*m)))+v(v(v(r-p)*v(v(e*g)-v(k*f)))+v(v(t-q)*v(v(k*m)-v(l*g)))));if(!(n>v(0)?!(f>v(0)^1|h>v(0)^1):0)){a=h<=v(0)&n<=v(0)&f<=v(0);}return a}function Pg(a){var b=0,c=v(0),d=0,f=v(0),j=0,k=v(0);j=(g(a),h(0));b=j&2147483647;if(b>>>0<1283457024){a:{b:{if(b>>>0<=1054867455){d=-1;if(b>>>0>=964689920){break b}break a}a=v(w(a));if(b>>>0<=1066926079){if(b>>>0<=1060110335){a=v(v(v(a+a)+v(-1))/v(a+v(2)));d=0;break b}a=v(v(a+v(-1))/v(a+v(1)));d=1;break b}if(b>>>0<=1075576831){a=v(v(a+v(-1.5))/v(v(a*v(1.5))+v(1)));d=2;break b}a=v(v(-1)/a);d=3;}b=d;f=v(a*a);c=v(f*f);k=v(c*v(v(c*v(-.106480173766613))+v(-.19999158382415771)));c=v(f*v(v(c*v(v(c*v(.06168760731816292))+v(.14253635704517365)))+v(.333333283662796)));if((b|0)<=-1){return v(a-v(a*v(k+c)))}b=b<<2;a=v(s[b+19328>>2]-v(v(v(a*v(k+c))-s[b+19344>>2])-a));a=(j|0)<0?v(-a):a;}return a}return b>>>0>2139095040?a:(e(0,(g(a),h(0))&-2147483648|1070141402),i())}function il(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;a:{b=o[b+68>>2];b=l[o[o[b>>2]+36>>2]](b)|0;g=l[o[o[b>>2]+36>>2]](b)|0;if(!g){break a}i=l[o[o[b>>2]+20>>2]](b)|0;if((g|0)<1){break a}while(1){b=(h<<4)+i|0;c=o[o[b>>2]>>2];b:{if(!c){break b}b=o[o[b+4>>2]>>2];if(!b|o[c+204>>2]&7|p[b+204|0]&7){break b}b=o[b+208>>2];e=o[a+16>>2];f=o[c+208>>2];d=e+(f<<3)|0;c=o[d>>2];if((c|0)!=(f|0)){while(1){c=(c<<3)+e|0;o[d>>2]=o[c>>2];f=o[c>>2];d=(f<<3)+e|0;c=o[d>>2];if((c|0)!=(f|0)){continue}break}}d=(b<<3)+e|0;c=o[d>>2];if((c|0)!=(b|0)){while(1){b=(c<<3)+e|0;o[d>>2]=o[b>>2];b=o[b>>2];d=(b<<3)+e|0;c=o[d>>2];if((b|0)!=(c|0)){continue}break}}if((b|0)==(f|0)){break b}c=(f<<3)+e|0;o[c>>2]=b;b=(b<<3)+e|0;o[b+4>>2]=o[b+4>>2]+o[c+4>>2];}h=h+1|0;if((h|0)!=(g|0)){continue}break}}}function Ac(a){a=a|0;var b=0;o[a>>2]=16296;b=o[a+160>>2];if(b){if(p[a+164|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+160>>2]=0;}o[a+160>>2]=0;o[a+152>>2]=0;o[a+156>>2]=0;m[a+164|0]=1;b=o[a+136>>2];if(b){if(p[a+140|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+136>>2]=0;}o[a+136>>2]=0;o[a+128>>2]=0;o[a+132>>2]=0;m[a+140|0]=1;b=o[a+116>>2];if(b){if(p[a+120|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+116>>2]=0;}o[a+116>>2]=0;o[a+108>>2]=0;o[a+112>>2]=0;m[a+120|0]=1;b=o[a+96>>2];if(b){if(p[a+100|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+96>>2]=0;}o[a+96>>2]=0;o[a+88>>2]=0;o[a+92>>2]=0;m[a+100|0]=1;b=o[a+76>>2];if(b){if(p[a+80|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+76>>2]=0;}o[a+76>>2]=0;o[a+68>>2]=0;o[a+72>>2]=0;m[a+80|0]=1;return a|0}function Vb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;o[b>>2]=l[o[o[c>>2]+28>>2]](c,o[a+28>>2]);o[b+4>>2]=l[o[o[c>>2]+28>>2]](c,o[a+32>>2]);d=l[o[o[c>>2]+40>>2]](c,a)|0;e=l[o[o[c>>2]+28>>2]](c,d)|0;o[b+8>>2]=e;if(e){l[o[o[c>>2]+48>>2]](c,d);}o[b+12>>2]=o[a+4>>2];o[b+24>>2]=p[a+21|0];o[b+40>>2]=o[a+24>>2];o[b+44>>2]=o[a+16>>2];o[b+48>>2]=p[a+20|0];o[b+20>>2]=o[a+12>>2];o[b+16>>2]=o[a+8>>2];o[b+28>>2]=o[a+36>>2];d=o[a+40>>2];c=0;o[b+36>>2]=0;o[b+32>>2]=d;d=o[a+28>>2];e=o[d+548>>2];if((e|0)>=1){d=o[d+556>>2];while(1){if(o[d+(c<<2)>>2]==(a|0)){o[b+36>>2]=1;}c=c+1|0;if((e|0)!=(c|0)){continue}break}}c=o[a+32>>2];d=o[c+548>>2];if((d|0)>=1){e=o[c+556>>2];c=0;while(1){if(o[e+(c<<2)>>2]==(a|0)){o[b+36>>2]=1;}c=c+1|0;if((d|0)!=(c|0)){continue}break}}return 3536}function jd(a){var b=v(0),c=v(0),d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),p=v(0),q=v(0);o[a+368>>2]=0;o[a+352>>2]=0;o[a+336>>2]=0;n=s[a+456>>2];b=s[a+36>>2];c=v(n*b);p=s[a+460>>2];d=s[a+40>>2];e=v(p*d);q=s[a+464>>2];f=s[a+44>>2];g=v(q*f);s[a+364>>2]=v(v(c*b)+v(e*d))+v(g*f);k=s[a+20>>2];l=s[a+24>>2];m=s[a+28>>2];s[a+360>>2]=v(v(c*k)+v(e*l))+v(g*m);h=c;c=s[a+4>>2];i=e;e=s[a+8>>2];j=g;g=s[a+12>>2];s[a+356>>2]=v(v(h*c)+v(i*e))+v(j*g);h=v(n*k);i=v(p*l);j=v(q*m);s[a+348>>2]=v(v(b*h)+v(d*i))+v(f*j);s[a+344>>2]=v(v(h*k)+v(i*l))+v(j*m);s[a+340>>2]=v(v(h*c)+v(i*e))+v(j*g);h=b;b=v(c*n);i=d;d=v(e*p);j=f;f=v(g*q);s[a+332>>2]=v(v(h*b)+v(i*d))+v(j*f);s[a+328>>2]=v(v(b*k)+v(d*l))+v(f*m);s[a+324>>2]=v(v(b*c)+v(d*e))+v(f*g);}function Gd(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0;f=o[a+4>>2];a:{if(o[a>>2]==(b|0)){e=2;if((b|0)!=(f|0)){break a}f=o[b+12>>2];b=o[o[b+8>>2]+12>>2];h=o[b+96>>2];m=o[f+96>>2]-h|0;a=o[a+12>>2];e=o[b+92>>2];i=o[a+92>>2]-e|0;e=o[f+92>>2]-e|0;h=o[a+96>>2]-h|0;j=u(m,i)-u(e,h)|0;g=j;l=j>>31;j=o[c+8>>2];n=o[d+4>>2];p=o[c+4>>2];q=o[d+8>>2];k=u(j,n)-u(p,q)|0;k=Qw(g,l,k,k>>31);l=L;g=e;e=o[a+88>>2];a=o[b+88>>2];e=e-a|0;f=o[f+88>>2]-a|0;a=u(g,e)-u(f,i)|0;b=a;g=a>>31;d=o[d>>2];c=o[c>>2];a=u(d,p)-u(c,n)|0;i=Qw(b,g,a,a>>31);b=i+k|0;a=L+l|0;a=b>>>0<i>>>0?a+1|0:a;g=b;b=u(f,h)-u(e,m)|0;e=b;f=b>>31;b=u(c,q)-u(d,j)|0;c=Qw(e,f,b,b>>31);b=g+c|0;a=L+a|0;a=b>>>0<c>>>0?a+1|0:a;return ((a|0)>0?1:(a|0)>=0?b>>>0<=0?0:1:0)?2:1}e=(b|0)==(f|0);}return e}function Ff(a,b){var c=0,d=0;c=K-144|0;K=c;_c(a);m[a+560|0]=1;o[a>>2]=2244;o[a+556>>2]=0;o[a+548>>2]=0;o[a+552>>2]=0;o[c+72>>2]=0;o[c+4>>2]=0;s[c>>2]=0;d=o[b+12>>2];o[c+84>>2]=o[b+8>>2];o[c+88>>2]=d;d=o[b>>2];b=o[b+4>>2];o[c+20>>2]=0;o[c+24>>2]=0;o[c+12>>2]=0;o[c+16>>2]=0;o[c+28>>2]=1065353216;o[c+32>>2]=0;o[c+36>>2]=0;o[c+40>>2]=0;o[c+44>>2]=0;o[c+48>>2]=1065353216;o[c+68>>2]=0;o[c+60>>2]=0;o[c+64>>2]=0;o[c+52>>2]=0;o[c+56>>2]=0;o[c+76>>2]=d;o[c+80>>2]=b;o[c+136>>2]=1008981770;o[c+140>>2]=1008981770;o[c+128>>2]=1000593162;o[c+132>>2]=1008981770;m[c+124|0]=0;o[c+116>>2]=1061997773;o[c+120>>2]=1065353216;o[c+108>>2]=0;o[c+112>>2]=0;o[c+100>>2]=1056964608;o[c+104>>2]=0;o[c+92>>2]=0;o[c+96>>2]=0;o[c+8>>2]=1065353216;Gf(a,c);K=c+144|0;}function zv(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;a:{if(p[a+164|0]){if(o[a+132>>2]>=(b|0)){break a}if(b){o[6257]=o[6257]+1;e=l[o[4968]](b<<2,16)|0;}c=o[a+136>>2];f=o[a+128>>2];b:{c:{if((f|0)>=1){while(1){g=d<<2;o[g+e>>2]=o[c+g>>2];d=d+1|0;if((f|0)!=(d|0)){continue}break c}}if(!c){break b}}if(p[a+140|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+136>>2]=0;}o[a+136>>2]=e;o[a+132>>2]=b;m[a+140|0]=1;return}if(o[a+152>>2]>=(b|0)){break a}if(b){o[6257]=o[6257]+1;e=l[o[4968]](b<<1,16)|0;}c=o[a+156>>2];f=o[a+148>>2];d:{e:{if((f|0)>=1){while(1){g=d<<1;n[g+e>>1]=q[c+g>>1];d=d+1|0;if((f|0)!=(d|0)){continue}break e}}if(!c){break d}}if(p[a+160|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+156>>2]=0;}o[a+156>>2]=e;o[a+152>>2]=b;m[a+160|0]=1;}}function fo(a,b,c,d){a=a|0;b=v(b);c=c|0;d=v(d);var e=0,f=0,g=v(0);G(o[5678],0)|0;a:{if(c){s[a+284>>2]=d;b=v(s[a+280>>2]+b);s[a+280>>2]=b;if(!(b>=d)){break a}e=a;g=b;b=v(b/d);b:{if(v(w(b))<v(2147483648)){f=~~b;break b}f=-2147483648;}s[e+280>>2]=g-v(v(f|0)*d);break a}o[a+284>>2]=0;s[a+280>>2]=p[a+316|0]?v(0):b;d=b;f=v(w(b))<v(1.1920928955078125e-7)^1;c=f;}if(l[o[o[a>>2]+20>>2]](a)){e=l[o[o[a>>2]+20>>2]](a)|0;m[20820]=l[o[o[e>>2]+56>>2]](e)>>>4&1;}c:{if(f){e=(f|0)>(c|0)?c:f;l[o[o[a>>2]+168>>2]](a,v(d*v(e|0)));l[o[o[a>>2]+176>>2]](a);if((e|0)<1){break c}c=0;while(1){l[o[o[a>>2]+160>>2]](a,d);l[o[o[a>>2]+80>>2]](a);c=c+1|0;if((e|0)!=(c|0)){continue}break}break c}l[o[o[a>>2]+80>>2]](a);}l[o[o[a>>2]+120>>2]](a);o[6256]=o[6256]+1;return f|0}function ua(a){var b=0,c=0,d=0,f=0,j=0;j=(g(a),h(0));c=j>>>23&255;if((c|0)==255){a=v(a*v(6.2831854820251465));return v(a/a)}b=j<<1;if(b>>>0>2173837238){a:{if(!c){c=0;b=j<<9;if((b|0)>=0){while(1){c=c+ -1|0;b=b<<1;if((b|0)>-1){continue}break}}b=j<<1-c;break a}b=j&8388607|8388608;}d=b-13176795|0;f=(d|0)>-1;if((c|0)>129){while(1){b:{if(!(f&1)){break b}b=d;if(b){break b}return v(a*v(0))}b=b<<1;d=b-13176795|0;f=(d|0)>-1;c=c+ -1|0;if((c|0)>129){continue}break}c=129;}c:{if(!f){break c}b=d;if(b){break c}return v(a*v(0))}d:{if(b>>>0>8388607){f=b;break d}while(1){c=c+ -1|0;d=b>>>0<4194304;f=b<<1;b=f;if(d){continue}break}}d=j&-2147483648;return e(0,d|((c|0)>=1?f+ -8388608|c<<23:f>>>1-c|0)),i()}return (b|0)==-2121130058?v(a*v(0)):a}function Bw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=v(0),f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=0,l=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),x=v(0),y=v(0);k=a+32|0;f=o[a+56>>2];e=s[k+((f+2|0)%3<<2)>>2];a=K-16|0;o[a+12>>2]=0;s[a+8>>2]=e;s[a+4>>2]=e;s[a>>2]=e;f=f<<2;s[f+a>>2]=e+s[f+k>>2];l=s[b+52>>2];g=s[b+24>>2];p=s[b+20>>2];m=s[b+56>>2];h=s[b+40>>2];q=s[b+36>>2];n=s[b+48>>2];r=s[b+8>>2];t=s[b>>2];u=s[b+4>>2];x=s[b+16>>2];y=s[b+32>>2];e=s[a+8>>2];i=s[a>>2];j=s[a+4>>2];o[c+12>>2]=0;h=v(v(v(i*v(w(y)))+v(j*v(w(q))))+v(e*v(w(h))));s[c+8>>2]=m-h;g=v(v(v(i*v(w(x)))+v(j*v(w(p))))+v(e*v(w(g))));s[c+4>>2]=l-g;e=v(v(v(i*v(w(t)))+v(j*v(w(u))))+v(e*v(w(r))));s[c>>2]=n-e;o[d+12>>2]=0;s[d+8>>2]=m+h;s[d+4>>2]=l+g;s[d>>2]=n+e;}function $(a,b,c){var d=0,e=0,f=0,g=0;a:{if(!c){break a}d=a+c|0;m[d+ -1|0]=b;m[a|0]=b;if(c>>>0<3){break a}m[d+ -2|0]=b;m[a+1|0]=b;m[d+ -3|0]=b;m[a+2|0]=b;if(c>>>0<7){break a}m[d+ -4|0]=b;m[a+3|0]=b;if(c>>>0<9){break a}d=0-a&3;e=d+a|0;b=u(b&255,16843009);o[e>>2]=b;c=c-d&-4;d=c+e|0;o[d+ -4>>2]=b;if(c>>>0<9){break a}o[e+8>>2]=b;o[e+4>>2]=b;o[d+ -8>>2]=b;o[d+ -12>>2]=b;if(c>>>0<25){break a}o[e+24>>2]=b;o[e+20>>2]=b;o[e+16>>2]=b;o[e+12>>2]=b;o[d+ -16>>2]=b;o[d+ -20>>2]=b;o[d+ -24>>2]=b;o[d+ -28>>2]=b;g=e&4|24;c=c-g|0;if(c>>>0<32){break a}d=b;f=b;b=e+g|0;while(1){o[b+24>>2]=f;o[b+28>>2]=d;o[b+16>>2]=f;o[b+20>>2]=d;o[b+8>>2]=f;o[b+12>>2]=d;o[b>>2]=f;o[b+4>>2]=d;b=b+32|0;c=c+ -32|0;if(c>>>0>31){continue}break}}return a}function ge(a){a=a|0;var b=0,c=0,d=0,e=0,f=0;o[a>>2]=11340;b=o[a+56>>2];if(b){if(p[a+60|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+56>>2]=0;}o[a+56>>2]=0;o[a+48>>2]=0;o[a+52>>2]=0;m[a+60|0]=1;e=o[a+28>>2];if((e|0)>=1){while(1){b=o[a+36>>2]+u(c,36)|0;f=b;d=o[b+12>>2];if(d){if(p[b+16|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[f+12>>2]=0;}m[b+16|0]=1;o[f+12>>2]=0;o[b+4>>2]=0;o[b+8>>2]=0;c=c+1|0;if((e|0)!=(c|0)){continue}break}}b=o[a+36>>2];if(b){if(p[a+40|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+36>>2]=0;}o[a+36>>2]=0;o[a+28>>2]=0;o[a+32>>2]=0;m[a+40|0]=1;b=o[a+16>>2];if(b){if(p[a+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+16>>2]=0;}o[a+16>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;m[a+20|0]=1;return a|0}function Ih(a,b,c){a=a|0;b=v(b);c=c|0;var d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0);d=K-96|0;K=d;e=v(l[o[o[a>>2]+48>>2]](a));o[d+44>>2]=0;o[d+48>>2]=0;o[d+56>>2]=0;o[d+60>>2]=0;o[d+52>>2]=1065353216;o[d+76>>2]=0;o[d+80>>2]=0;o[d+72>>2]=1065353216;o[d+84>>2]=0;o[d+88>>2]=0;o[d+92>>2]=0;o[d+36>>2]=0;o[d+40>>2]=0;o[d+32>>2]=1065353216;o[d+64>>2]=0;o[d+68>>2]=0;l[o[o[a>>2]+8>>2]](a,d+32|0,d+16|0,d);h=s[d+24>>2];i=s[d+8>>2];f=s[d+16>>2];g=s[d>>2];j=s[d+20>>2];k=s[d+4>>2];o[c+12>>2]=0;b=v(b*v(.0833333283662796));f=v(e+v(v(g-f)*v(.5)));f=v(f+f);f=v(f*f);g=v(e+v(v(k-j)*v(.5)));g=v(g+g);g=v(g*g);s[c+8>>2]=b*v(f+g);e=v(e+v(v(i-h)*v(.5)));e=v(e+e);e=v(e*e);s[c+4>>2]=b*v(f+e);s[c>>2]=b*v(g+e);K=d+96|0;}function Di(a,b,c){a=a|0;b=v(b);c=c|0;var d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0);d=K-96|0;K=d;o[d+44>>2]=0;o[d+48>>2]=0;o[d+56>>2]=0;o[d+60>>2]=0;o[d+52>>2]=1065353216;o[d+76>>2]=0;o[d+80>>2]=0;o[d+72>>2]=1065353216;o[d+84>>2]=0;o[d+88>>2]=0;o[d+92>>2]=0;o[d+36>>2]=0;o[d+40>>2]=0;o[d+32>>2]=1065353216;o[d+64>>2]=0;o[d+68>>2]=0;l[o[o[a>>2]+8>>2]](a,d+32|0,d+16|0,d);h=s[d+24>>2];i=s[d+8>>2];f=s[d+16>>2];g=s[d>>2];j=s[d+20>>2];k=s[d+4>>2];e=v(l[o[o[a>>2]+48>>2]](a));o[c+12>>2]=0;b=v(b*v(.0833333283662796));f=v(e+v(v(g-f)*v(.5)));f=v(f+f);f=v(f*f);g=v(e+v(v(k-j)*v(.5)));g=v(g+g);g=v(g*g);s[c+8>>2]=b*v(f+g);e=v(e+v(v(i-h)*v(.5)));e=v(e+e);e=v(e*e);s[c+4>>2]=b*v(f+e);s[c>>2]=b*v(g+e);K=d+96|0;}function ec(a,b,c,d,e,f,g){var h=0,i=0;h=K-32|0;K=h;o[h+28>>2]=a;o[h+24>>2]=b;s[h+20>>2]=c;s[h+16>>2]=d;s[h+12>>2]=e;s[h+8>>2]=f;o[h+4>>2]=g;c=s[h+20>>2];g=o[h+24>>2];b=K-16|0;a=o[h+28>>2];o[b+12>>2]=a+80;o[b+8>>2]=g;s[o[o[b+12>>2]+12>>2]+(o[b+8>>2]<<2)>>2]=c;c=s[h+16>>2];g=o[h+24>>2];b=K-16|0;o[b+12>>2]=a+120;o[b+8>>2]=g;s[o[o[b+12>>2]+12>>2]+(o[b+8>>2]<<2)>>2]=c;c=s[h+12>>2];g=o[h+24>>2];b=K-16|0;o[b+12>>2]=a+100;o[b+8>>2]=g;s[o[o[b+12>>2]+12>>2]+(o[b+8>>2]<<2)>>2]=c;c=s[h+8>>2];g=o[h+24>>2];b=K-16|0;o[b+12>>2]=a+140;o[b+8>>2]=g;s[o[o[b+12>>2]+12>>2]+(o[b+8>>2]<<2)>>2]=c;g=o[h+4>>2];i=o[h+24>>2];b=K-16|0;o[b+12>>2]=a+160;o[b+8>>2]=i;o[o[o[b+12>>2]+12>>2]+(o[b+8>>2]<<2)>>2]=g;m[a+180|0]=1;K=h+32|0;}function Ue(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0,r=0,s=0;while(1){m=c;g=o[a+12>>2];j=o[g+((c+d|0)/2<<2)>>2];h=d;i=c;while(1){n=o[o[j+836>>2]+208>>2];while(1){c=i;p=(c<<2)+g|0;k=o[p>>2];e=o[o[k+836>>2]+208>>2];if((e|0)<=-1){e=o[o[k+840>>2]+208>>2];}i=c+1|0;f=e;e=n;q=(e|0)>-1;if(!q){e=o[o[j+840>>2]+208>>2];}if((f|0)<(e|0)){continue}break}while(1){e=h;r=e<<2;l=o[r+g>>2];f=n;h=e+ -1|0;if(!q){f=o[o[j+840>>2]+208>>2];}s=f;f=o[o[l+836>>2]+208>>2];if((f|0)<=-1){f=o[o[l+840>>2]+208>>2];}if((s|0)<(f|0)){continue}break}if((c|0)<=(e|0)){o[p>>2]=l;o[o[a+12>>2]+r>>2]=k;e=h;c=i;}if((c|0)<=(e|0)){g=o[a+12>>2];h=e;i=c;continue}break}if((e|0)>(m|0)){Ue(a,b,m,e);}if((c|0)<(d|0)){continue}break}}function Df(a,b){var c=0,d=0,e=0,f=0,g=0;a:{c=o[a+548>>2];b:{if((c|0)<1){break b}e=o[a+556>>2];while(1){if(o[e+(d<<2)>>2]!=(b|0)){d=d+1|0;if((d|0)!=(c|0)){continue}break b}break}if((c|0)!=(d|0)){break a}}c:{if(o[a+552>>2]!=(c|0)){break c}e=c?c<<1:1;if((c|0)>=(e|0)){break c}if(e){o[6257]=o[6257]+1;f=l[o[4968]](e<<2,16)|0;c=o[a+548>>2];}if((c|0)>=1){d=0;while(1){g=d<<2;o[g+f>>2]=o[o[a+556>>2]+g>>2];d=d+1|0;if((d|0)!=(c|0)){continue}break}}d=o[a+556>>2];if(d){if(p[a+560|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}c=o[a+548>>2];}o[a+556>>2]=0;}o[a+556>>2]=f;o[a+552>>2]=e;m[a+560|0]=1;}o[o[a+556>>2]+(c<<2)>>2]=b;o[a+548>>2]=c+1;c=o[b+32>>2];d=a;a=o[b+28>>2];if((d|0)==(a|0)){Kd(a,c,1);return}Kd(c,a,1);}}function yf(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0,r=0,s=0;while(1){m=c;g=o[a+12>>2];j=o[g+((c+d|0)/2<<2)>>2];h=d;i=c;while(1){n=o[o[j+28>>2]+208>>2];while(1){c=i;p=(c<<2)+g|0;k=o[p>>2];f=n;q=(f|0)>-1;if(!q){f=o[o[j+32>>2]+208>>2];}i=c+1|0;e=o[o[k+28>>2]+208>>2];if((e|0)<=-1){e=o[o[k+32>>2]+208>>2];}if((e|0)<(f|0)){continue}break}while(1){e=h;r=e<<2;l=o[r+g>>2];f=o[o[l+28>>2]+208>>2];if((f|0)<=-1){f=o[o[l+32>>2]+208>>2];}s=n;h=e+ -1|0;if(!q){s=o[o[j+32>>2]+208>>2];}if((s|0)<(f|0)){continue}break}if((c|0)<=(e|0)){o[p>>2]=l;o[o[a+12>>2]+r>>2]=k;e=h;c=i;}if((c|0)<=(e|0)){g=o[a+12>>2];h=e;i=c;continue}break}if((e|0)>(m|0)){yf(a,b,m,e);}if((c|0)<(d|0)){continue}break}}function Rc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0;d=o[b+188>>2];if(d){c=o[a+68>>2];c=l[o[o[c>>2]+36>>2]](c)|0;l[o[o[c>>2]+40>>2]](c,d,o[a+24>>2]);c=o[a+68>>2];l[o[o[c>>2]+12>>2]](c,d,o[a+24>>2]);o[b+188>>2]=0;}c=o[b+216>>2];d=o[a+8>>2];a:{if(!((c|0)<0|(c|0)>=(d|0))){e=o[a+16>>2];f=c<<2;g=e+f|0;h=o[g>>2];i=e;d=d+ -1|0;e=d<<2;o[g>>2]=o[i+e>>2];o[e+o[a+16>>2]>>2]=h;o[a+8>>2]=d;if((c|0)>=(d|0)){break a}o[o[f+o[a+16>>2]>>2]+216>>2]=c;break a}if((d|0)<1){break a}e=o[a+16>>2];c=0;while(1){f=e+(c<<2)|0;if(o[f>>2]!=(b|0)){c=c+1|0;if((d|0)!=(c|0)){continue}break a}break}if((d|0)<=(c|0)){break a}d=d+ -1|0;c=d<<2;o[f>>2]=o[c+e>>2];o[c+o[a+16>>2]>>2]=b;o[a+8>>2]=d;}o[b+216>>2]=-1;}function Yn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;if(!(p[b+204|0]&3|m[b+564|0]&1)){Zb(b,a+264|0);}if(o[b+192>>2]){a:{if(!(m[b+204|0]&1)){c=o[a+248>>2];b:{if((c|0)!=o[a+252>>2]){break b}e=c?c<<1:1;if((c|0)>=(e|0)){break b}if(e){o[6257]=o[6257]+1;f=l[o[4968]](e<<2,16)|0;c=o[a+248>>2];}if((c|0)>=1){while(1){g=d<<2;o[g+f>>2]=o[o[a+256>>2]+g>>2];d=d+1|0;if((d|0)!=(c|0)){continue}break}}d=o[a+256>>2];if(d){if(p[a+260|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}c=o[a+248>>2];}o[a+256>>2]=0;}o[a+256>>2]=f;o[a+252>>2]=e;m[a+260|0]=1;}o[o[a+256>>2]+(c<<2)>>2]=b;o[a+248>>2]=c+1;break a}if((o[b+220>>2]&-2)!=4){o[b+220>>2]=2;}}c=b;b=o[b+204>>2]&3;l[o[o[a>>2]+36>>2]](a,c,b?2:1,b?-3:-1);}}function dm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=v(0);d=K-96|0;K=d;e=o[o[a>>2]>>2];f=o[o[a+4>>2]>>2];a:{if(!l[o[o[b>>2]+24>>2]](b,e,f)){break a}g=o[e+192>>2];o[d+88>>2]=-1;o[d+92>>2]=-1;o[d+84>>2]=e+4;o[d+80>>2]=e;o[d+76>>2]=g;o[d+72>>2]=0;g=o[f+192>>2];o[d+64>>2]=-1;o[d+68>>2]=-1;o[d+60>>2]=f+4;o[d+56>>2]=f;o[d+52>>2]=g;o[d+48>>2]=0;if(!o[a+8>>2]){b=l[o[o[b>>2]+8>>2]](b,d+72|0,d+48|0,0,1)|0;o[a+8>>2]=b;if(!b){break a}}b=d+8|0;o[b+32>>2]=0;o[b+12>>2]=d+48;o[b+8>>2]=d+72;o[b+4>>2]=0;o[b>>2]=7172;a=o[a+8>>2];if(o[c+8>>2]==1){l[o[o[a>>2]+8>>2]](a,d+72|0,d+48|0,c,b);break a}h=v(l[o[o[a>>2]+12>>2]](a,e,f,c,b));if(!(s[c+12>>2]>h)){break a}s[c+12>>2]=h;}K=d+96|0;}function Uu(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0);f=o[a+44>>2];a=o[a+4>>2];a:{if(a){g=s[a>>2];if(f){d=s[a+20>>2];e=s[f+20>>2];h=d>e?d:e;d=s[a+8>>2];e=s[f+8>>2];i=d<e?d:e;d=s[a+4>>2];e=s[f+4>>2];j=d<e?d:e;d=s[a+16>>2];e=s[f+16>>2];k=d>e?d:e;d=s[f>>2];g=g<d?g:d;d=s[a+24>>2];e=s[f+24>>2];if(!(d>e)){d=e;break a}break a}e=s[a+28>>2];d=s[a+24>>2];h=s[a+20>>2];k=s[a+16>>2];l=s[a+12>>2];i=s[a+8>>2];j=s[a+4>>2];break a}if(!f){break a}e=s[f+28>>2];d=s[f+24>>2];h=s[f+20>>2];k=s[f+16>>2];l=s[f+12>>2];i=s[f+8>>2];j=s[f+4>>2];g=s[f>>2];}s[b+12>>2]=l;s[b+8>>2]=i;s[b+4>>2]=j;s[b>>2]=g;s[c+12>>2]=e;s[c+8>>2]=d;s[c+4>>2]=h;s[c>>2]=k;}function Jl(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;var k=v(0),l=v(0),m=v(0),n=v(0),p=v(0),q=v(0);j=K-80|0;K=j;k=s[e+52>>2];l=s[f+52>>2];m=s[e+56>>2];n=s[f+56>>2];p=s[e+48>>2];q=s[f+48>>2];a=0;o[j+76>>2]=0;s[j+64>>2]=q-p;s[j+72>>2]=n-m;s[j+68>>2]=l-k;b=1;a:{if(!Ml(c,e,d,f,j- -64|0,j+8|0)){b=0;if(!Ol(c,e,d,f,j- -64|0,j+8|0)){break a}}a=o[j+16>>2];o[h>>2]=o[j+12>>2];o[h+4>>2]=a;a=o[j+24>>2];o[h+8>>2]=o[j+20>>2];o[h+12>>2]=a;a=o[j+40>>2];o[i+8>>2]=o[j+36>>2];o[i+12>>2]=a;a=o[j+32>>2];o[i>>2]=o[j+28>>2];o[i+4>>2]=a;a=o[j+56>>2];o[g+8>>2]=o[j+52>>2];o[g+12>>2]=a;a=o[j+48>>2];o[g>>2]=o[j+44>>2];o[g+4>>2]=a;a=b;}K=j+80|0;return a|0}function Yc(a,b,c,d){var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),o=v(0),p=v(0);i=s[c+24>>2];e=s[b+24>>2];l=v(i-e);j=s[c+16>>2];g=s[b+16>>2];m=v(j-g);f=s[a+4>>2];k=s[c+20>>2];h=s[b+20>>2];n=v(k-h);o=s[a>>2];p=s[a+8>>2];if(!(v(v(e*v(v(m*f)-v(n*o)))+v(v(g*v(v(n*p)-v(l*f)))+v(h*v(v(l*o)-v(m*p)))))<v(0))){a=0;}else {f=v(v(v(g*g)+v(h*h))+v(e*e));a:{if(!!(v(v(v(g*m)+v(h*n))+v(e*l))>v(0))){break a}f=v(v(v(j*j)+v(k*k))+v(i*i));if(!!(v(v(v(j*m)+v(k*n))+v(i*l))<v(0))){break a}f=v(v(v(v(j*j)+v(k*k))+v(i*i))*v(v(v(g*g)+v(h*h))+v(e*e)));e=v(v(v(j*g)+v(k*h))+v(i*e));e=v(v(f-v(e*e))/v(v(v(m*m)+v(n*n))+v(l*l)));f=e>v(0)?e:v(0);}s[d>>2]=C(f);a=1;}return a}function mu(a,b,c){var d=0,e=v(0),f=v(0),g=0,h=0,i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),p=v(0);d=K-16|0;K=d;a:{b:{c:{d:{e:{if(o[c+100>>2]>=0){s[(o[b+108>>2]<<2)+d>>2]=o[c+88>>2];break e}e=Va(c+24|0);g=c+72|0;f=Va(g);h=o[c+100>>2];s[(o[b+108>>2]<<2)+d>>2]=e/f;if((h|0)<0){break d}}s[(o[b+112>>2]<<2)+d>>2]=o[c+92>>2];break c}e=Va(c+40|0);f=Va(g);h=o[c+100>>2];s[(o[b+112>>2]<<2)+d>>2]=e/f;if((h|0)<0){break b}}e=v(o[c+96>>2]);break a}e=v(Va(c+56|0)/Va(g));}s[(o[b+104>>2]<<2)+d>>2]=e;e=s[b+20>>2];f=s[b+24>>2];i=s[b+16>>2];j=s[b>>2];k=s[b+4>>2];l=s[b+8>>2];m=s[d>>2];n=s[d+4>>2];p=s[d+8>>2];o[a+12>>2]=0;s[a+8>>2]=f+v(p*l);s[a+4>>2]=e+v(n*k);s[a>>2]=i+v(m*j);K=d+16|0;}function Dn(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;d=o[a+8>>2];if((d|0)>=1){while(1){c=o[o[a+16>>2]+(e<<2)>>2];if(p[c+252|0]&2){d=(g=b,h=l[o[o[c>>2]+16>>2]](c)|0,i=1,f=o[o[b>>2]+16>>2],l[f](g|0,h|0,i|0)|0);i=b,h=d,g=l[o[o[c>>2]+20>>2]](c,o[d+8>>2],b)|0,j=1497645650,k=c,f=o[o[b>>2]+20>>2],l[f](i|0,h|0,g|0,j|0,k|0);d=o[a+8>>2];}e=e+1|0;if((e|0)<(d|0)){continue}break}}if(o[a+228>>2]>=1){e=0;while(1){c=o[o[a+236>>2]+(e<<2)>>2];d=(k=b,j=l[o[o[c>>2]+36>>2]](c)|0,g=1,f=o[o[b>>2]+16>>2],l[f](k|0,j|0,g|0)|0);g=b,j=d,k=l[o[o[c>>2]+40>>2]](c,o[d+8>>2],b)|0,h=1397641027,i=c,f=o[o[b>>2]+20>>2],l[f](g|0,j|0,k|0,h|0,i|0);e=e+1|0;if((e|0)<o[a+228>>2]){continue}break}}}function Lc(a){a=a|0;var b=0,c=0,d=0,e=0;o[a>>2]=10404;d=o[a+52>>2];if((d|0)>=1){while(1){e=b<<2;c=o[e+o[a+60>>2]>>2];if(c){l[o[o[c>>2]>>2]](c)|0;c=o[a+4>>2];l[o[o[c>>2]+60>>2]](c,o[o[a+60>>2]+e>>2]);}b=b+1|0;if((d|0)!=(b|0)){continue}break}}b=o[a+60>>2];if(b){if(p[a- -64|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+60>>2]=0;}o[a+60>>2]=0;o[a+52>>2]=0;o[a+56>>2]=0;m[a- -64|0]=1;b=o[a+40>>2];if(b){if(p[a+44|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+40>>2]=0;}o[a+40>>2]=0;o[a+32>>2]=0;o[a+36>>2]=0;m[a+44|0]=1;b=o[a+20>>2];if(b){if(p[a+24|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+20>>2]=0;}o[a+20>>2]=0;o[a+12>>2]=0;o[a+16>>2]=0;m[a+24|0]=1;return a|0}function Kf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K+ -64|0;K=d;o[d+60>>2]=a;o[d+56>>2]=b;m[d+55|0]=c;a=o[d+60>>2];o[a+8>>2]=o[o[d+56>>2]>>2];Ka(a+24|0,o[d+56>>2]);o[(K-16|0)+12>>2]=d+32;a:{if(m[d+55|0]&1){b=o[d+56>>2];c=o[b+12>>2];o[d+32>>2]=o[b+8>>2];o[d+36>>2]=c;c=o[b+20>>2];o[d+40>>2]=o[b+16>>2];o[d+44>>2]=c;break a}b=K-16|0;o[b+12>>2]=o[a+8>>2];c=K-16|0;o[c+12>>2]=o[b+12>>2]+4;Sa(d+16|0,o[c+12>>2],o[d+56>>2]+8|0);b=o[d+20>>2];o[d+32>>2]=o[d+16>>2];o[d+36>>2]=b;b=o[d+28>>2];o[d+40>>2]=o[d+24>>2];o[d+44>>2]=b;}Jf(a+76|0,d+32|0);o[(K-16|0)+12>>2]=d;ig(d,a+44|0,a+60|0,s[o[d+56>>2]+24>>2]);Jf(a+96|0,d);Vo(a+116|0,o[d+56>>2]+24|0);K=d- -64|0;return v(s[a+4>>2])}function Xn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;if(!(p[b+204|0]&3|m[b+564|0]&1)){Zb(b,a+264|0);}if(o[b+192>>2]){a:{if(!(m[b+204|0]&1)){e=o[a+248>>2];b:{if((e|0)!=o[a+252>>2]){break b}g=e?e<<1:1;if((e|0)>=(g|0)){break b}if(g){o[6257]=o[6257]+1;h=l[o[4968]](g<<2,16)|0;e=o[a+248>>2];}if((e|0)>=1){while(1){i=f<<2;o[i+h>>2]=o[o[a+256>>2]+i>>2];f=f+1|0;if((f|0)!=(e|0)){continue}break}}f=o[a+256>>2];if(f){if(p[a+260|0]){if(f){o[6258]=o[6258]+1;l[o[4969]](f);}e=o[a+248>>2];}o[a+256>>2]=0;}o[a+256>>2]=h;o[a+252>>2]=g;m[a+260|0]=1;}o[o[a+256>>2]+(e<<2)>>2]=b;o[a+248>>2]=e+1;break a}if((o[b+220>>2]&-2)!=4){o[b+220>>2]=2;}}l[o[o[a>>2]+36>>2]](a,b,c,d);}}function rw(a,b,c,d){a=a|0;b=b|0;c=c|0;var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0);g=s[a+24>>2];h=s[a+28>>2];i=s[a+32>>2];e=v(v(v(g*s[b>>2])+v(h*s[b+4>>2]))+v(i*s[b+8>>2]));f=s[a+20>>2];if(!!(e>f)){s[a+20>>2]=e;c=o[b+12>>2];o[a+12>>2]=o[b+8>>2];o[a+16>>2]=c;c=o[b+4>>2];o[a+4>>2]=o[b>>2];o[a+8>>2]=c;f=e;}e=v(v(v(g*s[b+16>>2])+v(h*s[b+20>>2]))+v(i*s[b+24>>2]));if(!!(e>f)){s[a+20>>2]=e;c=o[b+28>>2];o[a+12>>2]=o[b+24>>2];o[a+16>>2]=c;c=o[b+20>>2];o[a+4>>2]=o[b+16>>2];o[a+8>>2]=c;f=e;}e=v(v(v(g*s[b+32>>2])+v(h*s[b+36>>2]))+v(i*s[b+40>>2]));if(!!(e>f)){s[a+20>>2]=e;c=o[b+44>>2];o[a+12>>2]=o[b+40>>2];o[a+16>>2]=c;c=o[b+36>>2];o[a+4>>2]=o[b+32>>2];o[a+8>>2]=c;}}function bn(a,b,c){var d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),w=v(0);Um(a,b);o[a>>2]=3360;d=o[c+4>>2];o[a+300>>2]=o[c>>2];o[a+304>>2]=d;d=o[c+12>>2];o[a+308>>2]=o[c+8>>2];o[a+312>>2]=d;h=s[b+52>>2];i=s[b+8>>2];j=s[b+12>>2];k=s[b+56>>2];l=s[b+20>>2];n=s[b+24>>2];p=s[b+28>>2];q=s[b+60>>2];r=s[b+36>>2];t=s[b+40>>2];e=s[c+8>>2];u=s[b+44>>2];w=s[b+4>>2];f=s[c>>2];g=s[c+4>>2];o[a+356>>2]=0;o[a+348>>2]=1050253722;o[a+352>>2]=1065353216;m[a+344|0]=0;o[a+328>>2]=0;o[a+332>>2]=0;s[a+324>>2]=q+v(v(v(f*r)+v(g*t))+v(e*u));s[a+320>>2]=k+v(v(v(f*l)+v(g*n))+v(e*p));s[a+316>>2]=h+v(v(v(f*w)+v(g*i))+v(e*j));}function Vh(a,b,c,d){a=a|0;b=b|0;c=c|0;var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0);g=s[a+88>>2];h=s[a+92>>2];i=s[a+96>>2];e=v(v(v(g*s[b>>2])+v(h*s[b+4>>2]))+v(i*s[b+8>>2]));f=s[a+84>>2];if(!!(e>f)){s[a+84>>2]=e;c=o[b+12>>2];o[a+12>>2]=o[b+8>>2];o[a+16>>2]=c;c=o[b+4>>2];o[a+4>>2]=o[b>>2];o[a+8>>2]=c;f=e;}e=v(v(v(g*s[b+16>>2])+v(h*s[b+20>>2]))+v(i*s[b+24>>2]));if(!!(e>f)){s[a+84>>2]=e;c=o[b+28>>2];o[a+12>>2]=o[b+24>>2];o[a+16>>2]=c;c=o[b+20>>2];o[a+4>>2]=o[b+16>>2];o[a+8>>2]=c;f=e;}e=v(v(v(g*s[b+32>>2])+v(h*s[b+36>>2]))+v(i*s[b+40>>2]));if(!!(e>f)){s[a+84>>2]=e;c=o[b+44>>2];o[a+12>>2]=o[b+40>>2];o[a+16>>2]=c;c=o[b+36>>2];o[a+4>>2]=o[b+32>>2];o[a+8>>2]=c;}}function Yq(a){a=a|0;var b=0,c=0,d=0;b=K-16|0;K=b;o[b+12>>2]=a;d=o[b+12>>2];o[b+8>>2]=0;while(1){a=o[b+8>>2];c=K-16|0;o[c+12>>2]=d+244;if((a|0)<o[o[c+12>>2]+4>>2]){c=o[b+8>>2];a=K-16|0;o[a+12>>2]=d+244;o[a+8>>2]=c;o[b+4>>2]=o[o[o[a+12>>2]+12>>2]+(o[a+8>>2]<<2)>>2];a:{if(!(pd(o[b+4>>2])&1)){break a}a=K-16|0;o[a+12>>2]=o[b+4>>2];if(o[o[a+12>>2]+204>>2]&2){break a}a=K-16|0;o[a+12>>2]=o[b+4>>2];b:{if(+s[o[a+12>>2]+504>>2]==1){a=K-16|0;o[a+12>>2]=o[b+4>>2];od(o[a+12>>2]+472|0);break b}Ef(o[b+4>>2]);}a=K-16|0;o[a+12>>2]=o[b+4>>2];if(+s[o[a+12>>2]+508>>2]==1){a=K-16|0;o[a+12>>2]=o[b+4>>2];od(o[a+12>>2]+488|0);}}o[b+8>>2]=o[b+8>>2]+1;continue}break}K=b+16|0;}function jp(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-32|0;K=d;o[d+24>>2]=a;o[d+20>>2]=b;o[d+16>>2]=c;m[d+15|0]=(o[o[d+20>>2]+4>>2]&o[o[d+16>>2]+8>>2])!=0;m[d+15|0]=m[d+15|0]&1?(o[o[d+16>>2]+4>>2]&o[o[d+20>>2]+8>>2])!=0:0;a:{if(m[d+15|0]&1){o[d+8>>2]=o[o[d+20>>2]>>2];o[d+4>>2]=o[o[d+16>>2]>>2];a=K-16|0;o[a+12>>2]=o[d+8>>2];b:{if(!(o[o[a+12>>2]+204>>2]&1)){break b}a=K-16|0;o[a+12>>2]=o[d+4>>2];if(!(o[o[a+12>>2]+204>>2]&1)){break b}m[d+31|0]=0;break a}a=K-16|0;o[a+12>>2]=o[d+8>>2];c:{if(o[o[a+12>>2]+220>>2]!=2){break c}a=K-16|0;o[a+12>>2]=o[d+4>>2];if(o[o[a+12>>2]+220>>2]!=2){break c}m[d+31|0]=0;break a}}m[d+31|0]=m[d+15|0]&1;}K=d+32|0;return m[d+31|0]&1}function vh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0),x=v(0),y=v(0);e=v(l[o[o[a>>2]+48>>2]](a));j=s[b+52>>2];h=s[b+20>>2];n=s[b+24>>2];k=s[b+56>>2];i=s[b+36>>2];f=s[a+36>>2];p=s[b+40>>2];q=s[a+40>>2];m=s[b+48>>2];r=s[b>>2];t=s[b+4>>2];u=s[b+8>>2];x=s[b+16>>2];y=s[b+32>>2];g=s[a+32>>2];o[c+12>>2]=0;g=v(e+g);f=v(e+f);e=v(e+q);i=v(v(v(g*v(w(y)))+v(f*v(w(i))))+v(e*v(w(p))));s[c+8>>2]=k-i;h=v(v(v(g*v(w(x)))+v(f*v(w(h))))+v(e*v(w(n))));s[c+4>>2]=j-h;e=v(v(v(g*v(w(r)))+v(f*v(w(t))))+v(e*v(w(u))));s[c>>2]=m-e;o[d+12>>2]=0;s[d+8>>2]=k+i;s[d+4>>2]=h+j;s[d>>2]=e+m;}function Ti(a){a=a|0;var b=v(0),c=0,d=0,e=0,f=0;c=K-32|0;K=c;o[a+52>>2]=-581039253;o[a+56>>2]=-581039253;o[a+36>>2]=1566444395;o[a+40>>2]=1566444395;o[a+60>>2]=-581039253;o[a+64>>2]=0;o[a+44>>2]=1566444395;o[a+48>>2]=0;if(o[a+20>>2]>=1){while(1){e=o[a+28>>2]+u(d,80)|0;f=o[e+64>>2];l[o[o[f>>2]+8>>2]](f,e,c+16|0,c);b=s[c+16>>2];if(!!(s[a+36>>2]>b)){s[a+36>>2]=b;}b=s[c>>2];if(!!(s[a+52>>2]<b)){s[a+52>>2]=b;}b=s[c+20>>2];if(!!(s[a+40>>2]>b)){s[a+40>>2]=b;}b=s[c+4>>2];if(!!(s[a+56>>2]<b)){s[a+56>>2]=b;}b=s[c+24>>2];if(!!(s[a+44>>2]>b)){s[a+44>>2]=b;}b=s[c+8>>2];if(!!(s[a+60>>2]<b)){s[a+60>>2]=b;}d=d+1|0;if((d|0)<o[a+20>>2]){continue}break}}K=c+32|0;}function wj(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;d=o[a+4>>2];if((d|0)<(b|0)){if(o[a+8>>2]<(b|0)){if(b){o[6257]=o[6257]+1;g=l[o[4968]](b<<3,16)|0;c=o[a+4>>2];}else {c=d;}if((c|0)>=1){while(1){e=f<<3;h=e+g|0;e=o[a+12>>2]+e|0;i=o[e+4>>2];o[h>>2]=o[e>>2];o[h+4>>2]=i;f=f+1|0;if((c|0)!=(f|0)){continue}break}}c=o[a+12>>2];if(c){if(p[a+16|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+12>>2]=0;}o[a+12>>2]=g;m[a+16|0]=1;o[a+8>>2]=b;}while(1){c=o[a+12>>2]+(d<<3)|0;o[c>>2]=0;o[c+4>>2]=0;d=d+1|0;if((d|0)!=(b|0)){continue}break}}o[a+4>>2]=b;if((b|0)>=1){a=o[a+12>>2];d=0;while(1){c=a+(d<<3)|0;o[c+4>>2]=1;o[c>>2]=d;d=d+1|0;if((d|0)!=(b|0)){continue}break}}}function hb(a){var b=0,c=0,d=v(0),e=0;a:{b:{e=(g(a),h(0));c=e&2147483647;if(c>>>0>=1065353216){if((c|0)!=1065353216){break b}return v(+a*1.5707963267948966+7.52316384526264e-37)}if(c>>>0<=1056964607){if(c+ -8388608>>>0<956301312){break a}d=v(a*a);return v(v(v(v(d*v(v(d*v(v(d*v(-.008656363002955914))+v(-.04274342209100723)))+v(.16666586697101593)))/v(v(d*v(-.7066296339035034))+v(1)))*a)+a)}a=v(v(v(1)-v(w(a)))*v(.5));b=C(+a);b=b+b*+v(v(a*v(v(a*v(v(a*v(-.008656363002955914))+v(-.04274342209100723)))+v(.16666586697101593)))/v(v(a*v(-.7066296339035034))+v(1)));a=v(1.5707963267948966-(b+b));return (e|0)<0?v(-a):a}a=v(v(0)/v(a-a));}return a}function Qf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-32|0;K=d;o[d+28>>2]=a;o[d+24>>2]=b;m[d+23|0]=c;a=o[d+28>>2];s[a+4>>2]=s[o[d+24>>2]+40>>2];o[a+80>>2]=o[o[d+24>>2]>>2];a:{if(m[d+23|0]&1){b=o[d+24>>2];c=o[b+12>>2];o[a+48>>2]=o[b+8>>2];o[a+52>>2]=c;c=o[b+20>>2];o[a+56>>2]=o[b+16>>2];o[a+60>>2]=c;break a}b=K-16|0;o[b+12>>2]=o[a+80>>2];c=K-16|0;o[c+12>>2]=o[b+12>>2]+4;Sa(d,o[c+12>>2],o[d+24>>2]+8|0);b=o[d+4>>2];o[a+48>>2]=o[d>>2];o[a+52>>2]=b;b=o[d+12>>2];o[a+56>>2]=o[d+8>>2];o[a+60>>2]=b;}b=o[d+24>>2];c=o[b+28>>2];o[a+64>>2]=o[b+24>>2];o[a+68>>2]=c;c=o[b+36>>2];o[a+72>>2]=o[b+32>>2];o[a+76>>2]=c;K=d+32|0;return v(s[o[d+24>>2]+40>>2])}function of(a,b,c,d){var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0);f=wa(c);e=s[b+444>>2];c=va(c);a:{if(!(v(w(f))>v(1.1920928955078125e-7))){g=v(c*c);i=v(f*f);break a}g=v(c*c);i=v(f*f);j=v(g/i);h=s[b+448>>2];e=v(C(v(v(j+v(1))/v(v(v(1)/v(h*h))+v(j/v(e*e))))));}o[a+12>>2]=0;e=v(e*v(.5));g=v(va(e)/v(C(v(g+v(i+v(0))))));i=v(g*v(0));e=wa(e);h=v(e*v(0));c=v(g*v(-c));k=v(i*v(0));j=v(v(h+v(c*d))-k);f=v(f*g);h=v(v(h+k)-v(f*d));k=v(f*v(0));l=v(c*v(0));g=v(v(v(v(g*v(-0))*d)-k)-l);d=v(v(v(e*d)+k)-l);s[a+8>>2]=v(i*j)+v(v(v(e*h)-v(c*g))-v(f*d));s[a+4>>2]=v(c*d)+v(v(v(e*j)-v(f*g))-v(i*h));s[a>>2]=v(f*h)+v(v(v(e*d)-v(i*g))-v(c*j));}function mf(a){o[a>>2]=3756;m[a+20|0]=1;o[a+16>>2]=0;m[a+40|0]=1;o[a+8>>2]=0;o[a+12>>2]=0;o[a+36>>2]=0;m[a+60|0]=1;o[a+28>>2]=0;o[a+32>>2]=0;o[a+56>>2]=0;m[a+80|0]=1;o[a+48>>2]=0;o[a+52>>2]=0;o[a+76>>2]=0;m[a+100|0]=1;o[a+68>>2]=0;o[a+72>>2]=0;o[a+96>>2]=0;m[a+120|0]=1;o[a+88>>2]=0;o[a+92>>2]=0;o[a+116>>2]=0;m[a+140|0]=1;o[a+108>>2]=0;o[a+112>>2]=0;o[a+136>>2]=0;o[a+128>>2]=0;o[a+132>>2]=0;m[a+160|0]=1;o[a+156>>2]=0;o[a+148>>2]=0;o[a+152>>2]=0;m[a+180|0]=1;o[a+176>>2]=0;o[a+168>>2]=0;o[a+172>>2]=0;m[a+208|0]=1;o[a+232>>2]=0;o[a+204>>2]=0;o[a+196>>2]=0;o[a+200>>2]=0;o[a+224>>2]=0;o[a+212>>2]=142;o[a+216>>2]=143;o[a+220>>2]=144;}function Ch(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0);d=K-96|0;K=d;o[d+44>>2]=0;o[d+48>>2]=0;o[d+56>>2]=0;o[d+60>>2]=0;o[d+52>>2]=1065353216;o[d+76>>2]=0;o[d+80>>2]=0;o[d+72>>2]=1065353216;o[d+84>>2]=0;o[d+88>>2]=0;o[d+92>>2]=0;o[d+36>>2]=0;o[d+40>>2]=0;o[d+32>>2]=1065353216;o[d+64>>2]=0;o[d+68>>2]=0;l[o[o[a>>2]+8>>2]](a,d+32|0,d+16|0,d);h=s[d>>2];i=s[d+16>>2];e=v(h-i);g=v(e*e);e=s[d+4>>2];j=s[d+20>>2];f=v(e-j);m=v(g+v(f*f));f=s[d+8>>2];g=s[d+24>>2];k=v(f-g);s[c>>2]=v(C(v(m+v(k*k))))*v(.5);o[b+12>>2]=0;s[b+8>>2]=v(f+g)*v(.5);s[b+4>>2]=v(e+j)*v(.5);s[b>>2]=v(h+i)*v(.5);K=d+96|0;}function lh(a){a=a|0;var b=0;o[a>>2]=15268;b=o[a+156>>2];if(b){if(p[a+160|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+156>>2]=0;}o[a+156>>2]=0;o[a+148>>2]=0;o[a+152>>2]=0;m[a+160|0]=1;b=o[a+136>>2];if(b){if(p[a+140|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+136>>2]=0;}o[a+136>>2]=0;o[a+128>>2]=0;o[a+132>>2]=0;m[a+140|0]=1;b=o[a+116>>2];if(b){if(p[a+120|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+116>>2]=0;}o[a+116>>2]=0;o[a+108>>2]=0;o[a+112>>2]=0;m[a+120|0]=1;b=o[a+96>>2];if(b){if(p[a+100|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+96>>2]=0;}o[a+96>>2]=0;o[a+88>>2]=0;o[a+92>>2]=0;m[a+100|0]=1;ph(a);return a|0}function yb(a){var b=0,c=v(0);b=K-96|0;K=b;m[a+92|0]=1;a:{if(m[22688]&1){break a}if(!Fa(22688)){break a}o[5649]=0;o[5650]=0;o[5648]=1065353216;o[5651]=0;o[5652]=0;o[5654]=0;o[5655]=0;o[5653]=1065353216;o[5656]=0;o[5657]=0;o[5661]=0;o[5662]=0;o[5660]=-1082130432;o[5658]=1065353216;o[5659]=0;o[5663]=0;o[5664]=0;o[5666]=0;o[5667]=0;o[5665]=-1082130432;o[5668]=0;o[5669]=0;o[5670]=-1082130432;o[5671]=0;Ea(22688);}b=$(b,0,96);l[o[o[a>>2]+76>>2]](a,22592,b,6);c=s[a+48>>2];s[a+76>>2]=s[b>>2]+c;s[a+60>>2]=s[b+48>>2]-c;s[a+80>>2]=c+s[b+20>>2];s[a- -64>>2]=s[b+68>>2]-c;s[a+84>>2]=c+s[b+40>>2];s[a+68>>2]=s[b+88>>2]-c;K=b+96|0;}function Pm(a,b){var c=v(0),d=v(0),e=v(0);a:{d=s[a+4>>2];if(!(d>v(0))){break a}e=s[a>>2];c=ua(v(s[b>>2]-e));b:{if(!!(c<v(-3.1415927410125732))){c=v(c+v(6.2831854820251465));break b}if(!(c>v(3.1415927410125732))){break b}c=v(c+v(-6.2831854820251465));}if(c<v(-d)^1?!!(c<=d):0){break a}if(!!(c>v(0))){c=ua(v(d+e));if(!!(c<v(-3.1415927410125732))){s[b>>2]=c+v(6.2831854820251465);return}s[b>>2]=c>v(3.1415927410125732)^1?c:v(c+v(-6.2831854820251465));return}c=ua(v(e-d));c:{if(!!(c<v(-3.1415927410125732))){c=v(c+v(6.2831854820251465));break c}if(!(c>v(3.1415927410125732))){break c}c=v(c+v(-6.2831854820251465));}s[b>>2]=c;}}function Ri(a,b,c){a=a|0;b=v(b);c=c|0;var d=0,e=v(0),f=v(0),g=v(0),h=v(0);d=K-96|0;K=d;o[d+44>>2]=0;o[d+48>>2]=0;o[d+56>>2]=0;o[d+60>>2]=0;o[d+52>>2]=1065353216;o[d+76>>2]=0;o[d+80>>2]=0;o[d+72>>2]=1065353216;o[d+84>>2]=0;o[d+88>>2]=0;o[d+92>>2]=0;o[d+36>>2]=0;o[d+40>>2]=0;o[d+32>>2]=1065353216;o[d+64>>2]=0;o[d+68>>2]=0;l[o[o[a>>2]+8>>2]](a,d+32|0,d+16|0,d);e=s[d+24>>2];h=s[d+8>>2];b=v(b/v(12));f=v(v(s[d>>2]-s[d+16>>2])*v(.5));f=v(f+f);f=v(f*f);g=v(v(s[d+4>>2]-s[d+20>>2])*v(.5));g=v(g+g);g=v(g*g);s[c+8>>2]=b*v(f+g);e=v(v(h-e)*v(.5));e=v(e+e);e=v(e*e);s[c+4>>2]=b*v(f+e);s[c>>2]=b*v(g+e);K=d+96|0;}function gh(a,b){var c=0,d=0,e=0,f=0,g=0;o[a+12>>2]=0;m[a+16|0]=1;o[a+4>>2]=0;o[a+8>>2]=0;d=o[b+4>>2];if((d|0)<=0){o[a+4>>2]=d;return}o[6257]=o[6257]+1;e=l[o[4968]](d<<2,16)|0;f=o[a+4>>2];if((f|0)>=1){while(1){g=c<<2;o[g+e>>2]=o[o[a+12>>2]+g>>2];c=c+1|0;if((f|0)!=(c|0)){continue}break}}c=o[a+12>>2];if(c){if(p[a+16|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+12>>2]=0;}o[a+12>>2]=e;m[a+16|0]=1;o[a+8>>2]=d;c=0;while(1){o[(c<<2)+e>>2]=0;e=o[a+12>>2];c=c+1|0;if((d|0)!=(c|0)){continue}break}o[a+4>>2]=d;c=0;while(1){a=c<<2;o[a+e>>2]=o[a+o[b+12>>2]>>2];c=c+1|0;if((d|0)!=(c|0)){continue}break}}function La(a,b){var c=v(0),d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0);if(!(!a|!(o[a+180>>2]&1))){r=s[a+172>>2];c=s[a+44>>2];j=s[a+12>>2];k=s[a+28>>2];e=s[a+36>>2];l=s[a+20>>2];t=s[a+168>>2];d=s[a+40>>2];m=s[a+8>>2];n=s[a+24>>2];f=s[a+164>>2];p=s[a+4>>2];o[b+12>>2]=0;q=e;g=f;f=s[b>>2];h=s[b+4>>2];e=s[b+8>>2];i=v(g*v(v(v(p*f)+v(l*h))+v(q*e)));u=d;d=v(t*v(v(v(f*m)+v(h*n))+v(e*d)));g=c;c=v(r*v(v(v(f*j)+v(h*k))+v(e*c)));s[b+8>>2]=v(v(q*i)+v(u*d))+v(g*c);s[b+4>>2]=v(v(l*i)+v(n*d))+v(k*c);s[b>>2]=v(v(p*i)+v(m*d))+v(j*c);}}function dv(a){var b=0,c=0,d=0,e=0,f=0,g=0;if(o[a+8>>2]<1){o[6257]=o[6257]+1;f=l[o[4968]](20,16)|0;c=o[a+4>>2];a:{if((c|0)<1){break a}while(1){d=u(b,20);gh(d+f|0,d+o[a+12>>2]|0);b=b+1|0;if((c|0)!=(b|0)){continue}break}g=o[a+4>>2];if((g|0)<1){break a}c=0;while(1){b=o[a+12>>2]+u(c,20)|0;d=b;e=o[b+12>>2];if(e){if(p[b+16|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}}o[d+12>>2]=0;}m[b+16|0]=1;o[d+12>>2]=0;o[b+4>>2]=0;o[b+8>>2]=0;c=c+1|0;if((g|0)!=(c|0)){continue}break}}b=o[a+12>>2];if(b){if(p[a+16|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+12>>2]=0;}o[a+12>>2]=f;m[a+16|0]=1;o[a+8>>2]=1;}}function vv(a){var b=0,c=0,d=0,e=0,f=0;o[a>>2]=15368;o[a+24>>2]=0;o[a+68>>2]=0;m[a+20|0]=1;o[a+16>>2]=0;m[a+44|0]=1;o[a+8>>2]=0;o[a+12>>2]=0;o[a+40>>2]=0;m[a- -64|0]=1;o[a+32>>2]=0;o[a+36>>2]=0;o[a+60>>2]=0;o[a+52>>2]=0;o[a+56>>2]=0;o[6257]=o[6257]+1;e=l[o[4968]](32,16)|0;f=o[a+8>>2];if((f|0)>=1){while(1){c=d<<4;b=c+e|0;c=c+o[a+16>>2]|0;o[b>>2]=o[c>>2];o[b+4>>2]=o[c+4>>2];o[b+8>>2]=o[c+8>>2];o[b+12>>2]=o[c+12>>2];d=d+1|0;if((f|0)!=(d|0)){continue}break}}b=o[a+16>>2];if(b){if(p[a+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+16>>2]=0;}o[a+16>>2]=e;m[a+20|0]=1;o[a+12>>2]=2;kh(a);}function gg(a,b,c,d,e){var f=0;f=K-32|0;K=f;o[f+28>>2]=a;s[f+24>>2]=b;o[f+20>>2]=c;o[f+16>>2]=d;o[f+12>>2]=e;a=o[f+28>>2];s[a>>2]=s[f+24>>2];o[a+4>>2]=o[f+20>>2];wb(a+8|0);o[a+72>>2]=o[f+16>>2];c=o[f+12>>2];d=o[c+4>>2];o[a+76>>2]=o[c>>2];o[a+80>>2]=d;d=o[c+12>>2];o[a+84>>2]=o[c+8>>2];o[a+88>>2]=d;s[a+92>>2]=0;s[a+96>>2]=0;s[a+100>>2]=.5;s[a+104>>2]=0;s[a+108>>2]=0;s[a+112>>2]=0;s[a+116>>2]=.800000011920929;s[a+120>>2]=1;m[a+124|0]=0;s[a+128>>2]=.004999999888241291;s[a+132>>2]=.009999999776482582;s[a+136>>2]=.009999999776482582;s[a+140>>2]=.009999999776482582;ud(a+8|0);K=f+32|0;}function Wt(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0;if(pa(a,o[b+8>>2],f)){Dd(b,c,d,e);return}h=p[b+53|0];g=o[a+12>>2];m[b+53|0]=0;i=p[b+52|0];m[b+52|0]=0;j=a+16|0;Cd(j,b,c,d,e,f);k=p[b+53|0];h=h|k;l=p[b+52|0];i=i|l;a:{if((g|0)<2){break a}j=j+(g<<3)|0;g=a+24|0;while(1){if(p[b+54|0]){break a}b:{if(l){if(o[b+24>>2]==1){break a}if(p[a+8|0]&2){break b}break a}if(!k){break b}if(!(m[a+8|0]&1)){break a}}n[b+52>>1]=0;Cd(g,b,c,d,e,f);k=p[b+53|0];h=k|h;l=p[b+52|0];i=l|i;g=g+8|0;if(g>>>0<j>>>0){continue}break}}m[b+53|0]=(h&255)!=0;m[b+52|0]=(i&255)!=0;}function Ia(a,b,c){var d=0,e=v(0),f=v(0),g=v(0),h=v(0),i=0,j=0,k=0,m=0,n=0,p=v(0),q=v(0);d=K-48|0;K=d;e=s[b+8>>2];f=s[b>>2];g=s[b+4>>2];o[c+12>>2]=0;h=e;e=v(v(1)/v(C(v(v(v(f*f)+v(g*g))+v(e*e)))));s[c+8>>2]=h*e;s[c+4>>2]=g*e;s[c>>2]=f*e;b=o[a+120>>2];k=d+32|0;i=o[a+124>>2];j=o[a>>2]+(i>>1)|0;m=j;n=c;if(i&1){b=o[b+o[j>>2]>>2];}l[b](k,m,n);e=s[c>>2];f=s[c+4>>2];g=s[c+8>>2];o[d+12>>2]=0;s[d+8>>2]=-g;s[d+4>>2]=-f;s[d>>2]=-e;Kl(d+16|0,a,d);e=s[d+16>>2];f=s[d+32>>2];g=s[d+20>>2];h=s[d+36>>2];p=s[d+24>>2];q=s[d+40>>2];o[c+28>>2]=0;s[c+24>>2]=q-p;s[c+20>>2]=h-g;s[c+16>>2]=f-e;K=d+48|0;}function bk(a,b,c,d,e){a=a|0;b=b|0;c=v(c);d=d|0;e=e|0;var f=0,g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0),n=v(0),p=v(0),q=v(0),r=v(0),t=v(0),u=v(0);f=K-48|0;K=f;o[f+44>>2]=e;o[f+40>>2]=d;j=s[a- -64>>2];k=s[a+60>>2];m=s[a+80>>2];n=s[a+72>>2];p=s[a+76>>2];q=s[a+96>>2];r=s[a+88>>2];t=s[a+92>>2];u=s[a+56>>2];g=s[b+8>>2];h=s[b>>2];i=s[b+4>>2];b=o[a+48>>2];o[f+28>>2]=0;s[f+24>>2]=v(v(h*r)+v(i*t))+v(g*q);s[f+20>>2]=v(v(h*n)+v(i*p))+v(g*m);s[f+32>>2]=c;o[f+8>>2]=b;s[f+16>>2]=v(v(u*h)+v(k*i))+v(j*g);o[f+12>>2]=f+40;a=o[a+44>>2];c=v(l[o[o[a>>2]+12>>2]](a,f+8|0,1));K=f+48|0;return v(c)}function fh(a){a=a|0;var b=0,c=0,d=0,e=0,f=0;o[a>>2]=15928;if(p[a+152|0]){b=o[a+96>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+96>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}e=o[a+160>>2];if((e|0)>=1){while(1){b=o[a+168>>2]+u(c,20)|0;f=b;d=o[b+12>>2];if(d){if(p[b+16|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}}o[f+12>>2]=0;}m[b+16|0]=1;o[f+12>>2]=0;o[b+4>>2]=0;o[b+8>>2]=0;c=c+1|0;if((e|0)!=(c|0)){continue}break}}b=o[a+168>>2];if(b){if(p[a+172|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+168>>2]=0;}o[a+168>>2]=0;o[a+160>>2]=0;o[a+164>>2]=0;m[a+172|0]=1;Md(a+44|0);Md(a+4|0);return a|0}function Wh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=v(0),g=v(0),h=v(0),i=v(0),j=0;a:{f=s[b>>2];g=s[b+16>>2];i=f<g?f:g;h=s[b+32>>2];if((i<h?i:h)>s[a+24>>2]){break a}e=(f>g^1)<<4;if(s[(s[b+e>>2]>h?e:32)+b>>2]<s[a+8>>2]){break a}f=s[b+8>>2];e=b+24|0;g=s[e>>2];i=f<g?f:g;j=b+40|0;h=s[j>>2];if((i<h?i:h)>s[a+32>>2]){break a}e=f>g?b+8|0:e;if(s[(s[e>>2]>h?e:j)>>2]<s[a+16>>2]){break a}f=s[b+4>>2];e=b+20|0;g=s[e>>2];i=f<g?f:g;j=b+36|0;h=s[j>>2];if((i<h?i:h)>s[a+28>>2]){break a}e=f>g?b+4|0:e;if(s[(s[e>>2]>h?e:j)>>2]<s[a+12>>2]){break a}a=o[a+4>>2];l[o[o[a>>2]+8>>2]](a,b,c,d);}}function eo(a,b){a=a|0;b=v(b);var c=0,d=0,e=0;d=K-16|0;K=d;l[o[4966]](2531);c=o[a+84>>2];if(c){l[c](a,b);}l[o[o[a>>2]+140>>2]](a,b);c=0;o[a+32>>2]=0;s[a+28>>2]=b;o[a+48>>2]=l[o[o[a>>2]+20>>2]](a);l[o[o[a>>2]+164>>2]](a,b);l[o[o[a>>2]+44>>2]](a);l[o[o[a>>2]+148>>2]](a);s[a+104>>2]=b;l[o[o[a>>2]+152>>2]](a,a+92|0);l[o[o[a>>2]+144>>2]](a,b);l[o[4966]](2560);if(o[a+296>>2]>=1){while(1){e=o[o[a+304>>2]+(c<<2)>>2];l[o[o[e>>2]+8>>2]](e,a,b);c=c+1|0;if((c|0)<o[a+296>>2]){continue}break}}l[o[4967]]();l[o[o[a>>2]+156>>2]](a,b);c=o[a+80>>2];if(c){l[c](a,b);}l[o[4967]]();K=d+16|0;}function Tk(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=v(0);h=K-16|0;K=h;l[o[4966]](6418);i=p[a+76|0];g=i?b:c;f=o[g+4>>2];a:{if(o[f+4>>2]+ -21>>>0>8){break a}b=i?c:b;if(o[o[b+4>>2]+4>>2]>19){break a}j=v(l[o[o[f>>2]+48>>2]](f));o[e+4>>2]=o[a+72>>2];c=a+8|0;Uk(c,j,d,b,g,e);b=o[b+8>>2];d=o[a+72>>2];o[d+840>>2]=o[g+8>>2];o[d+836>>2]=b;l[o[o[f>>2]+64>>2]](f,c,a+12|0,a+28|0);b=o[e+4>>2];if(o[b+844>>2]){d=o[b+836>>2];f=o[o[e+8>>2]+8>>2];c=(d|0)==(f|0);g=b;b=o[o[e+12>>2]+8>>2];da(g,(c?d:b)+4|0,(c?b:f)+4|0);}o[a+44>>2]=0;o[a+48>>2]=0;}l[o[4967]]();K=h+16|0;}function If(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-32|0;K=d;o[d+28>>2]=a;o[d+24>>2]=b;m[d+23|0]=c;a=o[d+28>>2];s[a+4>>2]=s[o[d+24>>2]+24>>2];o[a+8>>2]=o[o[d+24>>2]>>2];a:{if(m[d+23|0]&1){b=o[d+24>>2];c=o[b+12>>2];o[a+56>>2]=o[b+8>>2];o[a+60>>2]=c;c=o[b+20>>2];o[a+64>>2]=o[b+16>>2];o[a+68>>2]=c;break a}b=K-16|0;o[b+12>>2]=o[a+8>>2];c=K-16|0;o[c+12>>2]=o[b+12>>2]+4;Sa(d,o[c+12>>2],o[d+24>>2]+8|0);b=o[d+4>>2];o[a+56>>2]=o[d>>2];o[a+60>>2]=b;b=o[d+12>>2];o[a+64>>2]=o[d+8>>2];o[a+68>>2]=b;}ig(a+72|0,a+24|0,a+40|0,s[o[d+24>>2]+24>>2]);K=d+32|0;return v(s[o[d+24>>2]+24>>2])}function Yt(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;if(pa(a,o[b+8>>2],e)){if(!(o[b+28>>2]==1|o[b+4>>2]!=(c|0))){o[b+28>>2]=d;}return}a:{if(pa(a,o[b>>2],e)){if(!(o[b+20>>2]!=(c|0)?o[b+16>>2]!=(c|0):0)){if((d|0)!=1){break a}o[b+32>>2]=1;return}o[b+32>>2]=d;b:{if(o[b+44>>2]==4){break b}n[b+52>>1]=0;a=o[a+8>>2];l[o[o[a>>2]+20>>2]](a,b,c,c,1,e);if(p[b+53|0]){o[b+44>>2]=3;if(!p[b+52|0]){break b}break a}o[b+44>>2]=4;}o[b+20>>2]=c;o[b+40>>2]=o[b+40>>2]+1;if(o[b+36>>2]!=1|o[b+24>>2]!=2){break a}m[b+54|0]=1;return}a=o[a+8>>2];l[o[o[a>>2]+24>>2]](a,b,c,d,e);}}



            function Xa(a,b,c,d,e,f,g,h,i,j,k,n){var q=0,r=0,s=0,t=0,v=0,w=0;s=o[a+68>>2];q=s;a:{if((s|0)!=o[a+72>>2]){break a}q=s;t=s?s<<1:1;if((s|0)>=(t|0)){break a}if(t){o[6257]=o[6257]+1;v=l[o[4968]](u(t,152),16)|0;q=o[a+68>>2];}else {q=s;}r=q;if((r|0)>=1){q=0;while(1){w=u(q,152);ra(w+v|0,o[a+76>>2]+w|0,152);q=q+1|0;if((r|0)!=(q|0)){continue}break}}r=o[a+76>>2];if(r){if(p[a+80|0]){if(r){o[6258]=o[6258]+1;l[o[4969]](r);}}o[a+76>>2]=0;}o[a+76>>2]=v;o[a+72>>2]=t;m[a+80|0]=1;q=o[a+68>>2];}o[a+68>>2]=q+1;r=o[a+76>>2]+u(s,152)|0;o[r+140>>2]=e;xm(a,r,b,c,d,f,g,h,i,j,k,n);}function Ek(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0),p=v(0);h=s[a+92>>2];i=s[a+76>>2];j=s[a+80>>2];l=s[a+100>>2];g=s[a+68>>2];m=s[a+84>>2];k=s[a+96>>2];e=s[a- -64>>2];f=s[a+60>>2];o[c+12>>2]=0;i=v(i-f);k=v(k-e);j=v(j-e);f=v(h-f);e=v(v(i*k)-v(j*f));n=e;p=v(e*e);e=v(l-g);h=v(m-g);g=v(v(j*e)-v(h*k));e=v(v(h*f)-v(i*e));f=v(v(1)/v(C(v(p+v(v(g*g)+v(e*e))))));s[c+8>>2]=n*f;s[c+4>>2]=e*f;s[c>>2]=g*f;b=o[a+72>>2];o[d+8>>2]=o[a+68>>2];o[d+12>>2]=b;b=o[a+64>>2];o[d>>2]=o[a+60>>2];o[d+4>>2]=b;}function wl(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=(b|0)!=8;if(!(d|(c|0)!=8)){return o[a+56>>2]}if(!((c|0)!=1|d)){return o[a+72>>2]}if(!((b|0)!=1|(c|0)!=8)){return o[a+76>>2]}if(!(b|c)){return o[a+68>>2]}if(!((c|0)!=28|(b|0)>19)){return o[a+84>>2]}if(!((b|0)!=28|(c|0)>19)){return o[a+80>>2]}a:{if((b|0)<=19){if((c|0)<=19){return o[a+28>>2]}if(c+ -21>>>0>8){break a}return o[a+32>>2]}if(!((c|0)>19|b+ -21>>>0>8)){return o[a+36>>2]}if((b|0)!=31){break a}if((c|0)==31){return o[a+44>>2]}return o[a+40>>2]}if((c|0)==31){return o[a+48>>2]}return o[a+52>>2]}function pj(a){var b=0,c=0,d=0,e=0,f=0,g=0;o[a>>2]=10552;m[a+20|0]=1;o[a+16>>2]=0;m[a+40|0]=1;o[a+8>>2]=0;o[a+12>>2]=0;o[a+36>>2]=0;m[a+60|0]=1;o[a+28>>2]=0;o[a+32>>2]=0;o[a+56>>2]=0;o[a+48>>2]=0;o[a+52>>2]=0;o[6257]=o[6257]+1;e=l[o[4968]](24,16)|0;f=o[a+8>>2];if((f|0)>=1){while(1){c=u(d,12);b=c+o[a+16>>2]|0;g=o[b+4>>2];c=c+e|0;o[c>>2]=o[b>>2];o[c+4>>2]=g;o[c+8>>2]=o[b+8>>2];d=d+1|0;if((f|0)!=(d|0)){continue}break}}b=o[a+16>>2];if(b){if(p[a+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+16>>2]=0;}o[a+16>>2]=e;m[a+20|0]=1;o[a+12>>2]=2;Kc(a);}function Jv(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=0,f=v(0),g=v(0),h=0,i=v(0),j=v(0);e=K-16|0;K=e;l[o[o[b>>2]+68>>2]](e,b,c);h=o[e+12>>2];o[a+8>>2]=o[e+8>>2];o[a+12>>2]=h;h=o[e+4>>2];o[a>>2]=o[e>>2];o[a+4>>2]=h;if(v(l[o[o[b>>2]+48>>2]](b))!=v(0)){f=s[c+4>>2];d=s[c>>2];g=s[c+8>>2];i=v(l[o[o[b>>2]+48>>2]](b));b=v(v(v(d*d)+v(f*f))+v(g*g))<v(1.4210854715202004e-14);d=b?v(-1):d;j=d;g=b?v(-1):g;f=b?v(-1):f;d=v(v(1)/v(C(v(v(g*g)+v(v(d*d)+v(f*f))))));s[a>>2]=s[a>>2]+v(i*v(j*d));s[a+4>>2]=s[a+4>>2]+v(i*v(f*d));s[a+8>>2]=s[a+8>>2]+v(i*v(g*d));}K=e+16|0;}function Hu(a,b,c,d){var e=0,f=0,g=0,h=0,i=0;if(o[a+56>>2]>=1){e=o[a+96>>2];while(1){f=0;a:{if(s[c>>2]>s[e+16>>2]){break a}f=0;if(s[d>>2]<s[e>>2]){break a}f=1;}g=0;g=s[d+8>>2]<s[e+8>>2]|s[c+8>>2]>s[e+24>>2]?g:f;b:{c:{d:{if(!(s[d+4>>2]<s[e+4>>2]^1?!(s[c+4>>2]>s[e+20>>2]):0)){f=o[e+32>>2]==-1;g=0;break d}f=o[e+32>>2]==-1;if((g&f)!=1){break d}l[o[o[b>>2]+8>>2]](b,o[e+36>>2],o[e+40>>2]);break c}if(f|g){break c}f=o[e+32>>2];h=f+h|0;e=(f<<6)+e|0;break b}h=h+1|0;e=e- -64|0;}i=i+1|0;if((h|0)<o[a+56>>2]){continue}break}}if(o[5677]<(i|0)){o[5677]=i;}}function dn(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0);if(c>>>0<=2){b=b+ -1|0;if(b>>>0>3){return v(v(0))}a:{switch(b-1|0){case 0:return v(s[((c<<2)+a|0)+728>>2]);case 2:return v(s[((c<<2)+a|0)+744>>2]);default:return v(s[((c<<2)+a|0)+760>>2]);case 1:break a}}return v(s[((c<<2)+a|0)+776>>2])}c=c+ -3|0;b:{if(c>>>0>2){break b}b=b+ -1|0;if(b>>>0>3){break b}c:{switch(b-1|0){case 0:return v(s[(u(c,88)+a|0)+980>>2]);case 2:return v(s[(u(c,88)+a|0)+984>>2]);default:return v(s[(u(c,88)+a|0)+988>>2]);case 1:break c}}d=s[(u(c,88)+a|0)+992>>2];}return v(d)}function ad(a,b,c,d,e,f){var g=0,h=0,i=0,j=0,k=0,n=0;i=o[a+88>>2];g=i;a:{if((i|0)!=o[a+92>>2]){break a}g=i;j=i?i<<1:1;if((i|0)>=(j|0)){break a}if(j){o[6257]=o[6257]+1;k=l[o[4968]](u(j,152),16)|0;g=o[a+88>>2];}else {g=i;}h=g;if((h|0)>=1){g=0;while(1){n=u(g,152);ra(n+k|0,o[a+96>>2]+n|0,152);g=g+1|0;if((h|0)!=(g|0)){continue}break}}h=o[a+96>>2];if(h){if(p[a+100|0]){if(h){o[6258]=o[6258]+1;l[o[4969]](h);}}o[a+96>>2]=0;}o[a+96>>2]=k;o[a+92>>2]=j;m[a+100|0]=1;g=o[a+88>>2];}o[a+88>>2]=g+1;h=o[a+96>>2]+u(i,152)|0;o[h+140>>2]=e;wm(a,h,b,c,d,f);}function Ic(a,b,c){var d=v(0),e=v(0),f=v(0),g=0,h=0,i=0,j=v(0),k=v(0);e=v(s[b+64>>2]*v(.5));g=o[b+68>>2];i=o[b+72>>2];h=i<<2;d=s[c>>2];f=v(d*d);d=s[c+4>>2];f=v(f+v(d*d));d=s[c+8>>2];a:{b:{if(!!(s[h+c>>2]>v(s[b+56>>2]*v(C(v(f+v(d*d))))))){o[(g<<2)+a>>2]=0;s[a+h>>2]=e;c=o[b+76>>2];break b}d=s[(g<<2)+c>>2];h=c;c=o[b+76>>2];j=s[h+(c<<2)>>2];k=v(C(v(v(d*d)+v(j*j))));if(!!(k>v(1.1920928955078125e-7))){f=d;d=v(s[b+60>>2]/k);s[(g<<2)+a>>2]=f*d;s[(i<<2)+a>>2]=-e;e=v(j*d);break a}o[(g<<2)+a>>2]=0;s[(i<<2)+a>>2]=-e;}e=v(0);}s[(c<<2)+a>>2]=e;}function Vn(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0;d=o[a+228>>2];a:{if((d|0)!=o[a+232>>2]){break a}f=d?d<<1:1;if((d|0)>=(f|0)){break a}if(f){o[6257]=o[6257]+1;g=l[o[4968]](f<<2,16)|0;d=o[a+228>>2];}if((d|0)>=1){while(1){h=e<<2;o[h+g>>2]=o[o[a+236>>2]+h>>2];e=e+1|0;if((e|0)!=(d|0)){continue}break}}e=o[a+236>>2];if(e){if(p[a+240|0]){if(e){o[6258]=o[6258]+1;l[o[4969]](e);}d=o[a+228>>2];}o[a+236>>2]=0;}o[a+236>>2]=g;o[a+232>>2]=f;m[a+240|0]=1;}o[o[a+236>>2]+(d<<2)>>2]=b;o[a+228>>2]=d+1;if(c){Df(o[b+28>>2],b);Df(o[b+32>>2],b);}}function Jf(a,b){var c=0,d=0,e=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;b=K-16|0;a=o[d+12>>2];o[b+12>>2]=a;o[d+4>>2]=o[o[b+12>>2]+4>>2];b=o[d+4>>2];c=K-16|0;o[c+12>>2]=a;if(o[o[c+12>>2]+8>>2]==(b|0)){c=K-16|0;o[c+12>>2]=a;e=o[o[c+12>>2]+4>>2];c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=e;b=a;if(o[c+8>>2]){c=o[c+8>>2]<<1;}else {c=1;}Uo(b,c);}c=o[a+12>>2]+(o[a+4>>2]<<4)|0;b=K-16|0;o[b+12>>2]=16;o[b+8>>2]=c;c=o[d+8>>2];e=o[c+4>>2];b=o[b+8>>2];o[b>>2]=o[c>>2];o[b+4>>2]=e;e=o[c+12>>2];o[b+8>>2]=o[c+8>>2];o[b+12>>2]=e;o[a+4>>2]=o[a+4>>2]+1;K=d+16|0;}function Lk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=v(0),g=0,h=0,i=v(0),j=v(0),k=0,l=v(0),m=v(0),n=0;if((d|0)>=1){n=a+60|0;while(1){e=h<<4;g=e+c|0;e=b+e|0;f=s[e>>2];i=s[e+4>>2];j=s[e+8>>2];l=v(v(v(f*s[a+76>>2])+v(i*s[a+80>>2]))+v(j*s[a+84>>2]));m=v(v(v(f*s[a+92>>2])+v(i*s[a+96>>2]))+v(j*s[a+100>>2]));f=v(v(v(f*s[a+60>>2])+v(i*s[a+64>>2]))+v(j*s[a+68>>2]));e=((f<l?l<m?2:1:(f<m)<<1)<<4)+n|0;k=o[e+4>>2];o[g>>2]=o[e>>2];o[g+4>>2]=k;k=o[e+12>>2];o[g+8>>2]=o[e+8>>2];o[g+12>>2]=k;h=h+1|0;if((h|0)!=(d|0)){continue}break}}}function bu(a){var b=0,c=0,d=0,e=0;b=K+ -64|0;K=b;c=o[a>>2];d=o[c+ -4>>2];e=o[c+ -8>>2];o[b+20>>2]=0;o[b+16>>2]=19560;o[b+12>>2]=a;o[b+8>>2]=19608;c=0;$(b+24|0,0,39);a=a+e|0;a:{if(pa(d,19608,0)){o[b+56>>2]=1;l[o[o[d>>2]+20>>2]](d,b+8|0,a,a,1,0);c=o[b+32>>2]==1?a:0;break a}l[o[o[d>>2]+24>>2]](d,b+8|0,a,1,0);a=o[b+44>>2];if(a>>>0>1){break a}if(a-1){c=o[b+48>>2]==1?o[b+36>>2]==1?o[b+40>>2]==1?o[b+28>>2]:0:0:0;break a}if(o[b+32>>2]!=1){if(o[b+48>>2]|o[b+36>>2]!=1|o[b+40>>2]!=1){break a}}c=o[b+24>>2];}K=b- -64|0;return c}function xl(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=(b|0)!=8;if(!(d|(c|0)!=8)){return o[a+56>>2]}if(!((c|0)!=1|d)){return o[a+72>>2]}if(!((b|0)!=1|(c|0)!=8)){return o[a+76>>2]}if(!((c|0)!=28|(b|0)>19)){return o[a+84>>2]}if(!((b|0)!=28|(c|0)>19)){return o[a+80>>2]}a:{if((b|0)<=19){if((c|0)<=19){return o[a+28>>2]}if(c+ -21>>>0>8){break a}return o[a+32>>2]}if(!((c|0)>19|b+ -21>>>0>8)){return o[a+36>>2]}if((b|0)!=31){break a}if((c|0)==31){return o[a+44>>2]}return o[a+40>>2]}if((c|0)==31){return o[a+48>>2]}return o[a+52>>2]}function Yo(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0);d=K-32|0;K=d;o[d+28>>2]=a;o[d+24>>2]=b;m[d+23|0]=c;a=o[d+28>>2];b=K-16|0;o[b+12>>2]=o[o[d+24>>2]>>2];o[d+16>>2]=o[o[b+12>>2]+192>>2];a:{if(!(!(Sb(o[d+16>>2])&1)|!o[o[d+24>>2]+4>>2])){o[d+12>>2]=o[d+16>>2];o[d+8>>2]=o[o[o[d+24>>2]+4>>2]>>2];b=fc(o[d+12>>2],o[d+8>>2]);c=K-16|0;o[c+12>>2]=b;o[d+4>>2]=o[o[c+12>>2]+8>>2];Ka(a+136|0,d+4|0);break a}b=K-16|0;o[b+12>>2]=o[d+16>>2];o[d>>2]=o[o[b+12>>2]+8>>2];Ka(a+136|0,d);}e=Kf(a,o[d+24>>2],m[d+23|0]&1);K=d+32|0;return v(e)}function Jk(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0),n=v(0);g=s[a+92>>2];h=s[a+76>>2];i=s[a+80>>2];k=s[a+100>>2];e=s[a+68>>2];l=s[a+84>>2];j=s[a+96>>2];d=s[a- -64>>2];f=s[a+60>>2];o[c+12>>2]=0;h=v(h-f);j=v(j-d);i=v(i-d);f=v(g-f);d=v(v(h*j)-v(i*f));m=d;n=v(d*d);d=v(k-e);g=v(l-e);e=v(v(i*d)-v(g*j));d=v(v(g*f)-v(h*d));f=v(v(1)/v(C(v(n+v(v(e*e)+v(d*d))))));g=v(m*f);s[c+8>>2]=g;d=v(d*f);s[c+4>>2]=d;e=v(e*f);s[c>>2]=e;if(b){s[c+8>>2]=-g;s[c+4>>2]=-d;s[c>>2]=-e;}}function zj(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;c=o[a+56>>2];if(!(!c|!p[a+52|0])){d=o[b+4>>2];a:{if((d|0)!=o[b+8>>2]){break a}e=d?d<<1:1;if((d|0)>=(e|0)){break a}if(e){o[6257]=o[6257]+1;f=l[o[4968]](e<<2,16)|0;d=o[b+4>>2];}if((d|0)>=1){c=0;while(1){g=c<<2;o[g+f>>2]=o[o[b+12>>2]+g>>2];c=c+1|0;if((c|0)!=(d|0)){continue}break}}c=o[b+12>>2];if(c){if(p[b+16|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}d=o[b+4>>2];}o[b+12>>2]=0;}o[b+12>>2]=f;m[b+16|0]=1;o[b+8>>2]=e;c=o[a+56>>2];}o[o[b+12>>2]+(d<<2)>>2]=c;o[b+4>>2]=d+1;}}function wc(a,b,c){var d=0;d=o[a+4>>2];a:{if(d){o[a+4>>2]=0;break a}o[6257]=o[6257]+1;d=l[o[4968]](44,16)|0;o[d>>2]=0;o[d+4>>2]=0;o[d+40>>2]=0;o[d+32>>2]=0;o[d+36>>2]=0;o[d+24>>2]=0;o[d+28>>2]=0;o[d+16>>2]=0;o[d+20>>2]=0;o[d+8>>2]=0;o[d+12>>2]=0;}o[d+36>>2]=c;o[d+32>>2]=0;o[d+40>>2]=0;c=o[b+4>>2];o[d>>2]=o[b>>2];o[d+4>>2]=c;c=o[b+12>>2];o[d+8>>2]=o[b+8>>2];o[d+12>>2]=c;c=o[b+20>>2];o[d+16>>2]=o[b+16>>2];o[d+20>>2]=c;c=o[b+28>>2];o[d+24>>2]=o[b+24>>2];o[d+28>>2]=c;xc(a,o[a>>2],d);o[a+12>>2]=o[a+12>>2]+1;return d}function Lb(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;c=o[a+12>>2];if(!(!c|!p[a+8|0])){d=o[b+4>>2];a:{if((d|0)!=o[b+8>>2]){break a}e=d?d<<1:1;if((d|0)>=(e|0)){break a}if(e){o[6257]=o[6257]+1;f=l[o[4968]](e<<2,16)|0;d=o[b+4>>2];}if((d|0)>=1){c=0;while(1){g=c<<2;o[g+f>>2]=o[o[b+12>>2]+g>>2];c=c+1|0;if((c|0)!=(d|0)){continue}break}}c=o[b+12>>2];if(c){if(p[b+16|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}d=o[b+4>>2];}o[b+12>>2]=0;}o[b+12>>2]=f;m[b+16|0]=1;o[b+8>>2]=e;c=o[a+12>>2];}o[o[b+12>>2]+(d<<2)>>2]=c;o[b+4>>2]=d+1;}}function ti(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=0,f=v(0),g=v(0),h=0,i=v(0),j=v(0);e=K-16|0;K=e;l[o[o[b>>2]+68>>2]](e,b,c);h=o[e+12>>2];o[a+8>>2]=o[e+8>>2];o[a+12>>2]=h;h=o[e+4>>2];o[a>>2]=o[e>>2];o[a+4>>2]=h;f=s[c+4>>2];d=s[c>>2];g=s[c+8>>2];i=v(l[o[o[b>>2]+48>>2]](b));b=v(v(v(d*d)+v(f*f))+v(g*g))<v(1.4210854715202004e-14);d=b?v(-1):d;j=d;g=b?v(-1):g;f=b?v(-1):f;d=v(v(1)/v(C(v(v(g*g)+v(v(d*d)+v(f*f))))));s[a>>2]=s[a>>2]+v(i*v(j*d));s[a+4>>2]=s[a+4>>2]+v(i*v(f*d));s[a+8>>2]=s[a+8>>2]+v(i*v(g*d));K=e+16|0;}function re(a){a=a|0;var b=0,c=0,d=0,e=0,f=0;o[a>>2]=10616;b=o[a+84>>2];e=o[b+8>>2];if((e|0)>=1){while(1){c=o[(o[b+16>>2]+u(d,12)|0)+8>>2];if(c){l[o[o[c>>2]>>2]](c)|0;f=o[a+4>>2];l[o[o[f>>2]+60>>2]](f,c);}d=d+1|0;if((e|0)!=(d|0)){continue}break}b=o[a+84>>2];}te(b);b=o[a+84>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+84>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}b=o[a+100>>2];if(b){if(p[a+104|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+100>>2]=0;}o[a+100>>2]=0;o[a+92>>2]=0;o[a+96>>2]=0;m[a+104|0]=1;Lc(a);return a|0}function up(a,b,c,d){var e=0;e=K+ -64|0;K=e;o[e+60>>2]=a;s[e+56>>2]=b;s[e+52>>2]=c;o[e+48>>2]=d;a=o[e+60>>2];o[a+56>>2]=o[e+48>>2];s[e+44>>2]=1;s[e+40>>2]=1;s[e+36>>2]=1;Z(a+16|0,e+44|0,e+40|0,e+36|0);a:{if(o[a+56>>2]==1){d=e+56|0;Z(a+32|0,d,e+52|0,d);break a}b:{if(!o[a+56>>2]){d=e+56|0;Z(a+32|0,e+52|0,d,d);break b}d=e+56|0;Z(a+32|0,d,d,e+52|0);}}s[e+12>>2]=l[o[o[a>>2]+48>>2]](a);s[e+8>>2]=l[o[o[a>>2]+48>>2]](a);s[e+4>>2]=l[o[o[a>>2]+48>>2]](a);d=e+16|0;Z(d,e+12|0,e+8|0,e+4|0);fs(a+32|0,d);K=e- -64|0;}function Yk(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;c=o[a+72>>2];if(c){d=o[b+4>>2];a:{if((d|0)!=o[b+8>>2]){break a}e=d?d<<1:1;if((d|0)>=(e|0)){break a}if(e){o[6257]=o[6257]+1;f=l[o[4968]](e<<2,16)|0;d=o[b+4>>2];}if((d|0)>=1){c=0;while(1){g=c<<2;o[g+f>>2]=o[o[b+12>>2]+g>>2];c=c+1|0;if((c|0)!=(d|0)){continue}break}}c=o[b+12>>2];if(c){if(p[b+16|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}d=o[b+4>>2];}o[b+12>>2]=0;}o[b+12>>2]=f;m[b+16|0]=1;o[b+8>>2]=e;c=o[a+72>>2];}o[o[b+12>>2]+(d<<2)>>2]=c;o[b+4>>2]=d+1;}}function Qu(a){m[a+60|0]=0;o[a+52>>2]=287;o[a>>2]=16296;o[a+144>>2]=0;m[a+80|0]=1;o[a+76>>2]=0;m[a+100|0]=1;o[a+68>>2]=0;o[a+72>>2]=0;o[a+96>>2]=0;m[a+120|0]=1;o[a+88>>2]=0;o[a+92>>2]=0;o[a+116>>2]=0;m[a+140|0]=1;o[a+108>>2]=0;o[a+112>>2]=0;o[a+136>>2]=0;m[a+164|0]=1;o[a+128>>2]=0;o[a+132>>2]=0;o[a+160>>2]=0;o[a+168>>2]=0;o[a+152>>2]=0;o[a+156>>2]=0;o[a+4>>2]=-8388609;o[a+8>>2]=-8388609;o[a+12>>2]=-8388609;o[a+16>>2]=0;o[a+20>>2]=2139095039;o[a+24>>2]=2139095039;o[a+28>>2]=2139095039;o[a+32>>2]=0;}function pm(a,b,c,d,e,f,g,h,i){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;h=h|0;var j=v(0),k=v(0);a:{if(!o[h+52>>2]|o[h+20>>2]<1){break a}b=0;while(1){j=v(0);c=0;e=o[a+28>>2];if((e|0)>=1){while(1){k=j;f=o[a+16>>2];d=o[a+36>>2]+u(o[o[a+116>>2]+(c<<2)>>2],152)|0;j=v(l[o[a+220>>2]](f+u(o[d+144>>2],244)|0,u(o[d+148>>2],244)+f|0,d));j=v(k+v(j*j));c=c+1|0;if((e|0)!=(c|0)){continue}break}}if(j<=s[h+92>>2]){break a}c=o[h+20>>2];if((b|0)>=(c+ -1|0)){break a}b=b+1|0;if((b|0)<(c|0)){continue}break}}}function so(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;d=K-16|0;b=o[c+8>>2];o[d+12>>2]=b;d=o[d+12>>2];e=K-16|0;o[e+12>>2]=b+16;e=o[e+12>>2];f=K-16|0;o[f+12>>2]=b+32;f=o[f+12>>2];g=K-16|0;o[g+12>>2]=b;g=o[g+12>>2]+4|0;h=K-16|0;o[h+12>>2]=b+16;h=o[h+12>>2]+4|0;i=K-16|0;o[i+12>>2]=b+32;i=o[i+12>>2]+4|0;j=K-16|0;o[j+12>>2]=b;j=o[j+12>>2]+8|0;k=K-16|0;o[k+12>>2]=b+16;k=o[k+12>>2]+8|0;l=K-16|0;o[l+12>>2]=b+32;ac(a,d,e,f,g,h,i,j,k,o[l+12>>2]+8|0);K=c+16|0;}function qv(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;o[5676]=o[5676]+1;d=o[b+12>>2]>o[c+12>>2];e=o[(d?b:c)+12>>2];f=o[(d?c:b)+12>>2];b=f|e<<16;b=(b<<15^-1)+b|0;b=u(b>>>10^b,9);b=b>>>6^b;b=(b<<11^-1)+b|0;b=o[a+12>>2]+ -1&(b>>>16^b);a:{b:{if((b|0)>=o[a+32>>2]){break b}b=o[o[a+40>>2]+(b<<2)>>2];if((b|0)==-1){break b}c=o[a+16>>2];while(1){g=b<<4;d=c+g|0;if(o[o[(c+g|0)+4>>2]+12>>2]==(e|0)?o[o[d>>2]+12>>2]==(f|0):0){break a}b=o[o[a+60>>2]+(b<<2)>>2];if((b|0)!=-1){continue}break}}d=0;}return d|0}function Cg(a,b){var c=0,d=0;d=K-16|0;K=d;o[d+8>>2]=a;o[d+4>>2]=b;a=o[d+8>>2];o[d+12>>2]=a;c=a+48|0;b=a;while(1){o[(K-16|0)+12>>2]=b;b=b+16|0;if((c|0)!=(b|0)){continue}break}b=o[d+4>>2];c=o[b+4>>2];o[a>>2]=o[b>>2];o[a+4>>2]=c;c=o[b+12>>2];o[a+8>>2]=o[b+8>>2];o[a+12>>2]=c;b=o[d+4>>2];c=o[b+20>>2];o[a+16>>2]=o[b+16>>2];o[a+20>>2]=c;c=o[b+28>>2];o[a+24>>2]=o[b+24>>2];o[a+28>>2]=c;b=o[d+4>>2];c=o[b+36>>2];o[a+32>>2]=o[b+32>>2];o[a+36>>2]=c;c=o[b+44>>2];o[a+40>>2]=o[b+40>>2];o[a+44>>2]=c;K=d+16|0;}function Mo(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0);d=K-32|0;K=d;o[d+28>>2]=a;o[d+24>>2]=b;m[d+23|0]=c;a=o[d+28>>2];b=K-16|0;o[b+12>>2]=o[o[d+24>>2]>>2];o[d+16>>2]=o[o[b+12>>2]+192>>2];a:{if(!(!(Sb(o[d+16>>2])&1)|!o[o[d+24>>2]+4>>2])){o[d+12>>2]=o[d+16>>2];o[d+8>>2]=o[o[o[d+24>>2]+4>>2]>>2];b=fc(o[d+12>>2],o[d+8>>2]);c=K-16|0;o[c+12>>2]=b;o[a+88>>2]=o[o[c+12>>2]+8>>2];break a}b=K-16|0;o[b+12>>2]=o[d+16>>2];o[a+88>>2]=o[o[b+12>>2]+8>>2];}e=If(a,o[d+24>>2],m[d+23|0]&1);K=d+32|0;return v(e)}function ze(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;while(1){k=c;g=o[a+12>>2];l=o[g+((c+d|0)/2<<3)>>2];h=c;e=d;while(1){c=h;h=c+1|0;f=(c<<3)+g|0;if(o[f>>2]<(l|0)){continue}i=e;while(1){e=i;i=e+ -1|0;m=e<<3;j=m+g|0;if(o[j>>2]>(l|0)){continue}break}if((c|0)<=(e|0)){c=o[f>>2];e=o[f+4>>2];g=o[j+4>>2];o[f>>2]=o[j>>2];o[f+4>>2]=g;f=o[a+12>>2]+m|0;o[f>>2]=c;o[f+4>>2]=e;e=i;c=h;}if((c|0)<=(e|0)){g=o[a+12>>2];h=c;continue}break}if((e|0)>(k|0)){ze(a,b,k,e);}if((c|0)<(d|0)){continue}break}}function df(a,b,c,d){var e=0,f=0;e=o[b+4>>2];o[a+292>>2]=o[b>>2];o[a+296>>2]=e;e=o[b+12>>2];o[a+300>>2]=o[b+8>>2];o[a+304>>2]=e;m[a+356|0]=1;f=o[b+4>>2];e=a+(o[a>>2]<<4)|0;o[e+4>>2]=o[b>>2];o[e+8>>2]=f;f=o[b+12>>2];o[e+12>>2]=o[b+8>>2];o[e+16>>2]=f;f=o[c+12>>2];b=(o[a>>2]<<4)+a|0;o[b+92>>2]=o[c+8>>2];o[b+96>>2]=f;e=o[c+4>>2];o[b+84>>2]=o[c>>2];o[b+88>>2]=e;e=o[d+12>>2];b=(o[a>>2]<<4)+a|0;o[b+172>>2]=o[d+8>>2];o[b+176>>2]=e;c=o[d+4>>2];o[b+164>>2]=o[d>>2];o[b+168>>2]=c;o[a>>2]=o[a>>2]+1;}function bq(a,b){var c=0;c=K-32|0;K=c;o[c+28>>2]=a;o[c+24>>2]=0;o[c+20>>2]=b;b=K-16|0;a=o[c+28>>2];o[b+12>>2]=a;o[c+16>>2]=o[o[b+12>>2]+4>>2];a:{if(o[c+24>>2]<o[c+16>>2]){o[c+12>>2]=o[c+24>>2];while(1){if(o[c+12>>2]<o[c+16>>2]){o[c+12>>2]=o[c+12>>2]+1;continue}break}break a}if(o[c+24>>2]>o[c+16>>2]){Ng(a,o[c+24>>2]);}o[c+8>>2]=o[c+16>>2];while(1){if(o[c+8>>2]<o[c+24>>2]){o[o[a+12>>2]+(o[c+8>>2]<<2)>>2]=o[o[c+20>>2]>>2];o[c+8>>2]=o[c+8>>2]+1;continue}break}}o[a+4>>2]=o[c+24>>2];K=c+32|0;}function Rg(a,b){var c=0,d=0,f=0,j=0,k=0,l=0;f=K-16|0;K=f;j=(g(a),h(0));c=j&2147483647;a:{if(c>>>0<=1305022426){k=+a;d=k*.6366197723675814+6755399441055744+ -6755399441055744;t[b>>3]=k+d*-1.5707963109016418+d*-1.5893254773528196e-8;if(w(d)<2147483648){c=~~d;break a}c=-2147483648;break a}if(c>>>0>=2139095040){t[b>>3]=v(a-a);c=0;break a}l=c;c=(c>>>23|0)+ -150|0;t[f+8>>3]=(e(0,l-(c<<23)|0),i());c=lu(f+8|0,f,c);d=t[f>>3];if((j|0)<=-1){t[b>>3]=-d;c=0-c|0;break a}t[b>>3]=d;}K=f+16|0;return c}function yj(a,b,c,d){a=a|0;b=b|0;c=c|0;d=v(d);var e=0,f=v(0),g=0,h=v(0),i=v(0),j=v(0),k=v(0),n=v(0),p=v(0);e=K-16|0;K=e;s[a+32>>2]=d;g=o[b+4>>2];o[a+8>>2]=o[b>>2];o[a+12>>2]=g;g=o[b+12>>2];o[a+16>>2]=o[b+8>>2];o[a+20>>2]=g;h=s[b+8>>2];i=s[c>>2];j=s[b>>2];k=s[c+4>>2];n=s[b+4>>2];p=s[c+8>>2];f=s[a+28>>2];o[e+12>>2]=0;s[e+8>>2]=p-v(f*h);s[e+4>>2]=k-v(f*n);s[e>>2]=i-v(j*f);d=v(v(f+s[a+24>>2])+d);s[a+32>>2]=d;if(!!(d<v(0))){m[a+36|0]=1;}a=o[a+4>>2];l[o[o[a>>2]+16>>2]](a,b,e,d);K=e+16|0;}function Tn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;c=o[a+296>>2];a:{if((c|0)!=o[a+300>>2]){break a}e=c?c<<1:1;if((c|0)>=(e|0)){break a}if(e){o[6257]=o[6257]+1;f=l[o[4968]](e<<2,16)|0;c=o[a+296>>2];}if((c|0)>=1){while(1){g=d<<2;o[g+f>>2]=o[o[a+304>>2]+g>>2];d=d+1|0;if((d|0)!=(c|0)){continue}break}}d=o[a+304>>2];if(d){if(p[a+308|0]){if(d){o[6258]=o[6258]+1;l[o[4969]](d);}c=o[a+296>>2];}o[a+304>>2]=0;}o[a+304>>2]=f;o[a+300>>2]=e;m[a+308|0]=1;}o[o[a+304>>2]+(c<<2)>>2]=b;o[a+296>>2]=c+1;}function id(a,b,c){var d=v(0),e=0,f=v(0),g=v(0);e=o[a+204>>2];a:{if(b==v(0)){o[a+204>>2]=e|1;break a}o[a+204>>2]=e&-2;d=v(v(1)/b);}s[a+404>>2]=d;o[a+436>>2]=0;s[a+424>>2]=s[a+440>>2]*b;s[a+432>>2]=s[a+448>>2]*b;s[a+428>>2]=s[a+444>>2]*b;b=s[c+8>>2];f=s[c+4>>2];g=s[c>>2];s[a+620>>2]=s[a+408>>2]*d;s[a+624>>2]=d*s[a+412>>2];s[a+628>>2]=d*s[a+416>>2];o[a+632>>2]=0;o[a+468>>2]=0;s[a+456>>2]=g!=v(0)?v(v(1)/g):v(0);s[a+460>>2]=f!=v(0)?v(v(1)/f):v(0);s[a+464>>2]=b!=v(0)?v(v(1)/b):v(0);}function Sc(a){a=a|0;var b=0,c=0,d=0,e=0,f=0;o[a>>2]=7540;b=o[a+16>>2];c=o[a+8>>2];if((c|0)>=1){while(1){f=o[(d<<2)+b>>2];e=o[f+188>>2];if(e){b=o[a+68>>2];b=l[o[o[b>>2]+36>>2]](b)|0;l[o[o[b>>2]+40>>2]](b,e,o[a+24>>2]);b=o[a+68>>2];l[o[o[b>>2]+12>>2]](b,e,o[a+24>>2]);o[f+188>>2]=0;c=o[a+8>>2];b=o[a+16>>2];}d=d+1|0;if((d|0)<(c|0)){continue}break}}if(b){if(p[a+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+16>>2]=0;}o[a+16>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;m[a+20|0]=1;return a|0}function em(a,b){var c=0,d=0,e=0;o[a+4>>2]=2;o[a>>2]=4064;o[a+10444>>2]=b;o[a+28>>2]=7172;o[a+64>>2]=163;m[a+24|0]=1;o[a+20>>2]=0;o[a+60>>2]=0;o[a+12>>2]=0;o[a+16>>2]=0;o[a+68>>2]=l[o[o[b>>2]+12>>2]](b);o[a+72>>2]=l[o[o[b>>2]+8>>2]](b);while(1){b=0;while(1){d=(u(c,144)+a|0)+(b<<2)|0;e=o[a+10444>>2];o[d+76>>2]=l[o[o[e>>2]+16>>2]](e,c,b);e=d+5260|0;d=o[a+10444>>2];o[e>>2]=l[o[o[d>>2]+20>>2]](d,c,b);b=b+1|0;if((b|0)!=36){continue}break}c=c+1|0;if((c|0)!=36){continue}break}}function _l(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0;o[5383]=o[5383]+ -1;l[o[o[a>>2]+20>>2]](a,b);c=o[b+864>>2];e=c<<2;f=o[a+20>>2];d=e+f|0;h=o[d>>2];i=d;d=o[a+12>>2]+ -1|0;g=d<<2;o[i>>2]=o[f+g>>2];o[o[a+20>>2]+g>>2]=h;o[o[o[a+20>>2]+e>>2]+864>>2]=c;o[a+12>>2]=d;a:{if(!b){break a}a=o[a+72>>2];c=o[a+16>>2];if(c>>>0>b>>>0|c+u(o[a>>2],o[a+4>>2])>>>0<=b>>>0){break a}o[b>>2]=o[a+12>>2];o[a+12>>2]=b;o[a+8>>2]=o[a+8>>2]+1;return}if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}function jh(a){a=a|0;var b=0;o[a>>2]=15368;b=o[a+60>>2];if(b){if(p[a- -64|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+60>>2]=0;}o[a+60>>2]=0;o[a+52>>2]=0;o[a+56>>2]=0;m[a- -64|0]=1;b=o[a+40>>2];if(b){if(p[a+44|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+40>>2]=0;}o[a+40>>2]=0;o[a+32>>2]=0;o[a+36>>2]=0;m[a+44|0]=1;b=o[a+16>>2];if(b){if(p[a+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+16>>2]=0;}o[a+16>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;m[a+20|0]=1;return a|0}function Bn(a){a=a|0;var b=0;o[a>>2]=2936;b=o[a+80>>2];if(b){if(p[a+84|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+80>>2]=0;}o[a+80>>2]=0;o[a+72>>2]=0;o[a+76>>2]=0;m[a+84|0]=1;b=o[a+60>>2];if(b){if(p[a- -64|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+60>>2]=0;}o[a+60>>2]=0;o[a+52>>2]=0;o[a+56>>2]=0;m[a- -64|0]=1;b=o[a+40>>2];if(b){if(p[a+44|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+40>>2]=0;}o[a+40>>2]=0;o[a+32>>2]=0;o[a+36>>2]=0;m[a+44|0]=1;return a|0}function Mn(a,b){a=a|0;b=v(b);var c=0,d=0,e=0,f=0;e=K-16|0;K=e;l[o[4966]](2704);l[o[4966]](2667);c=o[a+332>>2];if(o[a+324>>2]>=1){while(1){f=o[a+24>>2];l[o[o[f>>2]+16>>2]](f,o[(d<<2)+c>>2]);c=o[a+332>>2];d=d+1|0;if((d|0)<o[a+324>>2]){continue}break}}if(c){if(p[a+336|0]){if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+332>>2]=0;}o[a+332>>2]=0;o[a+324>>2]=0;o[a+328>>2]=0;m[a+336|0]=1;l[o[4967]]();c=o[a+248>>2];if((c|0)>=1){On(a,o[a+256>>2],c,b);}l[o[4967]]();K=e+16|0;}function ue(a){a=a|0;var b=0;o[a>>2]=10552;b=o[a+56>>2];if(b){if(p[a+60|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+56>>2]=0;}o[a+56>>2]=0;o[a+48>>2]=0;o[a+52>>2]=0;m[a+60|0]=1;b=o[a+36>>2];if(b){if(p[a+40|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+36>>2]=0;}o[a+36>>2]=0;o[a+28>>2]=0;o[a+32>>2]=0;m[a+40|0]=1;b=o[a+16>>2];if(b){if(p[a+20|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+16>>2]=0;}o[a+16>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;m[a+20|0]=1;return a|0}function gl(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;i=o[b+8>>2];if((i|0)>=1){k=o[b+16>>2];b=0;while(1){d=o[(e<<2)+k>>2];a:{if(!(p[d+204|0]&3)){c=b;f=o[a+16>>2];j=b<<3;g=f+j|0;h=o[g>>2];if((h|0)!=(b|0)){while(1){c=(h<<3)+f|0;o[g>>2]=o[c>>2];c=o[c>>2];g=(c<<3)+f|0;h=o[g>>2];if((c|0)!=(h|0)){continue}break}}o[d+208>>2]=c;o[(f+j|0)+4>>2]=e;o[d+212>>2]=-1;b=b+1|0;break a}o[d+208>>2]=-1;o[d+212>>2]=-2;}e=e+1|0;if((i|0)!=(e|0)){continue}break}}}function Ja(a,b,c,d,e){var f=0,g=v(0),h=v(0);f=K-32|0;K=f;o[f+28>>2]=a;o[f+24>>2]=b;o[f+20>>2]=c;o[f+16>>2]=d;o[f+12>>2]=e;b=K-16|0;a=o[f+28>>2];o[b+12>>2]=a+(o[f+24>>2]<<4);g=s[o[b+12>>2]+(o[f+20>>2]<<2)>>2];b=K-16|0;o[b+12>>2]=a+(o[f+16>>2]<<4);g=v(g*s[o[b+12>>2]+(o[f+12>>2]<<2)>>2]);b=K-16|0;o[b+12>>2]=a+(o[f+24>>2]<<4);h=s[o[b+12>>2]+(o[f+12>>2]<<2)>>2];b=K-16|0;o[b+12>>2]=a+(o[f+16>>2]<<4);K=f+32|0;return v(g-v(h*s[o[b+12>>2]+(o[f+20>>2]<<2)>>2]))}function $e(a,b){var c=0,d=v(0),e=0,f=v(0),g=0,h=v(0),i=v(0),j=v(0),k=v(0);g=o[a>>2];c=0;a:{if((g|0)<1){break a}h=s[a+308>>2];i=s[b+8>>2];j=s[b+4>>2];k=s[b>>2];while(1){c=(e<<4)+a|0;d=v(k-s[c+4>>2]);f=v(d*d);d=v(j-s[c+8>>2]);f=v(f+v(d*d));d=v(i-s[c+12>>2]);c=1;if(!!(v(f+v(d*d))<=h)){break a}e=e+1|0;if((g|0)!=(e|0)){continue}break}c=0;}e=c;if(!(s[b+12>>2]!=s[a+304>>2]|s[b+8>>2]!=s[a+300>>2]|(s[b+4>>2]!=s[a+296>>2]|s[b>>2]!=s[a+292>>2]))){e=1;}return e}function om(a,b,c,d,e,f,g,h,i){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,m=0,n=v(0),p=0;m=K-16|0;K=m;l[o[4966]](3837);l[o[o[a>>2]+32>>2]](a,b,c,d,e,f,g,h,i);j=o[a+184>>2];k=o[h+20>>2];k=(j|0)>(k|0)?j:k;a:{if((k|0)<1){break a}p=k+ -1|0;j=0;while(1){n=v(l[o[o[a>>2]+40>>2]](a,j,b,c,d,e,f,g,h,i));s[a+228>>2]=n;if((j|0)>=(p|0)|n<=s[h+92>>2]){break a}j=j+1|0;if((j|0)<(k|0)){continue}break}}l[o[4967]]();K=m+16|0;return v(v(0))}function yt(a,b,c,d){var e=0;e=K-32|0;K=e;o[e+28>>2]=a;s[e+24>>2]=b;s[e+20>>2]=c;o[e+16>>2]=d;a=o[e+28>>2];o[a+56>>2]=o[e+16>>2];s[e+12>>2]=1;s[e+8>>2]=1;s[e+4>>2]=1;Z(a+16|0,e+12|0,e+8|0,e+4|0);a:{if(o[a+56>>2]==1){d=e+24|0;Z(a+32|0,d,e+20|0,d);break a}b:{if(!o[a+56>>2]){d=e+24|0;Z(a+32|0,e+20|0,d,d);break b}d=e+24|0;Z(a+32|0,d,d,e+20|0);}}o[e>>2]=(o[e+16>>2]+2|0)%3;d=K-16|0;o[d+12>>2]=a+32;s[a+48>>2]=s[o[d+12>>2]+(o[e>>2]<<2)>>2];K=e+32|0;}function ji(a,b){a=a|0;b=b|0;var c=v(0),d=0,e=v(0);d=l[o[o[a>>2]+28>>2]](a)|0;c=v(s[d>>2]-s[b>>2]);e=v(c*c);c=v(s[d+4>>2]-s[b+4>>2]);e=v(e+v(c*c));c=v(s[d+8>>2]-s[b+8>>2]);if(!!(v(e+v(c*c))>v(1.1920928955078125e-7))){Zd(a,b);if(p[a+65|0]){b=o[a+56>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+56>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[6257]=o[6257]+1;b=l[o[4968]](172,16)|0;d=sh(b);o[a+56>>2]=b;rh(d,o[a+52>>2],p[a+64|0],a+20|0,a+36|0);m[a+65|0]=1;}}function Fe(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=v(d);e=e|0;f=f|0;var g=0;g=K+ -64|0;K=g;o[g+60>>2]=f;o[g+56>>2]=e;e=o[a+212>>2];if(!!(s[e+4>>2]>=d)){o[g+8>>2]=o[a+216>>2];o[g+12>>2]=g+56;a=o[b+12>>2];o[g+24>>2]=o[b+8>>2];o[g+28>>2]=a;a=o[b+4>>2];o[g+16>>2]=o[b>>2];o[g+20>>2]=a;a=o[c+12>>2];o[g+40>>2]=o[c+8>>2];o[g+44>>2]=a;a=o[c+4>>2];o[g+32>>2]=o[c>>2];o[g+36>>2]=a;s[g+48>>2]=d;d=v(l[o[o[e>>2]+12>>2]](e,g+8|0,1));}K=g- -64|0;return v(d)}function ip(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+8>>2]=a;o[c+4>>2]=b;a=o[c+8>>2];a:{if(o[o[c+4>>2]>>2]==o[a+84>>2]){m[c+15|0]=0;break a}if(!(Rf(a,o[c+4>>2])&1)){m[c+15|0]=0;break a}b=K-16|0;o[b+12>>2]=o[a+88>>2];if(!(m[o[b+12>>2]+368|0]&1)){o[c>>2]=o[o[c+4>>2]>>2];b=K-16|0;o[b+12>>2]=o[a+88>>2];b=o[o[b+12>>2]+24>>2];if(!(l[o[o[b>>2]+28>>2]](b,o[a+84>>2],o[c>>2])&1)){m[c+15|0]=0;break a}}m[c+15|0]=1;}K=c+16|0;return m[c+15|0]&1}function xp(a,b){var c=0;c=K-48|0;K=c;o[c+44>>2]=a;o[c+40>>2]=b;a=o[c+44>>2];s[c+36>>2]=bb(o[c+40>>2],a);s[c+32>>2]=ab(o[c+40>>2],a);s[c+28>>2]=$a(o[c+40>>2],a);s[c+24>>2]=bb(o[c+40>>2],a+16|0);s[c+20>>2]=ab(o[c+40>>2],a+16|0);s[c+16>>2]=$a(o[c+40>>2],a+16|0);s[c+12>>2]=bb(o[c+40>>2],a+32|0);s[c+8>>2]=ab(o[c+40>>2],a+32|0);s[c+4>>2]=$a(o[c+40>>2],a+32|0);cb(a,c+36|0,c+32|0,c+28|0,c+24|0,c+20|0,c+16|0,c+12|0,c+8|0,c+4|0);K=c+48|0;}function zh(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0);l[o[o[b>>2]+68>>2]](a,b,c);if(v(l[o[o[b>>2]+48>>2]](b))!=v(0)){e=s[c+4>>2];d=s[c>>2];f=s[c+8>>2];g=v(l[o[o[b>>2]+48>>2]](b));b=v(v(v(d*d)+v(e*e))+v(f*f))<v(1.4210854715202004e-14);d=b?v(-1):d;h=d;f=b?v(-1):f;e=b?v(-1):e;d=v(v(1)/v(C(v(v(f*f)+v(v(d*d)+v(e*e))))));s[a>>2]=s[a>>2]+v(g*v(h*d));s[a+4>>2]=s[a+4>>2]+v(g*v(e*d));s[a+8>>2]=s[a+8>>2]+v(g*v(f*d));}}function Hm(a,b,c,d){a=a|0;b=b|0;c=v(c);d=d|0;a:{d=d+1|0;if(d>>>0>6){break a}b:{switch(d-1|0){case 0:case 1:case 2:case 3:case 4:break a;default:break b}}b=b+ -1|0;if(b>>>0>3){break a}c:{switch(b-1|0){case 0:s[a+764>>2]=c;o[a+748>>2]=o[a+748>>2]|2;return;case 2:s[a+760>>2]=c;o[a+748>>2]=o[a+748>>2]|1;return;case 1:s[a+752>>2]=c;o[a+748>>2]=o[a+748>>2]|4;return;default:break c}}s[a+756>>2]=c;o[a+748>>2]=o[a+748>>2]|8;}}function Be(a){a=a|0;var b=0,c=0;o[a>>2]=9856;a:{if(!p[a+52|0]){break a}b=o[a+56>>2];if(!b){break a}c=o[a+4>>2];l[o[o[c>>2]+16>>2]](c,b);}b=o[a+44>>2];if(b){if(p[a+48|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+44>>2]=0;}o[a+44>>2]=0;o[a+36>>2]=0;o[a+40>>2]=0;m[a+48|0]=1;b=o[a+24>>2];if(b){if(p[a+28|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+24>>2]=0;}o[a+24>>2]=0;o[a+16>>2]=0;o[a+20>>2]=0;m[a+28|0]=1;return a|0}function ab(a,b){var c=0,d=v(0),e=v(0);c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=K-16|0;a=o[c+12>>2];o[b+12>>2]=a;d=s[o[b+12>>2]+4>>2];b=K-16|0;o[b+12>>2]=o[c+8>>2];d=v(d*s[o[b+12>>2]>>2]);b=K-16|0;o[b+12>>2]=a+16;e=s[o[b+12>>2]+4>>2];b=K-16|0;o[b+12>>2]=o[c+8>>2];d=v(d+v(e*s[o[b+12>>2]+4>>2]));b=K-16|0;o[b+12>>2]=a+32;e=s[o[b+12>>2]+4>>2];a=K-16|0;o[a+12>>2]=o[c+8>>2];K=c+16|0;return v(d+v(e*s[o[a+12>>2]+8>>2]))}function Fi(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0);Ic(a,b,c);if(v(l[o[o[b>>2]+48>>2]](b))!=v(0)){e=s[c+4>>2];d=s[c>>2];f=s[c+8>>2];g=v(l[o[o[b>>2]+48>>2]](b));b=v(v(v(d*d)+v(e*e))+v(f*f))<v(1.4210854715202004e-14);d=b?v(-1):d;h=d;f=b?v(-1):f;e=b?v(-1):e;d=v(v(1)/v(C(v(v(f*f)+v(v(d*d)+v(e*e))))));s[a>>2]=s[a>>2]+v(g*v(h*d));s[a+4>>2]=s[a+4>>2]+v(g*v(e*d));s[a+8>>2]=s[a+8>>2]+v(g*v(f*d));}}function $a(a,b){var c=0,d=v(0),e=v(0);c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=K-16|0;a=o[c+12>>2];o[b+12>>2]=a;d=s[o[b+12>>2]+8>>2];b=K-16|0;o[b+12>>2]=o[c+8>>2];d=v(d*s[o[b+12>>2]>>2]);b=K-16|0;o[b+12>>2]=a+16;e=s[o[b+12>>2]+8>>2];b=K-16|0;o[b+12>>2]=o[c+8>>2];d=v(d+v(e*s[o[b+12>>2]+4>>2]));b=K-16|0;o[b+12>>2]=a+32;e=s[o[b+12>>2]+8>>2];a=K-16|0;o[a+12>>2]=o[c+8>>2];K=c+16|0;return v(d+v(e*s[o[a+12>>2]+8>>2]))}function Va(a){var b=0,c=0,d=0,e=0,f=0,g=v(0);d=K-16|0;K=d;b=o[a+12>>2];c=b;f=o[a+8>>2];a:{if((b|0)>0?1:(b|0)>=0?f>>>0<0?0:1:0){g=v(v(v(+(f>>>0)+4294967296*+(c>>>0))*v(0x10000000000000000))+v(+r[a>>2]+4294967296*+r[a+4>>2]));break a}e=o[a+4>>2];b=o[a>>2];a=b;o[d>>2]=0-a;o[d+4>>2]=0-(e+(0<a>>>0)|0);c=c^-1;a=!(a|e);e=f^-1;b=a+e|0;if(b>>>0<e>>>0){c=c+1|0;}a=d;o[a+8>>2]=b;o[a+12>>2]=c;g=v(-Va(a));}K=d+16|0;return g}function pf(a,b){var c=v(0);o[a+20>>2]=0;o[a+24>>2]=0;m[a+28|0]=0;c=s[a+4>>2];a:{if(!(c>=v(0))){break a}b=ua(v(b-s[a>>2]));b:{if(!!(b<v(-3.1415927410125732))){b=v(b+v(6.2831854820251465));break b}if(!(b>v(3.1415927410125732))){break b}b=v(b+v(-6.2831854820251465));}if(!!(b<v(-c))){o[a+24>>2]=1065353216;m[a+28|0]=1;s[a+20>>2]=-v(c+b);return}if(!(b>c)){break a}o[a+24>>2]=-1082130432;m[a+28|0]=1;s[a+20>>2]=c-b;}}function dw(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0),f=v(0),g=v(0);if(c>>>0<=5){f=s[a+40>>2];g=s[a+36>>2];e=s[a+32>>2];a=1065353216;d=c;a:{b:{c:{d:{switch(c-1|0){case 0:c=0;a=-1082130432;d=0;break a;case 1:c=1065353216;break b;case 2:c=-1082130432;break b;case 3:d=1065353216;break c;case 4:break d;default:break a}}d=-1082130432;}a=0;e=f;c=0;break a}a=0;e=g;d=0;}o[b+8>>2]=d;o[b+4>>2]=c;o[b>>2]=a;s[b+12>>2]=-e;}}function dq(a){var b=0,c=0;b=K-16|0;K=b;o[b+8>>2]=a;c=K-16|0;a=o[b+8>>2];o[c+12>>2]=a;a:{if(o[o[c+12>>2]+220>>2]==4){m[b+15|0]=0;break a}if(!(s[4961]!=v(0)?!(m[20820]&1):0)){m[b+15|0]=0;break a}c=K-16|0;o[c+12>>2]=a;b:{if(o[o[c+12>>2]+220>>2]!=2){c=K-16|0;o[c+12>>2]=a;if(o[o[c+12>>2]+220>>2]!=3){break b}}m[b+15|0]=1;break a}if(s[a+224>>2]>s[4961]){m[b+15|0]=1;break a}m[b+15|0]=0;}K=b+16|0;return m[b+15|0]&1}function Ii(a,b){var c=0,d=0,e=0;a:{b:{c:{d:{if(b>>>0<=2){switch(b-1|0){case 1:break b;case 0:break c;default:break d}}c=o[a+72>>2];e=o[a+68>>2];b=o[a+76>>2];break a}o[a+68>>2]=1;o[a+72>>2]=0;o[a+76>>2]=2;e=1;b=2;break a}o[a+68>>2]=0;o[a+72>>2]=1;o[a+76>>2]=2;c=1;b=2;break a}o[a+68>>2]=0;o[a+72>>2]=2;o[a+76>>2]=1;c=2;b=1;}d=a+32|0;o[d+(e<<2)>>2]=o[a+60>>2];o[(c<<2)+d>>2]=o[a+64>>2];o[(b<<2)+d>>2]=o[a+60>>2];}function bb(a,b){var c=0,d=v(0),e=v(0);c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=K-16|0;a=o[c+12>>2];o[b+12>>2]=a;d=s[o[b+12>>2]>>2];b=K-16|0;o[b+12>>2]=o[c+8>>2];d=v(d*s[o[b+12>>2]>>2]);b=K-16|0;o[b+12>>2]=a+16;e=s[o[b+12>>2]>>2];b=K-16|0;o[b+12>>2]=o[c+8>>2];d=v(d+v(e*s[o[b+12>>2]+4>>2]));b=K-16|0;o[b+12>>2]=a+32;e=s[o[b+12>>2]>>2];a=K-16|0;o[a+12>>2]=o[c+8>>2];K=c+16|0;return v(d+v(e*s[o[a+12>>2]+8>>2]))}function Qo(a,b,c){var d=0,e=0;d=K-32|0;K=d;o[d+28>>2]=a;o[d+24>>2]=0;o[d+20>>2]=b;o[d+16>>2]=c;c=o[d+28>>2];o[d+12>>2]=o[d+24>>2];while(1){if(o[d+12>>2]<o[d+20>>2]){b=o[d+16>>2]+(o[d+12>>2]<<4)|0;a=K-16|0;o[a+12>>2]=16;o[a+8>>2]=b;b=o[c+12>>2]+(o[d+12>>2]<<4)|0;e=o[b+4>>2];a=o[a+8>>2];o[a>>2]=o[b>>2];o[a+4>>2]=e;e=o[b+12>>2];o[a+8>>2]=o[b+8>>2];o[a+12>>2]=e;o[d+12>>2]=o[d+12>>2]+1;continue}break}K=d+32|0;}function fw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;e=K-48|0;K=e;l[o[o[a>>2]+124>>2]](a,e+32|0,d);d=o[e+32>>2];f=o[e+36>>2];g=o[e+40>>2];o[b+12>>2]=0;o[b+8>>2]=g;o[b+4>>2]=f;o[b>>2]=d;o[e+12>>2]=0;o[e+8>>2]=g^-2147483648;o[e+4>>2]=f^-2147483648;o[e>>2]=d^-2147483648;l[o[o[a>>2]+64>>2]](e+16|0,a,e);a=o[e+28>>2];o[c+8>>2]=o[e+24>>2];o[c+12>>2]=a;a=o[e+20>>2];o[c>>2]=o[e+16>>2];o[c+4>>2]=a;K=e+48|0;}function Mk(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0);d=s[c>>2];e=s[c+4>>2];f=s[c+8>>2];g=v(v(v(d*s[b+76>>2])+v(e*s[b+80>>2]))+v(f*s[b+84>>2]));h=v(v(v(d*s[b+92>>2])+v(e*s[b+96>>2]))+v(f*s[b+100>>2]));d=v(v(v(d*s[b+60>>2])+v(e*s[b- -64>>2]))+v(f*s[b+68>>2]));b=(b+60|0)+((d<g?g<h?2:1:(d<h)<<1)<<4)|0;c=o[b+4>>2];o[a>>2]=o[b>>2];o[a+4>>2]=c;c=o[b+12>>2];o[a+8>>2]=o[b+8>>2];o[a+12>>2]=c;}function ac(a,b,c,d,e,f,g,h,i,j){var k=0;k=K-48|0;K=k;o[k+40>>2]=a;o[k+36>>2]=b;o[k+32>>2]=c;o[k+28>>2]=d;o[k+24>>2]=e;o[k+20>>2]=f;o[k+16>>2]=g;o[k+12>>2]=h;o[k+8>>2]=i;o[k+4>>2]=j;a=o[k+40>>2];o[k+44>>2]=a;c=a+48|0;b=a;while(1){o[(K-16|0)+12>>2]=b;d=b+16|0;b=d;if((c|0)!=(b|0)){continue}break}cb(a,o[k+36>>2],o[k+32>>2],o[k+28>>2],o[k+24>>2],o[k+20>>2],o[k+16>>2],o[k+12>>2],o[k+8>>2],o[k+4>>2]);K=k+48|0;}function Ld(a,b,c){var d=0,e=0,f=0,g=0;e=yc(a,b);a:{if(!e){e=0;break a}f=o[a+8>>2];if((f|0)>=0){if(!f){break a}while(1){d=o[e+32>>2];if(!d){break a}e=d;g=g+1|0;if((f|0)!=(g|0)){continue}break}break a}e=o[a>>2];}d=o[c+4>>2];o[b>>2]=o[c>>2];o[b+4>>2]=d;d=o[c+28>>2];o[b+24>>2]=o[c+24>>2];o[b+28>>2]=d;d=o[c+20>>2];o[b+16>>2]=o[c+16>>2];o[b+20>>2]=d;d=o[c+12>>2];o[b+8>>2]=o[c+8>>2];o[b+12>>2]=d;xc(a,e,b);}function Vo(a,b){var c=0,d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;b=K-16|0;a=o[d+12>>2];o[b+12>>2]=a;o[d+4>>2]=o[o[b+12>>2]+4>>2];b=o[d+4>>2];c=K-16|0;o[c+12>>2]=a;if(o[o[c+12>>2]+8>>2]==(b|0)){c=K-16|0;o[c+12>>2]=a;b=o[o[c+12>>2]+4>>2];c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=a;if(o[c+8>>2]){c=o[c+8>>2]<<1;}else {c=1;}To(b,c);}s[o[a+12>>2]+(o[a+4>>2]<<2)>>2]=s[o[d+8>>2]>>2];o[a+4>>2]=o[a+4>>2]+1;K=d+16|0;}function Ka(a,b){var c=0,d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;b=K-16|0;a=o[d+12>>2];o[b+12>>2]=a;o[d+4>>2]=o[o[b+12>>2]+4>>2];b=o[d+4>>2];c=K-16|0;o[c+12>>2]=a;if(o[o[c+12>>2]+8>>2]==(b|0)){c=K-16|0;o[c+12>>2]=a;b=o[o[c+12>>2]+4>>2];c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=a;if(o[c+8>>2]){c=o[c+8>>2]<<1;}else {c=1;}Ng(b,c);}o[o[a+12>>2]+(o[a+4>>2]<<2)>>2]=o[o[d+8>>2]>>2];o[a+4>>2]=o[a+4>>2]+1;K=d+16|0;}function bo(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=b;d=o[c+4>>2];o[a+264>>2]=o[c>>2];o[a+268>>2]=d;d=o[c+12>>2];o[a+272>>2]=o[c+8>>2];o[a+276>>2]=d;c=o[a+248>>2];if((c|0)>=1){while(1){a:{b:{d=o[o[a+256>>2]+(e<<2)>>2];f=o[d+220>>2]+ -2|0;if(f>>>0>3){break b}switch(f-1|0){case 0:case 1:break b;default:break a}}if(m[d+564|0]&1){break a}Zb(d,b);c=o[a+248>>2];}e=e+1|0;if((e|0)<(c|0)){continue}break}}}function Mv(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=v(0),g=v(0),h=v(0),i=0,j=v(0),k=0,l=v(0);if((d|0)>=1){while(1){f=s[a+36>>2];g=s[a+32>>2];k=i<<4;e=k+b|0;j=s[e>>2];h=s[e+8>>2];l=v(C(v(v(j*j)+v(h*h))));a:{if(l!=v(0)){g=v(g/l);h=v(h*g);g=v(j*g);f=s[e+4>>2]<v(0)?v(-f):f;break a}h=v(0);f=s[e+4>>2]<v(0)?v(-f):f;}e=c+k|0;s[e+8>>2]=h;s[e+4>>2]=f;s[e>>2]=g;i=i+1|0;if((i|0)!=(d|0)){continue}break}}}function An(a){a=a|0;var b=0;o[a>>2]=2936;b=o[a+80>>2];if(b){if(p[a+84|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+80>>2]=0;}o[a+80>>2]=0;o[a+72>>2]=0;o[a+76>>2]=0;m[a+84|0]=1;b=o[a+60>>2];if(b){if(p[a- -64|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+60>>2]=0;}o[a+60>>2]=0;o[a+52>>2]=0;o[a+56>>2]=0;m[a- -64|0]=1;b=o[a+40>>2];if(!(!b|!p[a+44|0])){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}aa(a);}function Aj(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;c=o[b>>2];c=l[o[o[c>>2]+56>>2]](c,72)|0;d=o[b+4>>2];e=o[a+12>>2];f=o[a+16>>2];a=o[a+8>>2];o[c>>2]=16448;o[c+4>>2]=o[b>>2];o[c>>2]=4944;m[c+28|0]=1;o[c+8>>2]=a;o[c>>2]=9856;o[c+24>>2]=0;m[c+48|0]=1;o[c+16>>2]=0;o[c+20>>2]=0;o[c+44>>2]=0;o[c+64>>2]=e;o[c+68>>2]=f;m[c+60|0]=0;o[c+56>>2]=d;m[c+52|0]=0;o[c+36>>2]=0;o[c+40>>2]=0;return c|0}



            function uh(a,b){a=a|0;b=b|0;var c=v(0),d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0);c=v(l[o[o[a>>2]+48>>2]](a));d=v(l[o[o[a>>2]+48>>2]](a));e=v(l[o[o[a>>2]+48>>2]](a));f=s[a+20>>2];g=s[a+36>>2];h=s[a+24>>2];i=s[a+40>>2];j=s[a+16>>2];k=s[a+32>>2];xb(a,b);o[a+44>>2]=0;s[a+40>>2]=v(v(v(e+i)/h)*s[a+24>>2])-e;s[a+36>>2]=v(v(v(d+g)/f)*s[a+20>>2])-d;s[a+32>>2]=v(v(v(c+k)/j)*s[a+16>>2])-c;}function Sa(a,b,c){var d=0;d=K-32|0;K=d;o[d+28>>2]=b;o[d+24>>2]=c;b=K-16|0;o[b+12>>2]=o[d+28>>2];o[b+8>>2]=0;s[d+20>>2]=Ga(o[b+12>>2]+(o[b+8>>2]<<4)|0,o[d+24>>2]);b=K-16|0;o[b+12>>2]=o[d+28>>2];o[b+8>>2]=1;s[d+16>>2]=Ga(o[b+12>>2]+(o[b+8>>2]<<4)|0,o[d+24>>2]);b=K-16|0;o[b+12>>2]=o[d+28>>2];o[b+8>>2]=2;s[d+12>>2]=Ga(o[b+12>>2]+(o[b+8>>2]<<4)|0,o[d+24>>2]);Z(a,d+20|0,d+16|0,d+12|0);K=d+32|0;}function sd(a,b){var c=0,d=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];d=o[b+4>>2];a=o[c+12>>2];o[a>>2]=o[b>>2];o[a+4>>2]=d;d=o[b+12>>2];o[a+8>>2]=o[b+8>>2];o[a+12>>2]=d;b=o[c+8>>2];d=o[b+20>>2];o[a+16>>2]=o[b+16>>2];o[a+20>>2]=d;d=o[b+28>>2];o[a+24>>2]=o[b+24>>2];o[a+28>>2]=d;b=o[c+8>>2];c=o[b+36>>2];o[a+32>>2]=o[b+32>>2];o[a+36>>2]=c;c=o[b+44>>2];o[a+40>>2]=o[b+40>>2];o[a+44>>2]=c;}function bs(a,b){var c=0,d=0,e=0;c=K-80|0;K=c;o[c+76>>2]=a;o[c+72>>2]=b;a=o[c+76>>2];s[c+52>>2]=l[o[o[a>>2]+48>>2]](a);s[c+48>>2]=l[o[o[a>>2]+48>>2]](a);s[c+44>>2]=l[o[o[a>>2]+48>>2]](a);d=c+56|0;Z(d,c+52|0,c+48|0,c+44|0);e=c+8|0;Ta(e,o[c+72>>2],a+16|0);b=c+24|0;gc(b,e,d);d=o[b+4>>2];o[a+32>>2]=o[b>>2];o[a+36>>2]=d;d=o[b+12>>2];o[a+40>>2]=o[b+8>>2];o[a+44>>2]=d;as(a,o[c+72>>2]);K=c+80|0;}function Cw(a,b,c){a=a|0;b=v(b);c=c|0;var d=v(0),e=v(0),f=v(0),g=0,h=0,i=0;i=a+32|0;h=o[a+56>>2];g=o[i+((h+2|0)%3<<2)>>2];a=K-16|0;o[a+12>>2]=0;o[a+8>>2]=g;o[a+4>>2]=g;o[a>>2]=g;g=h<<2;h=g+a|0;s[h>>2]=s[g+i>>2]+s[h>>2];d=s[a+8>>2];b=v(b*v(.0833333283662796));e=s[a>>2];e=v(e+e);e=v(e*e);f=s[a+4>>2];f=v(f+f);f=v(f*f);s[c+8>>2]=b*v(e+f);d=v(d+d);d=v(d*d);s[c+4>>2]=b*v(e+d);s[c>>2]=b*v(f+d);}function qn(a,b){var c=v(0),d=v(0);c=s[a+16>>2];if(!!(c<v(1))){if(!!(c>v(-1))){s[b>>2]=ba(s[a+24>>2],s[a+20>>2]);s[b+4>>2]=ba(s[a+32>>2],s[a>>2]);s[b+8>>2]=hb(v(y(v(z(v(-s[a+16>>2]),v(-1))),v(1))));return}c=s[a+40>>2];d=s[a+8>>2];o[b+4>>2]=0;s[b>>2]=-ba(v(-d),c);s[b+8>>2]=1.5707963705062866;return}c=s[a+40>>2];d=s[a+8>>2];o[b+4>>2]=0;s[b>>2]=ba(v(-d),c);s[b+8>>2]=-1.5707963705062866;}function nj(a,b,c){var d=0,e=0,f=0;o[5646]=o[5646]+1;d=c<<16|b;d=(d<<15^-1)+d|0;d=u(d>>>10^d,9);d=d>>>6^d;d=(d<<11^-1)+d|0;d=o[a+12>>2]+ -1&(d>>>16^d);a:{b:{if((d|0)>=o[a+28>>2]){break b}d=o[o[a+36>>2]+(d<<2)>>2];if((d|0)==-1){break b}f=o[a+16>>2];while(1){e=u(d,12)+f|0;if(o[e+4>>2]==(c|0)?o[e>>2]==(b|0):0){break a}d=o[o[a+56>>2]+(d<<2)>>2];if((d|0)!=-1){continue}break}}e=0;}return e}function Us(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];kp(a);o[a>>2]=1532;b=o[d+8>>2];c=o[b+4>>2];o[a+16>>2]=o[b>>2];o[a+20>>2]=c;c=o[b+12>>2];o[a+24>>2]=o[b+8>>2];o[a+28>>2]=c;b=o[d+4>>2];c=o[b+4>>2];o[a+32>>2]=o[b>>2];o[a+36>>2]=c;c=o[b+12>>2];o[a+40>>2]=o[b+8>>2];o[a+44>>2]=c;o[(K-16|0)+12>>2]=a+48;o[(K-16|0)+12>>2]=a- -64;o[a+80>>2]=0;K=d+16|0;}function Xl(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;a:{b:{a=o[b+220>>2]+ -2|0;if(a>>>0>3){break b}c:{switch(a-1|0){case 0:case 1:break b;default:break c}}d=o[c+220>>2]+ -2|0;if(d>>>0>3){break b}a=0;switch(d-1|0){case 0:case 1:break b;default:break a}}d:{if(o[b+280>>2]){if(!l[o[o[b>>2]+12>>2]](b,c)){break d}}a=1;if(!o[c+280>>2]){break a}if(l[o[o[c>>2]+12>>2]](c,b)){break a}}a=0;}return a|0}function Ec(a,b){a=a|0;b=v(b);var c=v(0),d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0);c=v(l[o[o[a>>2]+48>>2]](a));d=v(l[o[o[a>>2]+48>>2]](a));e=v(l[o[o[a>>2]+48>>2]](a));s[a+48>>2]=b;b=s[a+40>>2];f=s[a+36>>2];g=s[a+32>>2];h=v(l[o[o[a>>2]+48>>2]](a));i=v(l[o[o[a>>2]+48>>2]](a));j=v(l[o[o[a>>2]+48>>2]](a));o[a+44>>2]=0;s[a+36>>2]=v(d+f)-i;s[a+32>>2]=v(c+g)-h;s[a+40>>2]=v(e+b)-j;}function Uh(a,b,c){var d=v(0),e=v(0),f=v(0);o[a+4>>2]=35;o[a+8>>2]=0;o[a+12>>2]=-1;o[a+16>>2]=0;o[a>>2]=13904;o[a>>2]=12484;d=s[b+8>>2];e=s[b>>2];f=s[b+4>>2];b=o[b+12>>2];o[a+80>>2]=1065353216;o[a+84>>2]=0;o[a+72>>2]=1065353216;o[a+76>>2]=1065353216;s[a+68>>2]=c;o[a- -64>>2]=b;o[a+4>>2]=28;c=v(v(1)/v(C(v(v(v(e*e)+v(f*f))+v(d*d)))));s[a+60>>2]=d*c;s[a+56>>2]=f*c;s[a+52>>2]=e*c;}function nw(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0),m=v(0);d=s[b+36>>2];e=s[b+40>>2];f=s[b+32>>2];g=v(l[o[o[b>>2]+48>>2]](b));h=v(l[o[o[b>>2]+48>>2]](b));i=v(l[o[o[b>>2]+48>>2]](b));j=s[c>>2];k=s[c+4>>2];m=s[c+8>>2];o[a+12>>2]=0;e=v(e+i);s[a+8>>2]=m>=v(0)?e:v(-e);d=v(d+h);s[a+4>>2]=k>=v(0)?d:v(-d);d=v(f+g);s[a>>2]=j>=v(0)?d:v(-d);}function vj(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0;f=K-16|0;K=f;c=o[a+4>>2];a:{if((c|0)<=0){break a}g=o[a+12>>2];while(1){h=(d<<3)+g|0;i=h;b=d;e=o[h>>2];if((b|0)!=(e|0)){while(1){b=(e<<3)+g|0;o[i>>2]=o[b>>2];b=o[b>>2];i=(b<<3)+g|0;e=o[i>>2];if((b|0)!=(e|0)){continue}break}}o[h>>2]=b;d=d+1|0;if((c|0)!=(d|0)){continue}break}if((c|0)<2){break a}ze(a,f+8|0,0,c+ -1|0);}K=f+16|0;}function gw(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0);e=s[a+40>>2];d=s[a+36>>2];f=s[a+32>>2];g=v(l[o[o[a>>2]+48>>2]](a));h=v(l[o[o[a>>2]+48>>2]](a));i=v(l[o[o[a>>2]+48>>2]](a));o[c+12>>2]=0;d=v(d+h);a=b>>>1&1;s[c+4>>2]=v(d*v(a^1))-v(d*v(a|0));d=v(f+g);a=b&1;s[c>>2]=v(d*v(a^1))-v(d*v(a|0));e=v(e+i);a=b>>>2&1;s[c+8>>2]=v(e*v(a^1))-v(e*v(a|0));}function Cs(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];Mf(a);o[a>>2]=2112;b=o[d+8>>2];c=o[b+4>>2];o[a+24>>2]=o[b>>2];o[a+28>>2]=c;c=o[b+12>>2];o[a+32>>2]=o[b+8>>2];o[a+36>>2]=c;b=o[d+4>>2];c=o[b+4>>2];o[a+40>>2]=o[b>>2];o[a+44>>2]=c;c=o[b+12>>2];o[a+48>>2]=o[b+8>>2];o[a+52>>2]=c;o[(K-16|0)+12>>2]=a+56;o[(K-16|0)+12>>2]=a+72;K=d+16|0;}function pw(a,b,c){a=a|0;b=v(b);c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0);d=s[a+40>>2];e=s[a+36>>2];f=s[a+32>>2];g=v(l[o[o[a>>2]+48>>2]](a));h=v(l[o[o[a>>2]+48>>2]](a));i=v(l[o[o[a>>2]+48>>2]](a));o[c+12>>2]=0;b=v(b/v(12));f=v(f+g);f=v(f+f);f=v(f*f);e=v(e+h);e=v(e+e);e=v(e*e);s[c+8>>2]=b*v(f+e);d=v(d+i);d=v(d+d);d=v(d*d);s[c+4>>2]=b*v(f+d);s[c>>2]=b*v(e+d);}function Nn(a){var b=0,c=0,d=0,e=0;d=K-16|0;K=d;l[o[4966]](2667);b=o[a+332>>2];if(o[a+324>>2]>=1){while(1){e=o[a+24>>2];l[o[o[e>>2]+16>>2]](e,o[(c<<2)+b>>2]);b=o[a+332>>2];c=c+1|0;if((c|0)<o[a+324>>2]){continue}break}}if(b){if(p[a+336|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+332>>2]=0;}o[a+332>>2]=0;o[a+324>>2]=0;o[a+328>>2]=0;m[a+336|0]=1;l[o[4967]]();K=d+16|0;}function Ht(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];Mf(a);o[a>>2]=1940;db(a+24|0);b=o[d+8>>2];c=o[b+4>>2];o[a+44>>2]=o[b>>2];o[a+48>>2]=c;c=o[b+12>>2];o[a+52>>2]=o[b+8>>2];o[a+56>>2]=c;b=o[d+4>>2];c=o[b+4>>2];o[a+60>>2]=o[b>>2];o[a+64>>2]=c;c=o[b+12>>2];o[a+68>>2]=o[b+8>>2];o[a+72>>2]=c;db(a+76|0);db(a+96|0);db(a+116|0);K=d+16|0;}function im(a,b){var c=v(0),d=v(0),e=0,f=0,g=v(0),h=0,i=v(0),j=v(0),k=v(0);h=o[a+844>>2];a:{if((h|0)<1){f=-1;break a}i=s[b+8>>2];j=s[b+4>>2];k=s[b>>2];d=s[a+848>>2];d=v(d*d);b=0;f=-1;while(1){e=u(b,208)+a|0;c=v(s[e+4>>2]-k);g=v(c*c);c=v(s[e+8>>2]-j);g=v(g+v(c*c));c=v(s[e+12>>2]-i);c=v(g+v(c*c));e=c<d;d=e?c:d;f=e?b:f;b=b+1|0;if((h|0)!=(b|0)){continue}break}}return f}function Uj(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=v(0),g=0,h=0;c=K-32|0;K=c;d=o[a+184>>2];a:{if(s[d+4>>2]==v(0)){break a}e=1;b=o[b>>2];if(!l[o[o[d>>2]+8>>2]](d,o[b+188>>2])){break a}f=s[a+188>>2];d=o[a+184>>2];g=o[a+192>>2];h=o[b+192>>2];o[c+24>>2]=-1;o[c+28>>2]=-1;o[c+20>>2]=b+4;o[c+16>>2]=b;o[c+12>>2]=h;o[c+8>>2]=0;Qc(g,a+36|0,a+100|0,c+8|0,d,f);}K=c+32|0;return e|0}function ju(a,b){a:{if((b|0)>=128){a=v(a*v(1.7014118346046923e+38));if((b|0)<255){b=b+ -127|0;break a}a=v(a*v(1.7014118346046923e+38));b=((b|0)<381?b:381)+ -254|0;break a}if((b|0)>-127){break a}a=v(a*v(1.1754943508222875e-38));if((b|0)>-253){b=b+126|0;break a}a=v(a*v(1.1754943508222875e-38));b=((b|0)>-378?b:-378)+252|0;}return v(a*(e(0,(b<<23)+1065353216|0),i()))}function Pv(a,b){var c=v(0),d=v(0),e=v(0),f=v(0);sa(a);o[a+56>>2]=1;o[a>>2]=14808;c=s[b>>2];e=s[b+4>>2];d=s[b+8>>2];o[a+44>>2]=0;f=v(d*s[a+24>>2]);d=s[a+48>>2];s[a+40>>2]=f-d;s[a+36>>2]=v(e*s[a+20>>2])-d;s[a+32>>2]=v(c*s[a+16>>2])-d;c=s[b>>2];e=s[b+8>>2];f=s[b+4>>2];c=v(s[((c<f?(c<e^1)<<1:f<e?1:2)<<2)+b>>2]*v(.10000000149011612));if(!!(c<d)){Ec(a,c);}o[a+4>>2]=13;}function Xt(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;if(pa(a,o[b+8>>2],e)){if(!(o[b+28>>2]==1|o[b+4>>2]!=(c|0))){o[b+28>>2]=d;}return}a:{if(!pa(a,o[b>>2],e)){break a}if(!(o[b+20>>2]!=(c|0)?o[b+16>>2]!=(c|0):0)){if((d|0)!=1){break a}o[b+32>>2]=1;return}o[b+20>>2]=c;o[b+32>>2]=d;o[b+40>>2]=o[b+40>>2]+1;if(!(o[b+36>>2]!=1|o[b+24>>2]!=2)){m[b+54|0]=1;}o[b+44>>2]=4;}}function ts(a,b,c,d,e,f,g,h,i){a=a|0;b=b|0;c=c|0;d=v(d);e=v(e);f=v(f);g=g|0;h=h|0;i=i|0;var j=0;j=K-48|0;K=j;o[j+44>>2]=a;o[j+40>>2]=b;o[j+36>>2]=c;s[j+32>>2]=d;s[j+28>>2]=e;s[j+24>>2]=f;o[j+20>>2]=g;o[j+16>>2]=h;m[j+15|0]=i;a=_(128);Zv(a,o[j+44>>2],o[j+40>>2],o[j+36>>2],s[j+32>>2],s[j+28>>2],s[j+24>>2],o[j+20>>2],o[j+16>>2],m[j+15|0]&1);K=j+48|0;return a|0}function de(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0);h=v(l[o[o[a>>2]+48>>2]](a));i=v(l[o[o[a>>2]+48>>2]](a));j=v(l[o[o[a>>2]+48>>2]](a));e=s[b+52>>2];f=s[b+56>>2];g=s[b+48>>2];o[c+12>>2]=0;s[c+8>>2]=f-j;s[c+4>>2]=e-i;s[c>>2]=g-h;e=s[b+52>>2];f=s[b+56>>2];g=s[b+48>>2];o[d+12>>2]=0;s[d+8>>2]=j+f;s[d+4>>2]=i+e;s[d>>2]=h+g;}function Yp(a){var b=0;b=K+ -64|0;K=b;o[b+60>>2]=a;a=o[b+60>>2];s[b+56>>2]=0;s[b+52>>2]=0;s[b+48>>2]=0;Z(a+372|0,b+56|0,b+52|0,b+48|0);s[b+44>>2]=0;s[b+40>>2]=0;s[b+36>>2]=0;Z(a+388|0,b+44|0,b+40|0,b+36|0);s[b+32>>2]=0;s[b+28>>2]=0;s[b+24>>2]=0;Z(a+472|0,b+32|0,b+28|0,b+24|0);s[b+20>>2]=0;s[b+16>>2]=0;s[b+12>>2]=0;Z(a+488|0,b+20|0,b+16|0,b+12|0);K=b- -64|0;}function rn(a,b){var c=v(0),d=v(0);c=s[a+32>>2];a:{if(!!(c<v(1))){if(!!(c>v(-1))){s[b>>2]=ba(v(-s[a+36>>2]),s[a+40>>2]);s[b+4>>2]=hb(v(y(v(z(s[a+32>>2],v(-1))),v(1))));s[b+8>>2]=ba(v(-s[a+16>>2]),s[a>>2]);return}c=s[a+20>>2];d=s[a+4>>2];o[b+4>>2]=-1077342245;s[b>>2]=-ba(d,c);break a}c=s[a+20>>2];d=s[a+4>>2];o[b+4>>2]=1070141403;s[b>>2]=ba(d,c);}s[b+8>>2]=0;}function on(a,b){var c=v(0);c=s[a+4>>2];if(!!(c<v(1))){if(!!(c>v(-1))){s[b>>2]=ba(v(-s[a+36>>2]),s[a+20>>2]);s[b+4>>2]=ba(v(-s[a+8>>2]),s[a>>2]);s[b+8>>2]=hb(v(y(v(z(s[a+4>>2],v(-1))),v(1))));return}o[b>>2]=0;s[b+4>>2]=-ba(s[a+24>>2],s[a+40>>2]);s[b+8>>2]=-1.5707963705062866;return}o[b>>2]=0;s[b+4>>2]=ba(s[a+24>>2],s[a+40>>2]);s[b+8>>2]=1.5707963705062866;}function qw(a,b){var c=v(0),d=v(0),e=v(0),f=v(0);zb(a);o[a+4>>2]=0;o[a>>2]=14012;c=s[b>>2];e=s[b+4>>2];d=s[b+8>>2];o[a+44>>2]=0;f=v(d*s[a+24>>2]);d=s[a+48>>2];s[a+40>>2]=f-d;s[a+36>>2]=v(e*s[a+20>>2])-d;s[a+32>>2]=v(c*s[a+16>>2])-d;c=s[b>>2];e=s[b+8>>2];f=s[b+4>>2];c=v(s[((c<f?(c<e^1)<<1:f<e?1:2)<<2)+b>>2]*v(.10000000149011612));if(!!(c<d)){Ec(a,c);}}function lw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=v(0),i=v(0),j=v(0),k=v(0),l=v(0),m=v(0);if((d|0)>=1){while(1){g=f<<4;e=g+b|0;k=s[e>>2];l=s[e+4>>2];m=s[e+8>>2];h=s[a+32>>2];i=s[a+36>>2];j=s[a+40>>2];e=c+g|0;o[e+12>>2]=0;s[e+8>>2]=m>=v(0)?j:v(-j);s[e+4>>2]=l>=v(0)?i:v(-i);s[e>>2]=k>=v(0)?h:v(-h);f=f+1|0;if((f|0)!=(d|0)){continue}break}}}function ig(a,b,c,d){var e=0;e=K-32|0;o[e+28>>2]=a;o[e+24>>2]=b;o[e+20>>2]=c;s[e+16>>2]=d;a=o[e+28>>2];s[e+12>>2]=v(1)-s[e+16>>2];s[a>>2]=v(s[e+12>>2]*s[o[e+24>>2]>>2])+v(s[e+16>>2]*s[o[e+20>>2]>>2]);s[a+4>>2]=v(s[e+12>>2]*s[o[e+24>>2]+4>>2])+v(s[e+16>>2]*s[o[e+20>>2]+4>>2]);s[a+8>>2]=v(s[e+12>>2]*s[o[e+24>>2]+8>>2])+v(s[e+16>>2]*s[o[e+20>>2]+8>>2]);}function Uv(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0);d=o[a+100>>2];a:{if(d>>>0>5){break a}b:{switch(d-1|0){default:return v(s[o[a+96>>2]+(u(o[a+68>>2],c)+b<<2)>>2]);case 4:return v(v(s[a+92>>2]*v(p[o[a+96>>2]+(u(o[a+68>>2],c)+b|0)|0])));case 0:case 1:case 3:break a;case 2:break b}}e=v(s[a+92>>2]*v(n[o[a+96>>2]+(u(o[a+68>>2],c)+b<<1)>>1]));}return v(e)}function $g(a,b,c,d,e){var f=0,g=0;while(1){a:{b:{if(q[e>>1]<q[b>>1]|q[d>>1]>q[b+6>>1]|(q[e+4>>1]<q[b+4>>1]|q[d+4>>1]>q[b+10>>1])){break b}if(q[e+2>>1]<q[b+2>>1]|q[d+2>>1]>q[b+8>>1]){break b}f=o[b+12>>2];if((f|0)<0){break a}l[o[o[c>>2]+8>>2]](c,f>>>21|0,f&2097151);}return}f=b+16|0;$g(a,f,c,d,e);g=b+32|0;b=o[b+28>>2];b=(b|0)>-1?g:f-(b<<4)|0;continue}}function Bo(a,b){var c=0,d=v(0),e=v(0);c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];d=s[a>>2];b=K-16|0;o[b+12>>2]=o[c+8>>2];d=v(d*s[o[b+12>>2]>>2]);e=s[a+4>>2];b=K-16|0;o[b+12>>2]=o[c+8>>2];d=v(d+v(e*s[o[b+12>>2]+4>>2]));e=s[a+8>>2];b=K-16|0;o[b+12>>2]=o[c+8>>2];K=c+16|0;return v(v(d+v(e*s[o[b+12>>2]+8>>2]))+v(s[a+12>>2]*s[o[c+8>>2]+12>>2]))}function tc(a,b){a:{if((b|0)>=1024){a=a*8.98846567431158e+307;if((b|0)<2047){b=b+ -1023|0;break a}a=a*8.98846567431158e+307;b=((b|0)<3069?b:3069)+ -2046|0;break a}if((b|0)>-1023){break a}a=a*2.2250738585072014e-308;if((b|0)>-2045){b=b+1022|0;break a}a=a*2.2250738585072014e-308;b=((b|0)>-3066?b:-3066)+2044|0;}e(0,0);e(1,b+1023<<20);return a*+f()}function mn(a,b){var c=v(0);c=s[a+8>>2];if(!!(c<v(1))){if(!!(c>v(-1))){s[b>>2]=ba(s[a+24>>2],s[a+40>>2]);s[b+4>>2]=hb(v(y(v(z(v(-s[a+8>>2]),v(-1))),v(1))));s[b+8>>2]=ba(s[a+4>>2],s[a>>2]);return}o[b>>2]=0;o[b+4>>2]=1070141403;s[b+8>>2]=-ba(s[a+16>>2],s[a+32>>2]);return}o[b>>2]=0;o[b+4>>2]=-1077342245;s[b+8>>2]=ba(v(-s[a+16>>2]),v(-s[a+32>>2]));}function cp(a,b){var c=0,d=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=K-16|0;a=o[c+12>>2];o[b+12>>2]=a;o[c+4>>2]=o[o[b+12>>2]+4>>2];o[c>>2]=0;while(1){b=o[c>>2];d=K-16|0;o[d+12>>2]=a;if((b|0)<o[o[d+12>>2]+4>>2]){if(o[o[a+12>>2]+(o[c>>2]<<2)>>2]==o[o[c+8>>2]>>2]){o[c+4>>2]=o[c>>2];}else {o[c>>2]=o[c>>2]+1;continue}}break}K=c+16|0;return o[c+4>>2]}function Yb(a,b,c){var d=0,e=0,f=0,g=0,h=0;d=K-32|0;K=d;o[d+28>>2]=b;o[d+24>>2]=c;f=o[d+24>>2];b=K-16|0;c=o[d+28>>2];o[b+12>>2]=c;o[b+8>>2]=0;g=o[b+12>>2]+(o[b+8>>2]<<4)|0;b=K-16|0;o[b+12>>2]=c;o[b+8>>2]=1;h=o[b+12>>2]+(o[b+8>>2]<<4)|0;b=K-16|0;o[b+12>>2]=c;o[b+8>>2]=2;e=d+8|0;dp(e,f,g,h,o[b+12>>2]+(o[b+8>>2]<<4)|0);mg(a,e,c+48|0);K=d+32|0;}function Zu(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-48|0;K=e;o[e+44>>2]=d;o[e+40>>2]=16200;d=o[b+12>>2];o[e+16>>2]=o[b+8>>2];o[e+20>>2]=d;d=o[b+4>>2];o[e+8>>2]=o[b>>2];o[e+12>>2]=d;b=o[c+12>>2];o[e+32>>2]=o[c+8>>2];o[e+36>>2]=b;b=o[c+4>>2];o[e+24>>2]=o[c>>2];o[e+28>>2]=b;nb(o[a+4>>2],e+8|0,e+40|0);nb(o[a+44>>2],e+8|0,e+40|0);K=e+48|0;}function Dd(a,b,c,d){m[a+53|0]=1;a:{if(o[a+4>>2]!=(c|0)){break a}m[a+52|0]=1;c=o[a+16>>2];if(!c){o[a+36>>2]=1;o[a+24>>2]=d;o[a+16>>2]=b;if((d|0)!=1|o[a+48>>2]!=1){break a}m[a+54|0]=1;return}if((b|0)==(c|0)){c=o[a+24>>2];if((c|0)==2){o[a+24>>2]=d;c=d;}if(o[a+48>>2]!=1|(c|0)!=1){break a}m[a+54|0]=1;return}m[a+54|0]=1;o[a+36>>2]=o[a+36>>2]+1;}}function $l(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;a=K-16|0;K=a;c=o[b+844>>2];if((c|0)>=1){while(1){c=u(d,208)+b|0;e=o[c+120>>2];a:{if(!e){break a}f=o[5379];if(!f){break a}l[f](e)|0;o[c+120>>2]=0;}d=d+1|0;c=o[b+844>>2];if((d|0)<(c|0)){continue}break}}b:{if(!c){break b}c=o[5382];if(!c){break b}o[a+12>>2]=b;l[c](a+12|0);}o[b+844>>2]=0;K=a+16|0;}function Aw(a,b){a=a|0;b=b|0;var c=v(0),d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0),j=v(0),k=v(0);c=s[a+20>>2];d=s[a+36>>2];e=s[a+24>>2];f=s[a+40>>2];g=s[a+16>>2];h=s[a+32>>2];xb(a,b);i=s[b>>2];j=s[b+4>>2];k=s[b+8>>2];o[a+44>>2]=0;s[a+40>>2]=k*v(f/e);s[a+36>>2]=j*v(d/c);s[a+32>>2]=i*v(h/g);o[a+48>>2]=o[(a+32|0)+((o[a+56>>2]+2|0)%3<<2)>>2];}function mk(a){a=a|0;var b=0,c=0,d=0,e=0,f=0;d=K-16|0;K=d;l[o[4966]](7783);b=o[a+8>>2];if((b|0)>=1){while(1){e=o[o[a+16>>2]+(c<<2)>>2];a:{b:{if(p[a+76|0]){break b}f=o[e+220>>2]+ -2|0;if(f>>>0>3){break b}switch(f-1|0){case 0:case 1:break b;default:break a}}nk(a,e);b=o[a+8>>2];}c=c+1|0;if((c|0)<(b|0)){continue}break}}l[o[4967]]();K=d+16|0;}function Wc(a,b,c,d,e){var f=v(0);o[a+32>>2]=c;o[a+28>>2]=b;o[a+24>>2]=d;o[a+20>>2]=e;o[a+4>>2]=0;o[a+8>>2]=1065353216;o[a>>2]=4416;o[a+12>>2]=0;o[a+16>>2]=0;o[a+36>>2]=o[b+4>>2];o[a+40>>2]=o[c+4>>2];s[a+44>>2]=l[o[o[b>>2]+48>>2]](b);f=v(l[o[o[c>>2]+48>>2]](c));o[a+72>>2]=1;o[a+76>>2]=1;o[a+60>>2]=-1;m[a+52|0]=0;s[a+48>>2]=f;return a}function kl(a){a=a|0;var b=0;o[a>>2]=6072;b=o[a+56>>2];if(b){if(p[a+60|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+56>>2]=0;}o[a+56>>2]=0;o[a+48>>2]=0;o[a+52>>2]=0;m[a+60|0]=1;b=o[a+36>>2];if(b){if(p[a+40|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+36>>2]=0;}o[a+36>>2]=0;o[a+28>>2]=0;o[a+32>>2]=0;m[a+40|0]=1;Ae(a+4|0);return a|0}function Zl(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0;f=K-16|0;K=f;o[f+12>>2]=d;o[f+8>>2]=a;d=o[o[c+4>>2]+4>>2];g=o[o[b+4>>2]+4>>2];a:{if((e|0)==1){a=o[((u(g,144)+a|0)+(d<<2)|0)+76>>2];a=l[o[o[a>>2]+8>>2]](a,f+8|0,b,c)|0;break a}a=o[((u(g,144)+a|0)+(d<<2)|0)+5260>>2];a=l[o[o[a>>2]+8>>2]](a,f+8|0,b,c)|0;}K=f+16|0;return a|0}function cu(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=K+ -64|0;K=d;e=1;a:{if(pa(a,b,0)){break a}e=0;if(!b){break a}b=bu(b);e=0;if(!b){break a}o[d+20>>2]=-1;o[d+16>>2]=a;o[d+12>>2]=0;o[d+8>>2]=b;$(d+24|0,0,39);o[d+56>>2]=1;l[o[o[b>>2]+28>>2]](b,d+8|0,o[c>>2],1);e=0;if(o[d+32>>2]!=1){break a}o[c>>2]=o[d+24>>2];e=1;}K=d- -64|0;return e|0}function Gm(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0);c=c+1|0;a:{if(c>>>0>6){break a}b:{switch(c-1|0){case 0:case 1:case 2:case 3:case 4:break a;default:break b}}b=b+ -1|0;if(b>>>0>3){break a}c:{switch(b-1|0){case 0:return v(s[a+764>>2]);case 2:return v(s[a+760>>2]);case 1:return v(s[a+752>>2]);default:break c}}d=s[a+756>>2];}return v(d)}function nn(a,b){var c=v(0);c=s[a+24>>2];if(!!(c<v(1))){if(!!(c>v(-1))){s[b>>2]=hb(v(y(v(z(c,v(-1))),v(1))));s[b+4>>2]=ba(v(-s[a+8>>2]),s[a+40>>2]);s[b+8>>2]=ba(v(-s[a+16>>2]),s[a+20>>2]);return}o[b>>2]=-1077342245;o[b+4>>2]=0;s[b+8>>2]=-ba(s[a+32>>2],s[a>>2]);return}o[b>>2]=1070141403;o[b+4>>2]=0;s[b+8>>2]=ba(s[a+32>>2],s[a>>2]);}function Mc(a,b,c,d,e){o[a>>2]=16448;o[a+4>>2]=o[b>>2];o[a>>2]=4944;m[a+24|0]=1;o[a>>2]=10404;o[a+20>>2]=0;m[a+44|0]=1;o[a+12>>2]=0;o[a+16>>2]=0;o[a+40>>2]=0;m[a- -64|0]=1;o[a+32>>2]=0;o[a+36>>2]=0;o[a+60>>2]=0;m[a+68|0]=e;o[a+52>>2]=0;o[a+56>>2]=0;b=o[b+4>>2];m[a+76|0]=0;o[a+72>>2]=b;o[a+80>>2]=o[o[(e?d:c)+4>>2]+72>>2];ye(a,c,d);}function dc(a,b,c){var d=0;d=K-32|0;K=d;o[d+28>>2]=b;o[d+24>>2]=c;b=o[d+28>>2];s[d+20>>2]=v(s[b+4>>2]*s[o[d+24>>2]+8>>2])-v(s[b+8>>2]*s[o[d+24>>2]+4>>2]);s[d+16>>2]=v(s[b+8>>2]*s[o[d+24>>2]>>2])-v(s[b>>2]*s[o[d+24>>2]+8>>2]);s[d+12>>2]=v(s[b>>2]*s[o[d+24>>2]+4>>2])-v(s[b+4>>2]*s[o[d+24>>2]>>2]);Z(a,d+20|0,d+16|0,d+12|0);K=d+32|0;}function Zh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-48|0;K=e;o[e+12>>2]=b;o[e+8>>2]=12276;b=o[c+12>>2];o[e+24>>2]=o[c+8>>2];o[e+28>>2]=b;b=o[c+4>>2];o[e+16>>2]=o[c>>2];o[e+20>>2]=b;b=o[d+12>>2];o[e+40>>2]=o[d+8>>2];o[e+44>>2]=b;b=o[d+4>>2];o[e+32>>2]=o[d>>2];o[e+36>>2]=b;a=o[a+52>>2];l[o[o[a>>2]+8>>2]](a,e+8|0,c,d);K=e+48|0;}function Pr(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0;f=K-32|0;K=f;o[f+28>>2]=a;o[f+24>>2]=b;o[f+20>>2]=c;o[f+16>>2]=d;o[f+12>>2]=e;a=o[f+28>>2];Bf(a,o[f+24>>2],o[f+20>>2],o[f+16>>2]);o[a>>2]=1032;Gr(a+344|0);db(a+348|0);m[a+368|0]=0;s[a+56>>2]=.009999999776482582;b=qr(a);l[o[o[b>>2]+44>>2]](b,a+344|0);K=f+32|0;return a|0}function jl(a){a=a|0;var b=0;o[a>>2]=6072;b=o[a+56>>2];if(b){if(p[a+60|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+56>>2]=0;}o[a+56>>2]=0;o[a+48>>2]=0;o[a+52>>2]=0;m[a+60|0]=1;b=o[a+36>>2];if(b){if(p[a+40|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+36>>2]=0;}o[a+36>>2]=0;o[a+28>>2]=0;o[a+32>>2]=0;m[a+40|0]=1;Ae(a+4|0);aa(a);}function Uo(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=K-16|0;a=o[c+12>>2];o[b+12>>2]=a;if(o[o[b+12>>2]+8>>2]<o[c+8>>2]){o[c+4>>2]=So(a,o[c+8>>2]);b=K-16|0;o[b+12>>2]=a;Qo(a,o[o[b+12>>2]+4>>2],o[c+4>>2]);b=K-16|0;o[b+12>>2]=a;kc(a,o[o[b+12>>2]+4>>2]);jc(a);m[a+16|0]=1;o[a+12>>2]=o[c+4>>2];o[a+8>>2]=o[c+8>>2];}K=c+16|0;}function To(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=K-16|0;a=o[c+12>>2];o[b+12>>2]=a;if(o[o[b+12>>2]+8>>2]<o[c+8>>2]){o[c+4>>2]=Of(a,o[c+8>>2]);b=K-16|0;o[b+12>>2]=a;Oo(a,o[o[b+12>>2]+4>>2],o[c+4>>2]);b=K-16|0;o[b+12>>2]=a;kc(a,o[o[b+12>>2]+4>>2]);jc(a);m[a+16|0]=1;o[a+12>>2]=o[c+4>>2];o[a+8>>2]=o[c+8>>2];}K=c+16|0;}function Ng(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=K-16|0;a=o[c+12>>2];o[b+12>>2]=a;if(o[o[b+12>>2]+8>>2]<o[c+8>>2]){o[c+4>>2]=Of(a,o[c+8>>2]);b=K-16|0;o[b+12>>2]=a;gp(a,o[o[b+12>>2]+4>>2],o[c+4>>2]);b=K-16|0;o[b+12>>2]=a;kc(a,o[o[b+12>>2]+4>>2]);jc(a);m[a+16|0]=1;o[a+12>>2]=o[c+4>>2];o[a+8>>2]=o[c+8>>2];}K=c+16|0;}function pn(a,b){var c=v(0);c=s[a+36>>2];a:{if(!!(c<v(1))){if(!!(c>v(-1))){s[b>>2]=hb(v(y(v(z(v(-c),v(-1))),v(1))));s[b+4>>2]=ba(s[a+32>>2],s[a+40>>2]);s[b+8>>2]=ba(s[a+4>>2],s[a+20>>2]);return}o[b>>2]=1070141403;s[b+4>>2]=-ba(v(-s[a+16>>2]),s[a>>2]);break a}o[b>>2]=-1077342245;s[b+4>>2]=ba(v(-s[a+16>>2]),s[a>>2]);}s[b+8>>2]=0;}function cb(a,b,c,d,e,f,g,h,i,j){var k=0;k=K-48|0;K=k;o[k+44>>2]=a;o[k+40>>2]=b;o[k+36>>2]=c;o[k+32>>2]=d;o[k+28>>2]=e;o[k+24>>2]=f;o[k+20>>2]=g;o[k+16>>2]=h;o[k+12>>2]=i;o[k+8>>2]=j;a=o[k+44>>2];Z(a,o[k+40>>2],o[k+36>>2],o[k+32>>2]);Z(a+16|0,o[k+28>>2],o[k+24>>2],o[k+20>>2]);Z(a+32|0,o[k+16>>2],o[k+12>>2],o[k+8>>2]);K=k+48|0;}function cn(a,b,c,d,e){dd(a,3,b,c);o[a>>2]=3360;b=o[d+4>>2];o[a+300>>2]=o[d>>2];o[a+304>>2]=b;b=o[d+12>>2];o[a+308>>2]=o[d+8>>2];o[a+312>>2]=b;b=o[e+4>>2];o[a+316>>2]=o[e>>2];o[a+320>>2]=b;b=o[e+12>>2];o[a+324>>2]=o[e+8>>2];o[a+328>>2]=b;o[a+356>>2]=0;o[a+348>>2]=1050253722;o[a+352>>2]=1065353216;m[a+344|0]=0;o[a+332>>2]=0;}function Vj(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=K-32|0;K=c;d=o[a+216>>2];a:{if(s[d+4>>2]==v(0)){break a}e=1;b=o[b>>2];if(!l[o[o[d>>2]+8>>2]](d,o[b+188>>2])){break a}d=o[a+216>>2];f=o[b+192>>2];o[c+24>>2]=-1;o[c+28>>2]=-1;o[c+20>>2]=b+4;o[c+16>>2]=b;o[c+12>>2]=f;o[c+8>>2]=0;Db(a+68|0,a+132|0,c+8|0,d);}K=c+32|0;return e|0}function Dq(a,b){var c=0,d=0;c=K-32|0;K=c;o[c+28>>2]=a;o[c+24>>2]=b;a=o[c+24>>2];d=o[a+4>>2];b=o[c+28>>2];o[b+408>>2]=o[a>>2];o[b+412>>2]=d;d=o[a+12>>2];o[b+416>>2]=o[a+8>>2];o[b+420>>2]=d;a=c+8|0;md(a,b+408|0,b+404|0);d=o[a+4>>2];o[b+620>>2]=o[a>>2];o[b+624>>2]=d;d=o[a+12>>2];o[b+628>>2]=o[a+8>>2];o[b+632>>2]=d;K=c+32|0;}function Tu(a,b){a=a|0;if(o[a+16>>2]==(0-o[a+56>>2]|0)){Wg(a+4|0);Wg(a+44|0);m[a+153|0]=256;m[a+154|0]=1;o[a+124>>2]=0;o[a+104>>2]=0;o[a+116>>2]=10;o[a+120>>2]=1;o[a+108>>2]=1;o[a+112>>2]=0;o[a+84>>2]=0;o[a+88>>2]=0;o[a+92>>2]=0;o[a+128>>2]=0;o[a+132>>2]=0;o[a+136>>2]=0;o[a+140>>2]=0;o[a+144>>2]=0;o[a+148>>2]=0;}}function Un(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=o[a+228>>2];a:{if((c|0)<1){break a}e=o[a+236>>2];while(1){f=(d<<2)+e|0;if(o[f>>2]!=(b|0)){d=d+1|0;if((c|0)!=(d|0)){continue}break a}break}if((c|0)<=(d|0)){break a}c=c+ -1|0;d=c<<2;o[f>>2]=o[d+e>>2];o[d+o[a+236>>2]>>2]=b;o[a+228>>2]=c;}Cf(o[b+28>>2],b);Cf(o[b+32>>2],b);}function Zo(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+8>>2]=a;o[c+4>>2]=b;a=o[c+8>>2];a:{if(o[o[c+4>>2]+4>>2]&o[a+16>>2]){if(!(!o[o[c+4>>2]>>2]|m[a+156|0]&1)){o[c>>2]=o[o[c+4>>2]>>2];a=K-16|0;o[a+12>>2]=o[c>>2];m[c+15|0]=!(o[o[a+12>>2]+204>>2]&4);break a}m[c+15|0]=1;break a}m[c+15|0]=0;}K=c+16|0;return m[c+15|0]&1}function Xf(a,b){var c=0,d=0;c=K-32|0;K=c;o[c+28>>2]=a;s[c+24>>2]=b;a=o[c+28>>2];sa(a);o[a>>2]=11388;o[a+4>>2]=8;s[c+20>>2]=1;s[c+16>>2]=1;s[c+12>>2]=1;Z(a+16|0,c+20|0,c+16|0,c+12|0);od(a+32|0);b=s[c+24>>2];d=K-16|0;o[d+12>>2]=a+32;s[d+8>>2]=b;s[o[d+12>>2]>>2]=s[d+8>>2];s[a+48>>2]=s[c+24>>2];s[a+52>>2]=0;K=c+32|0;}function xw(a,b,c){a=a|0;b=b|0;c=c|0;Na(a,b,c);o[b+28>>2]=o[a+32>>2];o[b+32>>2]=o[a+36>>2];o[b+36>>2]=o[a+40>>2];o[b+40>>2]=o[a+44>>2];o[b+12>>2]=o[a+16>>2];o[b+16>>2]=o[a+20>>2];o[b+20>>2]=o[a+24>>2];o[b+24>>2]=o[a+28>>2];c=o[a+48>>2];o[b+48>>2]=0;o[b+44>>2]=c;a=o[a+56>>2];o[b+56>>2]=0;o[b+52>>2]=a;return 13625}function av(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;vc(o[b+60>>2]==2?a+44|0:a+4|0,o[b+48>>2]);e=o[b+56>>2];d=o[b+52>>2];a:{if(d){d=d+56|0;break a}d=((o[b+60>>2]<<2)+a|0)+84|0;}o[d>>2]=e;d=o[b+56>>2];if(d){o[d+52>>2]=o[b+52>>2];}d=o[a+96>>2];l[o[o[d>>2]+16>>2]](d,b,c);if(b){o[6258]=o[6258]+1;l[o[4969]](b);}m[a+154|0]=1;}function No(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+8>>2]=a;o[c+4>>2]=b;a=o[c+8>>2];a:{if(o[o[c+4>>2]+4>>2]&o[a+16>>2]){if(!(!o[o[c+4>>2]>>2]|m[a+92|0]&1)){o[c>>2]=o[o[c+4>>2]>>2];a=K-16|0;o[a+12>>2]=o[c>>2];m[c+15|0]=!(o[o[a+12>>2]+204>>2]&4);break a}m[c+15|0]=1;break a}m[c+15|0]=0;}K=c+16|0;return m[c+15|0]&1}function Kv(a,b,c){a=a|0;b=b|0;c=c|0;Na(a,b,c);o[b+28>>2]=o[a+32>>2];o[b+32>>2]=o[a+36>>2];o[b+36>>2]=o[a+40>>2];o[b+40>>2]=o[a+44>>2];o[b+12>>2]=o[a+16>>2];o[b+16>>2]=o[a+20>>2];o[b+20>>2]=o[a+24>>2];o[b+24>>2]=o[a+28>>2];c=o[a+48>>2];o[b+48>>2]=0;o[b+44>>2]=c;a=o[a+56>>2];o[b+56>>2]=0;o[b+52>>2]=a;return 14946}function Ai(a,b,c){a=a|0;b=b|0;c=c|0;Na(a,b,c);o[b+28>>2]=o[a+32>>2];o[b+32>>2]=o[a+36>>2];o[b+36>>2]=o[a+40>>2];o[b+40>>2]=o[a+44>>2];o[b+12>>2]=o[a+16>>2];o[b+16>>2]=o[a+20>>2];o[b+20>>2]=o[a+24>>2];o[b+24>>2]=o[a+28>>2];c=o[a+48>>2];o[b+48>>2]=0;o[b+44>>2]=c;a=o[a+72>>2];o[b+56>>2]=0;o[b+52>>2]=a;return 11313}function kk(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0;c=K-16|0;K=c;l[o[4966]](7821);l[o[o[a>>2]+8>>2]](a);l[o[o[a>>2]+12>>2]](a);b=o[a+24>>2];l[o[4966]](7855);if(b){d=o[a+68>>2];f=b,g=l[o[o[d>>2]+36>>2]](d)|0,h=a+28|0,i=o[a+24>>2],e=o[o[b>>2]+32>>2],l[e](f|0,g|0,h|0,i|0);}l[o[4967]]();l[o[4967]]();K=c+16|0;}function Ei(a,b){a=a|0;b=b|0;var c=v(0),d=0,e=0,f=v(0);e=o[a+72>>2]<<2;c=s[e+b>>2];d=e;e=a+16|0;f=v(s[a+64>>2]*v(c/s[d+e>>2]));s[a+64>>2]=f;d=o[a+68>>2]<<2;c=v(s[d+b>>2]/s[e+d>>2]);d=o[a+76>>2]<<2;c=v(s[a+60>>2]*v(v(c+v(s[d+b>>2]/s[e+d>>2]))*v(.5)));s[a+60>>2]=c;s[a+56>>2]=c/v(C(v(v(f*f)+v(c*c))));xb(a,b);}function Kr(){var a=0;a=K-48|0;K=a;a:{if(m[20816]&1){break a}if(!Fa(20816)){break a}s[a+44>>2]=1;s[a+40>>2]=0;s[a+36>>2]=0;s[a+32>>2]=0;s[a+28>>2]=1;s[a+24>>2]=0;s[a+20>>2]=0;s[a+16>>2]=0;s[a+12>>2]=1;ac(20768,a+44|0,a+40|0,a+36|0,a+32|0,a+28|0,a+24|0,a+20|0,a+16|0,a+12|0);Ea(20816);}K=a+48|0;return 20768}function mv(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;f=K-16|0;K=f;l[o[4966]](15436);if(o[a+8>>2]>=1){while(1){e=o[a+16>>2]+(d<<4)|0;a:{if(l[o[o[b>>2]+8>>2]](b,e)){l[o[o[a>>2]+12>>2]](a,o[e>>2],o[e+4>>2],c)|0;o[5673]=o[5673]+ -1;break a}d=d+1|0;}if((d|0)<o[a+8>>2]){continue}break}}l[o[4967]]();K=f+16|0;}function pk(){var a=0,b=0;a=K+ -64|0;K=a;a:{if(m[20696]&1){break a}if(!Fa(20696)){break a}s[a+44>>2]=0;s[a+40>>2]=0;s[a+36>>2]=0;b=a+48|0;Z(b,a+44|0,a+40|0,a+36|0);Ff(20020,b);Ea(20696);}s[a+12>>2]=0;s[a+8>>2]=0;s[a+4>>2]=0;b=a+16|0;Z(b,a+12|0,a+8|0,a+4|0);id(20020,v(0),b);K=a- -64|0;return 20020}function Se(a,b,c,d,e){var f=0;o[a>>2]=16448;o[a+4>>2]=o[b>>2];o[a>>2]=4944;o[a>>2]=6336;b=o[b>>2];o[a+60>>2]=0;o[a+56>>2]=b;o[a+8>>2]=6364;f=e?c:d;o[a+48>>2]=f;c=e?d:c;o[a+44>>2]=c;b=l[o[o[b>>2]+12>>2]](b,o[c+8>>2],o[f+8>>2])|0;o[a+72>>2]=b;c=o[a+56>>2];l[o[o[c>>2]+20>>2]](c,b);m[a+76|0]=e;}



            function qk(a,b,c){o[a>>2]=7540;m[a+76|0]=1;o[a+72>>2]=0;o[a+68>>2]=c;o[a+28>>2]=0;o[a+32>>2]=0;o[a+24>>2]=b;m[a+20|0]=1;o[a+16>>2]=0;o[a- -64>>2]=0;m[a+60|0]=0;o[a+56>>2]=1025758986;m[a+54|0]=1;n[a+52>>1]=256;o[a+48>>2]=0;m[a+44|0]=1;o[a+36>>2]=1;o[a+40>>2]=1065353216;o[a+8>>2]=0;o[a+12>>2]=0;}function hi(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;c=o[a+56>>2];if(c){c=(f=b,g=l[o[o[c>>2]+12>>2]](c)|0,h=1,e=o[o[b>>2]+16>>2],l[e](f|0,g|0,h|0)|0);d=o[a+56>>2];h=b,g=c,f=l[o[o[d>>2]+16>>2]](d,o[c+8>>2],b)|0,i=1213612625,j=o[a+56>>2],e=o[o[b>>2]+20>>2],l[e](h|0,g|0,f|0,i|0,j|0);}}function gi(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;c=o[a+60>>2];if(c){c=(f=b,g=l[o[o[c>>2]+8>>2]](c)|0,h=1,e=o[o[b>>2]+16>>2],l[e](f|0,g|0,h|0)|0);d=o[a+60>>2];h=b,g=c,f=l[o[o[d>>2]+12>>2]](d,o[c+8>>2],b)|0,i=1346456916,j=o[a+60>>2],e=o[o[b>>2]+20>>2],l[e](h|0,g|0,f|0,i|0,j|0);}}function dl(a,b,c,d,e,f,g){o[a>>2]=16448;o[a+4>>2]=o[b>>2];o[a+24>>2]=g;o[a+20>>2]=f;m[a+16|0]=e;o[a+12>>2]=0;m[a+8|0]=0;o[a>>2]=6176;b=o[a+4>>2];f=e?d:c;c=e?c:d;if(l[o[o[b>>2]+24>>2]](b,o[f+8>>2],o[c+8>>2])){b=o[a+4>>2];b=l[o[o[b>>2]+12>>2]](b,o[f+8>>2],o[c+8>>2])|0;m[a+8|0]=1;o[a+12>>2]=b;}}function Zn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=o[a+248>>2];a:{if((c|0)<1){break a}e=o[a+256>>2];while(1){f=(d<<2)+e|0;if(o[f>>2]!=(b|0)){d=d+1|0;if((c|0)!=(d|0)){continue}break a}break}if((c|0)<=(d|0)){break a}c=c+ -1|0;d=c<<2;o[f>>2]=o[d+e>>2];o[d+o[a+256>>2]>>2]=b;o[a+248>>2]=c;}Rc(a,b);}function Nv(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0);d=s[b+36>>2];e=s[b+32>>2];f=s[c>>2];g=s[c+8>>2];h=v(C(v(v(f*f)+v(g*g))));a:{if(h!=v(0)){e=v(e/h);i=v(g*e);e=v(f*e);d=s[c+4>>2]<v(0)?v(-d):d;break a}d=s[c+4>>2]<v(0)?v(-d):d;}s[a+8>>2]=i;s[a+4>>2]=d;s[a>>2]=e;}function Sn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;a:{c=o[a+296>>2];if((c|0)<1){break a}e=o[a+304>>2];while(1){f=(d<<2)+e|0;if(o[f>>2]!=(b|0)){d=d+1|0;if((c|0)!=(d|0)){continue}break a}break}if((c|0)<=(d|0)){break a}c=c+ -1|0;d=c<<2;o[f>>2]=o[d+e>>2];o[d+o[a+304>>2]>>2]=b;o[a+296>>2]=c;}}function iu(a){a=a|0;var b=0;b=K-32|0;K=b;o[b+28>>2]=a;a:{if(m[19908]&1){break a}if(!Fa(19908)){break a}o[(K-16|0)+12>>2]=19892;Ea(19908);}a=o[b+28>>2];l[o[o[a>>2]+76>>2]](b+8|0,a);a=o[b+12>>2];o[4973]=o[b+8>>2];o[4974]=a;a=o[b+20>>2];o[4975]=o[b+16>>2];o[4976]=a;K=b+32|0;return 19892}function Op(a){a=a|0;var b=0;b=K-32|0;K=b;o[b+28>>2]=a;a:{if(m[19928]&1){break a}if(!Fa(19928)){break a}o[(K-16|0)+12>>2]=19912;Ea(19928);}a=o[b+28>>2];l[o[o[a>>2]+76>>2]](b+8|0,a);a=o[b+12>>2];o[4978]=o[b+8>>2];o[4979]=a;a=o[b+20>>2];o[4980]=o[b+16>>2];o[4981]=a;K=b+32|0;return 19912}function Zb(a,b){var c=v(0),d=0,e=v(0),f=v(0),g=v(0);c=s[a+404>>2];if(c!=v(0)){e=s[b>>2];f=s[b+4>>2];g=s[b+8>>2];o[a+436>>2]=0;c=v(v(1)/c);s[a+432>>2]=g*c;s[a+428>>2]=c*f;s[a+424>>2]=c*e;}d=o[b+4>>2];o[a+440>>2]=o[b>>2];o[a+444>>2]=d;d=o[b+12>>2];o[a+448>>2]=o[b+8>>2];o[a+452>>2]=d;}function tk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=v(d);var e=0;if(!!(s[a+36>>2]>d)){m[a+40|0]=1;e=o[b+4>>2];o[a+4>>2]=o[b>>2];o[a+8>>2]=e;e=o[b+12>>2];o[a+12>>2]=o[b+8>>2];o[a+16>>2]=e;b=o[c+4>>2];o[a+20>>2]=o[c>>2];o[a+24>>2]=b;b=o[c+12>>2];o[a+28>>2]=o[c+8>>2];o[a+32>>2]=b;s[a+36>>2]=d;}}function hl(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;f=o[b+8>>2];a:{if((f|0)<1){c=0;break a}g=o[b+16>>2];c=0;while(1){d=o[(e<<2)+g>>2];if(!(p[d+204|0]&3)){o[d+208>>2]=c;c=c+1|0;}o[d+268>>2]=1065353216;o[d+212>>2]=-1;e=e+1|0;if((f|0)!=(e|0)){continue}break}}wj(a+4|0,c);il(a,b);}function Nh(a,b,c){a=a|0;b=b|0;c=c|0;Na(a,b,c);o[b+12>>2]=o[a+72>>2];o[b+16>>2]=o[a+76>>2];o[b+20>>2]=o[a+80>>2];o[b+24>>2]=o[a+84>>2];o[b+28>>2]=o[a+52>>2];o[b+32>>2]=o[a+56>>2];o[b+36>>2]=o[a+60>>2];o[b+40>>2]=o[a- -64>>2];a=o[a+68>>2];o[b+48>>2]=0;o[b+44>>2]=a;return 12600}function lm(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;j=K-16|0;K=j;l[o[4966]](3871);v(l[o[o[a>>2]+44>>2]](a,b,c,d,e,f,g,h,i));v(l[o[o[a>>2]+48>>2]](a,b,c,d,e,f,g,h,i));v(l[o[o[a>>2]+36>>2]](a,b,c,h));l[o[4967]]();K=j+16|0;return v(v(0))}function bp(a,b){var c=0,d=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];d=K-16|0;a=o[c+12>>2];o[d+12>>2]=a;if((b|0)<o[o[d+12>>2]+4>>2]){b=o[c+8>>2];d=K-16|0;o[d+12>>2]=a;ap(a,b,o[o[d+12>>2]+4>>2]-1|0);b=K-16|0;o[b+12>>2]=a;a=o[b+12>>2];o[a+4>>2]=o[a+4>>2]+ -1;}K=c+16|0;}function Nk(a,b,c){a=a|0;b=b|0;c=c|0;Na(a,b,c);o[b+28>>2]=o[a+32>>2];o[b+32>>2]=o[a+36>>2];o[b+36>>2]=o[a+40>>2];o[b+40>>2]=o[a+44>>2];o[b+12>>2]=o[a+16>>2];o[b+16>>2]=o[a+20>>2];o[b+20>>2]=o[a+24>>2];o[b+24>>2]=o[a+28>>2];a=o[a+48>>2];o[b+48>>2]=0;o[b+44>>2]=a;return 6737}function sr(a,b,c){var d=0,e=0,f=0;d=K-48|0;K=d;o[d+44>>2]=b;o[d+40>>2]=c;b=d+24|0;Fo(b,o[d+44>>2],o[d+40>>2]);c=d+8|0;Eo(c,o[d+44>>2]);Do(b,c);c=K-16|0;o[c+12>>2]=b;c=o[c+12>>2];e=K-16|0;o[e+12>>2]=b;e=o[e+12>>2]+4|0;f=K-16|0;o[f+12>>2]=b;Z(a,c,e,o[f+12>>2]+8|0);K=d+48|0;}function Zj(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=v(0);e=K-16|0;K=e;d=o[a+24>>2];o[e+12>>2]=d;o[e+8>>2]=d;f=o[b+4>>2];a:{if(!f){o[b+4>>2]=e+8;break a}o[f+4>>2]=d;o[f>>2]=d;}d=o[a+20>>2];g=v(l[o[o[d>>2]+12>>2]](d,b,c));o[a+4>>2]=o[o[a+20>>2]+4>>2];K=e+16|0;return v(g)}function Wg(a){var b=0;b=o[a>>2];if(b){zc(a,b);}b=o[a+4>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}o[a+4>>2]=0;o[a+8>>2]=-1;b=o[a+32>>2];if(b){if(p[a+36|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+32>>2]=0;}o[a+32>>2]=0;o[a+24>>2]=0;o[a+28>>2]=0;o[a+16>>2]=0;m[a+36|0]=1;}function Mr(a,b,c,d,e,f,g){a=a|0;b=b|0;c=v(c);d=v(d);e=v(e);f=v(f);g=g|0;var h=0;h=K-32|0;K=h;o[h+28>>2]=a;o[h+24>>2]=b;s[h+20>>2]=c;s[h+16>>2]=d;s[h+12>>2]=e;s[h+8>>2]=f;o[h+4>>2]=g;ec(o[h+28>>2],o[h+24>>2],s[h+20>>2],s[h+16>>2],s[h+12>>2],s[h+8>>2],o[h+4>>2]);K=h+32|0;}function Md(a){var b=0;b=o[a>>2];if(b){zc(a,b);}b=o[a+4>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}o[a+4>>2]=0;o[a+8>>2]=-1;b=o[a+32>>2];if(b){if(p[a+36|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+32>>2]=0;}o[a+16>>2]=0;o[a+32>>2]=0;o[a+24>>2]=0;o[a+28>>2]=0;m[a+36|0]=1;}function ew(a,b,c){a=a|0;b=b|0;c=v(c);var d=v(0),e=v(0),f=0;d=s[b>>2];e=s[a+32>>2];a:{if(d<=v(e+c)^1|d>=v(v(-e)-c)^1){break a}d=s[b+4>>2];e=s[a+36>>2];if(d<=v(e+c)^1|d>=v(v(-e)-c)^1){break a}d=s[b+8>>2];e=s[a+40>>2];if(!(d<=v(e+c))){break a}f=d>=v(v(-e)-c);}return f|0}function Hl(a,b,c,d,e,f,g,h,i){o[a+72>>2]=1;o[a+76>>2]=1;o[a+60>>2]=-1;m[a+52|0]=0;s[a+48>>2]=g;s[a+44>>2]=f;o[a+40>>2]=e;o[a+36>>2]=d;o[a+32>>2]=c;o[a+28>>2]=b;o[a+24>>2]=h;o[a+20>>2]=i;o[a+4>>2]=0;o[a+8>>2]=1065353216;o[a>>2]=4416;o[a+12>>2]=0;o[a+16>>2]=0;return a}function Gi(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0;f=K-16|0;K=f;if((d|0)>=1){while(1){e=g<<4;Ic(f,a,e+b|0);h=o[f+12>>2];e=c+e|0;o[e+8>>2]=o[f+8>>2];o[e+12>>2]=h;h=o[f+4>>2];o[e>>2]=o[f>>2];o[e+4>>2]=h;g=g+1|0;if((g|0)!=(d|0)){continue}break}}K=f+16|0;}function ho(a){a=a|0;var b=0,c=0,d=0,e=0;b=o[a+248>>2];if((b|0)>=1){while(1){a:{b:{d=o[o[a+256>>2]+(c<<2)>>2];e=o[d+220>>2]+ -2|0;if(e>>>0>3){break b}switch(e-1|0){case 0:case 1:break b;default:break a}}Ef(d);b=o[a+248>>2];}c=c+1|0;if((c|0)<(b|0)){continue}break}}}function gp(a,b,c){var d=0;d=K-32|0;o[d+28>>2]=a;o[d+24>>2]=0;o[d+20>>2]=b;o[d+16>>2]=c;a=o[d+28>>2];o[d+12>>2]=o[d+24>>2];while(1){if(o[d+12>>2]<o[d+20>>2]){o[o[d+16>>2]+(o[d+12>>2]<<2)>>2]=o[o[a+12>>2]+(o[d+12>>2]<<2)>>2];o[d+12>>2]=o[d+12>>2]+1;continue}break}}function Wb(a,b,c,d,e){var f=v(0);f=v(1);a:{if(b>c){break a}f=v(0);if(b==c){break a}d=v(d/e);if(!!(d<v(0))){if(!(a>=b^1|v(b-d)>a^1)){return v(v(b-a)/d)}return a<b?v(0):v(1)}if(!(d>v(0))){break a}if(!(a<=c^1|v(c-d)<a^1)){return v(v(c-a)/d)}f=a>c?v(0):v(1);}return f}function Oo(a,b,c){var d=0;d=K-32|0;o[d+28>>2]=a;o[d+24>>2]=0;o[d+20>>2]=b;o[d+16>>2]=c;a=o[d+28>>2];o[d+12>>2]=o[d+24>>2];while(1){if(o[d+12>>2]<o[d+20>>2]){s[o[d+16>>2]+(o[d+12>>2]<<2)>>2]=s[o[a+12>>2]+(o[d+12>>2]<<2)>>2];o[d+12>>2]=o[d+12>>2]+1;continue}break}}function oh(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;a=o[a+32>>2]+(j<<5)|0;o[c>>2]=o[a+12>>2];o[b>>2]=o[a+16>>2];o[d>>2]=o[a+28>>2];o[e>>2]=o[a+20>>2];o[h>>2]=o[a>>2];o[f>>2]=o[a+4>>2];o[g>>2]=o[a+8>>2];o[i>>2]=o[a+24>>2];}function In(a,b){a=a|0;b=v(b);var c=0,d=0,e=0,f=0;f=K-16|0;K=f;l[o[4966]](2807);d=o[a+248>>2];if((d|0)>=1){while(1){c=o[o[a+256>>2]+(e<<2)>>2];if(!(p[c+204|0]&3)){wo(c,b);ub(c,b,c+68|0);d=o[a+248>>2];}e=e+1|0;if((e|0)<(d|0)){continue}break}}l[o[4967]]();K=f+16|0;}function wt(a,b,c){a=v(a);b=b|0;c=c|0;var d=0,e=0,f=0;d=K-48|0;K=d;s[d+44>>2]=a;o[d+40>>2]=b;o[d+36>>2]=c;b=qa(144);a=s[d+44>>2];c=o[d+40>>2];f=o[d+36>>2];s[d+12>>2]=0;s[d+8>>2]=0;s[d+4>>2]=0;e=d+16|0;Z(e,d+12|0,d+8|0,d+4|0);gg(b,a,c,f,e);K=d+48|0;return b|0}function _t(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;if(pa(a,o[b+8>>2],0)){Ed(b,c,d);return}e=o[a+12>>2];f=a+16|0;Lg(f,b,c,d);a:{if((e|0)<2){break a}e=(e<<3)+f|0;a=a+24|0;while(1){Lg(a,b,c,d);if(p[b+54|0]){break a}a=a+8|0;if(a>>>0<e>>>0){continue}break}}}function El(a,b,c,d){a=a|0;b=b|0;c=c|0;d=v(d);var e=0;e=o[b+4>>2];o[a+4>>2]=o[b>>2];o[a+8>>2]=e;e=o[b+12>>2];o[a+12>>2]=o[b+8>>2];o[a+16>>2]=e;b=o[c+4>>2];o[a+20>>2]=o[c>>2];o[a+24>>2]=b;b=o[c+12>>2];o[a+28>>2]=o[c+8>>2];o[a+32>>2]=b;m[a+40|0]=1;s[a+36>>2]=d;}function Qm(a,b,c,d,e,f){c=v(v(c-b)*v(.5));s[a+4>>2]=c;b=ua(v(c+b));a:{if(!!(b<v(-3.1415927410125732))){b=v(b+v(6.2831854820251465));break a}if(!(b>v(3.1415927410125732))){break a}b=v(b+v(-6.2831854820251465));}s[a+16>>2]=f;s[a+12>>2]=e;s[a+8>>2]=d;s[a>>2]=b;}function Le(a,b,c,d){var e=0;o[a>>2]=7408;e=o[b+4>>2];o[a+4>>2]=o[b>>2];o[a+8>>2]=e;e=o[b+12>>2];o[a+12>>2]=o[b+8>>2];o[a+16>>2]=e;b=o[c+4>>2];o[a+20>>2]=o[c>>2];o[a+24>>2]=b;b=o[c+12>>2];o[a+28>>2]=o[c+8>>2];o[a+32>>2]=b;o[a+40>>2]=1065353216;o[a+36>>2]=d;}function wn(a,b,c,d,e){sn(a,b,c,d,e);o[a>>2]=3128;b=a+1144|0;o[b>>2]=0;o[b+4>>2]=0;b=a+1056|0;o[b>>2]=0;o[b+4>>2]=0;o[a+968>>2]=0;o[a+972>>2]=0;o[a+680>>2]=0;o[a+684>>2]=0;o[a+688>>2]=0;o[a+692>>2]=0;o[a+696>>2]=0;o[a+700>>2]=0;o[a+704>>2]=0;o[a+708>>2]=0;}function Mb(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;h=K-32|0;K=h;o[h+28>>2]=a;o[h+24>>2]=b;o[h+20>>2]=c;o[h+16>>2]=d;o[h+12>>2]=e;o[h+8>>2]=f;o[h+4>>2]=g;jk(o[h+24>>2],o[h+20>>2],o[h+16>>2],o[h+12>>2],o[h+8>>2],o[h+4>>2]);K=h+32|0;}function dt(a){var b=0;b=K-48|0;K=b;o[b+44>>2]=a;a=o[b+44>>2];s[b+40>>2]=1;s[b+36>>2]=0;s[b+32>>2]=0;s[b+28>>2]=0;s[b+24>>2]=1;s[b+20>>2]=0;s[b+16>>2]=0;s[b+12>>2]=0;s[b+8>>2]=1;cb(a,b+40|0,b+36|0,b+32|0,b+28|0,b+24|0,b+20|0,b+16|0,b+12|0,b+8|0);K=b+48|0;}function Dp(a){a=a|0;var b=0,c=0;b=K-32|0;K=b;o[b+28>>2]=a;a:{if(m[19948]&1){break a}if(!Fa(19948)){break a}Ca(19932);Ea(19948);}a=b+8|0;Cp(a,o[b+28>>2]);c=o[a+4>>2];o[4983]=o[a>>2];o[4984]=c;c=o[a+12>>2];o[4985]=o[a+8>>2];o[4986]=c;K=b+32|0;return 19932}function $c(a,b){var c=0,d=0,e=0,f=0;c=o[a+844>>2];a:{if((c|0)==4){c=jm(a,b);d=u(c,208)+a|0;e=o[d+120>>2];if(!e){break a}f=o[5379];if(!f){break a}l[f](e)|0;o[d+120>>2]=0;break a}o[a+844>>2]=c+1;}d=a;a=(c|0)>0?c:0;ra((d+u(a,208)|0)+4|0,b,208);return a}function po(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0;c=(e=b,f=l[o[o[a>>2]+16>>2]](a)|0,g=1,d=o[o[b>>2]+16>>2],l[d](e|0,f|0,g|0)|0);g=b,f=c,e=l[o[o[a>>2]+20>>2]](a,o[c+8>>2],b)|0,h=1497645650,i=a,d=o[o[b>>2]+20>>2],l[d](g|0,f|0,e|0,h|0,i|0);}function gm(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0;c=(e=b,f=l[o[o[a>>2]+16>>2]](a)|0,g=1,d=o[o[b>>2]+16>>2],l[d](e|0,f|0,g|0)|0);g=b,f=c,e=l[o[o[a>>2]+20>>2]](a,o[c+8>>2],b)|0,h=1245859651,i=a,d=o[o[b>>2]+20>>2],l[d](g|0,f|0,e|0,h|0,i|0);}function Jw(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0;c=(e=b,f=l[o[o[a>>2]+52>>2]](a)|0,g=1,d=o[o[b>>2]+16>>2],l[d](e|0,f|0,g|0)|0);g=b,f=c,e=l[o[o[a>>2]+56>>2]](a,o[c+8>>2],b)|0,h=1346455635,i=a,d=o[o[b>>2]+20>>2],l[d](g|0,f|0,e|0,h|0,i|0);}function nd(a,b,c){var d=0;d=K-48|0;K=d;o[d+44>>2]=a;o[d+40>>2]=b;o[d+36>>2]=c;a=o[d+44>>2];if(s[a+404>>2]!=v(0)){vq(a,o[d+40>>2]);b=K-16|0;o[b+12>>2]=a+604;if(o[b+12>>2]){b=o[d+36>>2];Ta(d,o[d+40>>2],a+408|0);c=d+16|0;dc(c,b,d);Zf(a,c);}}K=d+48|0;}function io(a){a=a|0;var b=0,c=0;if(o[a+248>>2]>=1){while(1){b=o[o[a+256>>2]+(c<<2)>>2];o[b+472>>2]=0;o[b+476>>2]=0;o[b+496>>2]=0;o[b+500>>2]=0;o[b+488>>2]=0;o[b+492>>2]=0;o[b+480>>2]=0;o[b+484>>2]=0;c=c+1|0;if((c|0)<o[a+248>>2]){continue}break}}}function Nm(a,b){a=a|0;b=b|0;var c=v(0);if(p[a+738|0]){o[b>>2]=0;o[b+4>>2]=0;return}o[b>>2]=5;o[b+4>>2]=1;c=bd(a,o[a+28>>2]+4|0,o[a+32>>2]+4|0);s[a+728>>2]=c;pf(a+688|0,c);if(!(p[a+737|0]?0:!p[a+716|0])){o[b>>2]=o[b>>2]+1;o[b+4>>2]=o[b+4>>2]+ -1;}}function _u(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;c=K-16|0;K=c;o[c+8>>2]=16128;o[c+12>>2]=d;g=d+4|0;h=d+20|0;i=o[a+168>>2];eh(o[a+4>>2],b,g,h,s[d+32>>2],e,f,i,c+8|0);eh(o[a+44>>2],b,g,h,s[d+32>>2],e,f,i,c+8|0);K=c+16|0;}function Ak(a,b,c,d){o[a>>2]=16448;o[a+4>>2]=o[b>>2];o[a>>2]=4944;o[a+12>>2]=0;m[a+8|0]=0;o[a>>2]=7100;b=o[a+4>>2];if(l[o[o[b>>2]+24>>2]](b,o[c+8>>2],o[d+8>>2])){b=o[a+4>>2];b=l[o[o[b>>2]+12>>2]](b,o[c+8>>2],o[d+8>>2])|0;m[a+8|0]=1;o[a+12>>2]=b;}}function mw(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0),e=v(0),f=v(0),g=v(0),h=v(0),i=v(0);d=s[b+36>>2];e=s[b+40>>2];g=s[c+4>>2];h=s[c+8>>2];f=s[b+32>>2];i=s[c>>2];o[a+12>>2]=0;s[a>>2]=i>=v(0)?f:v(-f);s[a+8>>2]=h>=v(0)?e:v(-e);s[a+4>>2]=g>=v(0)?d:v(-d);}function Td(a){var b=0;sa(a);m[a+92|0]=0;o[a+88>>2]=0;o[a+80>>2]=-1082130432;o[a+84>>2]=-1082130432;o[a+72>>2]=0;o[a+76>>2]=-1082130432;b=a- -64|0;o[b>>2]=1065353216;o[b+4>>2]=1065353216;o[a>>2]=12764;o[a+56>>2]=0;o[a+60>>2]=1065353216;return a}function Pl(a){var b=0,c=0,d=0,e=0,f=v(0);b=K-128|0;K=b;o[b+124>>2]=a;a=o[b+124>>2];c=b+56|0;wb(c);ud(c);d=b+40|0;o[(K-16|0)+12>>2]=d;e=b+24|0;o[(K-16|0)+12>>2]=e;l[o[o[a>>2]+8>>2]](a,c,d,e);a=b+8|0;gc(a,e,d);f=zs(a);K=b+128|0;return v(f*v(.5))}function mg(a,b,c){var d=0;d=K-32|0;K=d;o[d+28>>2]=b;o[d+24>>2]=c;s[d+20>>2]=s[o[d+28>>2]>>2]+s[o[d+24>>2]>>2];s[d+16>>2]=s[o[d+28>>2]+4>>2]+s[o[d+24>>2]+4>>2];s[d+12>>2]=s[o[d+28>>2]+8>>2]+s[o[d+24>>2]+8>>2];Z(a,d+20|0,d+16|0,d+12|0);K=d+32|0;}function gc(a,b,c){var d=0;d=K-32|0;K=d;o[d+28>>2]=b;o[d+24>>2]=c;s[d+20>>2]=s[o[d+28>>2]>>2]-s[o[d+24>>2]>>2];s[d+16>>2]=s[o[d+28>>2]+4>>2]-s[o[d+24>>2]+4>>2];s[d+12>>2]=s[o[d+28>>2]+8>>2]-s[o[d+24>>2]+8>>2];Z(a,d+20|0,d+16|0,d+12|0);K=d+32|0;}function Ta(a,b,c){var d=0;d=K-32|0;K=d;o[d+28>>2]=b;o[d+24>>2]=c;s[d+20>>2]=s[o[d+28>>2]>>2]*s[o[d+24>>2]>>2];s[d+16>>2]=s[o[d+28>>2]+4>>2]*s[o[d+24>>2]+4>>2];s[d+12>>2]=s[o[d+28>>2]+8>>2]*s[o[d+24>>2]+8>>2];Z(a,d+20|0,d+16|0,d+12|0);K=d+32|0;}function Wm(a,b,c){a=a|0;b=b|0;c=c|0;Vb(a,b,c);o[b+52>>2]=o[a+300>>2];o[b+56>>2]=o[a+304>>2];o[b+60>>2]=o[a+308>>2];o[b+64>>2]=o[a+312>>2];o[b+68>>2]=o[a+316>>2];o[b+72>>2]=o[a+320>>2];o[b+76>>2]=o[a+324>>2];o[b+80>>2]=o[a+328>>2];return 3448}function Nr(a,b,c,d,e,f){a=a|0;b=b|0;c=v(c);d=v(d);e=v(e);f=v(f);var g=0;g=K-32|0;K=g;o[g+28>>2]=a;o[g+24>>2]=b;s[g+20>>2]=c;s[g+16>>2]=d;s[g+12>>2]=e;s[g+8>>2]=f;ec(o[g+28>>2],o[g+24>>2],s[g+20>>2],s[g+16>>2],s[g+12>>2],s[g+8>>2],2);K=g+32|0;}function Hp(a,b,c,d,e){var f=0;f=K-32|0;K=f;o[f+28>>2]=a;o[f+24>>2]=b;o[f+20>>2]=c;o[f+16>>2]=d;o[f+12>>2]=e;a=o[f+28>>2];Us(a,o[f+16>>2],o[f+12>>2]);o[a>>2]=1692;o[a+84>>2]=o[f+24>>2];o[a+88>>2]=o[f+20>>2];o[a+92>>2]=0;o[a+96>>2]=0;K=f+32|0;}function Dr(a,b,c,d,e,f){a=a|0;b=v(b);c=v(c);d=v(d);e=v(e);f=v(f);var g=0;g=K-32|0;K=g;o[g+28>>2]=a;s[g+24>>2]=b;s[g+20>>2]=c;s[g+16>>2]=d;s[g+12>>2]=e;s[g+8>>2]=f;dg(o[g+28>>2],s[g+24>>2],s[g+20>>2],s[g+16>>2],s[g+12>>2],s[g+8>>2]);K=g+32|0;}function Zq(a,b){var c=0,d=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;d=o[c+12>>2];o[a+12>>2]=d+32;s[a+8>>2]=b;s[o[a+12>>2]>>2]=s[a+8>>2];b=s[c+8>>2];a=K-16|0;o[a+12>>2]=d;s[a+8>>2]=b;s[o[a+12>>2]+48>>2]=s[a+8>>2];K=c+16|0;}function md(a,b,c){var d=0;d=K-32|0;K=d;o[d+28>>2]=b;o[d+24>>2]=c;s[d+20>>2]=s[o[d+28>>2]>>2]*s[o[d+24>>2]>>2];s[d+16>>2]=s[o[d+28>>2]+4>>2]*s[o[d+24>>2]>>2];s[d+12>>2]=s[o[d+28>>2]+8>>2]*s[o[d+24>>2]>>2];Z(a,d+20|0,d+16|0,d+12|0);K=d+32|0;}function Dv(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=o[b+4>>2];o[a+52>>2]=o[b>>2];o[a+56>>2]=d;d=o[b+12>>2];o[a+60>>2]=o[b+8>>2];o[a+64>>2]=d;b=o[c+4>>2];o[a+68>>2]=o[c>>2];o[a+72>>2]=b;b=o[c+12>>2];o[a+76>>2]=o[c+8>>2];o[a+80>>2]=b;o[a+48>>2]=1;}function Ul(a,b){a=a|0;b=b|0;var c=0;a:{if(!b){break a}a=o[a+68>>2];c=o[a+16>>2];if(c>>>0>b>>>0|u(o[a>>2],o[a+4>>2])+c>>>0<=b>>>0){break a}o[b>>2]=o[a+12>>2];o[a+12>>2]=b;o[a+8>>2]=o[a+8>>2]+1;return}if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}function Ym(a,b,c,d){a=a|0;b=b|0;c=v(c);d=d|0;a:{if((d|0)!=-1){break a}b=b+ -1|0;if(b>>>0>3){break a}b:{switch(b-2|0){default:s[a+336>>2]=c;o[a+332>>2]=o[a+332>>2]|1;return;case 0:case 1:break b}}s[a+340>>2]=c;o[a+332>>2]=o[a+332>>2]|2;}}function Fc(a){var b=0;a:{b=o[a+4>>2];if(b>>>0>13){break a}b:{switch(b-2|0){case 6:return v(s[a+32>>2]*s[a+16>>2]);case 0:case 1:case 4:case 5:case 7:case 10:break a;default:break b}}return s[a+48>>2]}return v(l[o[o[a>>2]+48>>2]](a))}function qd(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;b=K-16|0;a=o[d+12>>2];o[b+12>>2]=a;o[o[b+12>>2]>>2]=2220;o[a>>2]=2136;Bb(a+4|0,o[d+8>>2]);Bb(a+68|0,o[d+4>>2]);Bb(a+132|0,o[d+8>>2]);o[a+196>>2]=0;K=d+16|0;}function oo(a){a=a|0;var b=0;o[a>>2]=2244;b=o[a+556>>2];if(b){if(p[a+560|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+556>>2]=0;}o[a+556>>2]=0;o[a+548>>2]=0;o[a+552>>2]=0;m[a+560|0]=1;Rb(a);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function ap(a,b,c){var d=0;d=K-16|0;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];o[d>>2]=o[o[a+12>>2]+(o[d+8>>2]<<2)>>2];o[o[a+12>>2]+(o[d+8>>2]<<2)>>2]=o[o[a+12>>2]+(o[d+4>>2]<<2)>>2];o[o[a+12>>2]+(o[d+4>>2]<<2)>>2]=o[d>>2];}function Pb(a){m[a+356|0]=1;o[a>>2]=0;m[a+312|0]=0;o[a+292>>2]=1566444395;o[a+296>>2]=1566444395;o[a+336>>2]=0;o[a+340>>2]=0;o[a+300>>2]=1566444395;o[a+304>>2]=0;o[a+344>>2]=0;o[a+348>>2]=0;m[a+352|0]=0;m[a+332|0]=p[a+332|0]&240;}function Fr(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0;f=K-32|0;K=f;o[f+28>>2]=a;o[f+24>>2]=b;o[f+20>>2]=c;o[f+16>>2]=d;m[f+15|0]=e;a=_(768);nf(a,o[f+28>>2],o[f+24>>2],o[f+20>>2],o[f+16>>2],m[f+15|0]&1);K=f+32|0;return a|0}function ce(a,b,c,d){ai(a,b);m[a+65|0]=0;m[a+64|0]=c;o[a+56>>2]=0;o[a+60>>2]=0;o[a>>2]=11524;o[a+4>>2]=21;if(d){o[6257]=o[6257]+1;b=l[o[4968]](172,16)|0;c=sh(b);o[a+56>>2]=b;rh(c,o[a+52>>2],p[a+64|0],a+20|0,a+36|0);m[a+65|0]=1;}}function Wj(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=v(0);d=K-16|0;K=d;o[d+8>>2]=-1;o[d+12>>2]=o[a+20>>2];if(!o[b+4>>2]){o[b+4>>2]=d+8;}e=o[a+16>>2];f=v(l[o[o[e>>2]+12>>2]](e,b,c));o[a+4>>2]=o[o[a+16>>2]+4>>2];K=d+16|0;return v(f)}function Gu(a,b,c,d){var e=0;e=K-32|0;K=e;o[e+24>>2]=0;o[e+28>>2]=0;o[e+16>>2]=0;o[e+20>>2]=0;o[e+8>>2]=0;o[e+12>>2]=0;o[e>>2]=0;o[e+4>>2]=0;a:{if(p[a+60|0]){Zg(a,b,c,d,e+16|0,e,o[a+56>>2]);break a}_g(a,b,c,d,e+16|0,e);}K=e+32|0;}function ko(a,b){a=a|0;b=v(b);var c=0,d=0,e=0;d=o[a+8>>2];if((d|0)>=1){while(1){c=o[o[a+16>>2]+(e<<2)>>2];if(!(!c|!(o[c+252>>2]&2)|(!(p[c+204|0]&2)|o[c+220>>2]==2))){yo(c,b);d=o[a+8>>2];}e=e+1|0;if((e|0)<(d|0)){continue}break}}}function Xm(a,b,c){a=a|0;b=b|0;c=c|0;var d=v(0);d=v(3.4028234663852886e+38);a:{if((c|0)!=-1){break a}b=b+ -1|0;if(b>>>0>3){break a}b:{switch(b-2|0){default:return v(s[a+336>>2]);case 0:case 1:break b}}d=s[a+340>>2];}return v(d)}function Cv(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=o[a+56>>2];o[b>>2]=o[a+52>>2];o[b+4>>2]=d;d=o[a+64>>2];o[b+8>>2]=o[a+60>>2];o[b+12>>2]=d;b=o[a+80>>2];o[c+8>>2]=o[a+76>>2];o[c+12>>2]=b;b=o[a+72>>2];o[c>>2]=o[a+68>>2];o[c+4>>2]=b;}function $u(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=o[b+20>>2];o[c>>2]=o[b+16>>2];o[c+4>>2]=a;a=o[b+28>>2];o[c+8>>2]=o[b+24>>2];o[c+12>>2]=a;a=o[b+44>>2];o[d+8>>2]=o[b+40>>2];o[d+12>>2]=a;a=o[b+36>>2];o[d>>2]=o[b+32>>2];o[d+4>>2]=a;}function Tm(){var a=0;a=K-16|0;K=a;a:{if(m[21508]&1){break a}if(!Fa(21508)){break a}o[a+8>>2]=0;o[a+12>>2]=0;o[a>>2]=0;o[a+4>>2]=0;Ff(20832,a);Ea(21508);}o[a+8>>2]=0;o[a+12>>2]=0;o[a>>2]=0;o[a+4>>2]=0;id(20832,v(0),a);K=a+16|0;}function mc(a,b,c,d,e){var f=0;f=K-32|0;o[f+28>>2]=a;o[f+24>>2]=b;o[f+20>>2]=c;o[f+16>>2]=d;o[f+12>>2]=e;a=o[f+28>>2];s[a>>2]=s[o[f+24>>2]>>2];s[a+4>>2]=s[o[f+20>>2]>>2];s[a+8>>2]=s[o[f+16>>2]>>2];s[a+12>>2]=s[o[f+12>>2]>>2];}function hm(a){a=a|0;var b=0;o[a>>2]=3972;b=o[a+296>>2];if(b){if(p[a+300|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+296>>2]=0;}o[a+296>>2]=0;o[a+288>>2]=0;o[a+292>>2]=0;m[a+300|0]=1;if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function dp(a,b,c,d,e){var f=0;f=K-32|0;K=f;o[f+28>>2]=b;o[f+24>>2]=c;o[f+20>>2]=d;o[f+16>>2]=e;b=o[f+28>>2];s[f+12>>2]=Ga(b,o[f+24>>2]);s[f+8>>2]=Ga(b,o[f+20>>2]);s[f+4>>2]=Ga(b,o[f+16>>2]);Z(a,f+12|0,f+8|0,f+4|0);K=f+32|0;}function Ui(a,b){a=a|0;b=b|0;var c=0,d=0,e=0;o[a+72>>2]=o[a+72>>2]+1;c=o[a+20>>2];if((c|0)>=1){while(1){d=c+ -1|0;if(o[(o[a+28>>2]+u(d,80)|0)+64>>2]==(b|0)){ke(a,d);}e=(c|0)>1;c=d;if(e){continue}break}}l[o[o[a>>2]+68>>2]](a);}function jj(a,b,c,d){Mc(a,b,c,d,0);m[a+104|0]=1;o[a>>2]=10616;o[a+100>>2]=0;o[a+92>>2]=0;o[a+96>>2]=0;o[6257]=o[6257]+1;b=l[o[4968]](64,16)|0;pj(b);o[a+84>>2]=b;o[a+108>>2]=o[o[c+4>>2]+72>>2];o[a+112>>2]=o[o[d+4>>2]+72>>2];}function _e(a,b,c){var d=0;cf(a);d=o[a+248>>2];o[b>>2]=o[a+244>>2];o[b+4>>2]=d;d=o[a+256>>2];o[b+8>>2]=o[a+252>>2];o[b+12>>2]=d;b=o[a+272>>2];o[c+8>>2]=o[a+268>>2];o[c+12>>2]=b;b=o[a+264>>2];o[c>>2]=o[a+260>>2];o[c+4>>2]=b;}function Pw(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0;e=c>>>16|0;f=a>>>16|0;j=u(e,f);g=c&65535;h=a&65535;i=u(g,h);f=(i>>>16|0)+u(f,g)|0;e=(f&65535)+u(e,h)|0;a=(u(b,c)+j|0)+u(a,d)+(f>>>16)+(e>>>16)|0;b=i&65535|e<<16;L=a;return b}function Bt(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;m[d+7|0]=c;a=o[d+12>>2];o[a+16>>2]=o[d+8>>2];m[a+156|0]=m[d+7|0]&1;s[a+4>>2]=1;o[a+8>>2]=0;eb(a+136|0);eb(a+116|0);eb(a+24|0);eb(a+96|0);eb(a+76|0);K=d+16|0;}function zo(a,b,c){var d=0;d=K-16|0;s[d+8>>2]=c;s[d+12>>2]=b;o[d+4>>2]=0;o[d>>2]=1065353216;o[a+504>>2]=o[(b<v(0)?d+4|0:b>v(1)?d:d+12|0)>>2];o[d+4>>2]=0;o[d>>2]=1065353216;o[a+508>>2]=o[(c<v(0)?d+4|0:c>v(1)?d:d+8|0)>>2];}function kv(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;o[5675]=o[5675]+1;d=o[a+24>>2];a:{b:{if(d){if(l[o[o[d>>2]+8>>2]](d,b,c)){break b}break a}if(!(o[c+8>>2]&o[b+4>>2])|!(o[b+8>>2]&o[c+4>>2])){break a}}e=pv(a,b,c);}return e|0}function Kd(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;m[d+7|0]=c;a=o[d+12>>2];a:{if(m[d+7|0]&1){Ka(a+284|0,d+8|0);break a}tu(a+284|0,d+8|0);}b=K-16|0;o[b+12>>2]=a+284;o[a+280>>2]=o[o[b+12>>2]+4>>2]>0;K=d+16|0;}function fd(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];Cg(a,o[d+8>>2]);b=o[d+4>>2];c=o[b+4>>2];o[a+48>>2]=o[b>>2];o[a+52>>2]=c;c=o[b+12>>2];o[a+56>>2]=o[b+8>>2];o[a+60>>2]=c;K=d+16|0;}function Lp(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];Kp(a,o[d+8>>2]);b=o[d+4>>2];c=o[b+4>>2];o[a+48>>2]=o[b>>2];o[a+52>>2]=c;c=o[b+12>>2];o[a+56>>2]=o[b+8>>2];o[a+60>>2]=c;K=d+16|0;}function Fv(a){a=a|0;var b=0;o[a>>2]=15156;b=o[a+32>>2];if(b){if(p[a+36|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+32>>2]=0;}o[a+32>>2]=0;o[a+24>>2]=0;o[a+28>>2]=0;m[a+36|0]=1;if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function Or(a,b,c,d,e){a=a|0;b=b|0;c=v(c);d=v(d);e=v(e);var f=0;f=K-32|0;K=f;o[f+28>>2]=a;o[f+24>>2]=b;s[f+20>>2]=c;s[f+16>>2]=d;s[f+12>>2]=e;ec(o[f+28>>2],o[f+24>>2],s[f+20>>2],s[f+16>>2],s[f+12>>2],v(0),2);K=f+32|0;}function Er(a,b,c,d,e){a=a|0;b=v(b);c=v(c);d=v(d);e=v(e);var f=0;f=K-32|0;K=f;o[f+28>>2]=a;s[f+24>>2]=b;s[f+20>>2]=c;s[f+16>>2]=d;s[f+12>>2]=e;dg(o[f+28>>2],s[f+24>>2],s[f+20>>2],s[f+16>>2],s[f+12>>2],v(1));K=f+32|0;}function rd(){var a=0,b=0,c=0;a=K-32|0;K=a;a:{if(m[20764]&1){break a}if(!Fa(20764)){break a}c=Kr();s[a+12>>2]=0;s[a+8>>2]=0;s[a+4>>2]=0;b=a+16|0;Z(b,a+12|0,a+8|0,a+4|0);fd(20700,c,b);Ea(20764);}K=a+32|0;return 20700}function sc(a,b){var c=0,d=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];sd(a,o[c+8>>2]);b=o[c+8>>2];d=o[b+52>>2];o[a+48>>2]=o[b+48>>2];o[a+52>>2]=d;d=o[b+60>>2];o[a+56>>2]=o[b+56>>2];o[a+60>>2]=d;K=c+16|0;}function hj(a,b){a=a|0;b=b|0;var c=0,d=0,e=0;c=o[a+84>>2];d=o[c+8>>2];if((d|0)>=1){a=0;while(1){e=o[(o[c+16>>2]+u(a,12)|0)+8>>2];if(e){l[o[o[e>>2]+16>>2]](e,b);d=o[c+8>>2];}a=a+1|0;if((a|0)<(d|0)){continue}break}}}function Bb(a,b){var c=0,d=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];Cg(a,o[c+8>>2]);b=o[c+8>>2];d=o[b+52>>2];o[a+48>>2]=o[b+48>>2];o[a+52>>2]=d;d=o[b+60>>2];o[a+56>>2]=o[b+56>>2];o[a+60>>2]=d;K=c+16|0;}function co(a,b){var c=0,d=0,e=0;d=K-16|0;K=d;l[o[4966]](2560);if(o[a+296>>2]>=1){while(1){e=o[o[a+304>>2]+(c<<2)>>2];l[o[o[e>>2]+8>>2]](e,a,b);c=c+1|0;if((c|0)<o[a+296>>2]){continue}break}}l[o[4967]]();K=d+16|0;}function as(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;s[c+4>>2]=.10000000149011612;a=o[c+12>>2];b=K-16|0;o[b+12>>2]=o[c+8>>2];s[c>>2]=s[o[b+12>>2]+(Lo(o[c+8>>2])<<2)>>2];Ko(a,s[c>>2],s[c+4>>2]);K=c+16|0;}function Lj(a,b,c,d,e,f){o[a>>2]=16448;o[a+4>>2]=o[c>>2];o[a>>2]=4944;m[a+16|0]=f;o[a+12>>2]=b;m[a+8|0]=0;o[a>>2]=9756;if(!b){b=o[a+4>>2];b=l[o[o[b>>2]+12>>2]](b,o[d+8>>2],o[e+8>>2])|0;m[a+8|0]=1;o[a+12>>2]=b;}}function aq(a){var b=0;b=K-32|0;K=b;o[b+28>>2]=a;a=o[b+28>>2];s[b+24>>2]=0;s[b+20>>2]=0;s[b+16>>2]=0;Z(a+472|0,b+24|0,b+20|0,b+16|0);s[b+12>>2]=0;s[b+8>>2]=0;s[b+4>>2]=0;Z(a+488|0,b+12|0,b+8|0,b+4|0);K=b+32|0;}function Ed(a,b,c){var d=0;d=o[a+16>>2];if(!d){o[a+36>>2]=1;o[a+24>>2]=c;o[a+16>>2]=b;return}a:{if((b|0)==(d|0)){if(o[a+24>>2]!=2){break a}o[a+24>>2]=c;return}m[a+54|0]=1;o[a+24>>2]=2;o[a+36>>2]=o[a+36>>2]+1;}}function mo(a,b){a=a|0;b=b|0;var c=0,d=0;d=o[a+288>>2];c=d;a:{if((d|0)<1){break a}a=o[a+296>>2];c=0;while(1){if(o[a+(c<<2)>>2]==(b|0)){break a}c=c+1|0;if((d|0)!=(c|0)){continue}break}c=d;}return (c|0)>=(d|0)|0}function ms(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0;f=K-32|0;K=f;o[f+28>>2]=a;o[f+24>>2]=b;o[f+20>>2]=c;o[f+16>>2]=d;m[f+15|0]=e;mh(o[f+28>>2],o[f+24>>2],o[f+20>>2],o[f+16>>2],m[f+15|0]&1);K=f+32|0;}function dg(a,b,c,d,e,f){var g=0;g=K-32|0;K=g;o[g+28>>2]=a;s[g+24>>2]=b;s[g+20>>2]=c;s[g+16>>2]=d;s[g+12>>2]=e;s[g+8>>2]=f;Qm(o[g+28>>2]+688|0,s[g+24>>2],s[g+20>>2],s[g+16>>2],s[g+12>>2],s[g+8>>2]);K=g+32|0;}function Lw(a){a=a|0;var b=0,c=v(0),d=v(0);b=K-32|0;K=b;l[o[o[a>>2]+12>>2]](a,b+16|0,b+12|0);K=b+32|0;c=s[b+16>>2];d=v(c*c);c=s[b+20>>2];d=v(d+v(c*c));c=s[b+24>>2];return v(v(s[b+12>>2]+v(C(v(d+v(c*c))))))}function qq(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];o[a+304>>2]=o[a+304>>2]+1;b=o[c+8>>2];c=o[b+4>>2];o[a+372>>2]=o[b>>2];o[a+376>>2]=c;c=o[b+12>>2];o[a+380>>2]=o[b+8>>2];o[a+384>>2]=c;}function oq(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];o[a+304>>2]=o[a+304>>2]+1;b=o[c+8>>2];c=o[b+4>>2];o[a+388>>2]=o[b>>2];o[a+392>>2]=c;c=o[b+12>>2];o[a+396>>2]=o[b+8>>2];o[a+400>>2]=c;}function jq(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];o[a+304>>2]=o[a+304>>2]+1;b=o[c+8>>2];c=o[b+4>>2];o[a+604>>2]=o[b>>2];o[a+608>>2]=c;c=o[b+12>>2];o[a+612>>2]=o[b+8>>2];o[a+616>>2]=c;}function Dg(a,b,c,d){a=a|0;b=v(b);c=c|0;d=v(d);var e=0;e=K-16|0;K=e;o[e+12>>2]=a;s[e+8>>2]=b;o[e+4>>2]=c;s[e>>2]=d;a=o[e+12>>2];a=l[o[o[a>>2]+52>>2]](a,s[e+8>>2],o[e+4>>2],s[e>>2])|0;K=e+16|0;return a|0}function Wo(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];m[c+7|0]=(o[o[c+8>>2]+4>>2]&o[b+16>>2])!=0;m[c+7|0]=m[c+7|0]&1?(o[b+12>>2]&o[o[c+8>>2]+8>>2])!=0:0;return m[c+7|0]&1}function Um(a,b){o[a+28>>2]=b;o[a+24>>2]=-1;n[a+20>>1]=1;o[a+16>>2]=2139095039;o[a+8>>2]=-1;o[a+12>>2]=-1;o[a>>2]=3492;o[a+4>>2]=3;Tm();o[a+44>>2]=0;o[a+36>>2]=0;o[a+40>>2]=1028443341;o[a+32>>2]=20832;}function ai(a,b){o[a+4>>2]=35;o[a+8>>2]=0;o[a+12>>2]=-1;o[a+16>>2]=0;o[a>>2]=13904;o[a+52>>2]=b;o[a>>2]=12156;o[a+4>>2]=21;if(l[o[o[b>>2]+40>>2]](b)){l[o[o[b>>2]+48>>2]](b,a+20|0,a+36|0);return}_d(a);}function Rf(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];m[c+7|0]=(o[o[c+8>>2]+4>>2]&o[b+12>>2])!=0;m[c+7|0]=m[c+7|0]&1?(o[b+8>>2]&o[o[c+8>>2]+8>>2])!=0:0;return m[c+7|0]&1}function Kp(a,b){var c=0,d=0;c=K-16|0;K=c;o[c+8>>2]=a;o[c+4>>2]=b;a=o[c+8>>2];o[c+12>>2]=a;d=a+48|0;b=a;while(1){o[(K-16|0)+12>>2]=b;b=b+16|0;if((d|0)!=(b|0)){continue}break}Yf(a,o[c+4>>2]);K=c+16|0;}function Eg(a,b,c){a=a|0;b=v(b);c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;s[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];a=l[o[o[a>>2]+52>>2]](a,s[d+8>>2],o[d+4>>2],v(.01666666753590107))|0;K=d+16|0;return a|0}function si(a,b,c){a=a|0;b=v(b);c=c|0;var d=v(0),e=v(0);d=v(l[o[o[a>>2]+48>>2]](a));e=v(l[o[o[a>>2]+48>>2]](a));o[c+12>>2]=0;b=v(e*v(d*v(b*v(.4000000059604645))));s[c+8>>2]=b;s[c+4>>2]=b;s[c>>2]=b;}function Na(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=l[o[o[c>>2]+40>>2]](c,a)|0;e=l[o[o[c>>2]+28>>2]](c,d)|0;o[b>>2]=e;if(e){l[o[o[c>>2]+48>>2]](c,d);}a=o[a+4>>2];o[b+8>>2]=0;o[b+4>>2]=a;return 13090}function dd(a,b,c,d){o[a+44>>2]=0;o[a+36>>2]=0;o[a+40>>2]=1028443341;o[a+32>>2]=d;o[a+28>>2]=c;o[a+24>>2]=-1;n[a+20>>1]=1;o[a+16>>2]=2139095039;o[a+8>>2]=-1;o[a+12>>2]=-1;o[a>>2]=3492;o[a+4>>2]=b;}function Rb(a){a=a|0;var b=0;o[a>>2]=3972;b=o[a+296>>2];if(b){if(p[a+300|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+296>>2]=0;}o[a+296>>2]=0;o[a+288>>2]=0;o[a+292>>2]=0;m[a+300|0]=1;return a|0}function Ko(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=a;s[d+8>>2]=b;s[d+4>>2]=c;a=o[d+12>>2];s[d>>2]=s[d+4>>2]*s[d+8>>2];if(s[d>>2]<v(l[o[o[a>>2]+48>>2]](a))){l[o[o[a>>2]+44>>2]](a,s[d>>2]);}K=d+16|0;}function nr(a,b,c,d,e){a=a|0;b=v(b);c=v(c);d=v(d);e=v(e);var f=0;f=K-32|0;K=f;o[f+28>>2]=a;s[f+24>>2]=b;s[f+20>>2]=c;s[f+16>>2]=d;s[f+12>>2]=e;mc(o[f+28>>2],f+24|0,f+20|0,f+16|0,f+12|0);K=f+32|0;}function Th(a,b,c,d){c=c|0;d=d|0;o[c+8>>2]=-581039253;o[c+12>>2]=0;o[c>>2]=-581039253;o[c+4>>2]=-581039253;o[d+8>>2]=1566444395;o[d+12>>2]=0;o[d>>2]=1566444395;o[d+4>>2]=1566444395;}function yn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0;c=o[b>>2];d=o[a+84>>2];if(!(!(o[b+8>>2]&o[a+8>>2])|(!(o[a+12>>2]&o[b+4>>2])|(c|0)==(d|0)))){a=o[a+96>>2];e=l[o[o[a>>2]+28>>2]](a,d,c)|0;}return e|0}function pd(a){var b=0,c=0,d=0;b=K-16|0;K=b;o[b+12>>2]=a;a=0;c=K-16|0;d=o[b+12>>2];o[c+12>>2]=d;if(o[o[c+12>>2]+220>>2]!=2){a=K-16|0;o[a+12>>2]=d;a=o[o[a+12>>2]+220>>2]!=5;}K=b+16|0;return a&1}function ll(a){o[a>>2]=6072;o[a+16>>2]=0;m[a+20|0]=1;o[a+8>>2]=0;o[a+12>>2]=0;o[a+36>>2]=0;m[a+40|0]=1;m[a+60|0]=1;o[a+28>>2]=0;o[a+32>>2]=0;o[a+56>>2]=0;m[a+64|0]=1;o[a+48>>2]=0;o[a+52>>2]=0;}function Ji(a,b,c){sa(a);s[a+64>>2]=c;s[a+60>>2]=b;o[a>>2]=11188;o[a+76>>2]=2;o[a+68>>2]=0;o[a+72>>2]=1;o[a+4>>2]=11;s[a+40>>2]=b;s[a+36>>2]=c;s[a+32>>2]=b;s[a+56>>2]=b/v(C(v(v(b*b)+v(c*c))));}function rj(a,b){a=a|0;b=b|0;var c=0,d=0,e=0;c=o[a+52>>2];if((c|0)>=1){while(1){e=o[o[a+60>>2]+(d<<2)>>2];if(e){l[o[o[e>>2]+16>>2]](e,b);c=o[a+52>>2];}d=d+1|0;if((d|0)<(c|0)){continue}break}}}function Wp(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;a=_(372);l[2](a,o[e+12>>2],o[e+8>>2],o[e+4>>2],o[e>>2])|0;K=e+16|0;return a|0}function ph(a){a=a|0;var b=0;o[a>>2]=15156;b=o[a+32>>2];if(b){if(p[a+36|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+32>>2]=0;}o[a+32>>2]=0;o[a+24>>2]=0;o[a+28>>2]=0;m[a+36|0]=1;return a|0}function Zk(a){a=a|0;var b=0;o[a+8>>2]=6364;o[a>>2]=6336;b=o[a+56>>2];l[o[o[b>>2]+20>>2]](b,o[a+72>>2]);b=o[a+56>>2];l[o[o[b>>2]+16>>2]](b,o[a+72>>2]);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function Ot(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;K=c+16|0;return v(s[o[o[a+12>>2]+12>>2]+(o[a+8>>2]<<2)>>2])}function vt(a,b,c,d){a=v(a);b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;s[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;b=qa(144);gg(b,s[e+12>>2],o[e+8>>2],o[e+4>>2],o[e>>2]);K=e+16|0;return b|0}function cm(a){a=a|0;var b=0;o[a>>2]=4064;b=o[a+20>>2];if(b){if(p[a+24|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+20>>2]=0;}o[a+20>>2]=0;o[a+12>>2]=0;o[a+16>>2]=0;m[a+24|0]=1;return a|0}function Hr(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;a=_(768);nf(a,o[e+12>>2],o[e+8>>2],o[e+4>>2],o[e>>2],0);K=e+16|0;return a|0}function Ef(a){if(!(p[a+204|0]&3)){s[a+472>>2]=v(s[a+424>>2]*s[a+408>>2])+s[a+472>>2];s[a+476>>2]=v(s[a+428>>2]*s[a+412>>2])+s[a+476>>2];s[a+480>>2]=v(s[a+432>>2]*s[a+416>>2])+s[a+480>>2];}}function Nq(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;a=_(1460);wn(a,o[e+12>>2],o[e+8>>2],o[e+4>>2],o[e>>2]);K=e+16|0;return a|0}function xg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b+44>>2]=o[a>>2];o[b+48>>2]=c;c=o[a+12>>2];o[b+52>>2]=o[a+8>>2];o[b+56>>2]=c;}function vg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b+60>>2]=o[a>>2];o[b+64>>2]=c;c=o[a+12>>2];o[b+68>>2]=o[a+8>>2];o[b+72>>2]=c;}function rg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b+24>>2]=o[a>>2];o[b+28>>2]=c;c=o[a+12>>2];o[b+32>>2]=o[a+8>>2];o[b+36>>2]=c;}function pg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b+40>>2]=o[a>>2];o[b+44>>2]=c;c=o[a+12>>2];o[b+48>>2]=o[a+8>>2];o[b+52>>2]=c;}function nc(a,b,c,d){a=a|0;b=b|0;c=v(c);d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;s[e+4>>2]=c;o[e>>2]=d;a=o[e+12>>2];l[o[o[a>>2]+28>>2]](a,o[e+8>>2],s[e+4>>2],o[e>>2]);K=e+16|0;}function hn(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;c=a;d=b;b=o[a+28>>2];e=b+4|0;a=o[a+32>>2];f=a+4|0;g=b+372|0;h=a+372|0;b=b+388|0;a=a+388|0;fn(c,d,gn(c,d,e,f,g,h,b,a),e,f,g,h,b,a);}function _s(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b+32>>2]=o[a>>2];o[b+36>>2]=c;c=o[a+12>>2];o[b+40>>2]=o[a+8>>2];o[b+44>>2]=c;}function Ys(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b+64>>2]=o[a>>2];o[b+68>>2]=c;c=o[a+12>>2];o[b+72>>2]=o[a+8>>2];o[b+76>>2]=c;}function Os(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;a=_(360);cn(a,o[e+12>>2],o[e+8>>2],o[e+4>>2],o[e>>2]);K=e+16|0;return a|0}function Kt(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;K=c+16|0;return o[o[o[a+12>>2]+12>>2]+(o[a+8>>2]<<2)>>2]}function Bh(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b+48>>2]=o[a>>2];o[b+52>>2]=c;c=o[a+12>>2];o[b+56>>2]=o[a+8>>2];o[b+60>>2]=c;}function $s(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b+16>>2]=o[a>>2];o[b+20>>2]=c;c=o[a+12>>2];o[b+24>>2]=o[a+8>>2];o[b+28>>2]=c;}function fc(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2]+16;o[a+8>>2]=b;K=c+16|0;return o[(o[o[a+12>>2]+12>>2]+u(o[a+8>>2],80)|0)+64>>2]}function du(a,b){var c=0,d=0;c=p[a|0];d=p[b|0];a:{if(!c|(c|0)!=(d|0)){break a}while(1){d=p[b+1|0];c=p[a+1|0];if(!c){break a}b=b+1|0;a=a+1|0;if((c|0)==(d|0)){continue}break}}return c-d|0}function Ob(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;a=o[e+12>>2];l[o[o[a>>2]+32>>2]](a,o[e+8>>2],o[e+4>>2],o[e>>2]);K=e+16|0;}function Kg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;a=o[e+12>>2];l[o[o[a>>2]+88>>2]](a,o[e+8>>2],o[e+4>>2],o[e>>2]);K=e+16|0;}function Jb(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;a=o[e+12>>2];l[o[o[a>>2]+36>>2]](a,o[e+8>>2],o[e+4>>2],o[e>>2]);K=e+16|0;}function Cl(a,b,c,d){o[a>>2]=16448;o[a+4>>2]=o[b>>2];o[a>>2]=4944;o[a+12>>2]=0;m[a+8|0]=0;o[a>>2]=5020;b=o[a+4>>2];b=l[o[o[b>>2]+12>>2]](b,o[c+8>>2],o[d+8>>2])|0;m[a+8|0]=1;o[a+12>>2]=b;}function fa(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;a=o[e+12>>2];l[o[o[a>>2]+8>>2]](a,o[e+8>>2],o[e+4>>2],o[e>>2]);K=e+16|0;}function oc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=v(0);d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];e=v(l[o[o[a>>2]+32>>2]](a,o[d+8>>2],o[d+4>>2]));K=d+16|0;return v(e)}function bm(a){a=a|0;var b=0;o[a>>2]=4064;b=o[a+20>>2];if(b){if(p[a+24|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+20>>2]=0;}o[a+20>>2]=0;o[a+12>>2]=0;o[a+16>>2]=0;m[a+24|0]=1;aa(a);}function Z(a,b,c,d){var e=0;e=K-16|0;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;a=o[e+12>>2];s[a>>2]=s[o[e+8>>2]>>2];s[a+4>>2]=s[o[e+4>>2]>>2];s[a+8>>2]=s[o[e>>2]>>2];s[a+12>>2]=0;}function sa(a){o[a+12>>2]=-1;o[a+4>>2]=35;o[a+8>>2]=0;o[a>>2]=13148;o[a+48>>2]=1025758986;o[a+24>>2]=1065353216;o[a+28>>2]=0;o[a+16>>2]=1065353216;o[a+20>>2]=1065353216;o[a>>2]=13276;}function ni(a){a=a|0;var b=0;o[a>>2]=11524;if(p[a+65|0]){b=o[a+56>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+56>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function Xp(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;K=c+16|0;return o[o[a+12>>2]+12>>2]+(o[a+8>>2]<<5)|0}function Ub(a){var b=v(0);b=ua(v(s[a>>2]+s[a+4>>2]));if(!!(b<v(-3.1415927410125732))){return v(b+v(6.2831854820251465))}return b>v(3.1415927410125732)^1?b:v(b+v(-6.2831854820251465))}function Tb(a){var b=v(0);b=ua(v(s[a>>2]-s[a+4>>2]));if(!!(b<v(-3.1415927410125732))){return v(b+v(6.2831854820251465))}return b>v(3.1415927410125732)^1?b:v(b+v(-6.2831854820251465))}function Oq(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;K=c+16|0;return o[o[a+12>>2]+12>>2]+(o[a+8>>2]<<4)|0}function Aq(a,b,c){var d=0;d=K-48|0;K=d;o[d+44>>2]=a;o[d+40>>2]=b;o[d+36>>2]=c;a=o[d+44>>2];_f(a,o[d+40>>2]);b=o[d+36>>2];Ta(d,o[d+40>>2],a+408|0);c=d+16|0;dc(c,b,d);$f(a,c);K=d+48|0;}function Ap(a){a=a|0;var b=0;b=K-80|0;K=b;o[b+76>>2]=a;a:{if(m[20016]&1){break a}if(!Fa(20016)){break a}wb(19952);Ea(20016);}a=b+8|0;bc(a,o[b+76>>2]);sc(19952,a);K=b+80|0;return 19952}function bt(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b>>2]=o[a>>2];o[b+4>>2]=c;c=o[a+12>>2];o[b+8>>2]=o[a+8>>2];o[b+12>>2]=c;}function zi(a){o[a>>2]=11340;m[a+20|0]=1;o[a+16>>2]=0;m[a+40|0]=1;o[a+8>>2]=0;o[a+12>>2]=0;o[a+36>>2]=0;m[a+60|0]=1;o[a+28>>2]=0;o[a+32>>2]=0;o[a+56>>2]=0;o[a+48>>2]=0;o[a+52>>2]=0;}function es(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;K=c+16|0;return (o[a+12>>2]+4|0)+u(o[a+8>>2],208)|0}function ob(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];s[a>>2]=s[a>>2]+s[o[c+8>>2]>>2];s[a+4>>2]=s[a+4>>2]+s[o[c+8>>2]+4>>2];s[a+8>>2]=s[a+8>>2]+s[o[c+8>>2]+8>>2];}function fs(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];s[a>>2]=s[a>>2]-s[o[c+8>>2]>>2];s[a+4>>2]=s[a+4>>2]-s[o[c+8>>2]+4>>2];s[a+8>>2]=s[a+8>>2]-s[o[c+8>>2]+8>>2];}function Lg(a,b,c,d){var e=0,f=0,g=0,h=0;f=o[a+4>>2];a=o[a>>2];g=a;h=b;e=0;a:{if(!c){break a}b=f>>8;e=b;if(!(f&1)){break a}e=o[b+o[c>>2]>>2];}l[o[o[a>>2]+28>>2]](g,h,e+c|0,f&2?d:2);}function ou(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;a=_(344);Bf(a,o[e+12>>2],o[e+8>>2],o[e+4>>2]);K=e+16|0;return a|0}function iq(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];b=o[a+192>>2];l[o[o[b>>2]+8>>2]](b,a+4|0,o[d+8>>2],o[d+4>>2]);K=d+16|0;}function hw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;if(b>>>0<=11){b=b<<2;f=o[b+14292>>2];b=o[b+14244>>2];}else {b=0;}l[o[o[a>>2]+108>>2]](e,b,c);l[o[o[a>>2]+108>>2]](a,f,d);}function Qr(a,b,c,d){a=a|0;b=b|0;c=v(c);d=v(d);var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;s[e+4>>2]=c;s[e>>2]=d;ec(o[e+12>>2],o[e+8>>2],s[e+4>>2],s[e>>2],v(0),v(0),2);K=e+16|0;}function Ms(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b+300>>2]=o[a>>2];o[b+304>>2]=c;c=o[a+12>>2];o[b+308>>2]=o[a+8>>2];o[b+312>>2]=c;}function Ks(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b+316>>2]=o[a>>2];o[b+320>>2]=c;c=o[a+12>>2];o[b+324>>2]=o[a+8>>2];o[b+328>>2]=c;}function vb(a,b,c,d,e){var f=0;f=K-32|0;K=f;o[f+28>>2]=a;o[f+24>>2]=b;o[f+20>>2]=c;o[f+16>>2]=d;o[f+12>>2]=e;mc(o[f+28>>2],o[f+24>>2],o[f+20>>2],o[f+16>>2],o[f+12>>2]);K=f+32|0;}function or(a,b,c,d){a=v(a);b=v(b);c=v(c);d=v(d);var e=0,f=0;e=K-16|0;K=e;s[e+12>>2]=a;s[e+8>>2]=b;s[e+4>>2]=c;s[e>>2]=d;f=qa(16);vb(f,e+12|0,e+8|0,e+4|0,e);K=e+16|0;return f|0}function It(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];Ht(a,o[d+8>>2],o[d+4>>2]);o[a>>2]=1768;db(a+136|0);m[a+156|0]=1;o[a+12>>2]=-1;K=d+16|0;}function Ds(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];Cs(a,o[d+8>>2],o[d+4>>2]);o[a>>2]=1988;o[a+88>>2]=0;m[a+92|0]=1;o[a+12>>2]=-1;K=d+16|0;}function Wk(a){a=a|0;var b=0;o[a>>2]=6364;b=o[a+48>>2];l[o[o[b>>2]+20>>2]](b,o[a+64>>2]);b=o[a+48>>2];l[o[o[b>>2]+16>>2]](b,o[a+64>>2]);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function Ua(a){var b=0,c=0;b=o[6388];c=a+3&-4;a=b+c|0;a:{if(a>>>0<=b>>>0?(c|0)>=1:0){break a}if(a>>>0>M()<<16>>>0){if(!I(a|0)){break a}}o[6388]=a;return b}o[6259]=48;return -1}function Ga(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];return v(v(v(s[a>>2]*s[o[c+8>>2]>>2])+v(s[a+4>>2]*s[o[c+8>>2]+4>>2]))+v(s[a+8>>2]*s[o[c+8>>2]+8>>2]))}function zr(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;m[c+11|0]=b;b=m[c+11|0]&1;a=K-16|0;o[a+12>>2]=o[c+12>>2];m[a+11|0]=b;m[o[a+12>>2]+737|0]=m[a+11|0]&1;K=c+16|0;}function pr(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;m[c+11|0]=b;b=m[c+11|0]&1;a=K-16|0;o[a+12>>2]=o[c+12>>2];m[a+11|0]=b;m[o[a+12>>2]+740|0]=m[a+11|0]&1;K=c+16|0;}function Qp(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;m[c+11|0]=b;b=m[c+11|0]&1;a=K-16|0;o[a+12>>2]=o[c+12>>2];m[a+11|0]=b;m[o[a+12>>2]+368|0]=m[a+11|0]&1;K=c+16|0;}function Mj(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+12>>2];a=o[c+8>>2];c=o[a+4>>2];o[b+4>>2]=o[a>>2];o[b+8>>2]=c;c=o[a+12>>2];o[b+12>>2]=o[a+8>>2];o[b+16>>2]=c;}function Ar(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;m[c+11|0]=b;b=m[c+11|0]&1;a=K-16|0;o[a+12>>2]=o[c+12>>2];m[a+11|0]=b;m[o[a+12>>2]+736|0]=m[a+11|0]&1;K=c+16|0;}function rc(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;m[c+11|0]=b;b=m[c+11|0]&1;a=K-16|0;o[a+12>>2]=o[c+12>>2];m[a+11|0]=b;m[o[a+12>>2]+21|0]=m[a+11|0]&1;K=c+16|0;}function yr(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]+684>>2]=s[a+8>>2];K=c+16|0;}function ih(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]+276>>2]=s[a+8>>2];K=c+16|0;}function hh(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]+272>>2]=s[a+8>>2];K=c+16|0;}function dj(a,b){var c=0,d=0;c=o[a+96>>2];o[a+96>>2]=c+1;d=o[b+12>>2];c=(c<<4)+a|0;o[c+108>>2]=o[b+8>>2];o[c+112>>2]=d;d=o[b+4>>2];o[c+100>>2]=o[b>>2];o[c+104>>2]=d;yb(a);}function Tp(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;m[o[a+12>>2]+52|0]=o[a+8>>2]==1;K=c+16|0;}function qh(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;o[o[a+12>>2]+204>>2]=o[a+8>>2];K=c+16|0;}function pc(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]+16>>2]=s[a+8>>2];K=c+16|0;}function ng(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]+12>>2]=s[a+8>>2];K=c+16|0;}function lr(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]+60>>2]=s[a+8>>2];K=c+16|0;}function kr(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]+64>>2]=s[a+8>>2];K=c+16|0;}function fq(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;o[o[a+12>>2]+564>>2]=o[a+8>>2];K=c+16|0;}function er(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]+68>>2]=s[a+8>>2];K=c+16|0;}function bh(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;o[o[a+12>>2]+264>>2]=o[a+8>>2];K=c+16|0;}function ah(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;o[o[a+12>>2]+260>>2]=o[a+8>>2];K=c+16|0;}function Rp(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]+56>>2]=s[a+8>>2];K=c+16|0;}function Fg(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;a=o[c+12>>2];a=l[o[o[a>>2]+52>>2]](a,s[c+8>>2],1,v(.01666666753590107))|0;K=c+16|0;return a|0}function wd(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]+4>>2]=s[a+8>>2];K=c+16|0;}function vd(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]+8>>2]=s[a+8>>2];K=c+16|0;}function ia(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;o[o[a+12>>2]+12>>2]=o[a+8>>2];K=c+16|0;}function Rr(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;m[e+3|0]=d;le(o[e+12>>2],o[e+8>>2],o[e+4>>2],m[e+3|0]&1);K=e+16|0;}function Io(a,b){a=a|0;b=b|0;var c=0,d=0;c=K-144|0;K=c;o[c+140>>2]=a;o[c+136>>2]=b;a=c+8|0;b=o[c+140>>2];bc(a,b+68|0);d=c+72|0;Hf(d,b+4|0,a);sc(o[c+136>>2],d);K=c+144|0;}function Cr(a,b,c,d){a=a|0;b=b|0;c=v(c);d=v(d);var e=0;e=K-16|0;K=e;o[e+12>>2]=a;m[e+11|0]=b;s[e+4>>2]=c;s[e>>2]=d;Br(o[e+12>>2],m[e+11|0]&1,s[e+4>>2],s[e>>2]);K=e+16|0;}function ki(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=K+ -64|0;K=e;f=o[a+52>>2];o[e+60>>2]=0;o[e+8>>2]=b;o[e+4>>2]=f;o[e>>2]=11996;Ju(o[a+56>>2],e,c,d);K=e- -64|0;}function ga(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;o[o[a+12>>2]+8>>2]=o[a+8>>2];K=c+16|0;}function _r(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;b=o[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];o[a+8>>2]=b;o[o[a+12>>2]+4>>2]=o[a+8>>2];K=c+16|0;}function Su(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;if((b|0)!=(c|0)){d=o[o[a+4>>2]+96>>2];l[o[o[d>>2]+8>>2]](d,o[b+36>>2],o[c+36>>2])|0;a=o[a+4>>2];o[a+120>>2]=o[a+120>>2]+1;}}function zt(a,b,c,d){a=a|0;b=v(b);c=v(c);d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;s[e+8>>2]=b;s[e+4>>2]=c;o[e>>2]=d;yt(o[e+12>>2],s[e+8>>2],s[e+4>>2],o[e>>2]);K=e+16|0;}function xd(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[o[a+12>>2]>>2]=s[a+8>>2];K=c+16|0;}function vp(a,b,c,d){a=a|0;b=v(b);c=v(c);d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;s[e+8>>2]=b;s[e+4>>2]=c;o[e>>2]=d;up(o[e+12>>2],s[e+8>>2],s[e+4>>2],o[e>>2]);K=e+16|0;}function ns(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;mh(o[e+12>>2],o[e+8>>2],o[e+4>>2],o[e>>2],0);K=e+16|0;}function Vp(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;m[c+11|0]=b;b=m[c+11|0]&1;a=K-16|0;o[a+12>>2]=o[c+12>>2];m[a+11|0]=b;m[20820]=(p[a+11|0]^-1)&1;K=c+16|0;}function Vl(a,b){a=a|0;b=b|0;var c=0;a=o[a+68>>2];c=o[a+12>>2];if(c){o[a+12>>2]=o[c>>2];o[a+8>>2]=o[a+8>>2]+ -1;return c|0}o[6257]=o[6257]+1;return l[o[4968]](b,16)|0}function kd(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];o[a>>2]=1940;ta(a+116|0);ta(a+96|0);ta(a+76|0);ta(a+24|0);o[(K-16|0)+12>>2]=a;K=b+16|0;return a|0}function So(a,b){var c=0;c=K-16|0;K=c;o[c+8>>2]=a;o[c+4>>2]=b;a=o[c+8>>2];a:{if(o[c+4>>2]){o[c+12>>2]=Po(a,o[c+4>>2]);break a}o[c+12>>2]=0;}K=c+16|0;return o[c+12>>2]}function Of(a,b){var c=0;c=K-16|0;K=c;o[c+8>>2]=a;o[c+4>>2]=b;a=o[c+8>>2];a:{if(o[c+4>>2]){o[c+12>>2]=fp(a,o[c+4>>2]);break a}o[c+12>>2]=0;}K=c+16|0;return o[c+12>>2]}function zc(a,b){var c=0;if(o[b+40>>2]){zc(a,o[b+36>>2]);zc(a,o[b+40>>2]);}if(o[a>>2]==(b|0)){o[a>>2]=0;}c=o[a+4>>2];if(c){o[6258]=o[6258]+1;l[o[4969]](c);}o[a+4>>2]=b;}function ot(a){var b=0,c=0;b=K-16|0;K=b;o[b+8>>2]=a;a=o[b+8>>2];o[b+12>>2]=a;c=a+48|0;while(1){o[(K-16|0)+12>>2]=a;a=a+16|0;if((c|0)!=(a|0)){continue}break}K=b+16|0;}function ls(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+12>>2]=a;o[e+8>>2]=b;o[e+4>>2]=c;o[e>>2]=d;Bv(o[e+12>>2],o[e+8>>2],o[e+4>>2],o[e>>2]);K=e+16|0;}function lg(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=b;s[c+8>>2]=-s[o[c+12>>2]>>2];s[c+4>>2]=-s[o[c+12>>2]+4>>2];s[c>>2]=-s[o[c+12>>2]+8>>2];Z(a,c+8|0,c+4|0,c);K=c+16|0;}function Mm(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=o[a+32>>2];e=c+388|0;d=o[a+28>>2];f=d+388|0;c=c+4|0;d=d+4|0;if(p[a+739|0]){Lm(a,b,d,c,f,e);return}Km(a,b,d,c,f,e);}function Mt(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;m[d+11|0]=b;m[d+10|0]=c;a=_(80);ce(a,o[d+12>>2],m[d+11|0]&1,m[d+10|0]&1);K=d+16|0;return a|0}function Hs(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];b=o[c+8>>2];c=o[b+4>>2];o[a+348>>2]=o[b>>2];o[a+352>>2]=c;o[a+356>>2]=o[b+8>>2];}function Ve(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];l[o[o[a>>2]+36>>2]](a,o[d+8>>2],o[d+4>>2],-1);K=d+16|0;}function Sm(a){a=a|0;o[5208]=2244;a=o[5347];if(a){if(p[21392]){if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}o[5347]=0;}m[21392]=1;o[5345]=0;o[5346]=0;o[5347]=0;Rb(20832);}function Hf(a,b,c){var d=0;d=K-80|0;K=d;o[d+76>>2]=a;o[d+72>>2]=b;o[d+68>>2]=c;b=d+16|0;c=o[d+72>>2];bg(b,c,o[d+68>>2]);Yb(d,c,o[d+68>>2]+48|0);fd(a,b,d);K=d+80|0;}function Br(a,b,c,d){var e=0;e=K-16|0;o[e+12>>2]=a;m[e+11|0]=b;s[e+4>>2]=c;s[e>>2]=d;a=o[e+12>>2];m[a+737|0]=m[e+11|0]&1;s[a+680>>2]=s[e+4>>2];s[a+684>>2]=s[e>>2];}function Ag(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];l[o[o[a>>2]+36>>2]](a,o[d+8>>2],o[d+4>>2],-3);K=d+16|0;}function vq(a,b){var c=0,d=0;c=K-48|0;K=c;o[c+44>>2]=a;o[c+40>>2]=b;b=c+8|0;a=o[c+44>>2];Ta(b,o[c+40>>2],a+408|0);d=c+24|0;md(d,b,a+404|0);ob(a+372|0,d);K=c+48|0;}function _k(a){a=a|0;var b=0;o[a+8>>2]=6364;o[a>>2]=6336;b=o[a+56>>2];l[o[o[b>>2]+20>>2]](b,o[a+72>>2]);b=o[a+56>>2];l[o[o[b>>2]+16>>2]](b,o[a+72>>2]);return a|0}function Zf(a,b){var c=0,d=0;c=K-48|0;K=c;o[c+44>>2]=a;o[c+40>>2]=b;b=c+8|0;a=o[c+44>>2];Sa(b,a+324|0,o[c+40>>2]);d=c+24|0;Ta(d,b,a+604|0);ob(a+388|0,d);K=c+48|0;}function la(a,b,c){a=a|0;b=v(b);c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;s[d+8>>2]=b;o[d+4>>2]=c;a=o[d+12>>2];l[o[o[a>>2]+32>>2]](a,s[d+8>>2],o[d+4>>2]);K=d+16|0;}function bc(a,b){var c=0,d=0,e=0;c=K-96|0;K=c;o[c+92>>2]=a;o[c+88>>2]=b;b=c+40|0;d=o[c+88>>2];so(b,d);e=c+8|0;lg(e,d+48|0);d=c+24|0;Sa(d,b,e);fd(a,b,d);K=c+96|0;}function dr(a,b,c){a=a|0;b=b|0;c=v(c);var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;s[d+4>>2]=c;a=o[d+12>>2];l[o[o[a>>2]+8>>2]](a,o[d+8>>2],s[d+4>>2]);K=d+16|0;}function Hg(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;m[d+7|0]=c;a=o[d+12>>2];l[o[o[a>>2]+56>>2]](a,o[d+8>>2],m[d+7|0]&1);K=d+16|0;}function Eo(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=b;b=o[c+12>>2];s[c+8>>2]=-s[b>>2];s[c+4>>2]=-s[b+4>>2];s[c>>2]=-s[b+8>>2];vb(a,c+8|0,c+4|0,c,b+12|0);K=c+16|0;}function Up(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;b=s[c+8>>2];a=K-16|0;o[a+12>>2]=o[c+12>>2];s[a+8>>2]=b;s[4961]=s[a+8>>2];K=c+16|0;}function yp(a,b){var c=0;c=K-32|0;K=c;o[c+28>>2]=a;o[c+24>>2]=b;b=c+8|0;a=o[c+28>>2];Sa(b,a,o[c+24>>2]+48|0);ob(a+48|0,b);xp(a,o[c+24>>2]);K=c+32|0;return a}function xa(a){var b=0,c=0;b=a*a;c=b*a;return v(c*(b*b)*(b*2718311493989822e-21+ -.00019839334836096632)+(c*(b*.008333329385889463+ -.16666666641626524)+a))}function Ae(a){var b=0;b=o[a+12>>2];if(b){if(p[a+16|0]){if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}o[a+12>>2]=0;}o[a+12>>2]=0;m[a+16|0]=1;o[a+4>>2]=0;o[a+8>>2]=0;}function oi(a){a=a|0;var b=0;o[a>>2]=11524;if(p[a+65|0]){b=o[a+56>>2];l[o[o[b>>2]>>2]](b)|0;b=o[a+56>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}return a|0}function kc(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=0;o[c+4>>2]=b;o[c>>2]=o[c+8>>2];while(1){if(o[c>>2]<o[c+4>>2]){o[c>>2]=o[c>>2]+1;continue}break}}function br(a,b,c){a=v(a);b=v(b);c=v(c);var d=0,e=0;d=K-16|0;K=d;s[d+12>>2]=a;s[d+8>>2]=b;s[d+4>>2]=c;e=_(16);Z(e,d+12|0,d+8|0,d+4|0);K=d+16|0;return e|0}function Sb(a){var b=0,c=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];c=K-16|0;o[c+12>>2]=o[o[a+12>>2]+4>>2];K=b+16|0;return o[c+12>>2]==31}function Gn(a,b){a=a|0;b=b|0;var c=0;if(p[a+289|0]){c=o[a+216>>2];if(c){o[6258]=o[6258]+1;l[o[4969]](c);}}o[a+216>>2]=b;m[a+289|0]=0;o[o[a+212>>2]+8>>2]=b;}function ar(a,b,c,d){a=a|0;b=v(b);c=v(c);d=v(d);var e=0;e=K-16|0;K=e;o[e+12>>2]=a;s[e+8>>2]=b;s[e+4>>2]=c;s[e>>2]=d;Z(o[e+12>>2],e+8|0,e+4|0,e);K=e+16|0;}function Sp(a){var b=0,c=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];c=K-16|0;o[c+12>>2]=o[o[a+12>>2]+4>>2];K=b+16|0;return o[c+12>>2]<20}function us(a,b,c){var d=0;d=K-16|0;o[d+12>>2]=a;o[d+8>>2]=b;m[d+7|0]=c;a=o[d+12>>2];o[a+16>>2]=o[d+8>>2];m[a+92|0]=m[d+7|0]&1;s[a+4>>2]=1;o[a+8>>2]=0;}function tv(a,b,c){a=a|0;b=b|0;c=c|0;a:{if(!c){break a}a=o[b+8>>2];if(!a){break a}l[o[o[a>>2]>>2]](a)|0;l[o[o[c>>2]+60>>2]](c,o[b+8>>2]);o[b+8>>2]=0;}}function jk(a,b,c,d,e,f){var g=0;g=K-32|0;K=g;o[g+24>>2]=-1;o[g+28>>2]=-1;o[g+20>>2]=e;o[g+16>>2]=c;o[g+12>>2]=d;o[g+8>>2]=0;Db(a,b,g+8|0,f);K=g+32|0;}function Lo(a){var b=0;b=K-16|0;o[b+12>>2]=a;a=o[b+12>>2];a:{if(s[a>>2]<s[a+4>>2]){a=s[a>>2]<s[a+8>>2]?0:2;break a}a=s[a+4>>2]<s[a+8>>2]?1:2;}return a}function xb(a,b){a=a|0;b=b|0;var c=v(0),d=v(0),e=v(0);c=s[b>>2];d=s[b+4>>2];e=s[b+8>>2];o[a+28>>2]=0;s[a+24>>2]=w(e);s[a+20>>2]=w(d);s[a+16>>2]=w(c);}function uw(a,b){a=a|0;b=b|0;var c=0,d=0;d=o[b+4>>2];c=o[a+96>>2];o[c+4>>2]=o[b>>2];o[c+8>>2]=d;d=o[b+12>>2];o[c+12>>2]=o[b+8>>2];o[c+16>>2]=d;yb(a);}function Zd(a,b){a=a|0;b=b|0;var c=0,d=0;d=o[b+4>>2];c=o[a+52>>2];o[c+4>>2]=o[b>>2];o[c+8>>2]=d;d=o[b+12>>2];o[c+12>>2]=o[b+8>>2];o[c+16>>2]=d;_d(a);}function Iv(a){a=a|0;var b=v(0),c=v(0);b=s[a+32>>2];c=v(l[o[o[a>>2]+48>>2]](a));v(l[o[o[a>>2]+48>>2]](a));v(l[o[o[a>>2]+48>>2]](a));return v(v(b+c))}function zk(a){a=a|0;var b=0,c=0;o[a>>2]=7100;a:{if(!p[a+8|0]){break a}b=o[a+12>>2];if(!b){break a}c=o[a+4>>2];l[o[o[c>>2]+16>>2]](c,b);}return a|0}function qe(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+8>>2];b=o[c+12>>2];if((o[b+220>>2]&-2)!=4){o[b+220>>2]=a;}K=c+16|0;}function kb(a){a=a|0;var b=0;o[a>>2]=12632;b=o[a+56>>2];if(b){l[o[o[b>>2]>>2]](b)|0;b=o[a+56>>2];if(b){o[6258]=o[6258]+1;l[o[4969]](b);}}return a|0}function gv(a,b){a=a|0;b=b|0;var c=0;c=o[a+4>>2];if(!((c|0)!=o[b+4>>2]?(c|0)!=o[b>>2]:0)){c=o[a+8>>2];l[o[o[c>>2]+32>>2]](c,b,o[a+12>>2]);}return 0}function fp(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;o[c+4>>2]=0;a=o[c+8>>2]<<2;o[6257]=o[6257]+1;a=l[o[4968]](a,16)|0;K=c+16|0;return a}function cl(a){a=a|0;var b=0,c=0;o[a>>2]=6176;a:{if(!p[a+8|0]){break a}b=o[a+12>>2];if(!b){break a}c=o[a+4>>2];l[o[o[c>>2]+16>>2]](c,b);}return a|0}function Xk(a){a=a|0;var b=0;o[a>>2]=6364;b=o[a+48>>2];l[o[o[b>>2]+20>>2]](b,o[a+64>>2]);b=o[a+48>>2];l[o[o[b>>2]+16>>2]](b,o[a+64>>2]);return a|0}function Vt(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(pa(a,o[b+8>>2],f)){Dd(b,c,d,e);return}a=o[a+8>>2];l[o[o[a>>2]+20>>2]](a,b,c,d,e,f);}function Po(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;o[c+4>>2]=0;a=o[c+8>>2]<<4;o[6257]=o[6257]+1;a=l[o[4968]](a,16)|0;K=c+16|0;return a}function Kj(a){a=a|0;var b=0,c=0;o[a>>2]=9756;a:{if(!p[a+8|0]){break a}b=o[a+12>>2];if(!b){break a}c=o[a+4>>2];l[o[o[c>>2]+16>>2]](c,b);}return a|0}function Bl(a){a=a|0;var b=0,c=0;o[a>>2]=5020;a:{if(!p[a+8|0]){break a}b=o[a+12>>2];if(!b){break a}c=o[a+4>>2];l[o[o[c>>2]+16>>2]](c,b);}return a|0}function ml(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=o[b>>2];e=l[o[o[e>>2]+56>>2]](e,28)|0;dl(e,b,c,d,p[a+4|0],o[a+8>>2],o[a+12>>2]);return e|0}function tg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];a=l[o[o[a>>2]+40>>2]](a,o[c+8>>2])|0;K=c+16|0;return a|0}function sv(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=c;o[d+8>>2]=a;o[d+4>>2]=b;o[d>>2]=15620;l[o[o[a>>2]+48>>2]](a,d,c);K=d+16|0;}function Im(a,b,c){var d=0;d=K-16|0;K=d;s[d+12>>2]=b;Pm(a+688|0,d+12|0);s[a+680>>2]=v(s[d+12>>2]-bd(a,o[a+28>>2]+4|0,o[a+32>>2]+4|0))/c;K=d+16|0;}function $i(a,b,c){a=a|0;b=b|0;c=c|0;a=(b<<4)+a|0;b=o[a+112>>2];o[c+8>>2]=o[a+108>>2];o[c+12>>2]=b;b=o[a+104>>2];o[c>>2]=o[a+100>>2];o[c+4>>2]=b;}function sm(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;if((c|0)>=1){while(1){tm(a,o[(e<<2)+b>>2],d);e=e+1|0;if((e|0)!=(c|0)){continue}break}}}



            function Yl(a,b,c){a=a|0;b=b|0;c=c|0;a=0;b=o[b+204>>2];a:{if(b&4){break a}c=o[c+204>>2];if(c&4){break a}if(!(b&3)){return 1}a=!(c&3);}return a|0}function Cd(a,b,c,d,e,f){var g=0,h=0,i=0;g=o[a+4>>2];h=g>>8;a=o[a>>2];i=a;if(g&1){h=o[o[d>>2]+h>>2];}l[o[o[a>>2]+20>>2]](i,b,c,d+h|0,g&2?e:2,f);}function yk(a){a=a|0;var b=0,c=0;o[a>>2]=7100;a:{if(!p[a+8|0]){break a}b=o[a+12>>2];if(!b){break a}c=o[a+4>>2];l[o[o[c>>2]+16>>2]](c,b);}aa(a);}function bl(a){a=a|0;var b=0,c=0;o[a>>2]=6176;a:{if(!p[a+8|0]){break a}b=o[a+12>>2];if(!b){break a}c=o[a+4>>2];l[o[o[c>>2]+16>>2]](c,b);}aa(a);}function Jj(a){a=a|0;var b=0,c=0;o[a>>2]=9756;a:{if(!p[a+8|0]){break a}b=o[a+12>>2];if(!b){break a}c=o[a+4>>2];l[o[o[c>>2]+16>>2]](c,b);}aa(a);}function Go(a,b){a=a|0;b=b|0;var c=0;c=K-80|0;K=c;o[c+76>>2]=a;o[c+72>>2]=b;a=c+8|0;b=o[c+76>>2];Hf(a,o[c+72>>2],b+68|0);sc(b+4|0,a);K=c+80|0;}function Al(a){a=a|0;var b=0,c=0;o[a>>2]=5020;a:{if(!p[a+8|0]){break a}b=o[a+12>>2];if(!b){break a}c=o[a+4>>2];l[o[o[c>>2]+16>>2]](c,b);}aa(a);}function xr(a,b,c){a=a|0;b=v(b);c=v(c);var d=0;d=K-16|0;K=d;o[d+12>>2]=a;s[d+8>>2]=b;s[d+4>>2]=c;Im(o[d+12>>2],s[d+8>>2],s[d+4>>2]);K=d+16|0;}function kw(a,b,c){a=a|0;b=b|0;c=c|0;if(b>>>0<=5){o[c+12>>2]=0;a=b<<2;o[c+8>>2]=o[a+14220>>2];o[c+4>>2]=o[a+14196>>2];o[c>>2]=o[a+14172>>2];}}function af(a,b){var c=0,d=0;d=cf(a);c=o[a+288>>2];o[b+8>>2]=o[a+284>>2];o[b+12>>2]=c;c=o[a+280>>2];o[b>>2]=o[a+276>>2];o[b+4>>2]=c;return d}function Sr(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;le(o[d+12>>2],o[d+8>>2],o[d+4>>2],1);K=d+16|0;}function Kq(a,b,c){a=a|0;b=v(b);c=v(c);var d=0;d=K-16|0;K=d;o[d+12>>2]=a;s[d+8>>2]=b;s[d+4>>2]=c;Jq(o[d+12>>2],s[d+8>>2],s[d+4>>2]);K=d+16|0;}function Hq(a,b,c){a=a|0;b=v(b);c=v(c);var d=0;d=K-16|0;K=d;o[d+12>>2]=a;s[d+8>>2]=b;s[d+4>>2]=c;zo(o[d+12>>2],s[d+8>>2],s[d+4>>2]);K=d+16|0;}function Hk(a,b,c){a=a|0;b=b|0;c=c|0;a=(b<<4)+a|0;b=o[a+72>>2];o[c+8>>2]=o[a+68>>2];o[c+12>>2]=b;b=o[a+64>>2];o[c>>2]=o[a+60>>2];o[c+4>>2]=b;}function ql(a,b,c,d){a=a|0;b=b|0;a=o[b>>2];a=l[o[o[a>>2]+56>>2]](a,8)|0;o[a>>2]=16448;o[a+4>>2]=o[b>>2];o[a>>2]=4852;return a|0}function Gq(a,b,c){a=a|0;b=v(b);c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;s[d+8>>2]=b;o[d+4>>2]=c;id(o[d+12>>2],s[d+8>>2],o[d+4>>2]);K=d+16|0;}function ya(a){var b=0;a=a*a;b=a*a;return v(a*-.499999997251031+1+b*.04166662332373906+a*b*(a*2439044879627741e-20+ -.001388676377460993))}function xq(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;nd(o[d+12>>2],o[d+8>>2],o[d+4>>2]);K=d+16|0;}function wr(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;Jm(o[d+12>>2],o[d+8>>2],o[d+4>>2]);K=d+16|0;}function vs(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;m[d+7|0]=c;us(o[d+12>>2],o[d+8>>2],m[d+7|0]&1);K=d+16|0;}function uc(a,b,c,d,e){var f=0,g=0,h=0;f=o[a+4>>2];g=f>>8;a=o[a>>2];h=a;if(f&1){g=o[o[c>>2]+g>>2];}l[o[o[a>>2]+24>>2]](h,b,c+g|0,f&2?d:2,e);}function Xr(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;Wi(o[d+12>>2],o[d+8>>2],o[d+4>>2]);K=d+16|0;}function Xg(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;m[d+7|0]=c;Kd(o[d+12>>2],o[d+8>>2],m[d+7|0]&1);K=d+16|0;}function Wl(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=K-16|0;K=e;o[e+8>>2]=a;o[e+4>>2]=c;o[e>>2]=4172;l[o[o[b>>2]+48>>2]](b,e,d);K=e+16|0;}function Ct(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;m[d+7|0]=c;Bt(o[d+12>>2],o[d+8>>2],m[d+7|0]&1);K=d+16|0;}function Bq(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=a;o[d+8>>2]=b;o[d+4>>2]=c;Aq(o[d+12>>2],o[d+8>>2],o[d+4>>2]);K=d+16|0;}function fg(a){var b=0;b=K-16|0;o[b+12>>2]=a;a=o[b+12>>2];o[a>>2]=0;o[a+4>>2]=0;o[a+8>>2]=4096;o[a+12>>2]=4096;o[a+16>>2]=0;o[a+20>>2]=1;}function Zv(a,b,c,d,e,f,g,h,i,j){o[a+4>>2]=35;o[a+8>>2]=0;o[a+12>>2]=-1;o[a+16>>2]=0;o[a>>2]=13904;o[a>>2]=14676;Yv(a,b,c,d,e,f,g,h,i,j);}function mr(a,b){a=v(a);b=v(b);var c=0,d=0;c=K-16|0;K=c;s[c+12>>2]=a;s[c+8>>2]=b;d=_(80);Ji(d,s[c+12>>2],s[c+8>>2]);K=c+16|0;return d|0}function Fw(a,b,c){sa(a);s[a+48>>2]=b;o[a>>2]=13488;o[a+56>>2]=1;o[a+4>>2]=10;o[a+44>>2]=0;s[a+40>>2]=b;s[a+36>>2]=c*v(.5);s[a+32>>2]=b;}function At(a,b){a=v(a);b=v(b);var c=0,d=0;c=K-16|0;K=c;s[c+12>>2]=a;s[c+8>>2]=b;d=_(60);Fw(d,s[c+12>>2],s[c+8>>2]);K=c+16|0;return d|0}function ud(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];dt(a);s[b+8>>2]=0;s[b+4>>2]=0;s[b>>2]=0;Z(a+48|0,b+8|0,b+4|0,b);K=b+16|0;}function ol(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=o[b>>2];e=l[o[o[e>>2]+56>>2]](e,20)|0;Lj(e,o[b+4>>2],b,c,d,p[a+4|0]);return e|0}function li(a,b,c,d,e,f){var g=0,h=0;g=K-16|0;K=g;h=o[a+52>>2];o[g+8>>2]=b;o[g+4>>2]=h;o[g>>2]=11848;Fu(o[a+56>>2],g,c,d,e,f);K=g+16|0;}function Xe(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+36>>2]](a,o[c+8>>2],1,-1);K=c+16|0;}function Mf(a){var b=0;b=K-16|0;o[b+12>>2]=a;a=o[b+12>>2];o[a>>2]=1964;s[a+4>>2]=1;o[a+8>>2]=0;o[a+12>>2]=1;o[a+16>>2]=-1;o[a+20>>2]=0;}function Bg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+36>>2]](a,o[c+8>>2],2,-3);K=c+16|0;}function eb(a){var b=0,c=0;b=K-16|0;K=b;o[b+12>>2]=a;c=K-16|0;a=o[b+12>>2];o[c+12>>2]=a;kc(a,o[o[c+12>>2]+4>>2]);jc(a);ag(a);K=b+16|0;}function Vq(){var a=0;a=_(36);o[a+4>>2]=35;o[a+8>>2]=0;o[a+12>>2]=-1;o[a+16>>2]=0;o[a>>2]=13904;o[a+4>>2]=27;o[a>>2]=12988;return a|0}function Nt(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;m[c+11|0]=b;a=_(80);ce(a,o[c+12>>2],m[c+11|0]&1,1);K=c+16|0;return a|0}function Hb(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;a=K-16|0;s[a+12>>2]=s[c+8>>2];s[4962]=s[a+12>>2];K=c+16|0;}function os(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;m[c+15|0]=a;m[c+14|0]=b;a=_(172);Pd(a,m[c+15|0]&1,m[c+14|0]&1);K=c+16|0;return a|0}function _f(a,b){var c=0;c=K-32|0;K=c;o[c+28>>2]=a;o[c+24>>2]=b;a=c+8|0;b=o[c+28>>2];Ta(a,o[c+24>>2],b+408|0);ob(b+472|0,a);K=c+32|0;}function Fs(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;m[c+11|0]=b;a=_(100);xh(a,o[c+12>>2],m[c+11|0]&1);K=c+16|0;return a|0}function $f(a,b){var c=0;c=K-32|0;K=c;o[c+28>>2]=a;o[c+24>>2]=b;a=c+8|0;b=o[c+28>>2];Ta(a,o[c+24>>2],b+604|0);ob(b+488|0,a);K=c+32|0;}function lk(a){a=a|0;var b=0,c=0;b=K-16|0;K=b;l[o[4966]](7795);c=o[a+68>>2];l[o[o[c>>2]+32>>2]](c,o[a+24>>2]);l[o[4967]]();K=b+16|0;}function jc(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];if(o[a+12>>2]){if(m[a+16|0]&1){ep(a,o[a+12>>2]);}o[a+12>>2]=0;}K=b+16|0;}function ao(a,b){a=a|0;b=b|0;var c=0;c=o[b+268>>2];o[a>>2]=o[b+264>>2];o[a+4>>2]=c;c=o[b+276>>2];o[a+8>>2]=o[b+272>>2];o[a+12>>2]=c;}function Uq(){var a=0,b=0;b=qa(12);a=K-16|0;o[a+12>>2]=b;a=o[a+12>>2];s[a>>2]=.30000001192092896;s[a+4>>2]=1;s[a+8>>2]=0;return b|0}function Sv(a,b){a=a|0;b=b|0;var c=0;c=o[b+4>>2];o[a+112>>2]=o[b>>2];o[a+116>>2]=c;c=o[b+12>>2];o[a+120>>2]=o[b+8>>2];o[a+124>>2]=c;}function Jt(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=qa(160);It(a,o[c+12>>2],o[c+8>>2]);K=c+16|0;return a|0}function Ig(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+56>>2]](a,o[c+8>>2],0);K=c+16|0;}function Gr(a){var b=0,c=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;c=o[b+12>>2];o[a+12>>2]=c;o[o[a+12>>2]>>2]=1672;o[c>>2]=1580;K=b+16|0;}function nv(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];o[a+304>>2]=o[a+304>>2]+1;sc(a+4|0,o[c+8>>2]);K=c+16|0;}function gr(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;a=_(88);Uh(a,o[c+12>>2],s[c+8>>2]);K=c+16|0;return a|0}function ee(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return (o[o[a+12>>2]+204>>2]&2)!=0|0}function be(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return (o[o[a+12>>2]+204>>2]&1)!=0|0}function ae(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return (o[o[a+12>>2]+204>>2]&3)!=0|0}function Sf(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];o[a>>2]=1032;ta(a+348|0);Ca(a+344|0);gd(a);K=b+16|0;return a|0}function Ps(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=_(360);bn(a,o[c+12>>2],o[c+8>>2]);K=c+16|0;return a|0}function Mp(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=qa(64);Lp(a,o[c+12>>2],o[c+8>>2]);K=c+16|0;return a|0}function Ir(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=_(200);qd(a,o[c+12>>2],o[c+8>>2]);K=c+16|0;return a|0}function Es(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=qa(96);Ds(a,o[c+12>>2],o[c+8>>2]);K=c+16|0;return a|0}function Ba(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+44>>2]](a,s[c+8>>2]);K=c+16|0;}function zg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+12>>2]](a,o[c+8>>2]);K=c+16|0;}function na(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+24>>2]](a,o[c+8>>2]);K=c+16|0;}function Vc(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+68>>2]](a,o[c+8>>2]);K=c+16|0;}function Qg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+72>>2]](a,o[c+8>>2]);K=c+16|0;}function Mg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+84>>2]](a,o[c+8>>2]);K=c+16|0;}function Jq(a,b,c){var d=0;d=K-16|0;o[d+12>>2]=a;s[d+8>>2]=b;s[d+4>>2]=c;a=o[d+12>>2];s[a+532>>2]=s[d+8>>2];s[a+536>>2]=s[d+4>>2];}function Jg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+92>>2]](a,o[c+8>>2]);K=c+16|0;}function Ib(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+40>>2]](a,o[c+8>>2]);K=c+16|0;}function Gg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+60>>2]](a,o[c+8>>2]);K=c+16|0;}function Eb(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+64>>2]](a,o[c+8>>2]);K=c+16|0;}function Dc(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];l[o[o[a>>2]+8>>2]](a,o[c+8>>2]);K=c+16|0;}function zs(a){var b=0,c=v(0);b=K-16|0;K=b;o[b+12>>2]=a;c=eg(o[b+12>>2]);a=K-16|0;s[a+12>>2]=c;K=b+16|0;return v(C(s[a+12>>2]))}function Rh(a,b){a=a|0;b=b|0;var c=0;c=o[b+4>>2];o[a+72>>2]=o[b>>2];o[a+76>>2]=c;c=o[b+12>>2];o[a+80>>2]=o[b+8>>2];o[a+84>>2]=c;}function Fh(a,b){a=a|0;b=b|0;var c=0;c=o[b+4>>2];o[a+20>>2]=o[b>>2];o[a+24>>2]=c;c=o[b+12>>2];o[a+28>>2]=o[b+8>>2];o[a+32>>2]=c;}function tu(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+12>>2];o[c+4>>2]=cp(a,o[c+8>>2]);bp(a,o[c+4>>2]);K=c+16|0;}function rv(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;d=K-16|0;K=d;o[d+12>>2]=b;o[d+8>>2]=15764;l[o[o[a>>2]+48>>2]](a,d+8|0,c);K=d+16|0;}function mi(a,b,c,d){var e=0,f=0;e=K-16|0;K=e;f=o[a+52>>2];o[e+8>>2]=b;o[e+4>>2]=f;o[e>>2]=11680;Gu(o[a+56>>2],e,c,d);K=e+16|0;}function mb(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+8>>2]!=0|0}function Iq(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return v(s[o[a+12>>2]+532>>2])}function qc(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return v(s[o[a+12>>2]+16>>2])}function og(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return v(s[o[a+12>>2]+12>>2])}function $t(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;if(pa(a,o[b+8>>2],0)){Ed(b,c,d);return}a=o[a+8>>2];l[o[o[a>>2]+28>>2]](a,b,c,d);}function zd(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return v(s[o[a+12>>2]+4>>2])}function yd(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return v(s[o[a+12>>2]+8>>2])}function xs(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return v(s[o[a+12>>2]+4>>2])}function od(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];s[b+8>>2]=0;s[b+4>>2]=0;s[b>>2]=0;Z(a,b+8|0,b+4|0,b);K=b+16|0;}function Aa(a){a=a|0;var b=0,c=v(0);b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];c=v(l[o[o[a>>2]+48>>2]](a));K=b+16|0;return v(c)}function ve(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+192>>2]}function se(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+220>>2]}function nq(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+540>>2]}function is(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+836>>2]}function hs(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+840>>2]}function gs(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+844>>2]}function gq(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+564>>2]}function ft(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return +s[o[a+12>>2]+132>>2]}function dh(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+264>>2]}function ct(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+200>>2]}function Qd(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+204>>2]}function zp(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=yp(o[c+12>>2],o[c+8>>2]);K=c+16|0;return a|0}function ys(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+88>>2]}function ja(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+12>>2]}function et(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return +s[o[a+12>>2]+80>>2]}function ep(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=o[c+8>>2];if(a){o[6258]=o[6258]+1;l[o[4969]](a);}K=c+16|0;}function Tr(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;a=fc(o[c+12>>2],o[c+8>>2]);K=c+16|0;return a|0}function Ad(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return v(s[o[a+12>>2]>>2])}function vc(a,b){var c=0;yc(a,b);c=o[a+4>>2];if(c){o[6258]=o[6258]+1;l[o[4969]](c);}o[a+4>>2]=b;o[a+12>>2]=o[a+12>>2]+ -1;}function lc(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+4>>2]}function ha(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[o[a+12>>2]+8>>2]}function yw(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;a=o[c+12>>2];o[a+304>>2]=o[a+304>>2]+1;s[a+236>>2]=s[c+8>>2];}function qa(a){var b=0;a=a?a:1;a:{while(1){b=Bd(a);if(b){break a}b=o[6260];if(b){l[b]();continue}break}J();D();}return b}function jw(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;a=o[c+12>>2];o[a+304>>2]=o[a+304>>2]+1;s[a+240>>2]=s[c+8>>2];}function Oh(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;a=o[c+12>>2];o[a+304>>2]=o[a+304>>2]+1;s[a+232>>2]=s[c+8>>2];}function Nw(a,b){var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;a=o[c+12>>2];o[a+304>>2]=o[a+304>>2]+1;s[a+228>>2]=s[c+8>>2];}function tq(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+372|0}function sq(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+388|0}function lq(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+604|0}function _p(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+488|0}function Pp(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+348|0}function Nf(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];o[a>>2]=2244;ta(a+544|0);Rb(a);K=b+16|0;return a|0}function Lf(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];o[a>>2]=1768;ta(a+136|0);kd(a);K=b+16|0;return a|0}function Js(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+300|0}function Is(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+316|0}function Gt(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+116|0}function Fq(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+408|0}function Dt(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+136|0}function $p(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+472|0}function qj(a,b){a=a|0;b=b|0;var c=0,d=0;c=a;d=o[o[o[a+4>>2]+4>>2]+28>>2];a=o[b+36>>2];we(c,o[(d+u(a,80)|0)+64>>2],a);}function ks(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+20|0}function gb(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+32|0}function fr(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+52|0}function _(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];o[6257]=o[6257]+1;a=l[o[4968]](a,16)|0;K=b+16|0;return a}function Ur(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2]+16;K=b+16|0;return o[o[a+12>>2]+4>>2]}function Ft(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+76|0}function Et(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+96|0}function Ep(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+48|0}function Bs(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+56|0}function As(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+72|0}function Rd(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]+4|0}function qr(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[o[b+12>>2]+68>>2];a=l[o[o[a>>2]+36>>2]](a)|0;K=b+16|0;return a}function ug(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];a=l[o[o[a>>2]+36>>2]](a)|0;K=b+16|0;return a|0}function oe(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;o[o[c+12>>2]+220>>2]=o[c+8>>2];K=c+16|0;}function ma(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];a=l[o[o[a>>2]+28>>2]](a)|0;K=b+16|0;return a|0}function W(a){var b=0;while(1){o[a+4>>2]=0;o[a+8>>2]=0;b=o[a+24>>2];if(b){W(b);}a=o[a+28>>2];if(a){continue}break}}function Bp(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;o[a+12>>2]=o[b+12>>2];K=b+16|0;return o[a+12>>2]}function su(a,b){a=a|0;b=b|0;var c=0;a=l[o[4970]]((a+b|0)+3|0)|0;if(a){c=(a+b|0)+3&0-b;o[c+ -4>>2]=a;}return c|0}function yh(a,b){a=a|0;b=b|0;o[a>>2]=0;o[a+4>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;o[a+(o[b+56>>2]<<2)>>2]=1065353216;}function pa(a,b,c){if(!c){return o[a+4>>2]==o[b+4>>2]}if((a|0)==(b|0)){return 1}return !du(o[a+4>>2],o[b+4>>2])}function ie(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;m[c+11|0]=b;Qb(o[c+12>>2],m[c+11|0]&1);K=c+16|0;}function gu(a){var b=0;a:{a=o[a+8>>2];b=p[a|0];if((b|0)!=1){if(b&2){break a}m[a|0]=2;a=1;}else {a=0;}return a}D();}function Jd(a){var b=0;b=o[a+24>>2];if(b){Jd(b);aa(b);}o[a+24>>2]=0;b=o[a+28>>2];if(b){Jd(b);aa(b);}o[a+28>>2]=0;}function Ik(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;l[o[o[a>>2]+108>>2]](a,b,c);l[o[o[a>>2]+108>>2]](a,(b+1|0)%3|0,d);}function Fa(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=0;o[b+4>>2]=a;o[b>>2]=a;o[b+8>>2]=a+1;a=hu(b);K=b+16|0;return a}function wh(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;jw(o[c+12>>2],s[c+8>>2]);K=c+16|0;}function vl(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=o[b>>2];a=l[o[o[a>>2]+56>>2]](a,80)|0;Se(a,b,c,d,0);return a|0}function ul(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=o[b>>2];a=l[o[o[a>>2]+56>>2]](a,80)|0;Se(a,b,c,d,1);return a|0}function tl(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=o[b>>2];a=l[o[o[a>>2]+56>>2]](a,84)|0;Mc(a,b,c,d,0);return a|0}function rl(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=o[b>>2];a=l[o[o[a>>2]+56>>2]](a,84)|0;Mc(a,b,c,d,1);return a|0}function mh(a,b,c,d,e){var f=0;f=o[a+32>>2];o[f>>2]=o[f>>2]+1;jb(a,Od(a,b,e));jb(a,Od(a,c,e));jb(a,Od(a,d,e));}function lp(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;co(o[c+12>>2],s[c+8>>2]);K=c+16|0;}function _q(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;Zq(o[c+12>>2],s[c+8>>2]);K=c+16|0;}function Yd(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;Oh(o[c+12>>2],s[c+8>>2]);K=c+16|0;}function Ud(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;Nw(o[c+12>>2],s[c+8>>2]);K=c+16|0;}function Ah(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;K=c;o[c+12>>2]=a;s[c+8>>2]=b;yw(o[c+12>>2],s[c+8>>2]);K=c+16|0;}function zq(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;_f(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function yq(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;Zf(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function vr(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;ur(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function td(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];if(a){o[6258]=o[6258]+1;l[o[4969]](a);}K=b+16|0;}function sl(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=o[b>>2];a=l[o[o[a>>2]+56>>2]](a,116)|0;jj(a,b,c,d);return a|0}function rq(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;qq(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function pq(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;oq(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function nh(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;nv(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function kq(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;jq(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function kp(a){var b=0;b=K-16|0;o[b+12>>2]=a;a=o[b+12>>2];o[a>>2]=1556;s[a+4>>2]=1;o[a+8>>2]=1;o[a+12>>2]=-1;}function jr(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;Ii(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function hr(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;dj(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function hq(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;Zb(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function cs(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;bs(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function Wr(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;ke(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function Pt(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;fb(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function Ns(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;Ms(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function Ls(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;Ks(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function Lq(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;hd(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function Ip(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;Bh(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function Gp(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;Fp(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function Eq(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;Dq(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function Ee(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;Mj(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function Cq(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;$f(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function pl(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=o[b>>2];a=l[o[o[a>>2]+56>>2]](a,16)|0;Cl(a,b,c,d);return a|0}function nl(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=o[b>>2];a=l[o[o[a>>2]+56>>2]](a,16)|0;Ak(a,b,c,d);return a|0}function Ca(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];o[(K-16|0)+12>>2]=a;K=b+16|0;return a|0}function ag(a){var b=0;b=K-16|0;o[b+12>>2]=a;a=o[b+12>>2];m[a+16|0]=1;o[a+12>>2]=0;o[a+4>>2]=0;o[a+8>>2]=0;}function Jr(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=_(200);qd(a,o[b+12>>2],rd());K=b+16|0;return a|0}function $q(a){a=v(a);var b=0,c=0;b=K-16|0;K=b;s[b+12>>2]=a;c=_(56);Xf(c,s[b+12>>2]);K=b+16|0;return c|0}function hu(a){var b=0,c=0;b=K-16|0;K=b;o[b+8>>2]=o[a+4>>2];if(!p[o[b+8>>2]]){c=gu(a);}K=b+16|0;return c}function Y(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];if(a){l[o[o[a>>2]+4>>2]](a);}K=b+16|0;}function $r(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=qa(10448);em(a,o[b+12>>2]);K=b+16|0;return a|0}function pt(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;s[o[c+12>>2]+100>>2]=s[c+8>>2];}function ps(a){a=a|0;var b=0;b=K-16|0;K=b;m[b+15|0]=a;a=_(172);Pd(a,m[b+15|0]&1,1);K=b+16|0;return a|0}function mt(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;s[o[c+12>>2]+104>>2]=s[c+8>>2];}function kt(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;s[o[c+12>>2]+112>>2]=s[c+8>>2];}function it(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;s[o[c+12>>2]+116>>2]=s[c+8>>2];}function gt(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;s[o[c+12>>2]+120>>2]=s[c+8>>2];}function Pk(a,b){a=a|0;o[a+8>>2]=1065353216;o[a+12>>2]=0;o[a>>2]=1065353216;o[a+4>>2]=1065353216;}function Gs(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=_(100);xh(a,o[b+12>>2],1);K=b+16|0;return a|0}function tt(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;s[o[c+12>>2]+92>>2]=s[c+8>>2];}function rt(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;s[o[c+12>>2]+96>>2]=s[c+8>>2];}function Xq(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;s[o[c+12>>2]+48>>2]=s[c+8>>2];}function Ts(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;o[o[c+12>>2]+108>>2]=o[c+8>>2];}function Rs(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;o[o[c+12>>2]+112>>2]=o[c+8>>2];}function Ho(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=K-16|0;K=a;o[a+12>>2]=o[b+12>>2];K=a+16|0;K=b+16|0;}function rs(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=qa(88);Ze(a,o[b+12>>2]);K=b+16|0;return a|0}function pp(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;o[o[c+12>>2]+72>>2]=o[c+8>>2];}function _o(a,b,c){var d=0;d=K-16|0;K=d;o[d+12>>2]=b;o[d+8>>2]=c;Yb(a,o[d+12>>2],o[d+8>>2]);K=d+16|0;}function Yr(a){a=a|0;var b=0;b=K-16|0;K=b;m[b+15|0]=a;a=_(200);ne(a,m[b+15|0]&1);K=b+16|0;return a|0}function Rq(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;s[o[c+12>>2]+4>>2]=s[c+8>>2];}function Pq(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;s[o[c+12>>2]+8>>2]=s[c+8>>2];}function Ow(){var a=0;a=K-16|0;o[a+12>>2]=19888;o[a+8>>2]=2139095040;o[o[a+12>>2]>>2]=o[a+8>>2];xu();}function Mq(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=_(676);Ao(a,o[b+12>>2]);K=b+16|0;return a|0}function xt(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;o[o[c+12>>2]+8>>2]=o[c+8>>2];}function wp(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=_(60);Pv(a,o[b+12>>2]);K=b+16|0;return a|0}function wb(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];ot(a);o[(K-16|0)+12>>2]=a+48;K=b+16|0;}function kg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;o[o[c+12>>2]+4>>2]=o[c+8>>2];}function ea(a){a=a|0;var b=0,c=v(0);b=K-16|0;K=b;o[b+12>>2]=a;c=Pl(o[b+12>>2]);K=b+16|0;return v(c)}function ds(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=_(60);qw(a,o[b+12>>2]);K=b+16|0;return a|0}function Ea(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=0;o[b+4>>2]=a;o[b>>2]=a;o[b+8>>2]=a+1;fu(b);K=b+16|0;}function Sq(a,b){a=a|0;b=v(b);var c=0;c=K-16|0;o[c+12>>2]=a;s[c+8>>2]=b;s[o[c+12>>2]>>2]=s[c+8>>2];}function Ao(a,b){_c(a);m[a+560|0]=1;o[a>>2]=2244;o[a+556>>2]=0;o[a+548>>2]=0;o[a+552>>2]=0;Gf(a,b);}function hg(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;o[o[c+12>>2]>>2]=o[c+8>>2];}function rp(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;sd(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function eg(a){var b=0,c=v(0);b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];c=Ga(a,a);K=b+16|0;return c}function db(a){var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];o[(K-16|0)+12>>2]=a;ag(a);K=b+16|0;}function Fp(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=a;o[c+8>>2]=b;Yf(o[c+12>>2],o[c+8>>2]);K=c+16|0;}function Co(a){var b=0,c=v(0);b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];c=Bo(a,a);K=b+16|0;return c}function _n(a,b){a=a|0;b=b|0;if(!(!b|!(o[b+252>>2]&2))){l[o[o[a>>2]+92>>2]](a,b);return}Rc(a,b);}function Ws(a,b){a=a|0;b=+b;var c=0;c=K-16|0;o[c+12>>2]=a;t[c>>3]=b;s[o[c+12>>2]+80>>2]=t[c>>3];}function Ut(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(pa(a,o[b+8>>2],f)){Dd(b,c,d,e);}}function ic(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];if(a){ta(a);aa(a);}K=b+16|0;}function fu(a){var b=0;b=K-16|0;K=b;o[b+8>>2]=o[a+4>>2];m[o[b+8>>2]]=1;m[o[a+8>>2]]=1;K=b+16|0;}function Qb(a,b){if(!(p[a+204|0]&3?!b:0)){if((o[a+220>>2]&-2)!=4){o[a+220>>2]=1;}o[a+224>>2]=0;}}function ss(){var a=0,b=0,c=0;a=K-32|0;K=a;b=qa(88);c=a+8|0;fg(c);Ze(b,c);K=a+32|0;return b|0}function ka(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=Sb(o[b+12>>2])&1;K=b+16|0;return a|0}function he(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=pd(o[b+12>>2])&1;K=b+16|0;return a|0}function eq(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=dq(o[b+12>>2])&1;K=b+16|0;return a|0}function $b(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];Ca(a);K=b+16|0;return a|0}function Vr(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=Ur(o[b+12>>2]);K=b+16|0;return a|0}function Ql(a,b){a=a|0;b=b|0;var c=0;c=b;b=o[a+8>>2];l[o[b+64>>2]](c,b,o[a+4>>2]);return 0}function qp(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];Sf(a);td(a);K=b+16|0;}function ld(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];Ca(a);aa(a);K=b+16|0;}function hc(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];if(a){td(a);}K=b+16|0;}function Xo(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];kd(a);aa(a);K=b+16|0;}function Pf(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];$b(a);aa(a);K=b+16|0;}function Jo(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];Ca(a);td(a);K=b+16|0;}function Fu(a,b,c,d,e,f){if(p[a+60|0]){Zg(a,b,c,d,e,f,o[a+56>>2]);return}_g(a,b,c,d,e,f);}function Da(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];if(a){aa(a);}K=b+16|0;}function $o(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=o[b+12>>2];Lf(a);aa(a);K=b+16|0;}function zu(a){a=a|0;a=25024;while(1){a=a+ -36|0;Jd(a);if((a|0)!=22720){continue}break}}function xh(a,b,c){var d=0;d=Td(a);o[a+96>>2]=b;o[a>>2]=13652;o[a+4>>2]=3;if(c){yb(d);}}function ir(){var a=0;a=_(164);Td(a);o[a+96>>2]=0;o[a>>2]=10820;o[a+4>>2]=2;return a|0}function bj(a){a=a|0;a=o[a+96>>2]+ -2|0;if(a>>>0<=2){return o[(a<<2)+11e3>>2]}return 0}function Cp(a,b){var c=0;c=K-16|0;K=c;o[c+12>>2]=b;b=o[c+12>>2];Ca(a);fb(b,a);K=c+16|0;}function Fb(a,b,c){b=v(b);c=c|0;o[c>>2]=0;o[c+4>>2]=0;o[c+8>>2]=0;o[c+12>>2]=0;}function Bi(a,b){a=a|0;o[a+8>>2]=0;o[a+12>>2]=0;o[a>>2]=0;o[a+4>>2]=1065353216;}function vi(a,b,c){a=a|0;o[a>>2]=0;o[a+4>>2]=0;o[a+8>>2]=0;o[a+12>>2]=0;}function Bv(a,b,c,d){var e=0;e=o[a+32>>2];o[e>>2]=o[e>>2]+1;jb(a,b);jb(a,c);jb(a,d);}function no(a,b){a=a|0;b=b|0;o[a+200>>2]=b;o[a+192>>2]=b;o[a+304>>2]=o[a+304>>2]+1;}function ck(a,b){a=a|0;b=b|0;l[o[o[b>>2]+32>>2]](b);He(a,b);l[o[o[b>>2]+36>>2]](b);}function Pj(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=a+ -4|0;l[o[o[a>>2]+8>>2]](a,b,c,d);}function qt(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return v(s[o[b+12>>2]+100>>2])}function nt(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return v(s[o[b+12>>2]+104>>2])}function lt(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return v(s[o[b+12>>2]+112>>2])}function jt(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return v(s[o[b+12>>2]+116>>2])}function ht(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return v(s[o[b+12>>2]+120>>2])}function Uc(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;a=pk();K=b+16|0;return a|0}function ut(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return v(s[o[b+12>>2]+92>>2])}function st(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return v(s[o[b+12>>2]+96>>2])}function je(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;Qb(o[b+12>>2],0);K=b+16|0;}function ws(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return v(s[o[b+12>>2]+4>>2])}function Qq(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return v(s[o[b+12>>2]+8>>2])}function uq(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;jd(o[b+12>>2]);K=b+16|0;}function ta(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;eb(o[b+12>>2]);K=b+16|0;}function fv(a,b){a=a|0;b=b|0;a=o[a+4>>2];return (a|0)==o[b>>2]|(a|0)==o[b+4>>2]}function cq(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;aq(o[b+12>>2]);K=b+16|0;}function Zp(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;Yp(o[b+12>>2]);K=b+16|0;}function Vs(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[o[b+12>>2]+108>>2]}function Ss(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[o[b+12>>2]+112>>2]}function Rw(a){var b=0;b=a&31;a=0-a&31;return (-1>>>b&-2)<<b|(-1<<a&-2)>>>a}



            function Jp(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;ud(o[b+12>>2]);K=b+16|0;}function op(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[o[b+12>>2]+72>>2]}function au(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;if(pa(a,o[b+8>>2],0)){Ed(b,c,d);}}function Xs(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return +s[o[b+12>>2]+80>>2]}function Tq(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return v(s[o[b+12>>2]>>2])}function xo(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[o[b+12>>2]+8>>2]}function bf(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[o[b+12>>2]+4>>2]}function ch(a,b){a=a|0;b=b|0;a=o[a+4>>2];l[o[o[a>>2]+8>>2]](a,o[b+36>>2])|0;}function Zs(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[b+12>>2]- -64|0}function mq(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[b+12>>2]+348|0}function jg(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[o[b+12>>2]>>2]}function _j(a,b){a=a|0;b=b|0;a=o[a+20>>2];return l[o[o[a>>2]+8>>2]](a,b)|0}function Xj(a,b){a=a|0;b=b|0;a=o[a+16>>2];return l[o[o[a>>2]+8>>2]](a,b)|0}function Gk(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;l[o[o[a>>2]+124>>2]](a,d,b,c);}function yg(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[b+12>>2]+44|0}function wg(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[b+12>>2]+60|0}function sg(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[b+12>>2]+24|0}function qg(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[b+12>>2]+40|0}function kj(a,b,c){a=a|0;b=b|0;c=c|0;o[5645]=o[5645]+1;return mj(a,b,c)|0}function hk(a){a=a|0;var b=0;b=K-16|0;K=b;o[b+12>>2]=a;Nf(20020);K=b+16|0;}function at(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[b+12>>2]+16|0}function Wv(a){a=a|0;o[a>>2]=14676;if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function Rm(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[b+12>>2]+48|0}function Re(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;l[o[o[a>>2]+80>>2]](a,b,c,d);}function Qt(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[b+12>>2]+32|0}function Xb(a){a=a|0;o[a>>2]=3492;if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function Sj(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;l[o[o[a>>2]+8>>2]](a,b,c,d);}function Ru(a,b){a=a|0;b=b|0;l[o[o[a>>2]+8>>2]](a,b,o[o[a+8>>2]+48>>2]);}function ui(a,b,c,d){c=c|0;d=d|0;if((d|0)>=1){$(c,0,d<<4);}}function mp(a,b){a=a|0;b=b|0;var c=0;c=K-16|0;o[c+12>>2]=a;o[c+8>>2]=b;}function Mw(a,b){a=a|0;b=v(b);return v(v(v(l[o[o[a>>2]+16>>2]](a))*b))}function tb(a){a=a|0;var b=0;b=K-16|0;o[b+12>>2]=a;return o[b+12>>2]}function _i(a){a=a|0;a=o[a+96>>2];return ((a|0)==4?4:((a|0)==3)<<1)|0}function zm(a){a=a|0;a=lf(a);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function yv(a){a=a|0;a=lh(a);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function yi(a){a=a|0;a=ge(a);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function uv(a){a=a|0;a=jh(a);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function pb(a,b,c,d,e){return v(v(1))}function lo(a){a=a|0;a=gd(a);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function fj(a,b,c,d,e){return v(v(0))}function Xi(a){a=a|0;a=me(a);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function Ku(a){a=a|0;a=Ac(a);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function $m(a,b){a=a|0;b=b|0;a=p[a+344|0]?0:3;o[b+4>>2]=a;o[b>>2]=a;}function _m(a,b){a=a|0;b=b|0;Zm(a,b,o[a+28>>2]+4|0,o[a+32>>2]+4|0);}function bw(a){a=a|0;Ac(a);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function aw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Yg(a,b,c,d)|0}function Gb(a){a=a|0;kb(a);if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function Ha(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;Gl(a,b,c,d);}function ci(a,b,c){a=a|0;b=b|0;c=c|0;l[o[o[b>>2]+68>>2]](a,b,c);}function Rl(a){a=a|0;if(!o[a+12>>2]){return 0}return o[a+20>>2]}function vk(a,b,c){a=a|0;b=b|0;c=c|0;o[a+24>>2]=c;o[a+16>>2]=b;}function uk(a,b,c){a=a|0;b=b|0;c=c|0;o[a+28>>2]=c;o[a+20>>2]=b;}function $j(a,b,c){a=a|0;b=b|0;c=v(c);l[o[o[a>>2]+12>>2]](a,b);}function wf(a,b){a=a|0;b=b|0;return o[o[a+236>>2]+(b<<2)>>2]}function cr(){var a=0;a=_(16);o[(K-16|0)+12>>2]=a;return a|0}function Sl(a,b){a=a|0;b=b|0;return o[o[a+20>>2]+(b<<2)>>2]}function Oa(a){a=a|0;if(a){o[6258]=o[6258]+1;l[o[4969]](a);}}function Lr(){var a=0;a=_(200);qd(a,rd(),rd());return a|0}function zb(a){sa(a);o[a+56>>2]=0;o[a>>2]=12632;return a}function cj(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Sd(a,b,c,d);}function $n(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Je(a,b,c,d);}function pi(a){a=a|0;return v(v(s[a+32>>2]*s[a+16>>2]))}function zf(a,b){a=a|0;b=b|0;l[o[o[a>>2]+68>>2]](a,b);}function vn(a,b,c,d,e){e=v(e);}function Af(a,b){a=a|0;b=b|0;l[o[o[a>>2]+64>>2]](a,b);}function Dl(a,b,c,d,e){}function uu(a){a=a|0;if(a){l[o[4971]](o[a+ -4>>2]);}}function qs(){var a=0;a=_(172);Pd(a,1,1);return a|0}function np(a){a=a|0;o[(K-16|0)+12>>2]=a;return 2}function Zr(){var a=0;a=_(200);ne(a,1);return a|0}function ub(a,b,c){_a(a+4|0,a+372|0,a+388|0,b,c);}function Lt(){var a=0;a=qa(176);ev(a);return a|0}function js(){var a=0;a=_(868);sb(a);return a|0}function Wq(){var a=0;a=qa(24);fg(a);return a|0}function Qs(){var a=0;a=_(236);mf(a);return a|0}function Np(){var a=0;a=qa(64);wb(a);return a|0}function Ej(){var a=0;a=_(324);_c(a);return a|0}function pe(a,b,c){c=v(c);return 0}function Hi(a,b,c){a=a|0;b=b|0;c=c|0;Ic(a,b,c);}function uf(a,b,c,d){d=v(d);}function Xv(a){a=a|0;o[a>>2]=14676;return a|0}function vf(a){a=a|0;o[a>>2]=3492;return a|0}function cc(a){a=a|0;o[(K-16|0)+12>>2]=a;D();}function Xu(a,b){a=a|0;b=b|0;Wu(a,b);Vu(a,b);}function Cb(a,b,c,d){}function sh(a){Qu(a);o[a>>2]=14348;return a}function Qw(a,b,c,d){a=Pw(a,b,c,d);return a}function Ev(a){a=a|0;return o[a+48>>2]==1|0}function Au(a){a=a|0;a=o[5678];if(a){aa(a);}}function tw(a){a=a|0;return o[a+96>>2]+4|0}function qi(a,b){a=a|0;b=v(b);s[a+48>>2]=b;}function ei(a,b){a=a|0;b=v(b);s[a+16>>2]=b;}function _h(a){a=a|0;return o[a+52>>2]+4|0}function Mi(a,b){a=a|0;b=v(b);s[a+76>>2]=b;}function Hh(a,b){a=a|0;b=b|0;xb(a,b);yb(a);}function iv(a,b){a=a|0;b=b|0;o[a+24>>2]=b;}function hv(a,b){a=a|0;b=b|0;o[a+68>>2]=b;}function di(a){a=a|0;return v(s[a+16>>2])}function Ok(a){a=a|0;return v(s[a+48>>2])}function Li(a){a=a|0;return v(s[a+76>>2])}function Vm(a){a=a|0;return o[a+332>>2]}function Fn(a){a=a|0;return o[a+216>>2]}function En(a){a=a|0;return o[a+228>>2]}function Dm(a){a=a|0;return o[a+748>>2]}function xv(a){a=a|0;return o[a+24>>2]}function gf(a){a=a|0;return o[a+72>>2]}function Tl(a){a=a|0;return o[a+12>>2]}function Kb(a){a=a|0;return o[a+16>>2]}function Jc(a){a=a|0;return o[a+96>>2]}function cw(a){a=a|0;Ac(a);return a|0}function Zi(a,b){return 0}function We(a){a=a|0;return o[a+8>>2]}function Gh(a,b,c){b=v(b);}function Ge(a,b){return 1}function oa(a,b,c){}function St(a,b){a=a|0;b=b|0;l[a](b);}function ru(a){a=a|0;return Bd(a)|0}function Rv(a){a=a|0;return a+112|0}function Rj(a){a=a|0;return a+ -4|0}function Oi(a){a=a|0;return a+184|0}function km(a){a=a|0;o[a+232>>2]=0;}function Rk(a){a=a|0;return a+16|0}function Qh(a){a=a|0;return a+72|0}function Eh(a){a=a|0;return a+20|0}function zw(a){return 13612}function sw(a){return 13880}function ri(a){return 11508}function ow(a){return 14168}function jv(a){a=a|0;return a+4|0}function fi(a){return 12132}function Yi(a){return 10980}function Xh(a){return 12460}function Tt(a){return D()|0}function Qv(a){return 14788}function Ph(a){return 12588}function Ni(a){return 11168}function Lv(a){return 14936}function Dh(a){return 13084}function Ci(a){return 11308}function Qk(a){return 6728}function Qj(a){a=a|0;aa(a+ -4|0);}function un(a){return 644}function ro(a){return 496}function fm(a){return 264}function ca(a){a=a|0;return a|0}function Fm(a){return 220}function yl(a){a=a|0;aa(Ye(a));}function wv(a){return 28}function uj(a){a=a|0;aa(Lc(a));}function qf(a){return 84}function ok(a){a=a|0;aa(Sc(a));}function oj(a){a=a|0;aa(ue(a));}function ij(a){a=a|0;aa(re(a));}function cv(a){a=a|0;aa(fh(a));}function cd(a){return 52}function Xd(a){return 12}function Ki(a){return 24}function Dj(a){a=a|0;aa(Be(a));}function Ab(a){return 60}function th(a){return 6}function lb(a){return 0}function jf(a){return 1}function iw(a){return 8}function Qe(a){return 3}function Pe(a,b){b=v(b);}function Kk(a){return 2}function Pa(a,b){}function Rt(a){a=a|0;l[a]();}function X(a){a=a|0;aa(a);}function Kn(){return 1272}function za(a){D();}function tp(){return 0}function sp(){return 5}function Wf(){return 1}function Vf(){return 2}function Uf(){return 3}function Tf(){return 4}function Za(a){}function eu(){D();}function yu(){}
            // EMSCRIPTEN_END_FUNCS
            l[1]=hk;l[2]=Pr;l[3]=Sf;l[4]=qp;l[5]=mk;l[6]=lk;l[7]=pp;l[8]=op;l[9]=jo;l[10]=fk;l[11]=gk;l[12]=$n;l[13]=_n;l[14]=kk;l[15]=Cn;l[16]=fo;l[17]=Vn;l[18]=Un;l[19]=Tn;l[20]=Sn;l[21]=bo;l[22]=ao;l[23]=go;l[24]=Yn;l[25]=Xn;l[26]=Zn;l[27]=Gn;l[28]=Fn;l[29]=En;l[30]=wf;l[31]=wf;l[32]=np;l[33]=io;l[34]=Af;l[35]=zf;l[36]=Af;l[37]=zf;l[38]=In;l[39]=Jn;l[40]=Pn;l[41]=Rn;l[42]=Wn;l[43]=eo;l[44]=wq;l[45]=ko;l[46]=Hn;l[47]=Yq;l[48]=mp;l[49]=lp;l[50]=Ca;l[51]=ld;l[52]=Rf;l[53]=Qf;l[54]=tb;l[55]=cc;l[56]=eu;l[57]=Ca;l[58]=ld;l[59]=jp;l[60]=tb;l[61]=cc;l[62]=$b;l[63]=Pf;l[64]=ip;l[65]=hp;l[66]=Lf;l[67]=$o;l[68]=Zo;l[69]=Yo;l[70]=kd;l[71]=Xo;l[72]=Wo;l[73]=Kf;l[74]=tb;l[75]=cc;l[76]=$b;l[77]=Pf;l[78]=No;l[79]=Mo;l[80]=Ca;l[81]=ld;l[82]=If;l[83]=Ca;l[84]=Jo;l[85]=Io;l[86]=Go;l[87]=tb;l[88]=cc;l[89]=Nf;l[90]=oo;l[91]=no;l[92]=mo;l[93]=ro;l[94]=qo;l[95]=po;l[96]=gd;l[97]=lo;l[98]=Mn;l[99]=ho;l[100]=Bn;l[101]=An;l[102]=zn;l[103]=X;l[104]=yn;l[105]=xn;l[106]=vf;l[107]=Xb;l[108]=Za;l[109]=vn;l[110]=jn;l[111]=hn;l[112]=uf;l[113]=en;l[114]=dn;l[115]=un;l[116]=tn;l[117]=vf;l[118]=Xb;l[119]=Xb;l[120]=an;l[121]=$m;l[122]=_m;l[123]=Ym;l[124]=Xm;l[125]=qf;l[126]=Wm;l[127]=Vm;l[128]=Sm;l[129]=za;l[130]=Za;l[131]=cd;l[132]=Vb;l[133]=Xb;l[134]=Om;l[135]=Nm;l[136]=Mm;l[137]=Hm;l[138]=Gm;l[139]=Fm;l[140]=Em;l[141]=Dm;l[142]=Cm;l[143]=Bm;l[144]=Am;l[145]=lf;l[146]=zm;l[147]=oa;l[148]=lm;l[149]=oa;l[150]=km;l[151]=jf;l[152]=sm;l[153]=pm;l[154]=nm;l[155]=qm;l[156]=rm;l[157]=om;l[158]=Rb;l[159]=hm;l[160]=fm;l[161]=hf;l[162]=gm;l[163]=dm;l[164]=cm;l[165]=bm;l[166]=Zl;l[167]=am;l[168]=_l;l[169]=$l;l[170]=Xl;l[171]=Yl;l[172]=Wl;l[173]=Tl;l[174]=Sl;l[175]=Rl;l[176]=gf;l[177]=gf;l[178]=Vl;l[179]=Ul;l[180]=ca;l[181]=X;l[182]=Ql;l[183]=Ma;l[184]=Hw;l[185]=ca;l[186]=X;l[187]=Jl;l[188]=ca;l[189]=X;l[190]=Ha;l[191]=X;l[192]=Fl;l[193]=ca;l[194]=X;l[195]=oa;l[196]=oa;l[197]=El;l[198]=ca;l[199]=X;l[200]=Dl;l[201]=pb;l[202]=Pa;l[203]=ca;l[204]=za;l[205]=Bl;l[206]=Al;l[207]=zl;l[208]=pb;l[209]=Lb;l[210]=Ye;l[211]=yl;l[212]=We;l[213]=Kb;l[214]=wl;l[215]=xl;l[216]=ca;l[217]=X;l[218]=vl;l[219]=X;l[220]=ul;l[221]=X;l[222]=tl;l[223]=X;l[224]=sl;l[225]=X;l[226]=rl;l[227]=X;l[228]=ql;l[229]=X;l[230]=pl;l[231]=X;l[232]=ol;l[233]=X;l[234]=nl;l[235]=X;l[236]=ml;l[237]=kl;l[238]=jl;l[239]=hl;l[240]=gl;l[241]=cl;l[242]=bl;l[243]=$k;l[244]=pb;l[245]=Lb;l[246]=ca;l[247]=X;l[248]=Te;l[249]=_k;l[250]=Zk;l[251]=Tk;l[252]=Sk;l[253]=Yk;l[254]=Xk;l[255]=Wk;l[256]=Vk;l[257]=kb;l[258]=Gb;l[259]=Re;l[260]=Ch;l[261]=Lw;l[262]=Mw;l[263]=xb;l[264]=Rk;l[265]=Fb;l[266]=Qk;l[267]=Pk;l[268]=Xq;l[269]=Ok;l[270]=cd;l[271]=Nk;l[272]=Jw;l[273]=zh;l[274]=Mk;l[275]=Iw;l[276]=Lk;l[277]=Gw;l[278]=Kk;l[279]=Jk;l[280]=Mh;l[281]=Qe;l[282]=Qe;l[283]=Ik;l[284]=Hk;l[285]=jf;l[286]=Gk;l[287]=Fk;l[288]=Ek;l[289]=ca;l[290]=X;l[291]=Dk;l[292]=Pe;l[293]=Pa;l[294]=oa;l[295]=ca;l[296]=X;l[297]=X;l[298]=Oe;l[299]=zk;l[300]=yk;l[301]=xk;l[302]=pb;l[303]=Lb;l[304]=X;l[305]=vk;l[306]=uk;l[307]=wk;l[308]=X;l[309]=Tc;l[310]=X;l[311]=oa;l[312]=oa;l[313]=tk;l[314]=X;l[315]=Me;l[316]=za;l[317]=sk;l[318]=za;l[319]=rk;l[320]=Sc;l[321]=ok;l[322]=Ie;l[323]=Je;l[324]=Rc;l[325]=ck;l[326]=X;l[327]=bk;l[328]=ca;l[329]=X;l[330]=oa;l[331]=ak;l[332]=$j;l[333]=Ge;l[334]=Ge;l[335]=X;l[336]=_j;l[337]=Zj;l[338]=X;l[339]=Fe;l[340]=X;l[341]=Fe;l[342]=X;l[343]=Yj;l[344]=X;l[345]=Xj;l[346]=Wj;l[347]=ca;l[348]=X;l[349]=Vj;l[350]=X;l[351]=Uj;l[352]=ca;l[353]=X;l[354]=Tj;l[355]=Sj;l[356]=Rj;l[357]=Qj;l[358]=Pj;l[359]=X;l[360]=De;l[361]=Kj;l[362]=Jj;l[363]=Ij;l[364]=pb;l[365]=Lb;l[366]=ca;l[367]=X;l[368]=Aj;l[369]=Be;l[370]=Dj;l[371]=Cj;l[372]=Bj;l[373]=zj;l[374]=X;l[375]=oa;l[376]=oa;l[377]=uf;l[378]=X;l[379]=oa;l[380]=oa;l[381]=yj;l[382]=X;l[383]=xj;l[384]=Lc;l[385]=uj;l[386]=xe;l[387]=sj;l[388]=rj;l[389]=X;l[390]=qj;l[391]=ue;l[392]=oj;l[393]=lj;l[394]=kj;l[395]=Kb;l[396]=re;l[397]=ij;l[398]=gj;l[399]=fj;l[400]=hj;l[401]=X;l[402]=ej;l[403]=Pa;l[404]=Gb;l[405]=cj;l[406]=Hh;l[407]=Ih;l[408]=Yi;l[409]=Kh;l[410]=Jh;l[411]=lb;l[412]=oa;l[413]=Jc;l[414]=bj;l[415]=aj;l[416]=$i;l[417]=_i;l[418]=Cb;l[419]=pe;l[420]=Zi;l[421]=me;l[422]=Xi;l[423]=Si;l[424]=Qi;l[425]=Oi;l[426]=Ri;l[427]=Ni;l[428]=Mi;l[429]=Li;l[430]=Ki;l[431]=Pi;l[432]=Ui;l[433]=Ti;l[434]=ca;l[435]=Oa;l[436]=Re;l[437]=Ei;l[438]=Di;l[439]=Ci;l[440]=Bi;l[441]=Ab;l[442]=Ai;l[443]=Fi;l[444]=Hi;l[445]=Gi;l[446]=ge;l[447]=yi;l[448]=Oa;l[449]=de;l[450]=si;l[451]=ri;l[452]=qi;l[453]=pi;l[454]=ti;l[455]=vi;l[456]=ui;l[457]=oi;l[458]=ni;l[459]=$h;l[460]=ji;l[461]=_h;l[462]=Fb;l[463]=fi;l[464]=ei;l[465]=di;l[466]=Ab;l[467]=ii;l[468]=ki;l[469]=Yh;l[470]=ci;l[471]=hi;l[472]=gi;l[473]=ca;l[474]=X;l[475]=$d;l[476]=X;l[477]=$d;l[478]=X;l[479]=bi;l[480]=ca;l[481]=Oa;l[482]=Zd;l[483]=Xh;l[484]=Xd;l[485]=Na;l[486]=Zh;l[487]=ca;l[488]=X;l[489]=Wh;l[490]=X;l[491]=Vh;l[492]=ca;l[493]=Oa;l[494]=Th;l[495]=Rh;l[496]=Qh;l[497]=Fb;l[498]=Ph;l[499]=cd;l[500]=Nh;l[501]=Sh;l[502]=za;l[503]=za;l[504]=Sd;l[505]=ca;l[506]=Oa;l[507]=de;l[508]=Fh;l[509]=Eh;l[510]=Gh;l[511]=Dh;l[512]=Cb;l[513]=za;l[514]=za;l[515]=Oa;l[516]=Bw;l[517]=Aw;l[518]=Cw;l[519]=zw;l[520]=yh;l[521]=Pe;l[522]=Ab;l[523]=xw;l[524]=Ew;l[525]=Dw;l[526]=Gb;l[527]=uw;l[528]=tw;l[529]=sw;l[530]=zh;l[531]=ww;l[532]=vw;l[533]=lb;l[534]=lb;l[535]=Cb;l[536]=oa;l[537]=lb;l[538]=Cb;l[539]=pe;l[540]=X;l[541]=rw;l[542]=ca;l[543]=za;l[544]=Gb;l[545]=vh;l[546]=uh;l[547]=pw;l[548]=ow;l[549]=Ec;l[550]=nw;l[551]=mw;l[552]=lw;l[553]=th;l[554]=kw;l[555]=iw;l[556]=Xd;l[557]=hw;l[558]=gw;l[559]=th;l[560]=fw;l[561]=ew;l[562]=dw;l[563]=cw;l[564]=bw;l[565]=Yg;l[566]=qf;l[567]=Cu;l[568]=Eu;l[569]=Du;l[570]=aw;l[571]=X;l[572]=$v;l[573]=X;l[574]=_v;l[575]=Xv;l[576]=Wv;l[577]=Vv;l[578]=Sv;l[579]=Rv;l[580]=Fb;l[581]=Qv;l[582]=Tv;l[583]=Uv;l[584]=Oa;l[585]=vh;l[586]=uh;l[587]=Ov;l[588]=Lv;l[589]=yh;l[590]=Ec;l[591]=Ab;l[592]=Kv;l[593]=Jv;l[594]=Nv;l[595]=Mv;l[596]=Iv;l[597]=ph;l[598]=Fv;l[599]=Hv;l[600]=oh;l[601]=oh;l[602]=Pa;l[603]=Pa;l[604]=xv;l[605]=Pa;l[606]=Pa;l[607]=Ev;l[608]=Dv;l[609]=Cv;l[610]=wv;l[611]=Gv;l[612]=lh;l[613]=yv;l[614]=Av;l[615]=zv;l[616]=jh;l[617]=uv;l[618]=kv;l[619]=ov;l[620]=rv;l[621]=Kb;l[622]=Kb;l[623]=jv;l[624]=tv;l[625]=We;l[626]=sv;l[627]=iv;l[628]=mv;l[629]=qv;l[630]=lb;l[631]=hv;l[632]=lv;l[633]=X;l[634]=gv;l[635]=X;l[636]=fv;l[637]=fh;l[638]=cv;l[639]=bv;l[640]=av;l[641]=Yu;l[642]=$u;l[643]=_u;l[644]=Zu;l[645]=Xu;l[646]=Jc;l[647]=Jc;l[648]=Uu;l[649]=Tu;l[650]=Za;l[651]=X;l[652]=Su;l[653]=Ru;l[654]=X;l[655]=ch;l[656]=X;l[657]=ch;l[658]=Ac;l[659]=Ku;l[660]=za;l[661]=Au;l[662]=zu;l[663]=Za;l[664]=yu;l[665]=su;l[666]=uu;l[667]=ru;l[668]=X;l[669]=ca;l[670]=X;l[671]=Za;l[672]=Za;l[673]=cu;l[674]=Ut;l[675]=Xt;l[676]=au;l[677]=X;l[678]=Vt;l[679]=Yt;l[680]=$t;l[681]=X;l[682]=Wt;l[683]=Zt;l[684]=_t;function M(){return buffer.byteLength/65536|0}return {"__wasm_call_ctors":Ow,"__em_js__array_bounds_check_error":Kn,"a0_1":na,"a1_0":ma,"a2_2":la,"a3_1":Ba,"a4_0":Aa,"a5_0":ka,"a6_0":ja,"a7_1":ia,"a8_0":ha,"a9_1":ga,"a10_3":fa,"a11_0":ea,"a12_0":Y,"a13_3":Ob,"a14_6":Mb,"a15_1":Xe,"a15_2":Ve,"a15_3":Jb,"a16_1":Ib,"a17_1":Hb,"a18_0":Y,"a19_1":na,"a20_0":ma,"a21_2":la,"a22_1":Ba,"a23_0":Aa,"a24_0":ka,"a25_0":ja,"a26_1":ia,"a27_0":ha,"a28_1":ga,"a29_3":fa,"a30_0":ea,"a31_0":Y,"a32_1":Eb,"a33_1":Vc,"a34_0":Uc,"a35_3":Ob,"a36_6":Mb,"a37_1":Xe,"a37_2":Ve,"a37_3":Jb,"a38_1":Ib,"a39_1":Hb,"a40_0":Y,"a41_0":mb,"a42_0":Y,"a43_1":na,"a44_0":ma,"a45_2":la,"a46_0":ka,"a47_0":ja,"a48_1":ia,"a49_0":ha,"a50_1":ga,"a51_3":fa,"a52_0":ea,"a53_0":Y,"a54_1":Ee,"a55_0":Y,"a56_0":Y,"a57_0":Ej,"a58_0":ve,"a59_0":se,"a60_1":qe,"a61_1":oe,"a62_0":je,"a62_1":ie,"a63_0":he,"a64_0":ee,"a65_0":be,"a66_0":ae,"a67_1":Yd,"a68_1":Ud,"a69_1":Ah,"a70_1":wh,"a71_0":Rd,"a72_0":Qd,"a73_1":qh,"a74_1":nh,"a75_1":Dc,"a76_1":ih,"a77_1":hh,"a78_0":dh,"a79_1":bh,"a80_1":ah,"a81_2":Xg,"a82_0":Y,"a83_4":ou,"a84_1":Qg,"a85_0":iu,"a86_1":Mg,"a86_3":Kg,"a87_1":Jg,"a88_1":Ig,"a88_2":Hg,"a89_1":Gg,"a90_1":Fg,"a90_2":Eg,"a90_3":Dg,"a91_3":Ob,"a92_6":Mb,"a93_1":Bg,"a93_2":Ag,"a93_3":Jb,"a94_1":Ib,"a95_1":Hb,"a96_1":Eb,"a97_1":Vc,"a98_0":Uc,"a99_0":Y,"a100_1":Dc,"a101_1":zg,"a102_0":Y,"a103_0":gb,"a104_1":na,"a105_0":ma,"a106_2":la,"a107_1":Ba,"a108_0":Aa,"a109_0":ka,"a110_0":ja,"a111_1":ia,"a112_0":ha,"a113_1":ga,"a114_3":fa,"a115_0":ea,"a116_0":Y,"a117_0":mb,"a118_0":yg,"a119_1":xg,"a120_0":wg,"a121_1":vg,"a122_0":Y,"a123_0":ug,"a124_1":tg,"a125_0":Y,"a126_0":mb,"a127_0":sg,"a128_1":rg,"a129_0":qg,"a130_1":pg,"a131_0":Y,"a132_1":na,"a133_0":ma,"a134_2":la,"a135_0":ka,"a136_0":ja,"a137_1":ia,"a138_0":ha,"a139_1":ga,"a140_3":fa,"a141_0":ea,"a142_0":Y,"a143_0":Ad,"a144_0":zd,"a145_0":yd,"a146_0":og,"a147_1":xd,"a148_1":wd,"a149_1":vd,"a150_1":ng,"a151_0":Da,"a152_1":rc,"a153_0":qc,"a154_1":pc,"a155_2":oc,"a156_3":nc,"a157_0":Y,"a158_1":Pt,"a159_0":Da,"a160_0":lc,"a161_1":Ot,"a162_0":ta,"a163_0":ic,"a164_2":Nt,"a164_3":Mt,"a165_1":na,"a166_0":ma,"a167_2":la,"a168_0":ka,"a169_0":ja,"a170_1":ia,"a171_0":ha,"a172_1":ga,"a173_3":fa,"a174_0":ea,"a175_0":Y,"a176_0":Lt,"a177_0":Y,"a178_0":lc,"a179_1":Kt,"a180_0":ta,"a181_0":ic,"a182_2":Jt,"a183_0":Gt,"a184_0":Ft,"a185_0":Et,"a186_0":Dt,"a187_2":Ct,"a188_0":mb,"a189_0":yg,"a190_1":xg,"a191_0":wg,"a192_1":vg,"a193_0":Y,"a194_2":At,"a195_1":Ba,"a196_0":Aa,"a197_3":zt,"a198_1":na,"a199_0":ma,"a200_2":la,"a201_0":ka,"a202_0":ja,"a203_1":ia,"a204_0":ha,"a205_1":ga,"a206_3":fa,"a207_0":ea,"a208_0":gb,"a209_0":Y,"a210_0":bf,"a211_1":kg,"a212_0":xo,"a213_1":xt,"a214_0":hc,"a215_0":jg,"a216_1":hg,"a217_0":hc,"a218_3":wt,"a218_4":vt,"a219_0":ut,"a220_1":tt,"a221_0":st,"a222_1":rt,"a223_0":qt,"a224_1":pt,"a225_0":nt,"a226_1":mt,"a227_0":lt,"a228_1":kt,"a229_0":jt,"a230_1":it,"a231_0":ht,"a232_1":gt,"a233_0":Da,"a234_0":ft,"a235_0":et,"a236_0":ct,"a237_0":Qd,"a238_0":tb,"a239_1":bt,"a240_0":at,"a241_1":$s,"a242_0":Rm,"a243_1":Bh,"a244_0":Qt,"a245_1":_s,"a246_0":Zs,"a247_1":Ys,"a248_0":Xs,"a249_1":Ws,"a250_0":Vs,"a251_1":Ts,"a252_0":Ss,"a253_1":Rs,"a254_0":Da,"a255_0":Qs,"a256_0":Y,"a257_2":Ps,"a257_4":Os,"a258_1":Ns,"a259_1":Ls,"a260_0":Js,"a261_0":Is,"a262_1":rc,"a263_0":qc,"a264_1":pc,"a265_2":oc,"a266_3":nc,"a267_0":mq,"a268_1":Hs,"a269_0":Y,"a270_1":Gs,"a270_2":Fs,"a271_1":na,"a272_0":ma,"a273_2":la,"a274_1":Ba,"a275_0":Aa,"a276_0":ka,"a277_0":ja,"a278_1":ia,"a279_0":ha,"a280_1":ga,"a281_3":fa,"a282_0":ea,"a283_0":Y,"a284_2":Es,"a285_0":Bs,"a286_0":As,"a287_0":ys,"a288_0":xs,"a289_2":vs,"a290_0":mb,"a291_0":sg,"a292_1":rg,"a293_0":qg,"a294_1":pg,"a295_0":Y,"a296_9":ts,"a297_1":Ba,"a298_0":Aa,"a299_1":na,"a300_0":ma,"a301_2":la,"a302_0":ka,"a303_0":ja,"a304_1":ia,"a305_0":ha,"a306_1":ga,"a307_3":fa,"a308_0":ea,"a309_0":Y,"a310_0":Da,"a311_0":ss,"a311_1":rs,"a312_0":Y,"a313_0":qs,"a313_1":ps,"a313_2":os,"a314_3":ns,"a314_4":ms,"a315_3":ls,"a316_0":ks,"a317_1":Ee,"a318_0":Y,"a319_0":Y,"a320_0":js,"a321_0":is,"a322_0":hs,"a323_0":gs,"a324_1":es,"a325_0":hc,"a326_1":ds,"a327_1":Ba,"a328_0":Aa,"a329_1":cs,"a330_1":na,"a331_0":ma,"a332_2":la,"a333_0":ka,"a334_0":ja,"a335_1":ia,"a336_0":ha,"a337_1":ga,"a338_3":fa,"a339_0":ea,"a340_0":gb,"a341_0":Y,"a342_1":$r,"a343_1":_r,"a344_0":ug,"a345_1":tg,"a346_0":Y,"a347_0":Zr,"a347_1":Yr,"a348_2":Xr,"a349_1":Eb,"a350_1":Wr,"a351_0":Vr,"a352_1":Tr,"a353_2":Sr,"a353_3":Rr,"a354_1":Ba,"a355_0":Aa,"a356_3":Qr,"a356_4":Or,"a356_5":Nr,"a356_6":Mr,"a357_1":na,"a358_0":ma,"a359_2":la,"a360_0":ka,"a361_0":ja,"a362_1":ia,"a363_0":ha,"a364_1":ga,"a365_3":fa,"a366_0":ea,"a367_0":Y,"a368_0":Lr,"a368_1":Jr,"a368_2":Ir,"a369_1":Dc,"a370_1":zg,"a371_0":Y,"a372_4":Hr,"a372_5":Fr,"a373_4":Er,"a373_5":Dr,"a374_3":Cr,"a375_1":Ar,"a376_1":zr,"a377_1":yr,"a378_2":xr,"a379_2":wr,"a380_1":vr,"a381_1":pr,"a382_1":rc,"a383_0":qc,"a384_1":pc,"a385_2":oc,"a386_3":nc,"a387_0":Y,"a388_4":or,"a389_4":nr,"a390_0":Ad,"a391_0":zd,"a392_0":yd,"a393_0":og,"a394_1":xd,"a395_1":wd,"a396_1":vd,"a397_1":ng,"a398_0":Da,"a399_2":mr,"a400_1":lr,"a401_1":kr,"a402_1":jr,"a403_1":na,"a404_0":ma,"a405_2":la,"a406_0":ka,"a407_0":ja,"a408_1":ia,"a409_0":ha,"a410_1":ga,"a411_3":fa,"a412_0":ea,"a413_0":gb,"a414_0":Y,"a415_0":ir,"a416_1":hr,"a417_1":na,"a418_0":ma,"a419_2":la,"a420_0":ka,"a421_0":ja,"a422_1":ia,"a423_0":ha,"a424_1":ga,"a425_3":fa,"a426_0":ea,"a427_0":Y,"a428_2":gr,"a429_0":fr,"a430_1":er,"a431_1":na,"a432_0":ma,"a433_2":la,"a434_0":ka,"a435_0":ja,"a436_1":ia,"a437_0":ha,"a438_1":ga,"a439_3":fa,"a440_0":ea,"a441_0":Y,"a442_2":dr,"a443_0":Y,"a444_0":Y,"a445_0":cr,"a445_3":br,"a446_0":Ad,"a447_0":zd,"a448_0":yd,"a449_1":xd,"a450_1":wd,"a451_1":vd,"a452_3":ar,"a453_0":hc,"a454_1":$q,"a455_1":Ba,"a456_0":Aa,"a457_1":_q,"a458_1":na,"a459_0":ma,"a460_2":la,"a461_0":ka,"a462_0":ja,"a463_1":ia,"a464_0":ha,"a465_1":ga,"a466_3":fa,"a467_0":ea,"a468_0":gb,"a469_0":Y,"a470_0":Wq,"a471_0":Da,"a472_0":Vq,"a473_1":na,"a474_0":ma,"a475_2":la,"a476_0":ka,"a477_0":ja,"a478_1":ia,"a479_0":ha,"a480_1":ga,"a481_3":fa,"a482_0":ea,"a483_0":Y,"a484_0":Uq,"a485_0":Tq,"a486_1":Sq,"a487_0":ws,"a488_1":Rq,"a489_0":Qq,"a490_1":Pq,"a491_0":Da,"a492_0":jg,"a493_1":hg,"a494_0":bf,"a495_1":kg,"a496_0":Da,"a497_0":lc,"a498_1":Oq,"a499_0":ta,"a500_0":ic,"a501_0":Y,"a502_4":Nq,"a503_1":rc,"a504_0":qc,"a505_1":pc,"a506_2":oc,"a507_3":nc,"a508_0":Y,"a509_1":Mq,"a510_0":Rd,"a511_1":Lq,"a512_2":Kq,"a513_0":Iq,"a514_2":Hq,"a515_2":Gq,"a516_0":Fq,"a517_1":Eq,"a518_1":Cq,"a519_2":Bq,"a520_1":zq,"a521_1":yq,"a522_2":xq,"a523_0":uq,"a524_0":tq,"a525_0":sq,"a526_1":rq,"a527_1":pq,"a528_0":nq,"a529_0":lq,"a530_1":kq,"a531_2":iq,"a532_1":hq,"a533_0":gq,"a534_1":fq,"a535_0":eq,"a536_0":cq,"a537_0":$p,"a538_0":_p,"a539_0":Zp,"a540_0":ve,"a541_0":se,"a542_1":qe,"a543_1":oe,"a544_0":je,"a544_1":ie,"a545_0":he,"a546_0":ee,"a547_0":be,"a548_0":ae,"a549_1":Yd,"a550_1":Ud,"a551_1":Ah,"a552_1":wh,"a553_0":Rd,"a554_0":Qd,"a555_1":qh,"a556_1":nh,"a557_1":Dc,"a558_1":ih,"a559_1":hh,"a560_0":dh,"a561_1":bh,"a562_1":ah,"a563_2":Xg,"a564_0":Y,"a565_0":lc,"a566_1":Xp,"a567_0":ic,"a568_4":Wp,"a569_1":Vp,"a570_1":Up,"a571_1":Tp,"a572_1":Rp,"a573_1":Qp,"a574_0":Pp,"a575_3":Ob,"a576_6":Mb,"a577_1":Bg,"a577_2":Ag,"a577_3":Jb,"a578_1":Ib,"a579_1":Hb,"a580_1":Qg,"a581_0":Op,"a582_1":Mg,"a582_3":Kg,"a583_1":Jg,"a584_1":Ig,"a584_2":Hg,"a585_1":Gg,"a586_1":Fg,"a586_2":Eg,"a586_3":Dg,"a587_1":Eb,"a588_1":Vc,"a589_0":Uc,"a590_0":Y,"a591_0":Np,"a591_2":Mp,"a592_0":Jp,"a593_1":Ip,"a594_1":Gp,"a595_0":Ep,"a596_0":Dp,"a597_0":Bp,"a598_0":Ap,"a599_1":zp,"a600_0":Da,"a601_1":wp,"a602_1":Ba,"a603_0":Aa,"a604_3":vp,"a605_1":na,"a606_0":ma,"a607_2":la,"a608_0":ka,"a609_0":ja,"a610_1":ia,"a611_0":ha,"a612_1":ga,"a613_3":fa,"a614_0":ea,"a615_0":gb,"a616_0":Y,"a617a618":Wf,"a617a619":Vf,"a617a620":Uf,"a617a621":Tf,"a622a623":tp,"a622a624":Wf,"a622a625":Vf,"a622a626":Uf,"a622a627":Tf,"a622a628":sp,"malloc":Bd,"free":aa,"__growWasmMemory":Tt,"dynCall_vi":St,"dynCall_v":Rt}}for(var N=new Uint8Array(123),O=25;O>=0;--O){N[48+O]=52+O;N[65+O]=O;N[97+O]=26+O;}N[43]=62;N[47]=63;function P(uint8Array,offset,b64){var Q,R,O=0,S=offset,T=b64.length,U=offset+(T*3>>2);if(b64[T-2]=="=")--U;if(b64[T-1]=="=")--U;for(;O<T;O+=4,S+=3){Q=N[b64.charCodeAt(O+1)];R=N[b64.charCodeAt(O+2)];uint8Array[S]=N[b64.charCodeAt(O)]<<2|Q>>4;if(S+1<U)uint8Array[S+1]=Q<<4|R>>2;if(S+2<U)uint8Array[S+2]=R<<6|N[b64.charCodeAt(O+3)];}}var V=new Uint8Array(wasmMemory.buffer);P(V,1028,"dAUAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAY3JlYXRlUHJlZGljdGl2ZUNvbnRhY3RzAHByZWRpY3RpdmUgY29udmV4U3dlZXBUZXN0AChzaXplX3QgaWR4LCBzaXplX3Qgc2l6ZSk8Ojo+eyB0aHJvdyAnQXJyYXkgaW5kZXggJyArIGlkeCArICcgb3V0IG9mIGJvdW5kczogWzAsJyArIHNpemUgKyAnKSc7IH0AMjNjY0Rpc2NyZXRlRHluYW1pY3NXb3JsZADUTAAAWgUAAGQLAABOMTZidENvbGxpc2lvbldvcmxkMjdDbG9zZXN0Q29udmV4UmVzdWx0Q2FsbGJhY2tFAE4xNmJ0Q29sbGlzaW9uV29ybGQyMENvbnZleFJlc3VsdENhbGxiYWNrRQAAAACsTAAAsgUAANRMAACABQAA4AUAAAAAAADoBQAAMgAAADMAAAA0AAAANQAAAAAAAADgBQAANgAAADcAAAA0AAAAOAAAAAAAAAB0BgAAOQAAADoAAAA7AAAAMjNjY092ZXJsYXBGaWx0ZXJDYWxsYmFjawAyM2J0T3ZlcmxhcEZpbHRlckNhbGxiYWNrAKxMAABSBgAA1EwAADgGAABsBgAAAAAAAGwGAAA8AAAAPQAAADgAAAAAAAAA1AYAAD4AAAA/AAAAQAAAAEEAAAAzNGNjTm90TWVDbG9zZXN0Q29udmV4UmVzdWx0Q2FsbGJhY2sAAAAA1EwAAKwGAADoBQAAAAAAAIAHAABCAAAAQwAAAEQAAABFAAAAMjZjY0FsbEhpdHNSYXlSZXN1bHRDYWxsYmFjawBOMTZidENvbGxpc2lvbldvcmxkMjRBbGxIaXRzUmF5UmVzdWx0Q2FsbGJhY2tFAE4xNmJ0Q29sbGlzaW9uV29ybGQxN1JheVJlc3VsdENhbGxiYWNrRQCsTAAARAcAANRMAAAVBwAAbAcAANRMAAD4BgAAdAcAAAAAAAB0BwAARgAAAEcAAABIAAAASQAAAAAAAABsBwAASgAAAEsAAABIAAAAOAAAAAAAAAAsCAAATAAAAE0AAABOAAAATwAAADI2Y2NDbG9zZXN0UmF5UmVzdWx0Q2FsbGJhY2sATjE2YnRDb2xsaXNpb25Xb3JsZDI0Q2xvc2VzdFJheVJlc3VsdENhbGxiYWNrRQDUTAAA8QcAAGwHAADUTAAA1AcAACAIAAAAAAAAIAgAAFAAAABRAAAASAAAAFIAAAAAAAAAmAgAAFMAAABUAAAAVQAAAFYAAAAyMGJ0RGVmYXVsdE1vdGlvblN0YXRlADEzYnRNb3Rpb25TdGF0ZQAArEwAAH8IAADUTAAAaAgAAJAIAAAAAAAAkAgAAFcAAABYAAAAOAAAADgAAAAAAAAABAkAAFkAAABaAAAAWwAAAFwAAABdAAAAXgAAAF8AAABidFJpZ2lkQm9keUZsb2F0RGF0YQAxMWJ0UmlnaWRCb2R5AADUTAAA9QgAANAPAAAAAAAAZAsAAGAAAABhAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAAYgAAAC0AAAAuAAAAYwAAADAAAAAxAAAAZGVidWdEcmF3V29ybGQAaW50ZXJuYWxTaW5nbGVTdGVwU2ltdWxhdGlvbgB1cGRhdGVBY3Rpb25zAHVwZGF0ZUFjdGl2YXRpb25TdGF0ZQBzb2x2ZUNvbnN0cmFpbnRzAGNhbGN1bGF0ZVNpbXVsYXRpb25Jc2xhbmRzAHByZWRpY3RpdmUgY29udmV4U3dlZXBUZXN0AHJlbGVhc2UgcHJlZGljdGl2ZSBjb250YWN0IG1hbmlmb2xkcwBjcmVhdGVQcmVkaWN0aXZlQ29udGFjdHMAQ0NEIG1vdGlvbiBjbGFtcGluZwBpbnRlZ3JhdGVUcmFuc2Zvcm1zAGFwcGx5IHNwZWN1bGF0aXZlIGNvbnRhY3QgcmVzdGl0dXRpb24AcHJlZGljdFVuY29uc3RyYWludE1vdGlvbgBidER5bmFtaWNzV29ybGRGbG9hdERhdGEAMjNidERpc2NyZXRlRHluYW1pY3NXb3JsZAAxNWJ0RHluYW1pY3NXb3JsZAAAANRMAABECwAAAB8AANRMAAAqCwAAWAsAAAAAAADYCwAAZAAAAGUAAABmAAAAMjdJbnBsYWNlU29sdmVySXNsYW5kQ2FsbGJhY2sATjI1YnRTaW11bGF0aW9uSXNsYW5kTWFuYWdlcjE0SXNsYW5kQ2FsbGJhY2tFAKxMAACiCwAA1EwAAIQLAADQCwAAAAAAACQMAAA2AAAAZwAAAGgAAABpAAAAMzRidENsb3Nlc3ROb3RNZUNvbnZleFJlc3VsdENhbGxiYWNrAAAAANRMAAD8CwAA6AUAAAAAAAB4DAAAagAAAGsAAABsAAAAbQAAAG4AAABvAAAAcAAAAHEAAAByAAAAcwAAAHQAAAAxN2J0Rml4ZWRDb25zdHJhaW50ANRMAABkDAAADA0AAGJ0R2VuZXJpYzZEb2ZTcHJpbmcyQ29uc3RyYWludERhdGEAAAAAAAAMDQAAdQAAAHYAAABsAAAAbQAAAG4AAABvAAAAcAAAAHEAAAByAAAAcwAAAHQAAAAAAAAAAQAAAAIAAAAzMGJ0R2VuZXJpYzZEb2ZTcHJpbmcyQ29uc3RyYWludAAAAADUTAAA6AwAABgOAAAAAAAAbA0AAHUAAAB3AAAAeAAAAG0AAAB5AAAAegAAAHAAAAB7AAAAfAAAAH0AAAB+AAAAfwAAADIzYnRQb2ludDJQb2ludENvbnN0cmFpbnQAAADUTAAAUA0AABgOAABidFBvaW50MlBvaW50Q29uc3RyYWludEZsb2F0RGF0YQAAAAAAAAAAGA4AAHUAAACBAAAAggAAAG0AAAA4AAAAOAAAAHAAAAA4AAAAOAAAAIMAAACEAAAAYnRUeXBlZENvbnN0cmFpbnRGbG9hdERhdGEAMTdidFR5cGVkQ29uc3RyYWludAAxM2J0VHlwZWRPYmplY3QAAKxMAAD/DQAAME0AAOsNAAAAAAAAAQAAABAOAAACBAAAAAAAAHwOAAB1AAAAhQAAAIYAAABtAAAAhwAAAIgAAABwAAAAiQAAAIoAAACLAAAAjAAAAI0AAAAxN2J0SGluZ2VDb25zdHJhaW50ANRMAABoDgAAGA4AAGJ0SGluZ2VDb25zdHJhaW50RmxvYXREYXRhAAAAAAAAcA8AAJEAAACSAAAAkwAAAJQAAACVAAAAlgAAAJcAAACYAAAAmQAAAJoAAACbAAAAnAAAAJ0AAABzb2x2ZUdyb3VwQ2FjaGVGcmllbmRseVNldHVwAHNvbHZlR3JvdXBDYWNoZUZyaWVuZGx5SXRlcmF0aW9ucwBzb2x2ZUdyb3VwADM1YnRTZXF1ZW50aWFsSW1wdWxzZUNvbnN0cmFpbnRTb2x2ZXIAMThidENvbnN0cmFpbnRTb2x2ZXIAAAAArEwAAFAPAADUTAAAKg8AAGgPAAAAAAAA0A8AAJ4AAACfAAAAWwAAAFwAAACgAAAAoQAAAKIAAABidENvbGxpc2lvbk9iamVjdEZsb2F0RGF0YQAxN2J0Q29sbGlzaW9uT2JqZWN0AACsTAAAuw8AAAAAAAA4EAAApAAAAKUAAACmAAAApwAAAKgAAACpAAAAqgAAAKsAAACsAAAArQAAAK4AAACvAAAAsAAAALEAAACyAAAAswAAADIxYnRDb2xsaXNpb25EaXNwYXRjaGVyANRMAAAgEAAAmD8AAAAAAACQEAAAtAAAALUAAAC2AAAAMjNidENvbGxpc2lvblBhaXJDYWxsYmFjawAxN2J0T3ZlcmxhcENhbGxiYWNrAAAArEwAAHIQAADUTAAAWBAAAIgQAAABAAAAAgAAAAAAAAABAAAAAgAAAAAAAAABAAAAAgAAAAAAAAACAAAAAAAAAAEAAAAAAAAALBEAALkAAAC6AAAAuwAAADMwYnRHamtFcGFQZW5ldHJhdGlvbkRlcHRoU29sdmVyADMwYnRDb252ZXhQZW5ldHJhdGlvbkRlcHRoU29sdmVyAAAArEwAAAERAADUTAAA4BAAACQRAAAAAAAAkBEAALwAAAC9AAAAvgAAADE3YnRHamtQYWlyRGV0ZWN0b3IAMzZidERpc2NyZXRlQ29sbGlzaW9uRGV0ZWN0b3JJbnRlcmZhY2UAAKxMAABgEQAA1EwAAEwRAACIEQAAAAAAANQRAAC5AAAAvwAAAMAAAAAzM2J0TWlua293c2tpUGVuZXRyYXRpb25EZXB0aFNvbHZlcgDUTAAAsBEAACQRAAAAAAAA4BIAAMEAAADCAAAAwwAAAMQAAADFAAAAWk4zM2J0TWlua293c2tpUGVuZXRyYXRpb25EZXB0aFNvbHZlcjEyY2FsY1BlbkRlcHRoRVIyMmJ0Vm9yb25vaVNpbXBsZXhTb2x2ZXJQSzEzYnRDb252ZXhTaGFwZVM0X1JLMTFidFRyYW5zZm9ybVM3X1I5YnRWZWN0b3IzUzlfUzlfUDEyYnRJRGVidWdEcmF3RTIwYnRJbnRlcm1lZGlhdGVSZXN1bHQATjM2YnREaXNjcmV0ZUNvbGxpc2lvbkRldGVjdG9ySW50ZXJmYWNlNlJlc3VsdEUAAKxMAACnEgAA1EwAAPwRAADYEgAAAAAAADwTAADGAAAAxwAAAMgAAADJAAAAygAAADE2YnRFbXB0eUFsZ29yaXRobQAyMGJ0Q29sbGlzaW9uQWxnb3JpdGhtAAAArEwAABsTAADUTAAACBMAADQTAAAAAAAAiBMAAMsAAADMAAAAOAAAADgAAAA4AAAAMzBidEFjdGl2YXRpbmdDb2xsaXNpb25BbGdvcml0aG0AAAAA1EwAAGQTAAA0EwAAAAAAANQTAADNAAAAzgAAAM8AAADQAAAA0QAAADMyYnRTcGhlcmVTcGhlcmVDb2xsaXNpb25BbGdvcml0aG0AANRMAACwEwAAiBMAAAAAAABIFAAA0gAAANMAAADUAAAA1QAAANYAAADXAAAAMzFidERlZmF1bHRDb2xsaXNpb25Db25maWd1cmF0aW9uADI0YnRDb2xsaXNpb25Db25maWd1cmF0aW9uAAAAAKxMAAAiFAAA1EwAAAAUAABAFAAAAAAAAMQUAADYAAAA2QAAANoAAABOMzNidENvbnZleENvbmNhdmVDb2xsaXNpb25BbGdvcml0aG0xMENyZWF0ZUZ1bmNFADMwYnRDb2xsaXNpb25BbGdvcml0aG1DcmVhdGVGdW5jAACsTAAAmhQAANRMAABoFAAAvBQAAAAAAAAgFQAA2AAAANsAAADcAAAATjMzYnRDb252ZXhDb25jYXZlQ29sbGlzaW9uQWxnb3JpdGhtMTdTd2FwcGVkQ3JlYXRlRnVuY0UAAAAA1EwAAOQUAAC8FAAAAAAAAHAVAADYAAAA3QAAAN4AAABOMjhidENvbXBvdW5kQ29sbGlzaW9uQWxnb3JpdGhtMTBDcmVhdGVGdW5jRQAAAADUTAAAQBUAALwUAAAAAAAAyBUAANgAAADfAAAA4AAAAE4zNmJ0Q29tcG91bmRDb21wb3VuZENvbGxpc2lvbkFsZ29yaXRobTEwQ3JlYXRlRnVuY0UAAAAA1EwAAJAVAAC8FAAAAAAAABwWAADYAAAA4QAAAOIAAABOMjhidENvbXBvdW5kQ29sbGlzaW9uQWxnb3JpdGhtMTdTd2FwcGVkQ3JlYXRlRnVuY0UA1EwAAOgVAAC8FAAAAAAAAGAWAADYAAAA4wAAAOQAAABOMTZidEVtcHR5QWxnb3JpdGhtMTBDcmVhdGVGdW5jRQAAAADUTAAAPBYAALwUAAAAAAAAtBYAANgAAADlAAAA5gAAAE4zMmJ0U3BoZXJlU3BoZXJlQ29sbGlzaW9uQWxnb3JpdGhtMTBDcmVhdGVGdW5jRQAAAADUTAAAgBYAALwUAAAAAAAACBcAANgAAADnAAAA6AAAAE4zNGJ0U3BoZXJlVHJpYW5nbGVDb2xsaXNpb25BbGdvcml0aG0xMENyZWF0ZUZ1bmNFAADUTAAA1BYAALwUAAAAAAAAVBcAANgAAADpAAAA6gAAAE4yNmJ0Qm94Qm94Q29sbGlzaW9uQWxnb3JpdGhtMTBDcmVhdGVGdW5jRQAA1EwAACgXAAC8FAAAAAAAAKQXAADYAAAA6wAAAOwAAABOMzFidENvbnZleFBsYW5lQ29sbGlzaW9uQWxnb3JpdGhtMTBDcmVhdGVGdW5jRQDUTAAAdBcAALwUAAAAAAAAEBgAAO0AAADuAAAA7wAAAPAAAABpc2xhbmRVbmlvbkZpbmRBbmRRdWlja1NvcnQAcHJvY2Vzc0lzbGFuZHMAMjVidFNpbXVsYXRpb25Jc2xhbmRNYW5hZ2VyAACsTAAA8xcAAAAAAABYGAAA8QAAAPIAAADzAAAA9AAAAPUAAAAzMWJ0Q29udmV4UGxhbmVDb2xsaXNpb25BbGdvcml0aG0AAADUTAAANBgAADQTAAAxMmJ0Q29udmV4Q2FzdAAArEwAAGQYAAAAAAAArBgAAPYAAAD3AAAA+AAAADIyYnRTdWJzaW1wbGV4Q29udmV4Q2FzdAAAAADUTAAAkBgAAHQYAAAAAAAAbBkAAPkAAAD6AAAA+wAAAPwAAAD9AAAAAAAAAJQZAAD+AAAA/wAAAAABAABidENvbnZleFRyaWFuZ2xlQ2FsbGJhY2s6OnByb2Nlc3NUcmlhbmdsZQBidENvbnZleENvbmNhdmVDb2xsaXNpb25BbGdvcml0aG06OnByb2Nlc3NDb2xsaXNpb24AMzNidENvbnZleENvbmNhdmVDb2xsaXNpb25BbGdvcml0aG0AAADUTAAARhkAAIgTAAAyNGJ0Q29udmV4VHJpYW5nbGVDYWxsYmFjawAA1EwAAHgZAAB0NAAAAAAAADwaAAABAQAAAgEAAAMBAAAEAQAABQEAAAYBAAAHAQAACAEAAAkBAAAKAQAACwEAAAwBAAANAQAADgEAAA8BAAAQAQAAEQEAABIBAAATAQAAFAEAABUBAAAWAQAAFwEAABgBAAAZAQAAGgEAABsBAAAcAQAAHQEAAB4BAAAfAQAAIAEAADE1YnRUcmlhbmdsZVNoYXBlAAAA1EwAACgaAAB0MgAAVHJpYW5nbGUAYnRDb252ZXhJbnRlcm5hbFNoYXBlRGF0YQAAAAAAACAbAAAhAQAAIgEAACMBAABaTjMzYnRDb252ZXhDb25jYXZlQ29sbGlzaW9uQWxnb3JpdGhtMjFjYWxjdWxhdGVUaW1lT2ZJbXBhY3RFUDE3YnRDb2xsaXNpb25PYmplY3RTMV9SSzE2YnREaXNwYXRjaGVySW5mb1AxNmJ0TWFuaWZvbGRSZXN1bHRFMzFMb2NhbFRyaWFuZ2xlU3BoZXJlQ2FzdENhbGxiYWNrAAAA1EwAAIAaAAB0NAAAcHJvY2Vzc1RyaWFuZ2xlAAAAAAB4GwAAJAEAACUBAAAmAQAAJwEAACgBAABOMTJidENvbnZleENhc3QxMENhc3RSZXN1bHRFAAAAAKxMAABYGwAAAAAAAKgbAAC8AAAAKQEAACoBAAAxNmJ0Qm94Qm94RGV0ZWN0b3IAANRMAACUGwAAiBEAAAAAAADwGwAAKwEAACwBAAAtAQAALgEAAC8BAAAyNmJ0Qm94Qm94Q29sbGlzaW9uQWxnb3JpdGhtAAAAANRMAADQGwAAiBMAAAAAAAAsHAAAwQAAADABAAAxAQAAMgEAADMBAAAxNmJ0TWFuaWZvbGRSZXN1bHQAANRMAAAYHAAA2BIAAAAAAABgHAAA9gAAADQBAAA1AQAAMTVidEdqa0NvbnZleENhc3QAAADUTAAATBwAAHQYAAAAAAAAnBwAAMEAAAA2AQAANwEAADgBAAA5AQAAMTZidFBvaW50Q29sbGVjdG9yAADUTAAAiBwAANgSAAAAAAAA3BwAAPYAAAA6AQAAOwEAADI3YnRDb250aW51b3VzQ29udmV4Q29sbGlzaW9uAAAA1EwAALwcAAB0GAAAAAAAADQdAAAhAQAAPAEAAD0BAAA4AAAAAAAAAGAdAAAhAQAAPgEAAD8BAAA4AAAAMjVidFRyaWFuZ2xlUmF5Y2FzdENhbGxiYWNrANRMAAAYHQAAdDQAADI4YnRUcmlhbmdsZUNvbnZleGNhc3RDYWxsYmFjawAA1EwAAEAdAAB0NAAAAAAAAAAfAABAAQAAQQEAAAUAAAAGAAAABwAAAAgAAABCAQAACgAAAAsAAABDAQAARAEAAA4AAABFAQAAT3ZlcmZsb3cgaW4gQUFCQiwgb2JqZWN0IHJlbW92ZWQgZnJvbSBzaW11bGF0aW9uAElmIHlvdSBjYW4gcmVwcm9kdWNlIHRoaXMsIHBsZWFzZSBlbWFpbCBidWdzQGNvbnRpbnVvdXNwaHlzaWNzLmNvbQoAUGxlYXNlIGluY2x1ZGUgYWJvdmUgaW5mb3JtYXRpb24sIHlvdXIgUGxhdGZvcm0sIHZlcnNpb24gb2YgT1MuCgBUaGFua3MuCgB1cGRhdGVBYWJicwBjYWxjdWxhdGVPdmVybGFwcGluZ1BhaXJzAHBlcmZvcm1EaXNjcmV0ZUNvbGxpc2lvbkRldGVjdGlvbgBkaXNwYXRjaEFsbENvbGxpc2lvblBhaXJzAGNvbnZleFN3ZWVwQ29tcG91bmQAY29udmV4U3dlZXBUZXN0ADE2YnRDb2xsaXNpb25Xb3JsZACsTAAA7R4AAAAAAAC0HwAAIQEAAEYBAAA9AQAARwEAAFpOMTZidENvbGxpc2lvbldvcmxkMjFyYXlUZXN0U2luZ2xlSW50ZXJuYWxFUksxMWJ0VHJhbnNmb3JtUzJfUEsyNGJ0Q29sbGlzaW9uT2JqZWN0V3JhcHBlclJOU18xN1JheVJlc3VsdENhbGxiYWNrRUUyOUJyaWRnZVRyaWFuZ2xlUmF5Y2FzdENhbGxiYWNrAADUTAAAIB8AADQdAAAAAAAAgCAAAEgBAABJAQAASgEAAEsBAABMAQAATQEAAE4BAABaTjE2YnRDb2xsaXNpb25Xb3JsZDIxcmF5VGVzdFNpbmdsZUludGVybmFsRVJLMTFidFRyYW5zZm9ybVMyX1BLMjRidENvbGxpc2lvbk9iamVjdFdyYXBwZXJSTlNfMTdSYXlSZXN1bHRDYWxsYmFja0VFOVJheVRlc3RlcgBONmJ0RGJ2dDhJQ29sbGlkZUUAAAAArEwAAGIgAADUTAAA5B8AAHggAAAAAAAALCEAAEoAAABPAQAAUAEAAFEBAABaTjE2YnRDb2xsaXNpb25Xb3JsZDIxcmF5VGVzdFNpbmdsZUludGVybmFsRVJLMTFidFRyYW5zZm9ybVMyX1BLMjRidENvbGxpc2lvbk9iamVjdFdyYXBwZXJSTlNfMTdSYXlSZXN1bHRDYWxsYmFja0VFMTVMb2NhbEluZm9BZGRlcjIAAAAA1EwAAKQgAABsBwAAAAAAAAAiAAAhAQAAUgEAAD8BAABTAQAAWk4xNmJ0Q29sbGlzaW9uV29ybGQyNW9iamVjdFF1ZXJ5U2luZ2xlSW50ZXJuYWxFUEsxM2J0Q29udmV4U2hhcGVSSzExYnRUcmFuc2Zvcm1TNV9QSzI0YnRDb2xsaXNpb25PYmplY3RXcmFwcGVyUk5TXzIwQ29udmV4UmVzdWx0Q2FsbGJhY2tFZkUzMkJyaWRnZVRyaWFuZ2xlQ29udmV4Y2FzdENhbGxiYWNrAADUTAAAUCEAAGAdAAAAAAAA2CIAACEBAABUAQAAPwEAAFUBAABaTjE2YnRDb2xsaXNpb25Xb3JsZDI1b2JqZWN0UXVlcnlTaW5nbGVJbnRlcm5hbEVQSzEzYnRDb252ZXhTaGFwZVJLMTFidFRyYW5zZm9ybVM1X1BLMjRidENvbGxpc2lvbk9iamVjdFdyYXBwZXJSTlNfMjBDb252ZXhSZXN1bHRDYWxsYmFja0VmRTMyQnJpZGdlVHJpYW5nbGVDb252ZXhjYXN0Q2FsbGJhY2tfMAAAAADUTAAAJCIAAGAdAAAAAAAAsCMAAEgBAABWAQAASgEAAFcBAABMAQAATQEAAE4BAABaTjE2YnRDb2xsaXNpb25Xb3JsZDI1b2JqZWN0UXVlcnlTaW5nbGVJbnRlcm5hbEVQSzEzYnRDb252ZXhTaGFwZVJLMTFidFRyYW5zZm9ybVM1X1BLMjRidENvbGxpc2lvbk9iamVjdFdyYXBwZXJSTlNfMjBDb252ZXhSZXN1bHRDYWxsYmFja0VmRTIyYnRDb21wb3VuZExlYWZDYWxsYmFjawAAAADUTAAACCMAAHggAAAAAAAAtCQAADYAAABYAQAAWQEAAFoBAABaWk4xNmJ0Q29sbGlzaW9uV29ybGQyNW9iamVjdFF1ZXJ5U2luZ2xlSW50ZXJuYWxFUEsxM2J0Q29udmV4U2hhcGVSSzExYnRUcmFuc2Zvcm1TNV9QSzI0YnRDb2xsaXNpb25PYmplY3RXcmFwcGVyUk5TXzIwQ29udmV4UmVzdWx0Q2FsbGJhY2tFZkVOMjJidENvbXBvdW5kTGVhZkNhbGxiYWNrMTJQcm9jZXNzQ2hpbGRFaVM1X1BLMTZidENvbGxpc2lvblNoYXBlRTE0TG9jYWxJbmZvQWRkZXIAANRMAADUIwAA4AUAAAAAAAA0JQAAWwEAAFwBAABdAQAAMTlidFNpbmdsZVJheUNhbGxiYWNrADIzYnRCcm9hZHBoYXNlUmF5Q2FsbGJhY2sAMjRidEJyb2FkcGhhc2VBYWJiQ2FsbGJhY2sAAKxMAAAEJQAA1EwAAOokAAAgJQAA1EwAANQkAAAoJQAAAAAAAGwlAABbAQAAXgEAAF8BAAAyMWJ0U2luZ2xlU3dlZXBDYWxsYmFjawDUTAAAVCUAACglAAAAAAAAuCUAAGABAABhAQAAYgEAAGMBAAD8////uCUAAGQBAABlAQAAZgEAADE3RGVidWdEcmF3Y2FsbGJhY2sAME0AAKQlAAAAAAAAAgAAAHQ0AAACAAAAoDQAAAIEAAAAAAAACCYAALwAAABnAQAAaAEAADIyU3BoZXJlVHJpYW5nbGVEZXRlY3RvcgAAAADUTAAA7CUAAIgRAAAAAAAAWCYAAGkBAABqAQAAawEAAGwBAABtAQAAMzRidFNwaGVyZVRyaWFuZ2xlQ29sbGlzaW9uQWxnb3JpdGhtAAAAANRMAAAwJgAAiBMAAAAAAAC8JgAAbgEAAG8BAABwAQAAAAAAAOQmAABxAQAAcgEAAHMBAAB0AQAAdQEAAE4yM2J0Q29udmV4Q29udmV4QWxnb3JpdGhtMTBDcmVhdGVGdW5jRQDUTAAAlCYAALwUAAAyM2J0Q29udmV4Q29udmV4QWxnb3JpdGhtAAAA1EwAAMgmAACIEwAAAAAAAJQnAADBAAAAdgEAAHcBAAB4AQAAeQEAAFpOMjNidENvbnZleENvbnZleEFsZ29yaXRobTE2cHJvY2Vzc0NvbGxpc2lvbkVQSzI0YnRDb2xsaXNpb25PYmplY3RXcmFwcGVyUzJfUksxNmJ0RGlzcGF0Y2hlckluZm9QMTZidE1hbmlmb2xkUmVzdWx0RTEzYnREdW1teVJlc3VsdAAAAADUTAAADCcAANgSAAAAAAAATCgAAMEAAAB6AQAAewEAAHwBAAB9AQAAWk4yM2J0Q29udmV4Q29udmV4QWxnb3JpdGhtMTZwcm9jZXNzQ29sbGlzaW9uRVBLMjRidENvbGxpc2lvbk9iamVjdFdyYXBwZXJTMl9SSzE2YnREaXNwYXRjaGVySW5mb1AxNmJ0TWFuaWZvbGRSZXN1bHRFMjFidFdpdGhvdXRNYXJnaW5SZXN1bHQAAAAA1EwAALwnAADYEgAAAAAAAJAoAADBAAAAfgEAADEBAAAyAQAAfwEAADI0YnRQZXJ0dXJiZWRDb250YWN0UmVzdWx0AADUTAAAdCgAACwcAAAAAAAA2CgAAIABAACBAQAAggEAAIMBAACEAQAAMjhidENvbXBvdW5kQ29sbGlzaW9uQWxnb3JpdGhtAADUTAAAuCgAAIgTAAAAAAAAJCkAAEgBAACFAQAASgEAAIYBAABMAQAATQEAAE4BAAAyMmJ0Q29tcG91bmRMZWFmQ2FsbGJhY2sAAAAA1EwAAAgpAAB4IAAAAAAAAGgpAACHAQAAiAEAAIkBAACKAQAAiwEAADIzYnRIYXNoZWRTaW1wbGVQYWlyQ2FjaGUAAACsTAAATCkAAAAAAAC0KQAAjAEAAI0BAACOAQAAjwEAAJABAAAzNmJ0Q29tcG91bmRDb21wb3VuZENvbGxpc2lvbkFsZ29yaXRobQAA1EwAAIwpAADYKAAAAAAAAAgqAABIAQAAkQEAAJIBAACTAQAATAEAAE0BAABOAQAAMzBidENvbXBvdW5kQ29tcG91bmRMZWFmQ2FsbGJhY2sAAAAA1EwAAOQpAAB4IAAAYnRDb21wb3VuZENvbXBvdW5kTGVhZkNhbGxiYWNrOjpQcm9jZXNzAAAAAADYKgAAAQEAAJQBAACVAQAABAEAAAUBAAAGAQAAlgEAAAgBAACXAQAAmAEAAAsBAAAMAQAADQEAAA4BAAAPAQAAEAEAABEBAACZAQAAEwEAAJoBAAAVAQAAmwEAAJwBAAAYAQAAnQEAAJ4BAACfAQAAoAEAAKEBAACiAQAAowEAAKQBAAAxNmJ0QlVfU2ltcGxleDF0bzQAANRMAADEKgAAqDIAAGJ0QlVfU2ltcGxleDF0bzQAAAAAAQAAAAMAAAAGAAAAAAAAAJQrAAClAQAApgEAAKcBAAAEAQAABQEAAAYBAACoAQAAqQEAAKoBAACrAQAACwEAAKwBAACtAQAArgEAAK8BAAAQAQAAsAEAALEBAABidENvbXBvdW5kU2hhcGVDaGlsZERhdGEAYnRDb21wb3VuZFNoYXBlRGF0YQAxNWJ0Q29tcG91bmRTaGFwZQAA1EwAAIErAABMMwAAQ29tcG91bmQAAAAAAAAAACAsAACyAQAAswEAALQBAAAEAQAABQEAAAYBAAC1AQAACAEAALYBAAC3AQAAuAEAAAwBAAANAQAAuQEAALoBAAAQAQAAuwEAALwBAAATAQAAvQEAABUBAACbAQAAnAEAADExYnRDb25lU2hhcGUAAADUTAAAECwAAFA0AABDb25lAGJ0Q29uZVNoYXBlRGF0YQAAAAAAAAAAbCwAAL4BAAC/AQAAMThidENvbnZleFBvbHloZWRyb24AAAAArEwAAFQsAAAAAAAA6CwAALIBAADAAQAAwQEAAAQBAAAFAQAABgEAAAcBAAAIAQAAwgEAAMMBAAALAQAAxAEAAMUBAAAOAQAADwEAABABAADGAQAAxwEAABMBAADIAQAAFQEAAJsBAACcAQAAMTNidFNwaGVyZVNoYXBlANRMAADYLAAAUDQAAFNQSEVSRQAAAAAAAIwtAADJAQAAygEAAMsBAAAEAQAABQEAAAYBAADMAQAAzQEAAM4BAADPAQAACwEAANABAADRAQAA0gEAANMBAAAQAQAA1AEAANUBAADWAQAA1wEAANgBAABidFRyaWFuZ2xlTWVzaFNoYXBlRGF0YQAyMmJ0QnZoVHJpYW5nbGVNZXNoU2hhcGUAAAAA1EwAAHAtAADgLwAAAAAAADQuAADZAQAA2gEAANsBAABaTjIyYnRCdmhUcmlhbmdsZU1lc2hTaGFwZTE0cGVyZm9ybVJheWNhc3RFUDE4YnRUcmlhbmdsZUNhbGxiYWNrUks5YnRWZWN0b3IzUzRfRTIxTXlOb2RlT3ZlcmxhcENhbGxiYWNrADIxYnROb2RlT3ZlcmxhcENhbGxiYWNrAKxMAAAULgAA1EwAAKwtAAAsLgAAAAAAAMguAADZAQAA3AEAAN0BAABaTjIyYnRCdmhUcmlhbmdsZU1lc2hTaGFwZTE3cGVyZm9ybUNvbnZleGNhc3RFUDE4YnRUcmlhbmdsZUNhbGxiYWNrUks5YnRWZWN0b3IzUzRfUzRfUzRfRTIxTXlOb2RlT3ZlcmxhcENhbGxiYWNrAAAAANRMAABULgAALC4AAAAAAABYLwAA2QEAAN4BAADfAQAAWk5LMjJidEJ2aFRyaWFuZ2xlTWVzaFNoYXBlMTlwcm9jZXNzQWxsVHJpYW5nbGVzRVAxOGJ0VHJpYW5nbGVDYWxsYmFja1JLOWJ0VmVjdG9yM1M0X0UyMU15Tm9kZU92ZXJsYXBDYWxsYmFjawAAANRMAADoLgAALC4AAEJWSFRSSUFOR0xFTUVTSAAAAAAA4C8AAOABAADhAQAAywEAAAQBAAAFAQAABgEAAOIBAADNAQAAzgEAAOMBAAALAQAA0AEAANEBAADkAQAA5QEAABABAADmAQAA1QEAANYBAAAxOWJ0VHJpYW5nbGVNZXNoU2hhcGUAAADUTAAAyC8AAKg2AAAAAAAAaDAAAOcBAADoAQAA6QEAAFpOSzE5YnRUcmlhbmdsZU1lc2hTaGFwZTE5cHJvY2Vzc0FsbFRyaWFuZ2xlc0VQMThidFRyaWFuZ2xlQ2FsbGJhY2tSSzlidFZlY3RvcjNTNF9FMTZGaWx0ZXJlZENhbGxiYWNrAAAA1EwAAAAwAACgNAAAAAAAAKAwAAAhAQAA6gEAAOsBAAAyMVN1cHBvcnRWZXJ0ZXhDYWxsYmFjawDUTAAAiDAAAHQ0AABUUklBTkdMRU1FU0gAAAAAAAAAACAxAADsAQAA7QEAAO4BAAAEAQAABQEAAAYBAADvAQAA8AEAAPEBAADyAQAACwEAANABAADRAQAA8wEAAPQBAAAQAQAA9QEAADE4YnRTdGF0aWNQbGFuZVNoYXBlAAAAANRMAAAIMQAAqDYAAFNUQVRJQ1BMQU5FAGJ0U3RhdGljUGxhbmVTaGFwZURhdGEAAAAAAAB0MgAAAQEAAPYBAAC0AQAABAEAAAUBAAAGAQAABwEAAAgBAACXAQAAOAAAAAsBAAAMAQAADQEAAA4BAAAPAQAAEAEAABEBAACZAQAAEwEAAJoBAAAVAQAAmwEAAJwBAAAYAQAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAAAAAAACoMgAAAQEAAPcBAAD4AQAABAEAAAUBAAAGAQAAlgEAAAgBAACXAQAAOAAAAAsBAAAMAQAADQEAAA4BAAAPAQAAEAEAABEBAACZAQAAEwEAAJoBAAAVAQAAmwEAAJwBAAAYAQAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADIzYnRQb2x5aGVkcmFsQ29udmV4U2hhcGUAAADUTAAAWDIAAFA0AAAzNGJ0UG9seWhlZHJhbENvbnZleEFhYmJDYWNoaW5nU2hhcGUAAAAA1EwAAIAyAAB0MgAAAAAAABAzAAD5AQAA+gEAAPsBAAAEAQAABQEAAAYBAAD8AQAA/QEAAP4BAAD/AQAACwEAANABAADRAQAA5AEAAOUBAAAQAQAAAAIAADEyYnRFbXB0eVNoYXBlAADUTAAAADMAAKg2AABFbXB0eQBidENvbGxpc2lvblNoYXBlRGF0YQAxNmJ0Q29sbGlzaW9uU2hhcGUAAACsTAAANzMAAAAAAADIMwAAsgEAAAECAAA4AAAABAEAAAUBAAAGAQAAOAAAADgAAAA4AAAAOAAAAAsBAAA4AAAAOAAAAOQBAADlAQAAEAEAADgAAAA4AAAAEwEAADgAAAA4AAAAOAAAADgAAAAxM2J0Q29udmV4U2hhcGUA1EwAALgzAABMMwAAAAAAAFA0AACyAQAAAgIAALQBAAAEAQAABQEAAAYBAAAHAQAACAEAADgAAAA4AAAACwEAAAwBAAANAQAADgEAAA8BAAAQAQAAEQEAADgAAAATAQAAOAAAABUBAACbAQAAnAEAADIxYnRDb252ZXhJbnRlcm5hbFNoYXBlANRMAAA4NAAAyDMAADE4YnRUcmlhbmdsZUNhbGxiYWNrAAAAAKxMAABcNAAAMzFidEludGVybmFsVHJpYW5nbGVJbmRleENhbGxiYWNrAAAArEwAAHw0AAAAAAAAIDUAALIBAAADAgAABAIAAAQBAAAFAQAABgEAAAUCAAAIAQAABgIAAAcCAAAIAgAACQIAAA0BAAAKAgAACwIAABABAAARAQAADAIAABMBAAANAgAAFQEAAJsBAACcAQAAMTRidENhcHN1bGVTaGFwZQAAAADUTAAADDUAAFA0AABDYXBzdWxlU2hhcGUAYnRDYXBzdWxlU2hhcGVEYXRhAAAAAADsNQAAAQEAAA4CAAD4AQAABAEAAAUBAAAGAQAADwIAABACAACXAQAAEQIAAAsBAAAMAQAADQEAAA4BAAAPAQAAEAEAABICAAATAgAAEwEAABQCAAAVAQAAmwEAAJwBAAAYAQAAFQIAABYCAAAXAgAAGAIAABkCAAAaAgAAGwIAADI1YnRDb252ZXhUcmlhbmdsZU1lc2hTaGFwZQDUTAAA0DUAAKgyAAAAAAAALDYAAOcBAAAcAgAAHQIAADI2TG9jYWxTdXBwb3J0VmVydGV4Q2FsbGJhY2sAAAAA1EwAAAw2AACgNAAAQ29udmV4VHJpbWVzaAAAAAAAAACoNgAAHgIAAB8CAAA4AAAABAEAAAUBAAAGAQAAOAAAADgAAAA4AAAAOAAAAAsBAADQAQAA0QEAAOQBAADlAQAAEAEAADgAAAAxNGJ0Q29uY2F2ZVNoYXBlAAAAANRMAACUNgAATDMAAAAAAABMNwAAAQEAACACAAAhAgAABAEAAAUBAAAGAQAAIgIAAAgBAAAjAgAAJAIAAAsBAAAlAgAADQEAAA4BAAAPAQAAEAEAACYCAAAnAgAAEwEAACgCAAAVAQAAKQIAACoCAAAYAQAAKwIAACwCAAAtAgAALgIAAC8CAAAwAgAAMQIAADICAAAxMGJ0Qm94U2hhcGUAAAAA1EwAADw3AAB0MgAAQm94AAAAgD8AAIC/");P(V,14206,"gD8AAIC/");P(V,14238,"gD8AAIC/AAAAAAAAAAABAAAAAgAAAAAAAAABAAAAAgAAAAMAAAAEAAAABAAAAAUAAAAGAAAAAQAAAAIAAAADAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAFAAAABgAAAAcAAAAHAAAAAAAAAEA4AAAzAgAANAIAADUCAAA2AgAANwIAADgCAAA5AgAAOgIAADE0YnRPcHRpbWl6ZWRCdmgAAAAA1EwAACw4AAAwQAAAAAAAAMQ4AADnAQAAOwIAADwCAABaTjE0YnRPcHRpbWl6ZWRCdmg1YnVpbGRFUDIzYnRTdHJpZGluZ01lc2hJbnRlcmZhY2ViUks5YnRWZWN0b3IzUzRfRTI5UXVhbnRpemVkTm9kZVRyaWFuZ2xlQ2FsbGJhY2sA1EwAAGA4AACgNAAAAAAAAEA5AADnAQAAPQIAAD4CAABaTjE0YnRPcHRpbWl6ZWRCdmg1YnVpbGRFUDIzYnRTdHJpZGluZ01lc2hJbnRlcmZhY2ViUks5YnRWZWN0b3IzUzRfRTIwTm9kZVRyaWFuZ2xlQ2FsbGJhY2sAANRMAADkOAAAoDQAAAAAAAC4OQAAPwIAAEACAABBAgAABAEAAAUBAAAGAQAAQgIAAEMCAABEAgAARQIAAAsBAADQAQAA0QEAAOQBAADlAQAAEAEAAEYCAABHAgAAMjVidEhlaWdodGZpZWxkVGVycmFpblNoYXBlANRMAACcOQAAqDYAAEhFSUdIVEZJRUxEAAAAAABMOgAAsgEAAEgCAABJAgAABAEAAAUBAAAGAQAASgIAAAgBAABLAgAATAIAAE0CAABOAgAADQEAAE8CAABQAgAAEAEAAFECAABSAgAAEwEAAFMCAAAVAQAAmwEAAJwBAABUAgAAMTVidEN5bGluZGVyU2hhcGUAAADUTAAAODoAAFA0AABDeWxpbmRlclkAYnRDeWxpbmRlclNoYXBlRGF0YQBidEludEluZGV4RGF0YQBidFNob3J0SW50SW5kZXhUcmlwbGV0RGF0YQBidENoYXJJbmRleFRyaXBsZXREYXRhAGJ0VmVjdG9yM0Zsb2F0RGF0YQBidFZlY3RvcjNEb3VibGVEYXRhAGJ0TWVzaFBhcnREYXRhAGJ0U3RyaWRpbmdNZXNoSW50ZXJmYWNlRGF0YQAyM2J0U3RyaWRpbmdNZXNoSW50ZXJmYWNlAACsTAAACTsAAAAAAACQOwAAVQIAAFYCAABXAgAAWAIAAFkCAABaAgAAWwIAAFwCAABdAgAAXgIAAF8CAABgAgAAYQIAAGICAABjAgAAMjZidFRyaWFuZ2xlSW5kZXhWZXJ0ZXhBcnJheQAAAADUTAAAcDsAACQ7AAAAAAAA9DsAAGQCAABlAgAAVwIAAFgCAABZAgAAWgIAAFsCAABcAgAAZgIAAGcCAABfAgAAYAIAAGECAABiAgAAYwIAADE0YnRUcmlhbmdsZU1lc2gAAAAA1EwAAOA7AACQOwAAAAAAAPA8AABoAgAAaQIAAGoCAABrAgAAbAIAAG0CAABuAgAAbwIAAHACAABxAgAAcgIAAHMCAAB0AgAAdQIAAHYCAAB3AgAAeAIAAGJ0SGFzaGVkT3ZlcmxhcHBpbmdQYWlyQ2FjaGU6OnByb2Nlc3NBbGxPdmVybGFwcGluZ1BhaXJzADI4YnRIYXNoZWRPdmVybGFwcGluZ1BhaXJDYWNoZQAyMmJ0T3ZlcmxhcHBpbmdQYWlyQ2FjaGUAMjVidE92ZXJsYXBwaW5nUGFpckNhbGxiYWNrAAAAAKxMAAC9PAAA1EwAAKQ8AADcPAAA1EwAAIU8AADkPAAAAAAAAIA9AAC0AAAAeQIAAHoCAABaTjI4YnRIYXNoZWRPdmVybGFwcGluZ1BhaXJDYWNoZTE5Y2xlYW5Qcm94eUZyb21QYWlyc0VQMTdidEJyb2FkcGhhc2VQcm94eVAxMmJ0RGlzcGF0Y2hlckUxN0NsZWFuUGFpckNhbGxiYWNrAAAA1EwAABA9AACIEAAAAAAAACQ+AAC0AAAAewIAAHwCAABaTjI4YnRIYXNoZWRPdmVybGFwcGluZ1BhaXJDYWNoZTM3cmVtb3ZlT3ZlcmxhcHBpbmdQYWlyc0NvbnRhaW5pbmdQcm94eUVQMTdidEJyb2FkcGhhc2VQcm94eVAxMmJ0RGlzcGF0Y2hlckUxOFJlbW92ZVBhaXJDYWxsYmFjawAAAADUTAAAoD0AAIgQAAAAAAAApD4AAH0CAAB+AgAAfwIAAIACAACBAgAAggIAAIMCAACEAgAAhQIAAIYCAACHAgAAiAIAAIkCAACKAgAAMTZidERidnRCcm9hZHBoYXNlADIxYnRCcm9hZHBoYXNlSW50ZXJmYWNlAACsTAAAgz4AANRMAABwPgAAnD4AAAAAAADsPgAASAEAAIsCAACMAgAAjQIAAEwBAABNAQAATgEAADE4YnREYnZ0VHJlZUNvbGxpZGVyAAAAANRMAADUPgAAeCAAAAAAAAA0PwAASAEAAI4CAABKAQAAjwIAAEwBAABNAQAATgEAADE5QnJvYWRwaGFzZVJheVRlc3RlcgAAANRMAAAcPwAAeCAAAAAAAAB8PwAASAEAAJACAABKAQAAkQIAAEwBAABNAQAATgEAADIwQnJvYWRwaGFzZUFhYmJUZXN0ZXIAANRMAABkPwAAeCAAADEyYnREaXNwYXRjaGVyAACsTAAAiD8AAAAAAAAwQAAAkgIAAJMCAAA1AgAANgIAADcCAAA4AgAAOQIAAGJ0T3B0aW1pemVkQnZoTm9kZURhdGEAYnRRdWFudGl6ZWRCdmhOb2RlRGF0YQBidEJ2aFN1YnRyZWVJbmZvRGF0YQBidFF1YW50aXplZEJ2aEZsb2F0RGF0YQAxNGJ0UXVhbnRpemVkQnZoAKxMAAAfQAAAAAAAADQTAADGAAAAlAIAADgAAAA4AAAAOAAAAFJvb3QAAAAAAAAAAAMAAAAEAAAABAAAAAYAAACD+aIARE5uAPwpFQDRVycA3TT1AGLbwAA8mZUAQZBDAGNR/gC73qsAt2HFADpuJADSTUIASQbgAAnqLgAcktEA6x3+ACmxHADoPqcA9TWCAES7LgCc6YQAtCZwAEF+XwDWkTkAU4M5AJz0OQCLX4QAKPm9APgfOwDe/5cAD5gFABEv7wAKWosAbR9tAM9+NgAJyycARk+3AJ5mPwAt6l8Auid1AOXrxwA9e/EA9zkHAJJSigD7a+oAH7FfAAhdjQAwA1YAe/xGAPCrawAgvM8ANvSaAOOpHQBeYZEACBvmAIWZZQCgFF8AjUBoAIDY/wAnc00ABgYxAMpWFQDJqHMAe+JgAGuMwAAZxEcAzWfDAAno3ABZgyoAi3bEAKYclgBEr90AGVfRAKU+BQAFB/8AM34/AMIy6ACYT94Au30yACY9wwAea+8An/heADUfOgB/8soA8YcdAHyQIQBqJHwA1W76ADAtdwAVO0MAtRTGAMMZnQCtxMIALE1BAAwAXQCGfUYA43EtAJvGmgAzYgAAtNJ8ALSnlwA3VdUA1z72AKMQGABNdvwAZJ0qAHDXqwBjfPgAerBXABcV5wDASVYAO9bZAKeEOAAkI8sA1op3AFpUIwAAH7kA8QobABnO3wCfMf8AZh5qAJlXYQCs+0cAfn/YACJltwAy6IkA5r9gAO/EzQBsNgkAXT/UABbe1wBYO94A3puSANIiKAAohugA4lhNAMbKMgAI4xYA4H3LABfAUADzHacAGOBbAC4TNACDEmIAg0gBAPWOWwCtsH8AHunyAEhKQwAQZ9MAqt3YAK5fQgBqYc4ACiikANOZtAAGpvIAXHd/AKPCgwBhPIgAinN4AK+MWgBv170ALaZjAPS/ywCNge8AJsFnAFXKRQDK2TYAKKjSAMJhjQASyXcABCYUABJGmwDEWcQAyMVEAE2ykQAAF/MA1EOtAClJ5QD91RAAAL78AB6UzABwzu4AEz71AOzxgACz58MAx/goAJMFlADBcT4ALgmzAAtF8wCIEpwAqyB7AC61nwBHksIAezIvAAxVbQByp5AAa+cfADHLlgB5FkoAQXniAPTfiQDolJcA4uaEAJkxlwCI7WsAX182ALv9DgBImrQAZ6RsAHFyQgCNXTIAnxW4ALzlCQCNMSUA93Q5ADAFHAANDAEASwhoACzuWABHqpAAdOcCAL3WJAD3faYAbkhyAJ8W7wCOlKYAtJH2ANFTUQDPCvIAIJgzAPVLfgCyY2gA3T5fAEBdAwCFiX8AVVIpADdkwABt2BAAMkgyAFtMdQBOcdQARVRuAAsJwQAq9WkAFGbVACcHnQBdBFAAtDvbAOp2xQCH+RcASWt9AB0nugCWaSkAxsysAK0UVACQ4moAiNmJACxyUAAEpL4AdweUAPMwcAAA/CcA6nGoAGbCSQBk4D0Al92DAKM/lwBDlP0ADYaMADFB3gCSOZ0A3XCMABe35wAI3zsAFTcrAFyAoABagJMAEBGSAA/o2ABsgK8A2/9LADiQDwBZGHYAYqUVAGHLuwDHibkAEEC9ANLyBABJdScA67b2ANsiuwAKFKoAiSYvAGSDdgAJOzMADpQaAFE6qgAdo8IAr+2uAFwmEgBtwk0ALXqcAMBWlwADP4MACfD2ACtAjABtMZkAObQHAAwgFQDYw1sA9ZLEAMatSwBOyqUApzfNAOapNgCrkpQA3UJoABlj3gB2jO8AaItSAPzbNwCuoasA3xUxAACuoQAM+9oAZE1mAO0FtwApZTAAV1a/AEf/OgBq+bkAdb7zACiT3wCrgDAAZoz2AATLFQD6IgYA2eQdAD2zpABXG48ANs0JAE5C6QATvqQAMyO1APCqGgBPZagA0sGlAAs/DwBbeM0AI/l2AHuLBACJF3IAxqZTAG9u4gDv6wAAm0pYAMTatwCqZroAds/PANECHQCx8S0AjJnBAMOtdwCGSNoA912gAMaA9ACs8C8A3eyaAD9cvADQ3m0AkMcfACrbtgCjJToAAK+aAK1TkwC2VwQAKS20AEuAfgDaB6cAdqoOAHtZoQAWEioA3LctAPrl/QCJ2/4Aib79AOR2bAAGqfwAPoBwAIVuFQD9h/8AKD4HAGFnMwAqGIYATb3qALPnrwCPbW4AlWc5ADG/WwCE10gAMN8WAMctQwAlYTUAyXDOADDLuAC/bP0ApACiAAVs5ABa3aAAIW9HAGIS0gC5XIQAcGFJAGtW4ACZUgEAUFU3AB7VtwAz8cQAE25fAF0w5ACFLqkAHbLDAKEyNgAIt6QA6rHUABb3IQCPaeQAJ/93AAwDgACNQC0AT82gACClmQCzotMAL10KALT5QgAR2ssAfb7QAJvbwQCrF70AyqKBAAhqXAAuVRcAJwBVAH8U8ADhB4YAFAtkAJZBjQCHvt4A2v0qAGsltgB7iTQABfP+ALm/ngBoak8ASiqoAE/EWgAt+LwA11qYAPTHlQANTY0AIDqmAKRXXwAUP7EAgDiVAMwgAQBx3YYAyd62AL9g9QBNZREAAQdrAIywrACywNAAUVVIAB77DgCVcsMAowY7AMBANQAG3HsA4EXMAE4p+gDWysgA6PNBAHxk3gCbZNgA2b4xAKSXwwB3WNQAaePFAPDaEwC6OjwARhhGAFV1XwDSvfUAbpLGAKwuXQAORO0AHD5CAGHEhwAp/ekA59bzACJ8ygBvkTUACODFAP/XjQBuauIAsP3GAJMIwQB8XXQAa62yAM1unQA+cnsAxhFqAPfPqQApc98Atcm6ALcAUQDisg0AdLokAOV9YAB02IoADRUsAIEYDAB+ZpQAASkWAJ96dgD9/b4AVkXvANl+NgDs2RMAi7q5AMSX/AAxqCcA8W7DAJTFNgDYqFYAtKi1AM/MDgASiS0Ab1c0ACxWiQCZzuMA1iC5AGteqgA+KpwAEV/MAP0LSgDh9PsAjjttAOKGLADp1IQA/LSpAO/u0QAuNckALzlhADghRAAb2cgAgfwKAPtKagAvHNgAU7SEAE6ZjABUIswAKlXcAMDG1gALGZYAGnC4AGmVZAAmWmAAP1LuAH8RDwD0tREA/Mv1ADS8LQA0vO4A6F3MAN1eYABnjpsAkjPvAMkXuABhWJsA4Ve8AFGDxgDYPhAA3XFIAC0c3QCvGKEAISxGAFnz1wDZepgAnlTAAE+G+gBWBvwA5XmuAIkiNgA4rSIAZ5PcAFXoqgCCJjgAyuebAFENpACZM7EAqdcOAGkFSABlsvAAf4inAIhMlwD50TYAIZKzAHuCSgCYzyEAQJ/cANxHVQDhdDoAZ+tCAP6d3wBe1F8Ae2ekALqsegBV9qIAK4gjAEG6VQBZbggAISqGADlHgwCJ4+YA5Z7UAEn7QAD/VukAHA/KAMVZigCU+isA08HFAA/FzwDbWq4AR8WGAIVDYgAhhjsALHmUABBhhwAqTHsAgCwaAEO/EgCIJpAAeDyJAKjE5ADl23sAxDrCACb06gD3Z4oADZK/AGWjKwA9k7EAvXwLAKRR3AAn3WMAaeHdAJqUGQCoKZUAaM4oAAnttABEnyAATpjKAHCCYwB+fCMAD7kyAKf1jgAUVucAIfEIALWdKgBvfk0ApRlRALX5qwCC39YAlt1hABY2AgDEOp8Ag6KhAHLtbQA5jXoAgripAGsyXABGJ1sAADTtANIAdwD89FUAAVlNAOBxgA==");P(V,19267,"QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNThj7T7aD0k/Xph7P9oPyT9pN6wxaCEiM7QPFDNoIaIz2w9JP9sPSb/kyxZA5MsWwAAAAAAAAACA2w9JQNsPScAAAIA/AADAPwAAAADcz9E1AAAAAADAFT9fX2N4YV9ndWFyZF9hY3F1aXJlIGRldGVjdGVkIHJlY3Vyc2l2ZSBpbml0aWFsaXphdGlvbgBQdXJlIHZpcnR1YWwgZnVuY3Rpb24gY2FsbGVkIQBTdDl0eXBlX2luZm8AAAAArEwAACxMAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAADUTAAAREwAADxMAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAADUTAAAdEwAAGhMAAAAAAAAmEwAAJ0CAACeAgAAnwIAAKACAAChAgAAogIAAKMCAACkAgAAAAAAABxNAACdAgAApQIAAJ8CAACgAgAAoQIAAKYCAACnAgAAqAIAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAADUTAAA9EwAAJhMAAAAAAAAeE0AAJ0CAACpAgAAnwIAAKACAAChAgAAqgIAAKsCAACsAgAATjEwX19jeHhhYml2MTIxX192bWlfY2xhc3NfdHlwZV9pbmZvRQAAANRMAABQTQAAmEw=");P(V,19847,"QArXozwBAAAAbxKDOgEAAACXAgAAmAIAAJkCAACaAgAAmwIAAJwC");return j({"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Uint32Array":Uint32Array,"Float32Array":Float32Array,"Float64Array":Float64Array,"NaN":NaN,"Infinity":Infinity,"Math":Math},asmLibraryArg,wasmMemory.buffer)}


            // EMSCRIPTEN_END_ASM




            )(sa,ta,ua)}}function va(){return {then:function(b){b({instance:new ra});}}}var wa=Error,WebAssembly={};na=[];"object"!==typeof WebAssembly&&ka("no native wasm support detected");
            var ta,ua=new function(b){var c=Array(b.initial);c.grow=function(){705<=c.length&&xa("Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.");c.push(null);};c.set=function(d,e){c[d]=e;};c.get=function(d){return c[d]};return c}({initial:685,maximum:705,element:"anyfunc"}),ya=!1,za,Aa,Ba,pa=a.INITIAL_MEMORY||67108864;if(ta=a.wasmMemory?a.wasmMemory:new oa)za=ta.buffer;pa=za.byteLength;var Ca=za;za=Ca;a.HEAP8=new Int8Array(Ca);a.HEAP16=new Int16Array(Ca);
            a.HEAP32=Ba=new Int32Array(Ca);a.HEAPU8=Aa=new Uint8Array(Ca);a.HEAPU16=new Uint16Array(Ca);a.HEAPU32=new Uint32Array(Ca);a.HEAPF32=new Float32Array(Ca);a.HEAPF64=new Float64Array(Ca);Ba[6388]=5268592;function Da(b){for(;0<b.length;){var c=b.shift();if("function"==typeof c)c(a);else {var d=c.l;"number"===typeof d?void 0===c.j?a.dynCall_v(d):a.dynCall_vi(d,c.j):d(void 0===c.j?null:c.j);}}}var Ea=[],Fa=[],Ga=[],Ha=[],Ja=!1;function Ka(){var b=a.preRun.shift();Ea.unshift(b);}var La=0,Na=null;
            a.preloadedImages={};a.preloadedAudios={};function xa(b){if(a.onAbort)a.onAbort(b);b+="";ja(b);ka(b);ya=!0;throw new wa("abort("+b+"). Build with -s ASSERTIONS=1 for more info.");}function Oa(b){var c=Pa;return String.prototype.startsWith?b.startsWith(c):0===b.indexOf(c)}var Pa="data:application/octet-stream;base64,",Ra="";if(!Oa(Ra)){var Sa=Ra;Ra=a.locateFile?a.locateFile(Sa,fa):fa+Sa;}
            function Ta(){try{if(na)return new Uint8Array(na);var b=ia(Ra);if(b)return b;if(ha)return ha(Ra);throw "both async and sync fetching of the wasm failed";}catch(c){xa(c);}}function Ua(){return na||!da&&!ea||"function"!==typeof fetch?new Promise(function(b){b(Ta());}):fetch(Ra,{credentials:"same-origin"}).then(function(b){if(!b.ok)throw "failed to load wasm binary file at '"+Ra+"'";return b.arrayBuffer()}).catch(function(){return Ta()})}Fa.push({l:function(){Va();}});
            var Wa="function"===typeof atob?atob:function(b){var c="",d=0;b=b.replace(/[^A-Za-z0-9\+\/=]/g,"");do{var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d++));var g="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d++));var n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d++));var Q="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d++));e=e<<2|g>>4;
            g=(g&15)<<4|n>>2;var Ia=(n&3)<<6|Q;c+=String.fromCharCode(e);64!==n&&(c+=String.fromCharCode(g));64!==Q&&(c+=String.fromCharCode(Ia));}while(d<b.length);return c};function ia(b){if(Oa(b)){try{var c=Wa(b.slice(Pa.length)),d=new Uint8Array(c.length);for(b=0;b<c.length;++b)d[b]=c.charCodeAt(b);}catch(e){throw Error("Converting base64 string to bytes failed.");}return d}}
            var sa={abort:function(){xa();},emscripten_memcpy_big:function(b,c,d){Aa.copyWithin(b,c,c+d);},emscripten_resize_heap:function(){xa("OOM");},gettimeofday:function(b){var c=Date.now();Ba[b>>2]=c/1E3|0;Ba[b+4>>2]=c%1E3*1E3|0;return 0},memory:ta,table:ua},Xa=function(){function b(g){a.asm=g.exports;La--;a.monitorRunDependencies&&a.monitorRunDependencies(La);0==La&&(Na&&(g=Na,Na=null,g()));}function c(g){b(g.instance);}function d(g){return Ua().then(function(){return va()}).then(g,
            function(n){ka("failed to asynchronously prepare wasm: "+n);xa(n);})}var e={env:sa,wasi_snapshot_preview1:sa};La++;a.monitorRunDependencies&&a.monitorRunDependencies(La);if(a.instantiateWasm)try{return a.instantiateWasm(e,b)}catch(g){return ka("Module.instantiateWasm callback failed with error: "+g),!1}(function(){if(na||"function"!==typeof WebAssembly.instantiateStreaming||Oa(Ra)||"function"!==typeof fetch)return d(c);fetch(Ra,{credentials:"same-origin"}).then(function(g){return WebAssembly.instantiateStreaming(g,
            e).then(c,function(n){ka("wasm streaming compile failed: "+n);ka("falling back to ArrayBuffer instantiation");d(c);})});})();return {}}();a.asm=Xa;var Va=a.___wasm_call_ctors=function(){return (Va=a.___wasm_call_ctors=a.asm.__wasm_call_ctors).apply(null,arguments)};a.___em_js__array_bounds_check_error=function(){return (a.___em_js__array_bounds_check_error=a.asm.__em_js__array_bounds_check_error).apply(null,arguments)};
            var Ya=a._a0_1=function(){return (Ya=a._a0_1=a.asm.a0_1).apply(null,arguments)},Za=a._a1_0=function(){return (Za=a._a1_0=a.asm.a1_0).apply(null,arguments)},$a=a._a2_2=function(){return ($a=a._a2_2=a.asm.a2_2).apply(null,arguments)},ab=a._a3_1=function(){return (ab=a._a3_1=a.asm.a3_1).apply(null,arguments)},bb=a._a4_0=function(){return (bb=a._a4_0=a.asm.a4_0).apply(null,arguments)},cb=a._a5_0=function(){return (cb=a._a5_0=a.asm.a5_0).apply(null,arguments)},db=a._a6_0=function(){return (db=a._a6_0=a.asm.a6_0).apply(null,
            arguments)},eb=a._a7_1=function(){return (eb=a._a7_1=a.asm.a7_1).apply(null,arguments)},fb=a._a8_0=function(){return (fb=a._a8_0=a.asm.a8_0).apply(null,arguments)},gb=a._a9_1=function(){return (gb=a._a9_1=a.asm.a9_1).apply(null,arguments)},hb=a._a10_3=function(){return (hb=a._a10_3=a.asm.a10_3).apply(null,arguments)},ib=a._a11_0=function(){return (ib=a._a11_0=a.asm.a11_0).apply(null,arguments)},jb=a._a12_0=function(){return (jb=a._a12_0=a.asm.a12_0).apply(null,arguments)},kb=a._a13_3=function(){return (kb=
            a._a13_3=a.asm.a13_3).apply(null,arguments)},lb=a._a14_6=function(){return (lb=a._a14_6=a.asm.a14_6).apply(null,arguments)},mb=a._a15_1=function(){return (mb=a._a15_1=a.asm.a15_1).apply(null,arguments)},nb=a._a15_2=function(){return (nb=a._a15_2=a.asm.a15_2).apply(null,arguments)},ob=a._a15_3=function(){return (ob=a._a15_3=a.asm.a15_3).apply(null,arguments)},pb=a._a16_1=function(){return (pb=a._a16_1=a.asm.a16_1).apply(null,arguments)},qb=a._a17_1=function(){return (qb=a._a17_1=a.asm.a17_1).apply(null,
            arguments)},rb=a._a18_0=function(){return (rb=a._a18_0=a.asm.a18_0).apply(null,arguments)},sb=a._a19_1=function(){return (sb=a._a19_1=a.asm.a19_1).apply(null,arguments)},tb=a._a20_0=function(){return (tb=a._a20_0=a.asm.a20_0).apply(null,arguments)},ub=a._a21_2=function(){return (ub=a._a21_2=a.asm.a21_2).apply(null,arguments)},vb=a._a22_1=function(){return (vb=a._a22_1=a.asm.a22_1).apply(null,arguments)},wb=a._a23_0=function(){return (wb=a._a23_0=a.asm.a23_0).apply(null,arguments)},xb=a._a24_0=function(){return (xb=
            a._a24_0=a.asm.a24_0).apply(null,arguments)},yb=a._a25_0=function(){return (yb=a._a25_0=a.asm.a25_0).apply(null,arguments)},zb=a._a26_1=function(){return (zb=a._a26_1=a.asm.a26_1).apply(null,arguments)},Ab=a._a27_0=function(){return (Ab=a._a27_0=a.asm.a27_0).apply(null,arguments)},Bb=a._a28_1=function(){return (Bb=a._a28_1=a.asm.a28_1).apply(null,arguments)},Cb=a._a29_3=function(){return (Cb=a._a29_3=a.asm.a29_3).apply(null,arguments)},Db=a._a30_0=function(){return (Db=a._a30_0=a.asm.a30_0).apply(null,
            arguments)},Eb=a._a31_0=function(){return (Eb=a._a31_0=a.asm.a31_0).apply(null,arguments)},Fb=a._a32_1=function(){return (Fb=a._a32_1=a.asm.a32_1).apply(null,arguments)},Gb=a._a33_1=function(){return (Gb=a._a33_1=a.asm.a33_1).apply(null,arguments)},Hb=a._a34_0=function(){return (Hb=a._a34_0=a.asm.a34_0).apply(null,arguments)},Ib=a._a35_3=function(){return (Ib=a._a35_3=a.asm.a35_3).apply(null,arguments)},Jb=a._a36_6=function(){return (Jb=a._a36_6=a.asm.a36_6).apply(null,arguments)},Kb=a._a37_1=function(){return (Kb=
            a._a37_1=a.asm.a37_1).apply(null,arguments)},Lb=a._a37_2=function(){return (Lb=a._a37_2=a.asm.a37_2).apply(null,arguments)},Mb=a._a37_3=function(){return (Mb=a._a37_3=a.asm.a37_3).apply(null,arguments)},Nb=a._a38_1=function(){return (Nb=a._a38_1=a.asm.a38_1).apply(null,arguments)},Ob=a._a39_1=function(){return (Ob=a._a39_1=a.asm.a39_1).apply(null,arguments)},Pb=a._a40_0=function(){return (Pb=a._a40_0=a.asm.a40_0).apply(null,arguments)},Qb=a._a41_0=function(){return (Qb=a._a41_0=a.asm.a41_0).apply(null,
            arguments)},Rb=a._a42_0=function(){return (Rb=a._a42_0=a.asm.a42_0).apply(null,arguments)},Sb=a._a43_1=function(){return (Sb=a._a43_1=a.asm.a43_1).apply(null,arguments)},Tb=a._a44_0=function(){return (Tb=a._a44_0=a.asm.a44_0).apply(null,arguments)},Ub=a._a45_2=function(){return (Ub=a._a45_2=a.asm.a45_2).apply(null,arguments)},Vb=a._a46_0=function(){return (Vb=a._a46_0=a.asm.a46_0).apply(null,arguments)},Wb=a._a47_0=function(){return (Wb=a._a47_0=a.asm.a47_0).apply(null,arguments)},Xb=a._a48_1=function(){return (Xb=
            a._a48_1=a.asm.a48_1).apply(null,arguments)},Yb=a._a49_0=function(){return (Yb=a._a49_0=a.asm.a49_0).apply(null,arguments)},Zb=a._a50_1=function(){return (Zb=a._a50_1=a.asm.a50_1).apply(null,arguments)},$b=a._a51_3=function(){return ($b=a._a51_3=a.asm.a51_3).apply(null,arguments)},ac=a._a52_0=function(){return (ac=a._a52_0=a.asm.a52_0).apply(null,arguments)},bc=a._a53_0=function(){return (bc=a._a53_0=a.asm.a53_0).apply(null,arguments)},cc=a._a54_1=function(){return (cc=a._a54_1=a.asm.a54_1).apply(null,
            arguments)},dc=a._a55_0=function(){return (dc=a._a55_0=a.asm.a55_0).apply(null,arguments)},ec=a._a56_0=function(){return (ec=a._a56_0=a.asm.a56_0).apply(null,arguments)},fc=a._a57_0=function(){return (fc=a._a57_0=a.asm.a57_0).apply(null,arguments)},gc=a._a58_0=function(){return (gc=a._a58_0=a.asm.a58_0).apply(null,arguments)},hc=a._a59_0=function(){return (hc=a._a59_0=a.asm.a59_0).apply(null,arguments)},ic=a._a60_1=function(){return (ic=a._a60_1=a.asm.a60_1).apply(null,arguments)},jc=a._a61_1=function(){return (jc=
            a._a61_1=a.asm.a61_1).apply(null,arguments)},kc=a._a62_0=function(){return (kc=a._a62_0=a.asm.a62_0).apply(null,arguments)},lc=a._a62_1=function(){return (lc=a._a62_1=a.asm.a62_1).apply(null,arguments)},mc=a._a63_0=function(){return (mc=a._a63_0=a.asm.a63_0).apply(null,arguments)},nc=a._a64_0=function(){return (nc=a._a64_0=a.asm.a64_0).apply(null,arguments)},oc=a._a65_0=function(){return (oc=a._a65_0=a.asm.a65_0).apply(null,arguments)},pc=a._a66_0=function(){return (pc=a._a66_0=a.asm.a66_0).apply(null,
            arguments)},qc=a._a67_1=function(){return (qc=a._a67_1=a.asm.a67_1).apply(null,arguments)},rc=a._a68_1=function(){return (rc=a._a68_1=a.asm.a68_1).apply(null,arguments)},sc=a._a69_1=function(){return (sc=a._a69_1=a.asm.a69_1).apply(null,arguments)},tc=a._a70_1=function(){return (tc=a._a70_1=a.asm.a70_1).apply(null,arguments)},uc=a._a71_0=function(){return (uc=a._a71_0=a.asm.a71_0).apply(null,arguments)},vc=a._a72_0=function(){return (vc=a._a72_0=a.asm.a72_0).apply(null,arguments)},wc=a._a73_1=function(){return (wc=
            a._a73_1=a.asm.a73_1).apply(null,arguments)},xc=a._a74_1=function(){return (xc=a._a74_1=a.asm.a74_1).apply(null,arguments)},yc=a._a75_1=function(){return (yc=a._a75_1=a.asm.a75_1).apply(null,arguments)},zc=a._a76_1=function(){return (zc=a._a76_1=a.asm.a76_1).apply(null,arguments)},Ac=a._a77_1=function(){return (Ac=a._a77_1=a.asm.a77_1).apply(null,arguments)},Bc=a._a78_0=function(){return (Bc=a._a78_0=a.asm.a78_0).apply(null,arguments)},Cc=a._a79_1=function(){return (Cc=a._a79_1=a.asm.a79_1).apply(null,
            arguments)},Dc=a._a80_1=function(){return (Dc=a._a80_1=a.asm.a80_1).apply(null,arguments)},Ec=a._a81_2=function(){return (Ec=a._a81_2=a.asm.a81_2).apply(null,arguments)},Fc=a._a82_0=function(){return (Fc=a._a82_0=a.asm.a82_0).apply(null,arguments)},Gc=a._a83_4=function(){return (Gc=a._a83_4=a.asm.a83_4).apply(null,arguments)},Hc=a._a84_1=function(){return (Hc=a._a84_1=a.asm.a84_1).apply(null,arguments)},Ic=a._a85_0=function(){return (Ic=a._a85_0=a.asm.a85_0).apply(null,arguments)},Jc=a._a86_1=function(){return (Jc=
            a._a86_1=a.asm.a86_1).apply(null,arguments)},Kc=a._a86_3=function(){return (Kc=a._a86_3=a.asm.a86_3).apply(null,arguments)},Lc=a._a87_1=function(){return (Lc=a._a87_1=a.asm.a87_1).apply(null,arguments)},Mc=a._a88_1=function(){return (Mc=a._a88_1=a.asm.a88_1).apply(null,arguments)},Nc=a._a88_2=function(){return (Nc=a._a88_2=a.asm.a88_2).apply(null,arguments)},Oc=a._a89_1=function(){return (Oc=a._a89_1=a.asm.a89_1).apply(null,arguments)},Pc=a._a90_1=function(){return (Pc=a._a90_1=a.asm.a90_1).apply(null,
            arguments)},Qc=a._a90_2=function(){return (Qc=a._a90_2=a.asm.a90_2).apply(null,arguments)},Rc=a._a90_3=function(){return (Rc=a._a90_3=a.asm.a90_3).apply(null,arguments)},Sc=a._a91_3=function(){return (Sc=a._a91_3=a.asm.a91_3).apply(null,arguments)},Tc=a._a92_6=function(){return (Tc=a._a92_6=a.asm.a92_6).apply(null,arguments)},Uc=a._a93_1=function(){return (Uc=a._a93_1=a.asm.a93_1).apply(null,arguments)},Vc=a._a93_2=function(){return (Vc=a._a93_2=a.asm.a93_2).apply(null,arguments)},Wc=a._a93_3=function(){return (Wc=
            a._a93_3=a.asm.a93_3).apply(null,arguments)},Xc=a._a94_1=function(){return (Xc=a._a94_1=a.asm.a94_1).apply(null,arguments)},Yc=a._a95_1=function(){return (Yc=a._a95_1=a.asm.a95_1).apply(null,arguments)},Zc=a._a96_1=function(){return (Zc=a._a96_1=a.asm.a96_1).apply(null,arguments)},$c=a._a97_1=function(){return ($c=a._a97_1=a.asm.a97_1).apply(null,arguments)},ad=a._a98_0=function(){return (ad=a._a98_0=a.asm.a98_0).apply(null,arguments)},bd=a._a99_0=function(){return (bd=a._a99_0=a.asm.a99_0).apply(null,
            arguments)},cd=a._a100_1=function(){return (cd=a._a100_1=a.asm.a100_1).apply(null,arguments)},dd=a._a101_1=function(){return (dd=a._a101_1=a.asm.a101_1).apply(null,arguments)},ed=a._a102_0=function(){return (ed=a._a102_0=a.asm.a102_0).apply(null,arguments)},fd=a._a103_0=function(){return (fd=a._a103_0=a.asm.a103_0).apply(null,arguments)},gd=a._a104_1=function(){return (gd=a._a104_1=a.asm.a104_1).apply(null,arguments)},hd=a._a105_0=function(){return (hd=a._a105_0=a.asm.a105_0).apply(null,arguments)},id=
            a._a106_2=function(){return (id=a._a106_2=a.asm.a106_2).apply(null,arguments)},jd=a._a107_1=function(){return (jd=a._a107_1=a.asm.a107_1).apply(null,arguments)},kd=a._a108_0=function(){return (kd=a._a108_0=a.asm.a108_0).apply(null,arguments)},ld=a._a109_0=function(){return (ld=a._a109_0=a.asm.a109_0).apply(null,arguments)},md=a._a110_0=function(){return (md=a._a110_0=a.asm.a110_0).apply(null,arguments)},nd=a._a111_1=function(){return (nd=a._a111_1=a.asm.a111_1).apply(null,arguments)},od=a._a112_0=function(){return (od=
            a._a112_0=a.asm.a112_0).apply(null,arguments)},pd=a._a113_1=function(){return (pd=a._a113_1=a.asm.a113_1).apply(null,arguments)},qd=a._a114_3=function(){return (qd=a._a114_3=a.asm.a114_3).apply(null,arguments)},rd=a._a115_0=function(){return (rd=a._a115_0=a.asm.a115_0).apply(null,arguments)},sd=a._a116_0=function(){return (sd=a._a116_0=a.asm.a116_0).apply(null,arguments)},td=a._a117_0=function(){return (td=a._a117_0=a.asm.a117_0).apply(null,arguments)},ud=a._a118_0=function(){return (ud=a._a118_0=a.asm.a118_0).apply(null,
            arguments)},vd=a._a119_1=function(){return (vd=a._a119_1=a.asm.a119_1).apply(null,arguments)},wd=a._a120_0=function(){return (wd=a._a120_0=a.asm.a120_0).apply(null,arguments)},xd=a._a121_1=function(){return (xd=a._a121_1=a.asm.a121_1).apply(null,arguments)},yd=a._a122_0=function(){return (yd=a._a122_0=a.asm.a122_0).apply(null,arguments)},zd=a._a123_0=function(){return (zd=a._a123_0=a.asm.a123_0).apply(null,arguments)},Ad=a._a124_1=function(){return (Ad=a._a124_1=a.asm.a124_1).apply(null,arguments)},Bd=
            a._a125_0=function(){return (Bd=a._a125_0=a.asm.a125_0).apply(null,arguments)},Cd=a._a126_0=function(){return (Cd=a._a126_0=a.asm.a126_0).apply(null,arguments)},Dd=a._a127_0=function(){return (Dd=a._a127_0=a.asm.a127_0).apply(null,arguments)},Ed=a._a128_1=function(){return (Ed=a._a128_1=a.asm.a128_1).apply(null,arguments)},Fd=a._a129_0=function(){return (Fd=a._a129_0=a.asm.a129_0).apply(null,arguments)},Gd=a._a130_1=function(){return (Gd=a._a130_1=a.asm.a130_1).apply(null,arguments)},Hd=a._a131_0=function(){return (Hd=
            a._a131_0=a.asm.a131_0).apply(null,arguments)},Id=a._a132_1=function(){return (Id=a._a132_1=a.asm.a132_1).apply(null,arguments)},Jd=a._a133_0=function(){return (Jd=a._a133_0=a.asm.a133_0).apply(null,arguments)},Kd=a._a134_2=function(){return (Kd=a._a134_2=a.asm.a134_2).apply(null,arguments)},Ld=a._a135_0=function(){return (Ld=a._a135_0=a.asm.a135_0).apply(null,arguments)},Md=a._a136_0=function(){return (Md=a._a136_0=a.asm.a136_0).apply(null,arguments)},Nd=a._a137_1=function(){return (Nd=a._a137_1=a.asm.a137_1).apply(null,
            arguments)},Od=a._a138_0=function(){return (Od=a._a138_0=a.asm.a138_0).apply(null,arguments)},Pd=a._a139_1=function(){return (Pd=a._a139_1=a.asm.a139_1).apply(null,arguments)},Qd=a._a140_3=function(){return (Qd=a._a140_3=a.asm.a140_3).apply(null,arguments)},Rd=a._a141_0=function(){return (Rd=a._a141_0=a.asm.a141_0).apply(null,arguments)},Sd=a._a142_0=function(){return (Sd=a._a142_0=a.asm.a142_0).apply(null,arguments)},Td=a._a143_0=function(){return (Td=a._a143_0=a.asm.a143_0).apply(null,arguments)},Ud=
            a._a144_0=function(){return (Ud=a._a144_0=a.asm.a144_0).apply(null,arguments)},Vd=a._a145_0=function(){return (Vd=a._a145_0=a.asm.a145_0).apply(null,arguments)},Wd=a._a146_0=function(){return (Wd=a._a146_0=a.asm.a146_0).apply(null,arguments)},Xd=a._a147_1=function(){return (Xd=a._a147_1=a.asm.a147_1).apply(null,arguments)},Yd=a._a148_1=function(){return (Yd=a._a148_1=a.asm.a148_1).apply(null,arguments)},Zd=a._a149_1=function(){return (Zd=a._a149_1=a.asm.a149_1).apply(null,arguments)},$d=a._a150_1=function(){return ($d=
            a._a150_1=a.asm.a150_1).apply(null,arguments)},ae=a._a151_0=function(){return (ae=a._a151_0=a.asm.a151_0).apply(null,arguments)},be=a._a152_1=function(){return (be=a._a152_1=a.asm.a152_1).apply(null,arguments)},ce=a._a153_0=function(){return (ce=a._a153_0=a.asm.a153_0).apply(null,arguments)},de=a._a154_1=function(){return (de=a._a154_1=a.asm.a154_1).apply(null,arguments)},ee=a._a155_2=function(){return (ee=a._a155_2=a.asm.a155_2).apply(null,arguments)},fe=a._a156_3=function(){return (fe=a._a156_3=a.asm.a156_3).apply(null,
            arguments)},ge=a._a157_0=function(){return (ge=a._a157_0=a.asm.a157_0).apply(null,arguments)},he=a._a158_1=function(){return (he=a._a158_1=a.asm.a158_1).apply(null,arguments)},ie=a._a159_0=function(){return (ie=a._a159_0=a.asm.a159_0).apply(null,arguments)},je=a._a160_0=function(){return (je=a._a160_0=a.asm.a160_0).apply(null,arguments)},ke=a._a161_1=function(){return (ke=a._a161_1=a.asm.a161_1).apply(null,arguments)},le=a._a162_0=function(){return (le=a._a162_0=a.asm.a162_0).apply(null,arguments)},me=
            a._a163_0=function(){return (me=a._a163_0=a.asm.a163_0).apply(null,arguments)},ne=a._a164_2=function(){return (ne=a._a164_2=a.asm.a164_2).apply(null,arguments)},oe=a._a164_3=function(){return (oe=a._a164_3=a.asm.a164_3).apply(null,arguments)},pe=a._a165_1=function(){return (pe=a._a165_1=a.asm.a165_1).apply(null,arguments)},qe=a._a166_0=function(){return (qe=a._a166_0=a.asm.a166_0).apply(null,arguments)},re=a._a167_2=function(){return (re=a._a167_2=a.asm.a167_2).apply(null,arguments)},se=a._a168_0=function(){return (se=
            a._a168_0=a.asm.a168_0).apply(null,arguments)},te=a._a169_0=function(){return (te=a._a169_0=a.asm.a169_0).apply(null,arguments)},ue=a._a170_1=function(){return (ue=a._a170_1=a.asm.a170_1).apply(null,arguments)},ve=a._a171_0=function(){return (ve=a._a171_0=a.asm.a171_0).apply(null,arguments)},we=a._a172_1=function(){return (we=a._a172_1=a.asm.a172_1).apply(null,arguments)},xe=a._a173_3=function(){return (xe=a._a173_3=a.asm.a173_3).apply(null,arguments)},ye=a._a174_0=function(){return (ye=a._a174_0=a.asm.a174_0).apply(null,
            arguments)},ze=a._a175_0=function(){return (ze=a._a175_0=a.asm.a175_0).apply(null,arguments)},Ae=a._a176_0=function(){return (Ae=a._a176_0=a.asm.a176_0).apply(null,arguments)},Be=a._a177_0=function(){return (Be=a._a177_0=a.asm.a177_0).apply(null,arguments)},Ce=a._a178_0=function(){return (Ce=a._a178_0=a.asm.a178_0).apply(null,arguments)},De=a._a179_1=function(){return (De=a._a179_1=a.asm.a179_1).apply(null,arguments)},Ee=a._a180_0=function(){return (Ee=a._a180_0=a.asm.a180_0).apply(null,arguments)},Fe=
            a._a181_0=function(){return (Fe=a._a181_0=a.asm.a181_0).apply(null,arguments)},Ge=a._a182_2=function(){return (Ge=a._a182_2=a.asm.a182_2).apply(null,arguments)},He=a._a183_0=function(){return (He=a._a183_0=a.asm.a183_0).apply(null,arguments)},Ie=a._a184_0=function(){return (Ie=a._a184_0=a.asm.a184_0).apply(null,arguments)},Je=a._a185_0=function(){return (Je=a._a185_0=a.asm.a185_0).apply(null,arguments)},Ke=a._a186_0=function(){return (Ke=a._a186_0=a.asm.a186_0).apply(null,arguments)},Le=a._a187_2=function(){return (Le=
            a._a187_2=a.asm.a187_2).apply(null,arguments)},Me=a._a188_0=function(){return (Me=a._a188_0=a.asm.a188_0).apply(null,arguments)},Ne=a._a189_0=function(){return (Ne=a._a189_0=a.asm.a189_0).apply(null,arguments)},Oe=a._a190_1=function(){return (Oe=a._a190_1=a.asm.a190_1).apply(null,arguments)},Pe=a._a191_0=function(){return (Pe=a._a191_0=a.asm.a191_0).apply(null,arguments)},Qe=a._a192_1=function(){return (Qe=a._a192_1=a.asm.a192_1).apply(null,arguments)},Re=a._a193_0=function(){return (Re=a._a193_0=a.asm.a193_0).apply(null,
            arguments)},Se=a._a194_2=function(){return (Se=a._a194_2=a.asm.a194_2).apply(null,arguments)},Te=a._a195_1=function(){return (Te=a._a195_1=a.asm.a195_1).apply(null,arguments)},Ue=a._a196_0=function(){return (Ue=a._a196_0=a.asm.a196_0).apply(null,arguments)},Ve=a._a197_3=function(){return (Ve=a._a197_3=a.asm.a197_3).apply(null,arguments)},We=a._a198_1=function(){return (We=a._a198_1=a.asm.a198_1).apply(null,arguments)},Xe=a._a199_0=function(){return (Xe=a._a199_0=a.asm.a199_0).apply(null,arguments)},Ye=
            a._a200_2=function(){return (Ye=a._a200_2=a.asm.a200_2).apply(null,arguments)},Ze=a._a201_0=function(){return (Ze=a._a201_0=a.asm.a201_0).apply(null,arguments)},$e=a._a202_0=function(){return ($e=a._a202_0=a.asm.a202_0).apply(null,arguments)},af=a._a203_1=function(){return (af=a._a203_1=a.asm.a203_1).apply(null,arguments)},bf=a._a204_0=function(){return (bf=a._a204_0=a.asm.a204_0).apply(null,arguments)},cf=a._a205_1=function(){return (cf=a._a205_1=a.asm.a205_1).apply(null,arguments)},df=a._a206_3=function(){return (df=
            a._a206_3=a.asm.a206_3).apply(null,arguments)},ef=a._a207_0=function(){return (ef=a._a207_0=a.asm.a207_0).apply(null,arguments)},ff=a._a208_0=function(){return (ff=a._a208_0=a.asm.a208_0).apply(null,arguments)},gf=a._a209_0=function(){return (gf=a._a209_0=a.asm.a209_0).apply(null,arguments)},hf=a._a210_0=function(){return (hf=a._a210_0=a.asm.a210_0).apply(null,arguments)},jf=a._a211_1=function(){return (jf=a._a211_1=a.asm.a211_1).apply(null,arguments)},kf=a._a212_0=function(){return (kf=a._a212_0=a.asm.a212_0).apply(null,
            arguments)},lf=a._a213_1=function(){return (lf=a._a213_1=a.asm.a213_1).apply(null,arguments)},mf=a._a214_0=function(){return (mf=a._a214_0=a.asm.a214_0).apply(null,arguments)},nf=a._a215_0=function(){return (nf=a._a215_0=a.asm.a215_0).apply(null,arguments)},of=a._a216_1=function(){return (of=a._a216_1=a.asm.a216_1).apply(null,arguments)},pf=a._a217_0=function(){return (pf=a._a217_0=a.asm.a217_0).apply(null,arguments)},qf=a._a218_3=function(){return (qf=a._a218_3=a.asm.a218_3).apply(null,arguments)},rf=
            a._a218_4=function(){return (rf=a._a218_4=a.asm.a218_4).apply(null,arguments)},sf=a._a219_0=function(){return (sf=a._a219_0=a.asm.a219_0).apply(null,arguments)},tf=a._a220_1=function(){return (tf=a._a220_1=a.asm.a220_1).apply(null,arguments)},uf=a._a221_0=function(){return (uf=a._a221_0=a.asm.a221_0).apply(null,arguments)},vf=a._a222_1=function(){return (vf=a._a222_1=a.asm.a222_1).apply(null,arguments)},wf=a._a223_0=function(){return (wf=a._a223_0=a.asm.a223_0).apply(null,arguments)},xf=a._a224_1=function(){return (xf=
            a._a224_1=a.asm.a224_1).apply(null,arguments)},yf=a._a225_0=function(){return (yf=a._a225_0=a.asm.a225_0).apply(null,arguments)},zf=a._a226_1=function(){return (zf=a._a226_1=a.asm.a226_1).apply(null,arguments)},Af=a._a227_0=function(){return (Af=a._a227_0=a.asm.a227_0).apply(null,arguments)},Bf=a._a228_1=function(){return (Bf=a._a228_1=a.asm.a228_1).apply(null,arguments)},Cf=a._a229_0=function(){return (Cf=a._a229_0=a.asm.a229_0).apply(null,arguments)},Df=a._a230_1=function(){return (Df=a._a230_1=a.asm.a230_1).apply(null,
            arguments)},Ef=a._a231_0=function(){return (Ef=a._a231_0=a.asm.a231_0).apply(null,arguments)},Ff=a._a232_1=function(){return (Ff=a._a232_1=a.asm.a232_1).apply(null,arguments)},Gf=a._a233_0=function(){return (Gf=a._a233_0=a.asm.a233_0).apply(null,arguments)},Hf=a._a234_0=function(){return (Hf=a._a234_0=a.asm.a234_0).apply(null,arguments)},If=a._a235_0=function(){return (If=a._a235_0=a.asm.a235_0).apply(null,arguments)},Jf=a._a236_0=function(){return (Jf=a._a236_0=a.asm.a236_0).apply(null,arguments)},Kf=
            a._a237_0=function(){return (Kf=a._a237_0=a.asm.a237_0).apply(null,arguments)},Lf=a._a238_0=function(){return (Lf=a._a238_0=a.asm.a238_0).apply(null,arguments)},Mf=a._a239_1=function(){return (Mf=a._a239_1=a.asm.a239_1).apply(null,arguments)},Nf=a._a240_0=function(){return (Nf=a._a240_0=a.asm.a240_0).apply(null,arguments)},Of=a._a241_1=function(){return (Of=a._a241_1=a.asm.a241_1).apply(null,arguments)},Pf=a._a242_0=function(){return (Pf=a._a242_0=a.asm.a242_0).apply(null,arguments)},Qf=a._a243_1=function(){return (Qf=
            a._a243_1=a.asm.a243_1).apply(null,arguments)},Rf=a._a244_0=function(){return (Rf=a._a244_0=a.asm.a244_0).apply(null,arguments)},Sf=a._a245_1=function(){return (Sf=a._a245_1=a.asm.a245_1).apply(null,arguments)},Tf=a._a246_0=function(){return (Tf=a._a246_0=a.asm.a246_0).apply(null,arguments)},Uf=a._a247_1=function(){return (Uf=a._a247_1=a.asm.a247_1).apply(null,arguments)},Vf=a._a248_0=function(){return (Vf=a._a248_0=a.asm.a248_0).apply(null,arguments)},Wf=a._a249_1=function(){return (Wf=a._a249_1=a.asm.a249_1).apply(null,
            arguments)},Xf=a._a250_0=function(){return (Xf=a._a250_0=a.asm.a250_0).apply(null,arguments)},Yf=a._a251_1=function(){return (Yf=a._a251_1=a.asm.a251_1).apply(null,arguments)},Zf=a._a252_0=function(){return (Zf=a._a252_0=a.asm.a252_0).apply(null,arguments)},$f=a._a253_1=function(){return ($f=a._a253_1=a.asm.a253_1).apply(null,arguments)},ag=a._a254_0=function(){return (ag=a._a254_0=a.asm.a254_0).apply(null,arguments)},bg=a._a255_0=function(){return (bg=a._a255_0=a.asm.a255_0).apply(null,arguments)},cg=
            a._a256_0=function(){return (cg=a._a256_0=a.asm.a256_0).apply(null,arguments)},dg=a._a257_2=function(){return (dg=a._a257_2=a.asm.a257_2).apply(null,arguments)},eg=a._a257_4=function(){return (eg=a._a257_4=a.asm.a257_4).apply(null,arguments)},fg=a._a258_1=function(){return (fg=a._a258_1=a.asm.a258_1).apply(null,arguments)},gg=a._a259_1=function(){return (gg=a._a259_1=a.asm.a259_1).apply(null,arguments)},hg=a._a260_0=function(){return (hg=a._a260_0=a.asm.a260_0).apply(null,arguments)},ig=a._a261_0=function(){return (ig=
            a._a261_0=a.asm.a261_0).apply(null,arguments)},jg=a._a262_1=function(){return (jg=a._a262_1=a.asm.a262_1).apply(null,arguments)},kg=a._a263_0=function(){return (kg=a._a263_0=a.asm.a263_0).apply(null,arguments)},lg=a._a264_1=function(){return (lg=a._a264_1=a.asm.a264_1).apply(null,arguments)},mg=a._a265_2=function(){return (mg=a._a265_2=a.asm.a265_2).apply(null,arguments)},ng=a._a266_3=function(){return (ng=a._a266_3=a.asm.a266_3).apply(null,arguments)},og=a._a267_0=function(){return (og=a._a267_0=a.asm.a267_0).apply(null,
            arguments)},pg=a._a268_1=function(){return (pg=a._a268_1=a.asm.a268_1).apply(null,arguments)},qg=a._a269_0=function(){return (qg=a._a269_0=a.asm.a269_0).apply(null,arguments)},rg=a._a270_1=function(){return (rg=a._a270_1=a.asm.a270_1).apply(null,arguments)},sg=a._a270_2=function(){return (sg=a._a270_2=a.asm.a270_2).apply(null,arguments)},tg=a._a271_1=function(){return (tg=a._a271_1=a.asm.a271_1).apply(null,arguments)},ug=a._a272_0=function(){return (ug=a._a272_0=a.asm.a272_0).apply(null,arguments)},vg=
            a._a273_2=function(){return (vg=a._a273_2=a.asm.a273_2).apply(null,arguments)},wg=a._a274_1=function(){return (wg=a._a274_1=a.asm.a274_1).apply(null,arguments)},xg=a._a275_0=function(){return (xg=a._a275_0=a.asm.a275_0).apply(null,arguments)},yg=a._a276_0=function(){return (yg=a._a276_0=a.asm.a276_0).apply(null,arguments)},zg=a._a277_0=function(){return (zg=a._a277_0=a.asm.a277_0).apply(null,arguments)},Ag=a._a278_1=function(){return (Ag=a._a278_1=a.asm.a278_1).apply(null,arguments)},Bg=a._a279_0=function(){return (Bg=
            a._a279_0=a.asm.a279_0).apply(null,arguments)},Cg=a._a280_1=function(){return (Cg=a._a280_1=a.asm.a280_1).apply(null,arguments)},Dg=a._a281_3=function(){return (Dg=a._a281_3=a.asm.a281_3).apply(null,arguments)},Eg=a._a282_0=function(){return (Eg=a._a282_0=a.asm.a282_0).apply(null,arguments)},Fg=a._a283_0=function(){return (Fg=a._a283_0=a.asm.a283_0).apply(null,arguments)},Gg=a._a284_2=function(){return (Gg=a._a284_2=a.asm.a284_2).apply(null,arguments)},Hg=a._a285_0=function(){return (Hg=a._a285_0=a.asm.a285_0).apply(null,
            arguments)},Ig=a._a286_0=function(){return (Ig=a._a286_0=a.asm.a286_0).apply(null,arguments)},Jg=a._a287_0=function(){return (Jg=a._a287_0=a.asm.a287_0).apply(null,arguments)},Kg=a._a288_0=function(){return (Kg=a._a288_0=a.asm.a288_0).apply(null,arguments)},Lg=a._a289_2=function(){return (Lg=a._a289_2=a.asm.a289_2).apply(null,arguments)},Mg=a._a290_0=function(){return (Mg=a._a290_0=a.asm.a290_0).apply(null,arguments)},Ng=a._a291_0=function(){return (Ng=a._a291_0=a.asm.a291_0).apply(null,arguments)},Og=
            a._a292_1=function(){return (Og=a._a292_1=a.asm.a292_1).apply(null,arguments)},Pg=a._a293_0=function(){return (Pg=a._a293_0=a.asm.a293_0).apply(null,arguments)},Qg=a._a294_1=function(){return (Qg=a._a294_1=a.asm.a294_1).apply(null,arguments)},Rg=a._a295_0=function(){return (Rg=a._a295_0=a.asm.a295_0).apply(null,arguments)},Sg=a._a296_9=function(){return (Sg=a._a296_9=a.asm.a296_9).apply(null,arguments)},Tg=a._a297_1=function(){return (Tg=a._a297_1=a.asm.a297_1).apply(null,arguments)},Ug=a._a298_0=function(){return (Ug=
            a._a298_0=a.asm.a298_0).apply(null,arguments)},Vg=a._a299_1=function(){return (Vg=a._a299_1=a.asm.a299_1).apply(null,arguments)},Wg=a._a300_0=function(){return (Wg=a._a300_0=a.asm.a300_0).apply(null,arguments)},Xg=a._a301_2=function(){return (Xg=a._a301_2=a.asm.a301_2).apply(null,arguments)},Yg=a._a302_0=function(){return (Yg=a._a302_0=a.asm.a302_0).apply(null,arguments)},Zg=a._a303_0=function(){return (Zg=a._a303_0=a.asm.a303_0).apply(null,arguments)},$g=a._a304_1=function(){return ($g=a._a304_1=a.asm.a304_1).apply(null,
            arguments)},ah=a._a305_0=function(){return (ah=a._a305_0=a.asm.a305_0).apply(null,arguments)},bh=a._a306_1=function(){return (bh=a._a306_1=a.asm.a306_1).apply(null,arguments)},ch=a._a307_3=function(){return (ch=a._a307_3=a.asm.a307_3).apply(null,arguments)},dh=a._a308_0=function(){return (dh=a._a308_0=a.asm.a308_0).apply(null,arguments)},eh=a._a309_0=function(){return (eh=a._a309_0=a.asm.a309_0).apply(null,arguments)},fh=a._a310_0=function(){return (fh=a._a310_0=a.asm.a310_0).apply(null,arguments)},gh=
            a._a311_0=function(){return (gh=a._a311_0=a.asm.a311_0).apply(null,arguments)},hh=a._a311_1=function(){return (hh=a._a311_1=a.asm.a311_1).apply(null,arguments)},ih=a._a312_0=function(){return (ih=a._a312_0=a.asm.a312_0).apply(null,arguments)},jh=a._a313_0=function(){return (jh=a._a313_0=a.asm.a313_0).apply(null,arguments)},kh=a._a313_1=function(){return (kh=a._a313_1=a.asm.a313_1).apply(null,arguments)},lh=a._a313_2=function(){return (lh=a._a313_2=a.asm.a313_2).apply(null,arguments)},mh=a._a314_3=function(){return (mh=
            a._a314_3=a.asm.a314_3).apply(null,arguments)},nh=a._a314_4=function(){return (nh=a._a314_4=a.asm.a314_4).apply(null,arguments)},oh=a._a315_3=function(){return (oh=a._a315_3=a.asm.a315_3).apply(null,arguments)},ph=a._a316_0=function(){return (ph=a._a316_0=a.asm.a316_0).apply(null,arguments)},qh=a._a317_1=function(){return (qh=a._a317_1=a.asm.a317_1).apply(null,arguments)},rh=a._a318_0=function(){return (rh=a._a318_0=a.asm.a318_0).apply(null,arguments)},sh=a._a319_0=function(){return (sh=a._a319_0=a.asm.a319_0).apply(null,
            arguments)},th=a._a320_0=function(){return (th=a._a320_0=a.asm.a320_0).apply(null,arguments)},uh=a._a321_0=function(){return (uh=a._a321_0=a.asm.a321_0).apply(null,arguments)},vh=a._a322_0=function(){return (vh=a._a322_0=a.asm.a322_0).apply(null,arguments)},wh=a._a323_0=function(){return (wh=a._a323_0=a.asm.a323_0).apply(null,arguments)},xh=a._a324_1=function(){return (xh=a._a324_1=a.asm.a324_1).apply(null,arguments)},yh=a._a325_0=function(){return (yh=a._a325_0=a.asm.a325_0).apply(null,arguments)},zh=
            a._a326_1=function(){return (zh=a._a326_1=a.asm.a326_1).apply(null,arguments)},Ah=a._a327_1=function(){return (Ah=a._a327_1=a.asm.a327_1).apply(null,arguments)},Bh=a._a328_0=function(){return (Bh=a._a328_0=a.asm.a328_0).apply(null,arguments)},Ch=a._a329_1=function(){return (Ch=a._a329_1=a.asm.a329_1).apply(null,arguments)},Dh=a._a330_1=function(){return (Dh=a._a330_1=a.asm.a330_1).apply(null,arguments)},Eh=a._a331_0=function(){return (Eh=a._a331_0=a.asm.a331_0).apply(null,arguments)},Fh=a._a332_2=function(){return (Fh=
            a._a332_2=a.asm.a332_2).apply(null,arguments)},Gh=a._a333_0=function(){return (Gh=a._a333_0=a.asm.a333_0).apply(null,arguments)},Hh=a._a334_0=function(){return (Hh=a._a334_0=a.asm.a334_0).apply(null,arguments)},Ih=a._a335_1=function(){return (Ih=a._a335_1=a.asm.a335_1).apply(null,arguments)},Jh=a._a336_0=function(){return (Jh=a._a336_0=a.asm.a336_0).apply(null,arguments)},Kh=a._a337_1=function(){return (Kh=a._a337_1=a.asm.a337_1).apply(null,arguments)},Lh=a._a338_3=function(){return (Lh=a._a338_3=a.asm.a338_3).apply(null,
            arguments)},Mh=a._a339_0=function(){return (Mh=a._a339_0=a.asm.a339_0).apply(null,arguments)},Nh=a._a340_0=function(){return (Nh=a._a340_0=a.asm.a340_0).apply(null,arguments)},Oh=a._a341_0=function(){return (Oh=a._a341_0=a.asm.a341_0).apply(null,arguments)},Ph=a._a342_1=function(){return (Ph=a._a342_1=a.asm.a342_1).apply(null,arguments)},Qh=a._a343_1=function(){return (Qh=a._a343_1=a.asm.a343_1).apply(null,arguments)},Rh=a._a344_0=function(){return (Rh=a._a344_0=a.asm.a344_0).apply(null,arguments)},Sh=
            a._a345_1=function(){return (Sh=a._a345_1=a.asm.a345_1).apply(null,arguments)},Th=a._a346_0=function(){return (Th=a._a346_0=a.asm.a346_0).apply(null,arguments)},Uh=a._a347_0=function(){return (Uh=a._a347_0=a.asm.a347_0).apply(null,arguments)},Vh=a._a347_1=function(){return (Vh=a._a347_1=a.asm.a347_1).apply(null,arguments)},Wh=a._a348_2=function(){return (Wh=a._a348_2=a.asm.a348_2).apply(null,arguments)},Xh=a._a349_1=function(){return (Xh=a._a349_1=a.asm.a349_1).apply(null,arguments)},Yh=a._a350_1=function(){return (Yh=
            a._a350_1=a.asm.a350_1).apply(null,arguments)},Zh=a._a351_0=function(){return (Zh=a._a351_0=a.asm.a351_0).apply(null,arguments)},$h=a._a352_1=function(){return ($h=a._a352_1=a.asm.a352_1).apply(null,arguments)},ai=a._a353_2=function(){return (ai=a._a353_2=a.asm.a353_2).apply(null,arguments)},bi=a._a353_3=function(){return (bi=a._a353_3=a.asm.a353_3).apply(null,arguments)},ci=a._a354_1=function(){return (ci=a._a354_1=a.asm.a354_1).apply(null,arguments)},di=a._a355_0=function(){return (di=a._a355_0=a.asm.a355_0).apply(null,
            arguments)},ei=a._a356_3=function(){return (ei=a._a356_3=a.asm.a356_3).apply(null,arguments)},fi=a._a356_4=function(){return (fi=a._a356_4=a.asm.a356_4).apply(null,arguments)},gi=a._a356_5=function(){return (gi=a._a356_5=a.asm.a356_5).apply(null,arguments)},hi=a._a356_6=function(){return (hi=a._a356_6=a.asm.a356_6).apply(null,arguments)},ii=a._a357_1=function(){return (ii=a._a357_1=a.asm.a357_1).apply(null,arguments)},ji=a._a358_0=function(){return (ji=a._a358_0=a.asm.a358_0).apply(null,arguments)},ki=
            a._a359_2=function(){return (ki=a._a359_2=a.asm.a359_2).apply(null,arguments)},li=a._a360_0=function(){return (li=a._a360_0=a.asm.a360_0).apply(null,arguments)},mi=a._a361_0=function(){return (mi=a._a361_0=a.asm.a361_0).apply(null,arguments)},ni=a._a362_1=function(){return (ni=a._a362_1=a.asm.a362_1).apply(null,arguments)},oi=a._a363_0=function(){return (oi=a._a363_0=a.asm.a363_0).apply(null,arguments)},pi=a._a364_1=function(){return (pi=a._a364_1=a.asm.a364_1).apply(null,arguments)},qi=a._a365_3=function(){return (qi=
            a._a365_3=a.asm.a365_3).apply(null,arguments)},ri=a._a366_0=function(){return (ri=a._a366_0=a.asm.a366_0).apply(null,arguments)},si=a._a367_0=function(){return (si=a._a367_0=a.asm.a367_0).apply(null,arguments)},ti=a._a368_0=function(){return (ti=a._a368_0=a.asm.a368_0).apply(null,arguments)},ui=a._a368_1=function(){return (ui=a._a368_1=a.asm.a368_1).apply(null,arguments)},vi=a._a368_2=function(){return (vi=a._a368_2=a.asm.a368_2).apply(null,arguments)},wi=a._a369_1=function(){return (wi=a._a369_1=a.asm.a369_1).apply(null,
            arguments)},xi=a._a370_1=function(){return (xi=a._a370_1=a.asm.a370_1).apply(null,arguments)},yi=a._a371_0=function(){return (yi=a._a371_0=a.asm.a371_0).apply(null,arguments)},zi=a._a372_4=function(){return (zi=a._a372_4=a.asm.a372_4).apply(null,arguments)},Ai=a._a372_5=function(){return (Ai=a._a372_5=a.asm.a372_5).apply(null,arguments)},Bi=a._a373_4=function(){return (Bi=a._a373_4=a.asm.a373_4).apply(null,arguments)},Ci=a._a373_5=function(){return (Ci=a._a373_5=a.asm.a373_5).apply(null,arguments)},Di=
            a._a374_3=function(){return (Di=a._a374_3=a.asm.a374_3).apply(null,arguments)},Ei=a._a375_1=function(){return (Ei=a._a375_1=a.asm.a375_1).apply(null,arguments)},Fi=a._a376_1=function(){return (Fi=a._a376_1=a.asm.a376_1).apply(null,arguments)},Gi=a._a377_1=function(){return (Gi=a._a377_1=a.asm.a377_1).apply(null,arguments)},Hi=a._a378_2=function(){return (Hi=a._a378_2=a.asm.a378_2).apply(null,arguments)},Ii=a._a379_2=function(){return (Ii=a._a379_2=a.asm.a379_2).apply(null,arguments)},Ji=a._a380_1=function(){return (Ji=
            a._a380_1=a.asm.a380_1).apply(null,arguments)},Ki=a._a381_1=function(){return (Ki=a._a381_1=a.asm.a381_1).apply(null,arguments)},Li=a._a382_1=function(){return (Li=a._a382_1=a.asm.a382_1).apply(null,arguments)},Mi=a._a383_0=function(){return (Mi=a._a383_0=a.asm.a383_0).apply(null,arguments)},Ni=a._a384_1=function(){return (Ni=a._a384_1=a.asm.a384_1).apply(null,arguments)},Oi=a._a385_2=function(){return (Oi=a._a385_2=a.asm.a385_2).apply(null,arguments)},Pi=a._a386_3=function(){return (Pi=a._a386_3=a.asm.a386_3).apply(null,
            arguments)},Qi=a._a387_0=function(){return (Qi=a._a387_0=a.asm.a387_0).apply(null,arguments)},Ri=a._a388_4=function(){return (Ri=a._a388_4=a.asm.a388_4).apply(null,arguments)},Si=a._a389_4=function(){return (Si=a._a389_4=a.asm.a389_4).apply(null,arguments)},Ti=a._a390_0=function(){return (Ti=a._a390_0=a.asm.a390_0).apply(null,arguments)},Ui=a._a391_0=function(){return (Ui=a._a391_0=a.asm.a391_0).apply(null,arguments)},Vi=a._a392_0=function(){return (Vi=a._a392_0=a.asm.a392_0).apply(null,arguments)},Wi=
            a._a393_0=function(){return (Wi=a._a393_0=a.asm.a393_0).apply(null,arguments)},Xi=a._a394_1=function(){return (Xi=a._a394_1=a.asm.a394_1).apply(null,arguments)},Yi=a._a395_1=function(){return (Yi=a._a395_1=a.asm.a395_1).apply(null,arguments)},Zi=a._a396_1=function(){return (Zi=a._a396_1=a.asm.a396_1).apply(null,arguments)},$i=a._a397_1=function(){return ($i=a._a397_1=a.asm.a397_1).apply(null,arguments)},aj=a._a398_0=function(){return (aj=a._a398_0=a.asm.a398_0).apply(null,arguments)},bj=a._a399_2=function(){return (bj=
            a._a399_2=a.asm.a399_2).apply(null,arguments)},cj=a._a400_1=function(){return (cj=a._a400_1=a.asm.a400_1).apply(null,arguments)},dj=a._a401_1=function(){return (dj=a._a401_1=a.asm.a401_1).apply(null,arguments)},ej=a._a402_1=function(){return (ej=a._a402_1=a.asm.a402_1).apply(null,arguments)},fj=a._a403_1=function(){return (fj=a._a403_1=a.asm.a403_1).apply(null,arguments)},gj=a._a404_0=function(){return (gj=a._a404_0=a.asm.a404_0).apply(null,arguments)},hj=a._a405_2=function(){return (hj=a._a405_2=a.asm.a405_2).apply(null,
            arguments)},ij=a._a406_0=function(){return (ij=a._a406_0=a.asm.a406_0).apply(null,arguments)},jj=a._a407_0=function(){return (jj=a._a407_0=a.asm.a407_0).apply(null,arguments)},kj=a._a408_1=function(){return (kj=a._a408_1=a.asm.a408_1).apply(null,arguments)},lj=a._a409_0=function(){return (lj=a._a409_0=a.asm.a409_0).apply(null,arguments)},mj=a._a410_1=function(){return (mj=a._a410_1=a.asm.a410_1).apply(null,arguments)},nj=a._a411_3=function(){return (nj=a._a411_3=a.asm.a411_3).apply(null,arguments)},oj=
            a._a412_0=function(){return (oj=a._a412_0=a.asm.a412_0).apply(null,arguments)},pj=a._a413_0=function(){return (pj=a._a413_0=a.asm.a413_0).apply(null,arguments)},qj=a._a414_0=function(){return (qj=a._a414_0=a.asm.a414_0).apply(null,arguments)},rj=a._a415_0=function(){return (rj=a._a415_0=a.asm.a415_0).apply(null,arguments)},sj=a._a416_1=function(){return (sj=a._a416_1=a.asm.a416_1).apply(null,arguments)},tj=a._a417_1=function(){return (tj=a._a417_1=a.asm.a417_1).apply(null,arguments)},uj=a._a418_0=function(){return (uj=
            a._a418_0=a.asm.a418_0).apply(null,arguments)},vj=a._a419_2=function(){return (vj=a._a419_2=a.asm.a419_2).apply(null,arguments)},wj=a._a420_0=function(){return (wj=a._a420_0=a.asm.a420_0).apply(null,arguments)},xj=a._a421_0=function(){return (xj=a._a421_0=a.asm.a421_0).apply(null,arguments)},yj=a._a422_1=function(){return (yj=a._a422_1=a.asm.a422_1).apply(null,arguments)},zj=a._a423_0=function(){return (zj=a._a423_0=a.asm.a423_0).apply(null,arguments)},Aj=a._a424_1=function(){return (Aj=a._a424_1=a.asm.a424_1).apply(null,
            arguments)},Bj=a._a425_3=function(){return (Bj=a._a425_3=a.asm.a425_3).apply(null,arguments)},Cj=a._a426_0=function(){return (Cj=a._a426_0=a.asm.a426_0).apply(null,arguments)},Dj=a._a427_0=function(){return (Dj=a._a427_0=a.asm.a427_0).apply(null,arguments)},Ej=a._a428_2=function(){return (Ej=a._a428_2=a.asm.a428_2).apply(null,arguments)},Fj=a._a429_0=function(){return (Fj=a._a429_0=a.asm.a429_0).apply(null,arguments)},Gj=a._a430_1=function(){return (Gj=a._a430_1=a.asm.a430_1).apply(null,arguments)},Hj=
            a._a431_1=function(){return (Hj=a._a431_1=a.asm.a431_1).apply(null,arguments)},Ij=a._a432_0=function(){return (Ij=a._a432_0=a.asm.a432_0).apply(null,arguments)},Jj=a._a433_2=function(){return (Jj=a._a433_2=a.asm.a433_2).apply(null,arguments)},Kj=a._a434_0=function(){return (Kj=a._a434_0=a.asm.a434_0).apply(null,arguments)},Lj=a._a435_0=function(){return (Lj=a._a435_0=a.asm.a435_0).apply(null,arguments)},Mj=a._a436_1=function(){return (Mj=a._a436_1=a.asm.a436_1).apply(null,arguments)},Nj=a._a437_0=function(){return (Nj=
            a._a437_0=a.asm.a437_0).apply(null,arguments)},Oj=a._a438_1=function(){return (Oj=a._a438_1=a.asm.a438_1).apply(null,arguments)},Pj=a._a439_3=function(){return (Pj=a._a439_3=a.asm.a439_3).apply(null,arguments)},Qj=a._a440_0=function(){return (Qj=a._a440_0=a.asm.a440_0).apply(null,arguments)},Rj=a._a441_0=function(){return (Rj=a._a441_0=a.asm.a441_0).apply(null,arguments)},Sj=a._a442_2=function(){return (Sj=a._a442_2=a.asm.a442_2).apply(null,arguments)},Tj=a._a443_0=function(){return (Tj=a._a443_0=a.asm.a443_0).apply(null,
            arguments)},Uj=a._a444_0=function(){return (Uj=a._a444_0=a.asm.a444_0).apply(null,arguments)},Vj=a._a445_0=function(){return (Vj=a._a445_0=a.asm.a445_0).apply(null,arguments)},Wj=a._a445_3=function(){return (Wj=a._a445_3=a.asm.a445_3).apply(null,arguments)},Xj=a._a446_0=function(){return (Xj=a._a446_0=a.asm.a446_0).apply(null,arguments)},Yj=a._a447_0=function(){return (Yj=a._a447_0=a.asm.a447_0).apply(null,arguments)},Zj=a._a448_0=function(){return (Zj=a._a448_0=a.asm.a448_0).apply(null,arguments)},ak=
            a._a449_1=function(){return (ak=a._a449_1=a.asm.a449_1).apply(null,arguments)},bk=a._a450_1=function(){return (bk=a._a450_1=a.asm.a450_1).apply(null,arguments)},ck=a._a451_1=function(){return (ck=a._a451_1=a.asm.a451_1).apply(null,arguments)},dk=a._a452_3=function(){return (dk=a._a452_3=a.asm.a452_3).apply(null,arguments)},ek=a._a453_0=function(){return (ek=a._a453_0=a.asm.a453_0).apply(null,arguments)},fk=a._a454_1=function(){return (fk=a._a454_1=a.asm.a454_1).apply(null,arguments)},gk=a._a455_1=function(){return (gk=
            a._a455_1=a.asm.a455_1).apply(null,arguments)},hk=a._a456_0=function(){return (hk=a._a456_0=a.asm.a456_0).apply(null,arguments)},ik=a._a457_1=function(){return (ik=a._a457_1=a.asm.a457_1).apply(null,arguments)},jk=a._a458_1=function(){return (jk=a._a458_1=a.asm.a458_1).apply(null,arguments)},kk=a._a459_0=function(){return (kk=a._a459_0=a.asm.a459_0).apply(null,arguments)},lk=a._a460_2=function(){return (lk=a._a460_2=a.asm.a460_2).apply(null,arguments)},mk=a._a461_0=function(){return (mk=a._a461_0=a.asm.a461_0).apply(null,
            arguments)},nk=a._a462_0=function(){return (nk=a._a462_0=a.asm.a462_0).apply(null,arguments)},ok=a._a463_1=function(){return (ok=a._a463_1=a.asm.a463_1).apply(null,arguments)},pk=a._a464_0=function(){return (pk=a._a464_0=a.asm.a464_0).apply(null,arguments)},qk=a._a465_1=function(){return (qk=a._a465_1=a.asm.a465_1).apply(null,arguments)},rk=a._a466_3=function(){return (rk=a._a466_3=a.asm.a466_3).apply(null,arguments)},sk=a._a467_0=function(){return (sk=a._a467_0=a.asm.a467_0).apply(null,arguments)},tk=
            a._a468_0=function(){return (tk=a._a468_0=a.asm.a468_0).apply(null,arguments)},uk=a._a469_0=function(){return (uk=a._a469_0=a.asm.a469_0).apply(null,arguments)},vk=a._a470_0=function(){return (vk=a._a470_0=a.asm.a470_0).apply(null,arguments)},wk=a._a471_0=function(){return (wk=a._a471_0=a.asm.a471_0).apply(null,arguments)},xk=a._a472_0=function(){return (xk=a._a472_0=a.asm.a472_0).apply(null,arguments)},yk=a._a473_1=function(){return (yk=a._a473_1=a.asm.a473_1).apply(null,arguments)},zk=a._a474_0=function(){return (zk=
            a._a474_0=a.asm.a474_0).apply(null,arguments)},Ak=a._a475_2=function(){return (Ak=a._a475_2=a.asm.a475_2).apply(null,arguments)},Bk=a._a476_0=function(){return (Bk=a._a476_0=a.asm.a476_0).apply(null,arguments)},Ck=a._a477_0=function(){return (Ck=a._a477_0=a.asm.a477_0).apply(null,arguments)},Dk=a._a478_1=function(){return (Dk=a._a478_1=a.asm.a478_1).apply(null,arguments)},Ek=a._a479_0=function(){return (Ek=a._a479_0=a.asm.a479_0).apply(null,arguments)},Fk=a._a480_1=function(){return (Fk=a._a480_1=a.asm.a480_1).apply(null,
            arguments)},Gk=a._a481_3=function(){return (Gk=a._a481_3=a.asm.a481_3).apply(null,arguments)},Hk=a._a482_0=function(){return (Hk=a._a482_0=a.asm.a482_0).apply(null,arguments)},Ik=a._a483_0=function(){return (Ik=a._a483_0=a.asm.a483_0).apply(null,arguments)},Jk=a._a484_0=function(){return (Jk=a._a484_0=a.asm.a484_0).apply(null,arguments)},Kk=a._a485_0=function(){return (Kk=a._a485_0=a.asm.a485_0).apply(null,arguments)},Lk=a._a486_1=function(){return (Lk=a._a486_1=a.asm.a486_1).apply(null,arguments)},Mk=
            a._a487_0=function(){return (Mk=a._a487_0=a.asm.a487_0).apply(null,arguments)},Nk=a._a488_1=function(){return (Nk=a._a488_1=a.asm.a488_1).apply(null,arguments)},Ok=a._a489_0=function(){return (Ok=a._a489_0=a.asm.a489_0).apply(null,arguments)},Pk=a._a490_1=function(){return (Pk=a._a490_1=a.asm.a490_1).apply(null,arguments)},Qk=a._a491_0=function(){return (Qk=a._a491_0=a.asm.a491_0).apply(null,arguments)},Rk=a._a492_0=function(){return (Rk=a._a492_0=a.asm.a492_0).apply(null,arguments)},Sk=a._a493_1=function(){return (Sk=
            a._a493_1=a.asm.a493_1).apply(null,arguments)},Tk=a._a494_0=function(){return (Tk=a._a494_0=a.asm.a494_0).apply(null,arguments)},Uk=a._a495_1=function(){return (Uk=a._a495_1=a.asm.a495_1).apply(null,arguments)},Vk=a._a496_0=function(){return (Vk=a._a496_0=a.asm.a496_0).apply(null,arguments)},Wk=a._a497_0=function(){return (Wk=a._a497_0=a.asm.a497_0).apply(null,arguments)},Xk=a._a498_1=function(){return (Xk=a._a498_1=a.asm.a498_1).apply(null,arguments)},Yk=a._a499_0=function(){return (Yk=a._a499_0=a.asm.a499_0).apply(null,
            arguments)},Zk=a._a500_0=function(){return (Zk=a._a500_0=a.asm.a500_0).apply(null,arguments)},$k=a._a501_0=function(){return ($k=a._a501_0=a.asm.a501_0).apply(null,arguments)},al=a._a502_4=function(){return (al=a._a502_4=a.asm.a502_4).apply(null,arguments)},bl=a._a503_1=function(){return (bl=a._a503_1=a.asm.a503_1).apply(null,arguments)},cl=a._a504_0=function(){return (cl=a._a504_0=a.asm.a504_0).apply(null,arguments)},dl=a._a505_1=function(){return (dl=a._a505_1=a.asm.a505_1).apply(null,arguments)},el=
            a._a506_2=function(){return (el=a._a506_2=a.asm.a506_2).apply(null,arguments)},fl=a._a507_3=function(){return (fl=a._a507_3=a.asm.a507_3).apply(null,arguments)},gl=a._a508_0=function(){return (gl=a._a508_0=a.asm.a508_0).apply(null,arguments)},hl=a._a509_1=function(){return (hl=a._a509_1=a.asm.a509_1).apply(null,arguments)},il=a._a510_0=function(){return (il=a._a510_0=a.asm.a510_0).apply(null,arguments)},jl=a._a511_1=function(){return (jl=a._a511_1=a.asm.a511_1).apply(null,arguments)},kl=a._a512_2=function(){return (kl=
            a._a512_2=a.asm.a512_2).apply(null,arguments)},ll=a._a513_0=function(){return (ll=a._a513_0=a.asm.a513_0).apply(null,arguments)},ml=a._a514_2=function(){return (ml=a._a514_2=a.asm.a514_2).apply(null,arguments)},nl=a._a515_2=function(){return (nl=a._a515_2=a.asm.a515_2).apply(null,arguments)},ol=a._a516_0=function(){return (ol=a._a516_0=a.asm.a516_0).apply(null,arguments)},pl=a._a517_1=function(){return (pl=a._a517_1=a.asm.a517_1).apply(null,arguments)},ql=a._a518_1=function(){return (ql=a._a518_1=a.asm.a518_1).apply(null,
            arguments)},rl=a._a519_2=function(){return (rl=a._a519_2=a.asm.a519_2).apply(null,arguments)},sl=a._a520_1=function(){return (sl=a._a520_1=a.asm.a520_1).apply(null,arguments)},tl=a._a521_1=function(){return (tl=a._a521_1=a.asm.a521_1).apply(null,arguments)},ul=a._a522_2=function(){return (ul=a._a522_2=a.asm.a522_2).apply(null,arguments)},vl=a._a523_0=function(){return (vl=a._a523_0=a.asm.a523_0).apply(null,arguments)},wl=a._a524_0=function(){return (wl=a._a524_0=a.asm.a524_0).apply(null,arguments)},xl=
            a._a525_0=function(){return (xl=a._a525_0=a.asm.a525_0).apply(null,arguments)},yl=a._a526_1=function(){return (yl=a._a526_1=a.asm.a526_1).apply(null,arguments)},zl=a._a527_1=function(){return (zl=a._a527_1=a.asm.a527_1).apply(null,arguments)},Al=a._a528_0=function(){return (Al=a._a528_0=a.asm.a528_0).apply(null,arguments)},Bl=a._a529_0=function(){return (Bl=a._a529_0=a.asm.a529_0).apply(null,arguments)},Cl=a._a530_1=function(){return (Cl=a._a530_1=a.asm.a530_1).apply(null,arguments)},Dl=a._a531_2=function(){return (Dl=
            a._a531_2=a.asm.a531_2).apply(null,arguments)},El=a._a532_1=function(){return (El=a._a532_1=a.asm.a532_1).apply(null,arguments)},Fl=a._a533_0=function(){return (Fl=a._a533_0=a.asm.a533_0).apply(null,arguments)},Gl=a._a534_1=function(){return (Gl=a._a534_1=a.asm.a534_1).apply(null,arguments)},Hl=a._a535_0=function(){return (Hl=a._a535_0=a.asm.a535_0).apply(null,arguments)},Il=a._a536_0=function(){return (Il=a._a536_0=a.asm.a536_0).apply(null,arguments)},Jl=a._a537_0=function(){return (Jl=a._a537_0=a.asm.a537_0).apply(null,
            arguments)},Kl=a._a538_0=function(){return (Kl=a._a538_0=a.asm.a538_0).apply(null,arguments)},Ll=a._a539_0=function(){return (Ll=a._a539_0=a.asm.a539_0).apply(null,arguments)},Ml=a._a540_0=function(){return (Ml=a._a540_0=a.asm.a540_0).apply(null,arguments)},Nl=a._a541_0=function(){return (Nl=a._a541_0=a.asm.a541_0).apply(null,arguments)},Ol=a._a542_1=function(){return (Ol=a._a542_1=a.asm.a542_1).apply(null,arguments)},Pl=a._a543_1=function(){return (Pl=a._a543_1=a.asm.a543_1).apply(null,arguments)},Ql=
            a._a544_0=function(){return (Ql=a._a544_0=a.asm.a544_0).apply(null,arguments)},Rl=a._a544_1=function(){return (Rl=a._a544_1=a.asm.a544_1).apply(null,arguments)},Sl=a._a545_0=function(){return (Sl=a._a545_0=a.asm.a545_0).apply(null,arguments)},Tl=a._a546_0=function(){return (Tl=a._a546_0=a.asm.a546_0).apply(null,arguments)},Ul=a._a547_0=function(){return (Ul=a._a547_0=a.asm.a547_0).apply(null,arguments)},Vl=a._a548_0=function(){return (Vl=a._a548_0=a.asm.a548_0).apply(null,arguments)},Wl=a._a549_1=function(){return (Wl=
            a._a549_1=a.asm.a549_1).apply(null,arguments)},Xl=a._a550_1=function(){return (Xl=a._a550_1=a.asm.a550_1).apply(null,arguments)},Yl=a._a551_1=function(){return (Yl=a._a551_1=a.asm.a551_1).apply(null,arguments)},Zl=a._a552_1=function(){return (Zl=a._a552_1=a.asm.a552_1).apply(null,arguments)},$l=a._a553_0=function(){return ($l=a._a553_0=a.asm.a553_0).apply(null,arguments)},am=a._a554_0=function(){return (am=a._a554_0=a.asm.a554_0).apply(null,arguments)},bm=a._a555_1=function(){return (bm=a._a555_1=a.asm.a555_1).apply(null,
            arguments)},cm=a._a556_1=function(){return (cm=a._a556_1=a.asm.a556_1).apply(null,arguments)},dm=a._a557_1=function(){return (dm=a._a557_1=a.asm.a557_1).apply(null,arguments)},em=a._a558_1=function(){return (em=a._a558_1=a.asm.a558_1).apply(null,arguments)},fm=a._a559_1=function(){return (fm=a._a559_1=a.asm.a559_1).apply(null,arguments)},gm=a._a560_0=function(){return (gm=a._a560_0=a.asm.a560_0).apply(null,arguments)},hm=a._a561_1=function(){return (hm=a._a561_1=a.asm.a561_1).apply(null,arguments)},im=
            a._a562_1=function(){return (im=a._a562_1=a.asm.a562_1).apply(null,arguments)},jm=a._a563_2=function(){return (jm=a._a563_2=a.asm.a563_2).apply(null,arguments)},km=a._a564_0=function(){return (km=a._a564_0=a.asm.a564_0).apply(null,arguments)},lm=a._a565_0=function(){return (lm=a._a565_0=a.asm.a565_0).apply(null,arguments)},mm=a._a566_1=function(){return (mm=a._a566_1=a.asm.a566_1).apply(null,arguments)},nm=a._a567_0=function(){return (nm=a._a567_0=a.asm.a567_0).apply(null,arguments)},om=a._a568_4=function(){return (om=
            a._a568_4=a.asm.a568_4).apply(null,arguments)},pm=a._a569_1=function(){return (pm=a._a569_1=a.asm.a569_1).apply(null,arguments)},qm=a._a570_1=function(){return (qm=a._a570_1=a.asm.a570_1).apply(null,arguments)},rm=a._a571_1=function(){return (rm=a._a571_1=a.asm.a571_1).apply(null,arguments)},sm=a._a572_1=function(){return (sm=a._a572_1=a.asm.a572_1).apply(null,arguments)},tm=a._a573_1=function(){return (tm=a._a573_1=a.asm.a573_1).apply(null,arguments)},um=a._a574_0=function(){return (um=a._a574_0=a.asm.a574_0).apply(null,
            arguments)},vm=a._a575_3=function(){return (vm=a._a575_3=a.asm.a575_3).apply(null,arguments)},wm=a._a576_6=function(){return (wm=a._a576_6=a.asm.a576_6).apply(null,arguments)},xm=a._a577_1=function(){return (xm=a._a577_1=a.asm.a577_1).apply(null,arguments)},ym=a._a577_2=function(){return (ym=a._a577_2=a.asm.a577_2).apply(null,arguments)},zm=a._a577_3=function(){return (zm=a._a577_3=a.asm.a577_3).apply(null,arguments)},Am=a._a578_1=function(){return (Am=a._a578_1=a.asm.a578_1).apply(null,arguments)},Bm=
            a._a579_1=function(){return (Bm=a._a579_1=a.asm.a579_1).apply(null,arguments)},Cm=a._a580_1=function(){return (Cm=a._a580_1=a.asm.a580_1).apply(null,arguments)},Dm=a._a581_0=function(){return (Dm=a._a581_0=a.asm.a581_0).apply(null,arguments)},Em=a._a582_1=function(){return (Em=a._a582_1=a.asm.a582_1).apply(null,arguments)},Fm=a._a582_3=function(){return (Fm=a._a582_3=a.asm.a582_3).apply(null,arguments)},Gm=a._a583_1=function(){return (Gm=a._a583_1=a.asm.a583_1).apply(null,arguments)},Hm=a._a584_1=function(){return (Hm=
            a._a584_1=a.asm.a584_1).apply(null,arguments)},Im=a._a584_2=function(){return (Im=a._a584_2=a.asm.a584_2).apply(null,arguments)},Jm=a._a585_1=function(){return (Jm=a._a585_1=a.asm.a585_1).apply(null,arguments)},Km=a._a586_1=function(){return (Km=a._a586_1=a.asm.a586_1).apply(null,arguments)},Lm=a._a586_2=function(){return (Lm=a._a586_2=a.asm.a586_2).apply(null,arguments)},Mm=a._a586_3=function(){return (Mm=a._a586_3=a.asm.a586_3).apply(null,arguments)},Nm=a._a587_1=function(){return (Nm=a._a587_1=a.asm.a587_1).apply(null,
            arguments)},Om=a._a588_1=function(){return (Om=a._a588_1=a.asm.a588_1).apply(null,arguments)},Pm=a._a589_0=function(){return (Pm=a._a589_0=a.asm.a589_0).apply(null,arguments)},Qm=a._a590_0=function(){return (Qm=a._a590_0=a.asm.a590_0).apply(null,arguments)},Rm=a._a591_0=function(){return (Rm=a._a591_0=a.asm.a591_0).apply(null,arguments)},Sm=a._a591_2=function(){return (Sm=a._a591_2=a.asm.a591_2).apply(null,arguments)},Tm=a._a592_0=function(){return (Tm=a._a592_0=a.asm.a592_0).apply(null,arguments)},Um=
            a._a593_1=function(){return (Um=a._a593_1=a.asm.a593_1).apply(null,arguments)},Vm=a._a594_1=function(){return (Vm=a._a594_1=a.asm.a594_1).apply(null,arguments)},Wm=a._a595_0=function(){return (Wm=a._a595_0=a.asm.a595_0).apply(null,arguments)},Xm=a._a596_0=function(){return (Xm=a._a596_0=a.asm.a596_0).apply(null,arguments)},Ym=a._a597_0=function(){return (Ym=a._a597_0=a.asm.a597_0).apply(null,arguments)},Zm=a._a598_0=function(){return (Zm=a._a598_0=a.asm.a598_0).apply(null,arguments)},$m=a._a599_1=function(){return ($m=
            a._a599_1=a.asm.a599_1).apply(null,arguments)},an=a._a600_0=function(){return (an=a._a600_0=a.asm.a600_0).apply(null,arguments)},bn=a._a601_1=function(){return (bn=a._a601_1=a.asm.a601_1).apply(null,arguments)},cn=a._a602_1=function(){return (cn=a._a602_1=a.asm.a602_1).apply(null,arguments)},dn=a._a603_0=function(){return (dn=a._a603_0=a.asm.a603_0).apply(null,arguments)},en=a._a604_3=function(){return (en=a._a604_3=a.asm.a604_3).apply(null,arguments)},fn=a._a605_1=function(){return (fn=a._a605_1=a.asm.a605_1).apply(null,
            arguments)},gn=a._a606_0=function(){return (gn=a._a606_0=a.asm.a606_0).apply(null,arguments)},hn=a._a607_2=function(){return (hn=a._a607_2=a.asm.a607_2).apply(null,arguments)},jn=a._a608_0=function(){return (jn=a._a608_0=a.asm.a608_0).apply(null,arguments)},kn=a._a609_0=function(){return (kn=a._a609_0=a.asm.a609_0).apply(null,arguments)},ln=a._a610_1=function(){return (ln=a._a610_1=a.asm.a610_1).apply(null,arguments)},mn=a._a611_0=function(){return (mn=a._a611_0=a.asm.a611_0).apply(null,arguments)},nn=
            a._a612_1=function(){return (nn=a._a612_1=a.asm.a612_1).apply(null,arguments)},on=a._a613_3=function(){return (on=a._a613_3=a.asm.a613_3).apply(null,arguments)},pn=a._a614_0=function(){return (pn=a._a614_0=a.asm.a614_0).apply(null,arguments)},qn=a._a615_0=function(){return (qn=a._a615_0=a.asm.a615_0).apply(null,arguments)},rn=a._a616_0=function(){return (rn=a._a616_0=a.asm.a616_0).apply(null,arguments)},sn=a._a617a618=function(){return (sn=a._a617a618=a.asm.a617a618).apply(null,arguments)},tn=a._a617a619=
            function(){return (tn=a._a617a619=a.asm.a617a619).apply(null,arguments)},un=a._a617a620=function(){return (un=a._a617a620=a.asm.a617a620).apply(null,arguments)},vn=a._a617a621=function(){return (vn=a._a617a621=a.asm.a617a621).apply(null,arguments)},wn=a._a622a623=function(){return (wn=a._a622a623=a.asm.a622a623).apply(null,arguments)},xn=a._a622a624=function(){return (xn=a._a622a624=a.asm.a622a624).apply(null,arguments)},yn=a._a622a625=function(){return (yn=a._a622a625=a.asm.a622a625).apply(null,arguments)},
            zn=a._a622a626=function(){return (zn=a._a622a626=a.asm.a622a626).apply(null,arguments)},An=a._a622a627=function(){return (An=a._a622a627=a.asm.a622a627).apply(null,arguments)},Bn=a._a622a628=function(){return (Bn=a._a622a628=a.asm.a622a628).apply(null,arguments)};a._malloc=function(){return (a._malloc=a.asm.malloc).apply(null,arguments)};a._free=function(){return (a._free=a.asm.free).apply(null,arguments)};
            var qa=a.__growWasmMemory=function(){return (qa=a.__growWasmMemory=a.asm.__growWasmMemory).apply(null,arguments)};a.dynCall_vi=function(){return (a.dynCall_vi=a.asm.dynCall_vi).apply(null,arguments)};a.dynCall_v=function(){return (a.dynCall_v=a.asm.dynCall_v).apply(null,arguments)};a.asm=Xa;
            a.addFunction=function(b){if(!ma){ma=new WeakMap;for(var c=0;c<ua.length;c++){var d=ua.get(c);d&&ma.set(d,c);}}if(ma.has(b))b=ma.get(b);else {if(la.length)c=la.pop();else {c=ua.length;try{ua.grow(1);}catch(e){if(!(e instanceof RangeError))throw e;throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";}}try{ua.set(c,b);}catch(e){if(!(e instanceof TypeError))throw e;ua.set(c,b);}ma.set(b,c);b=c;}return b};var Cn;Na=function Dn(){Cn||En();Cn||(Na=Dn);};
            function En(){function b(){if(!Cn&&(Cn=!0,a.calledRun=!0,!ya)){Ja=!0;Da(Fa);Da(Ga);aa(a);if(a.onRuntimeInitialized)a.onRuntimeInitialized();if(a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var c=a.postRun.shift();Ha.unshift(c);}Da(Ha);}}if(!(0<La)){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)Ka();Da(Ea);0<La||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("");},1);b();},1)):
            b());}}a.run=En;if(a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();noExitRuntime=!0;En();function f(){}f.prototype=Object.create(f.prototype);f.prototype.constructor=f;f.prototype.b=f;f.c={};a.WrapperObject=f;function h(b){return (b||f).c}a.getCache=h;function k(b,c){var d=h(c),e=d[b];if(e)return e;e=Object.create((c||f).prototype);e.a=b;return d[b]=e}a.wrapPointer=k;a.castObject=function(b,c){return k(b.a,c)};a.NULL=k(0);
            a.destroy=function(b){if(!b.__destroy__)throw "Error: Cannot destroy object. (Did you create it yourself?)";b.__destroy__();delete h(b.b)[b.a];};a.compare=function(b,c){return b.a===c.a};a.getPointer=function(b){return b.a};a.getClass=function(b){return b.b};function l(){throw "cannot construct a btCollisionShape, no constructor in IDL";}l.prototype=Object.create(f.prototype);l.prototype.constructor=l;l.prototype.b=l;l.c={};a.btCollisionShape=l;
            l.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ya(c,b);};l.prototype.getLocalScaling=function(){return k(Za(this.a),m)};l.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);$a(d,b,c);};l.prototype.setMargin=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ab(c,b);};l.prototype.getMargin=function(){return bb(this.a)};l.prototype.isCompound=function(){return !!cb(this.a)};
            l.prototype.getUserIndex=function(){return db(this.a)};l.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);eb(c,b);};l.prototype.getUserPointerAsInt=function(){return fb(this.a)};l.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);gb(c,b);};l.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);hb(e,b,c,d);};l.prototype.getLocalBoundingSphere=function(){return ib(this.a)};
            l.prototype.__destroy__=function(){jb(this.a);};function Fn(){throw "cannot construct a btCollisionWorld, no constructor in IDL";}Fn.prototype=Object.create(f.prototype);Fn.prototype.constructor=Fn;Fn.prototype.b=Fn;Fn.c={};a.btCollisionWorld=Fn;Fn.prototype.rayTest=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);kb(e,b,c,d);};
            Fn.prototype.rayTestSingle=function(b,c,d,e,g,n){var Q=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);g&&"object"===typeof g&&(g=g.a);n&&"object"===typeof n&&(n=n.a);lb(Q,b,c,d,e,g,n);};Fn.prototype.addCollisionObject=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);void 0===c?mb(e,b):void 0===d?nb(e,b,c):ob(e,b,c,d);};
            Fn.prototype.removeCollisionObject=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);pb(c,b);};Fn.prototype.setContactBreakingThreshold=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);qb(c,b);};Fn.prototype.__destroy__=function(){rb(this.a);};function p(){throw "cannot construct a btConvexShape, no constructor in IDL";}p.prototype=Object.create(l.prototype);p.prototype.constructor=p;p.prototype.b=p;p.c={};a.btConvexShape=p;
            p.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);sb(c,b);};p.prototype.getLocalScaling=function(){return k(tb(this.a),m)};p.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);ub(d,b,c);};p.prototype.setMargin=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);vb(c,b);};p.prototype.getMargin=function(){return wb(this.a)};p.prototype.isCompound=function(){return !!xb(this.a)};
            p.prototype.getUserIndex=function(){return yb(this.a)};p.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);zb(c,b);};p.prototype.getUserPointerAsInt=function(){return Ab(this.a)};p.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Bb(c,b);};p.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Cb(e,b,c,d);};p.prototype.getLocalBoundingSphere=function(){return Db(this.a)};
            p.prototype.__destroy__=function(){Eb(this.a);};function q(){throw "cannot construct a btDynamicsWorld, no constructor in IDL";}q.prototype=Object.create(Fn.prototype);q.prototype.constructor=q;q.prototype.b=q;q.c={};a.btDynamicsWorld=q;q.prototype.addAction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Fb(c,b);};q.prototype.removeAction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Gb(c,b);};q.prototype.getFixedBody=function(){return k(Hb(this.a),r)};
            q.prototype.rayTest=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Ib(e,b,c,d);};q.prototype.rayTestSingle=function(b,c,d,e,g,n){var Q=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);g&&"object"===typeof g&&(g=g.a);n&&"object"===typeof n&&(n=n.a);Jb(Q,b,c,d,e,g,n);};
            q.prototype.addCollisionObject=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);void 0===c?Kb(e,b):void 0===d?Lb(e,b,c):Mb(e,b,c,d);};q.prototype.removeCollisionObject=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Nb(c,b);};q.prototype.setContactBreakingThreshold=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ob(c,b);};q.prototype.__destroy__=function(){Pb(this.a);};
            function Gn(){throw "cannot construct a RayResultCallback, no constructor in IDL";}Gn.prototype=Object.create(f.prototype);Gn.prototype.constructor=Gn;Gn.prototype.b=Gn;Gn.c={};a.RayResultCallback=Gn;Gn.prototype.hasHit=function(){return !!Qb(this.a)};Gn.prototype.__destroy__=function(){Rb(this.a);};function t(){throw "cannot construct a btConcaveShape, no constructor in IDL";}t.prototype=Object.create(l.prototype);t.prototype.constructor=t;t.prototype.b=t;t.c={};a.btConcaveShape=t;
            t.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Sb(c,b);};t.prototype.getLocalScaling=function(){return k(Tb(this.a),m)};t.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Ub(d,b,c);};t.prototype.isCompound=function(){return !!Vb(this.a)};t.prototype.getUserIndex=function(){return Wb(this.a)};t.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Xb(c,b);};
            t.prototype.getUserPointerAsInt=function(){return Yb(this.a)};t.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Zb(c,b);};t.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);$b(e,b,c,d);};t.prototype.getLocalBoundingSphere=function(){return ac(this.a)};t.prototype.__destroy__=function(){bc(this.a);};
            function Hn(){throw "cannot construct a btStridingMeshInterface, no constructor in IDL";}Hn.prototype=Object.create(f.prototype);Hn.prototype.constructor=Hn;Hn.prototype.b=Hn;Hn.c={};a.btStridingMeshInterface=Hn;Hn.prototype.setScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);cc(c,b);};Hn.prototype.__destroy__=function(){dc(this.a);};function In(){throw "cannot construct a btBroadphaseInterface, no constructor in IDL";}In.prototype=Object.create(f.prototype);In.prototype.constructor=In;
            In.prototype.b=In;In.c={};a.btBroadphaseInterface=In;In.prototype.__destroy__=function(){ec(this.a);};function u(){this.a=fc();h(u)[this.a]=this;}u.prototype=Object.create(f.prototype);u.prototype.constructor=u;u.prototype.b=u;u.c={};a.btCollisionObject=u;u.prototype.getCollisionShape=function(){return k(gc(this.a),l)};u.prototype.getActivationState=function(){return hc(this.a)};u.prototype.setActivationState=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ic(c,b);};
            u.prototype.forceActivationState=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);jc(c,b);};u.prototype.activate=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);void 0===b?kc(c):lc(c,b);};u.prototype.isActive=function(){return !!mc(this.a)};u.prototype.isKinematicObject=function(){return !!nc(this.a)};u.prototype.isStaticObject=function(){return !!oc(this.a)};u.prototype.isStaticOrKinematicObject=function(){return !!pc(this.a)};
            u.prototype.setRestitution=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);qc(c,b);};u.prototype.setFriction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);rc(c,b);};u.prototype.setRollingFriction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);sc(c,b);};u.prototype.setSpinningFriction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);tc(c,b);};u.prototype.getWorldTransform=function(){return k(uc(this.a),v)};u.prototype.getCollisionFlags=function(){return vc(this.a)};
            u.prototype.setCollisionFlags=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);wc(c,b);};u.prototype.setWorldTransform=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);xc(c,b);};u.prototype.setCollisionShape=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);yc(c,b);};u.prototype.setCcdMotionThreshold=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);zc(c,b);};u.prototype.setCcdSweptSphereRadius=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ac(c,b);};
            u.prototype.getUserIndex=function(){return Bc(this.a)};u.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Cc(c,b);};u.prototype.setUserIndex2=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Dc(c,b);};u.prototype.setIgnoreCollisionCheck=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Ec(d,b,c);};u.prototype.__destroy__=function(){Fc(this.a);};
            function w(b,c,d,e){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);this.a=Gc(b,c,d,e);h(w)[this.a]=this;}w.prototype=Object.create(q.prototype);w.prototype.constructor=w;w.prototype.b=w;w.c={};a.btDiscreteDynamicsWorld=w;w.prototype.setGravity=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Hc(c,b);};w.prototype.getGravity=function(){return k(Ic(this.a),m)};
            w.prototype.addRigidBody=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);void 0===c?Jc(e,b):void 0===d?_a86_2(e,b,c):Kc(e,b,c,d);};w.prototype.removeRigidBody=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Lc(c,b);};w.prototype.addConstraint=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);void 0===c?Mc(d,b):Nc(d,b,c);};
            w.prototype.removeConstraint=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Oc(c,b);};w.prototype.stepSimulation=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);return void 0===c?Pc(e,b):void 0===d?Qc(e,b,c):Rc(e,b,c,d)};w.prototype.rayTest=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Sc(e,b,c,d);};
            w.prototype.rayTestSingle=function(b,c,d,e,g,n){var Q=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);g&&"object"===typeof g&&(g=g.a);n&&"object"===typeof n&&(n=n.a);Tc(Q,b,c,d,e,g,n);};w.prototype.addCollisionObject=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);void 0===c?Uc(e,b):void 0===d?Vc(e,b,c):Wc(e,b,c,d);};
            w.prototype.removeCollisionObject=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Xc(c,b);};w.prototype.setContactBreakingThreshold=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Yc(c,b);};w.prototype.addAction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Zc(c,b);};w.prototype.removeAction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);$c(c,b);};w.prototype.getFixedBody=function(){return k(ad(this.a),r)};w.prototype.__destroy__=function(){bd(this.a);};
            function Jn(){throw "cannot construct a btMotionState, no constructor in IDL";}Jn.prototype=Object.create(f.prototype);Jn.prototype.constructor=Jn;Jn.prototype.b=Jn;Jn.c={};a.btMotionState=Jn;Jn.prototype.getWorldTransform=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);cd(c,b);};Jn.prototype.setWorldTransform=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);dd(c,b);};Jn.prototype.__destroy__=function(){ed(this.a);};
            function x(){throw "cannot construct a btConvexInternalShape, no constructor in IDL";}x.prototype=Object.create(p.prototype);x.prototype.constructor=x;x.prototype.b=x;x.c={};a.btConvexInternalShape=x;x.prototype.getImplicitShapeDimensions=function(){return k(fd(this.a),m)};x.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);gd(c,b);};x.prototype.getLocalScaling=function(){return k(hd(this.a),m)};
            x.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);id(d,b,c);};x.prototype.setMargin=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);jd(c,b);};x.prototype.getMargin=function(){return kd(this.a)};x.prototype.isCompound=function(){return !!ld(this.a)};x.prototype.getUserIndex=function(){return md(this.a)};x.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);nd(c,b);};
            x.prototype.getUserPointerAsInt=function(){return od(this.a)};x.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);pd(c,b);};x.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);qd(e,b,c,d);};x.prototype.getLocalBoundingSphere=function(){return rd(this.a)};x.prototype.__destroy__=function(){sd(this.a);};
            function y(){throw "cannot construct a AllHitsRayResultCallback, no constructor in IDL";}y.prototype=Object.create(Gn.prototype);y.prototype.constructor=y;y.prototype.b=y;y.c={};a.AllHitsRayResultCallback=y;y.prototype.hasHit=function(){return !!td(this.a)};y.prototype.get_m_rayFromWorld=y.prototype.f=function(){return k(ud(this.a),m)};y.prototype.set_m_rayFromWorld=y.prototype.h=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);vd(c,b);};
            Object.defineProperty(y.prototype,"m_rayFromWorld",{get:y.prototype.f,set:y.prototype.h});y.prototype.get_m_rayToWorld=y.prototype.g=function(){return k(wd(this.a),m)};y.prototype.set_m_rayToWorld=y.prototype.i=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);xd(c,b);};Object.defineProperty(y.prototype,"m_rayToWorld",{get:y.prototype.g,set:y.prototype.i});y.prototype.__destroy__=function(){yd(this.a);};function Kn(){throw "cannot construct a btDispatcher, no constructor in IDL";}
            Kn.prototype=Object.create(f.prototype);Kn.prototype.constructor=Kn;Kn.prototype.b=Kn;Kn.c={};a.btDispatcher=Kn;Kn.prototype.getNumManifolds=function(){return zd(this.a)};Kn.prototype.getManifoldByIndexInternal=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);return k(Ad(c,b),Ln)};Kn.prototype.__destroy__=function(){Bd(this.a);};function z(){throw "cannot construct a ClosestRayResultCallback, no constructor in IDL";}z.prototype=Object.create(Gn.prototype);z.prototype.constructor=z;
            z.prototype.b=z;z.c={};a.ClosestRayResultCallback=z;z.prototype.hasHit=function(){return !!Cd(this.a)};z.prototype.get_m_rayFromWorld=z.prototype.f=function(){return k(Dd(this.a),m)};z.prototype.set_m_rayFromWorld=z.prototype.h=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ed(c,b);};Object.defineProperty(z.prototype,"m_rayFromWorld",{get:z.prototype.f,set:z.prototype.h});z.prototype.get_m_rayToWorld=z.prototype.g=function(){return k(Fd(this.a),m)};
            z.prototype.set_m_rayToWorld=z.prototype.i=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Gd(c,b);};Object.defineProperty(z.prototype,"m_rayToWorld",{get:z.prototype.g,set:z.prototype.i});z.prototype.__destroy__=function(){Hd(this.a);};function A(){throw "cannot construct a btTriangleMeshShape, no constructor in IDL";}A.prototype=Object.create(t.prototype);A.prototype.constructor=A;A.prototype.b=A;A.c={};a.btTriangleMeshShape=A;
            A.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Id(c,b);};A.prototype.getLocalScaling=function(){return k(Jd(this.a),m)};A.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Kd(d,b,c);};A.prototype.isCompound=function(){return !!Ld(this.a)};A.prototype.getUserIndex=function(){return Md(this.a)};A.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Nd(c,b);};
            A.prototype.getUserPointerAsInt=function(){return Od(this.a)};A.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Pd(c,b);};A.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Qd(e,b,c,d);};A.prototype.getLocalBoundingSphere=function(){return Rd(this.a)};A.prototype.__destroy__=function(){Sd(this.a);};
            function B(){throw "cannot construct a btQuadWord, no constructor in IDL";}B.prototype=Object.create(f.prototype);B.prototype.constructor=B;B.prototype.b=B;B.c={};a.btQuadWord=B;B.prototype.x=B.prototype.x=function(){return Td(this.a)};B.prototype.y=B.prototype.y=function(){return Ud(this.a)};B.prototype.z=B.prototype.z=function(){return Vd(this.a)};B.prototype.w=function(){return Wd(this.a)};B.prototype.setX=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Xd(c,b);};
            B.prototype.setY=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Yd(c,b);};B.prototype.setZ=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Zd(c,b);};B.prototype.setW=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);$d(c,b);};B.prototype.__destroy__=function(){ae(this.a);};function Mn(){throw "cannot construct a btTypedConstraint, no constructor in IDL";}Mn.prototype=Object.create(f.prototype);Mn.prototype.constructor=Mn;Mn.prototype.b=Mn;Mn.c={};a.btTypedConstraint=Mn;
            Mn.prototype.enableFeedback=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);be(c,b);};Mn.prototype.getBreakingImpulseThreshold=function(){return ce(this.a)};Mn.prototype.setBreakingImpulseThreshold=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);de(c,b);};Mn.prototype.getParam=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);return ee(d,b,c)};
            Mn.prototype.setParam=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);fe(e,b,c,d);};Mn.prototype.__destroy__=function(){ge(this.a);};function Nn(){throw "cannot construct a btMatrix3x3, no constructor in IDL";}Nn.prototype=Object.create(f.prototype);Nn.prototype.constructor=Nn;Nn.prototype.b=Nn;Nn.c={};a.btMatrix3x3=Nn;Nn.prototype.getRotation=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);he(c,b);};
            Nn.prototype.__destroy__=function(){ie(this.a);};function On(){throw "cannot construct a btScalarArray, no constructor in IDL";}On.prototype=Object.create(f.prototype);On.prototype.constructor=On;On.prototype.b=On;On.c={};a.btScalarArray=On;On.prototype.size=On.prototype.size=function(){return je(this.a)};On.prototype.at=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);return ke(c,b)};On.prototype.clear=On.prototype.clear=function(){le(this.a);};On.prototype.__destroy__=function(){me(this.a);};
            function C(b,c,d){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);this.a=void 0===d?ne(b,c):oe(b,c,d);h(C)[this.a]=this;}C.prototype=Object.create(A.prototype);C.prototype.constructor=C;C.prototype.b=C;C.c={};a.btBvhTriangleMeshShape=C;C.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);pe(c,b);};C.prototype.getLocalScaling=function(){return k(qe(this.a),m)};
            C.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);re(d,b,c);};C.prototype.isCompound=function(){return !!se(this.a)};C.prototype.getUserIndex=function(){return te(this.a)};C.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ue(c,b);};C.prototype.getUserPointerAsInt=function(){return ve(this.a)};C.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);we(c,b);};
            C.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);xe(e,b,c,d);};C.prototype.getLocalBoundingSphere=function(){return ye(this.a)};C.prototype.__destroy__=function(){ze(this.a);};function Pn(){this.a=Ae();h(Pn)[this.a]=this;}Pn.prototype=Object.create(In.prototype);Pn.prototype.constructor=Pn;Pn.prototype.b=Pn;Pn.c={};a.btDbvtBroadphase=Pn;Pn.prototype.__destroy__=function(){Be(this.a);};
            function Qn(){throw "cannot construct a btIntArray, no constructor in IDL";}Qn.prototype=Object.create(f.prototype);Qn.prototype.constructor=Qn;Qn.prototype.b=Qn;Qn.c={};a.btIntArray=Qn;Qn.prototype.size=Qn.prototype.size=function(){return Ce(this.a)};Qn.prototype.at=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);return De(c,b)};Qn.prototype.clear=Qn.prototype.clear=function(){Ee(this.a);};Qn.prototype.__destroy__=function(){Fe(this.a);};
            function D(b,c){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);this.a=Ge(b,c);h(D)[this.a]=this;}D.prototype=Object.create(y.prototype);D.prototype.constructor=D;D.prototype.b=D;D.c={};a.ccAllHitsRayResultCallback=D;D.prototype.getHitFractions=function(){return k(He(this.a),On)};D.prototype.getHitNormalWorld=function(){return k(Ie(this.a),Rn)};D.prototype.getHitPointWorld=function(){return k(Je(this.a),Rn)};D.prototype.getCollisionShapePtrs=function(){return k(Ke(this.a),Qn)};
            D.prototype.reset=D.prototype.reset=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Le(d,b,c);};D.prototype.hasHit=function(){return !!Me(this.a)};D.prototype.get_m_rayFromWorld=D.prototype.f=function(){return k(Ne(this.a),m)};D.prototype.set_m_rayFromWorld=D.prototype.h=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Oe(c,b);};Object.defineProperty(D.prototype,"m_rayFromWorld",{get:D.prototype.f,set:D.prototype.h});
            D.prototype.get_m_rayToWorld=D.prototype.g=function(){return k(Pe(this.a),m)};D.prototype.set_m_rayToWorld=D.prototype.i=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Qe(c,b);};Object.defineProperty(D.prototype,"m_rayToWorld",{get:D.prototype.g,set:D.prototype.i});D.prototype.__destroy__=function(){Re(this.a);};function E(b,c){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);this.a=Se(b,c);h(E)[this.a]=this;}E.prototype=Object.create(x.prototype);E.prototype.constructor=E;
            E.prototype.b=E;E.c={};a.btCapsuleShape=E;E.prototype.setMargin=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Te(c,b);};E.prototype.getMargin=function(){return Ue(this.a)};E.prototype.updateProp=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Ve(e,b,c,d);};E.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);We(c,b);};E.prototype.getLocalScaling=function(){return k(Xe(this.a),m)};
            E.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Ye(d,b,c);};E.prototype.isCompound=function(){return !!Ze(this.a)};E.prototype.getUserIndex=function(){return $e(this.a)};E.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);af(c,b);};E.prototype.getUserPointerAsInt=function(){return bf(this.a)};E.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);cf(c,b);};
            E.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);df(e,b,c,d);};E.prototype.getLocalBoundingSphere=function(){return ef(this.a)};E.prototype.getImplicitShapeDimensions=function(){return k(ff(this.a),m)};E.prototype.__destroy__=function(){gf(this.a);};function F(){throw "cannot construct a btBroadphaseProxy, no constructor in IDL";}F.prototype=Object.create(f.prototype);F.prototype.constructor=F;
            F.prototype.b=F;F.c={};a.btBroadphaseProxy=F;F.prototype.get_m_collisionFilterGroup=F.prototype.s=function(){return hf(this.a)};F.prototype.set_m_collisionFilterGroup=F.prototype.X=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);jf(c,b);};Object.defineProperty(F.prototype,"m_collisionFilterGroup",{get:F.prototype.s,set:F.prototype.X});F.prototype.get_m_collisionFilterMask=F.prototype.u=function(){return kf(this.a)};
            F.prototype.set_m_collisionFilterMask=F.prototype.Y=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);lf(c,b);};Object.defineProperty(F.prototype,"m_collisionFilterMask",{get:F.prototype.u,set:F.prototype.Y});F.prototype.__destroy__=function(){mf(this.a);};function Sn(){throw "cannot construct a btIndexedMesh, no constructor in IDL";}Sn.prototype=Object.create(f.prototype);Sn.prototype.constructor=Sn;Sn.prototype.b=Sn;Sn.c={};a.btIndexedMesh=Sn;Sn.prototype.get_m_numTriangles=Sn.prototype.L=function(){return nf(this.a)};
            Sn.prototype.set_m_numTriangles=Sn.prototype.ja=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);of(c,b);};Object.defineProperty(Sn.prototype,"m_numTriangles",{get:Sn.prototype.L,set:Sn.prototype.ja});Sn.prototype.__destroy__=function(){pf(this.a);};function G(b,c,d,e){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);this.a=void 0===e?qf(b,c,d):rf(b,c,d,e);h(G)[this.a]=this;}G.prototype=Object.create(f.prototype);
            G.prototype.constructor=G;G.prototype.b=G;G.c={};a.btRigidBodyConstructionInfo=G;G.prototype.get_m_linearDamping=G.prototype.G=function(){return sf(this.a)};G.prototype.set_m_linearDamping=G.prototype.ea=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);tf(c,b);};Object.defineProperty(G.prototype,"m_linearDamping",{get:G.prototype.G,set:G.prototype.ea});G.prototype.get_m_angularDamping=G.prototype.m=function(){return uf(this.a)};
            G.prototype.set_m_angularDamping=G.prototype.V=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);vf(c,b);};Object.defineProperty(G.prototype,"m_angularDamping",{get:G.prototype.m,set:G.prototype.V});G.prototype.get_m_friction=G.prototype.B=function(){return wf(this.a)};G.prototype.set_m_friction=G.prototype.aa=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);xf(c,b);};Object.defineProperty(G.prototype,"m_friction",{get:G.prototype.B,set:G.prototype.aa});
            G.prototype.get_m_rollingFriction=G.prototype.P=function(){return yf(this.a)};G.prototype.set_m_rollingFriction=G.prototype.na=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);zf(c,b);};Object.defineProperty(G.prototype,"m_rollingFriction",{get:G.prototype.P,set:G.prototype.na});G.prototype.get_m_restitution=G.prototype.O=function(){return Af(this.a)};G.prototype.set_m_restitution=G.prototype.ma=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Bf(c,b);};
            Object.defineProperty(G.prototype,"m_restitution",{get:G.prototype.O,set:G.prototype.ma});G.prototype.get_m_linearSleepingThreshold=G.prototype.H=function(){return Cf(this.a)};G.prototype.set_m_linearSleepingThreshold=G.prototype.fa=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Df(c,b);};Object.defineProperty(G.prototype,"m_linearSleepingThreshold",{get:G.prototype.H,set:G.prototype.fa});G.prototype.get_m_angularSleepingThreshold=G.prototype.o=function(){return Ef(this.a)};
            G.prototype.set_m_angularSleepingThreshold=G.prototype.W=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ff(c,b);};Object.defineProperty(G.prototype,"m_angularSleepingThreshold",{get:G.prototype.o,set:G.prototype.W});G.prototype.__destroy__=function(){Gf(this.a);};function H(){throw "cannot construct a btManifoldPoint, no constructor in IDL";}H.prototype=Object.create(f.prototype);H.prototype.constructor=H;H.prototype.b=H;H.c={};a.btManifoldPoint=H;H.prototype.getAppliedImpulse=function(){return Hf(this.a)};
            H.prototype.getDistance=function(){return If(this.a)};H.prototype.getShape0=function(){return k(Jf(this.a),l)};H.prototype.getShape1=function(){return k(Kf(this.a),l)};H.prototype.get_m_localPointA=H.prototype.I=function(){return k(Lf(this.a),m)};H.prototype.set_m_localPointA=H.prototype.ga=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Mf(c,b);};Object.defineProperty(H.prototype,"m_localPointA",{get:H.prototype.I,set:H.prototype.ga});
            H.prototype.get_m_localPointB=H.prototype.J=function(){return k(Nf(this.a),m)};H.prototype.set_m_localPointB=H.prototype.ha=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Of(c,b);};Object.defineProperty(H.prototype,"m_localPointB",{get:H.prototype.J,set:H.prototype.ha});H.prototype.get_m_positionWorldOnA=H.prototype.M=function(){return k(Pf(this.a),m)};H.prototype.set_m_positionWorldOnA=H.prototype.ka=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Qf(c,b);};
            Object.defineProperty(H.prototype,"m_positionWorldOnA",{get:H.prototype.M,set:H.prototype.ka});H.prototype.get_m_positionWorldOnB=H.prototype.N=function(){return k(Rf(this.a),m)};H.prototype.set_m_positionWorldOnB=H.prototype.la=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Sf(c,b);};Object.defineProperty(H.prototype,"m_positionWorldOnB",{get:H.prototype.N,set:H.prototype.la});H.prototype.get_m_normalWorldOnB=H.prototype.K=function(){return k(Tf(this.a),m)};
            H.prototype.set_m_normalWorldOnB=H.prototype.ia=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Uf(c,b);};Object.defineProperty(H.prototype,"m_normalWorldOnB",{get:H.prototype.K,set:H.prototype.ia});H.prototype.get_m_distance1=H.prototype.A=function(){return Vf(this.a)};H.prototype.set_m_distance1=H.prototype.$=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Wf(c,b);};Object.defineProperty(H.prototype,"m_distance1",{get:H.prototype.A,set:H.prototype.$});
            H.prototype.get_m_index0=H.prototype.D=function(){return Xf(this.a)};H.prototype.set_m_index0=H.prototype.ca=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Yf(c,b);};Object.defineProperty(H.prototype,"m_index0",{get:H.prototype.D,set:H.prototype.ca});H.prototype.get_m_index1=H.prototype.F=function(){return Zf(this.a)};H.prototype.set_m_index1=H.prototype.da=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);$f(c,b);};Object.defineProperty(H.prototype,"m_index1",{get:H.prototype.F,set:H.prototype.da});
            H.prototype.__destroy__=function(){ag(this.a);};function Tn(){this.a=bg();h(Tn)[this.a]=this;}Tn.prototype=Object.create(f.prototype);Tn.prototype.constructor=Tn;Tn.prototype.b=Tn;Tn.c={};a.btSequentialImpulseConstraintSolver=Tn;Tn.prototype.__destroy__=function(){cg(this.a);};
            function I(b,c,d,e){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);this.a=void 0===d?dg(b,c):void 0===e?_a257_3(b,c,d):eg(b,c,d,e);h(I)[this.a]=this;}I.prototype=Object.create(Mn.prototype);I.prototype.constructor=I;I.prototype.b=I;I.c={};a.btPoint2PointConstraint=I;I.prototype.setPivotA=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);fg(c,b);};
            I.prototype.setPivotB=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);gg(c,b);};I.prototype.getPivotInA=function(){return k(hg(this.a),m)};I.prototype.getPivotInB=function(){return k(ig(this.a),m)};I.prototype.enableFeedback=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);jg(c,b);};I.prototype.getBreakingImpulseThreshold=function(){return kg(this.a)};I.prototype.setBreakingImpulseThreshold=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);lg(c,b);};
            I.prototype.getParam=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);return mg(d,b,c)};I.prototype.setParam=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);ng(e,b,c,d);};I.prototype.get_m_setting=I.prototype.R=function(){return k(og(this.a),J)};I.prototype.set_m_setting=I.prototype.oa=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);pg(c,b);};
            Object.defineProperty(I.prototype,"m_setting",{get:I.prototype.R,set:I.prototype.oa});I.prototype.__destroy__=function(){qg(this.a);};function K(b,c){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);this.a=void 0===c?rg(b):sg(b,c);h(K)[this.a]=this;}K.prototype=Object.create(p.prototype);K.prototype.constructor=K;K.prototype.b=K;K.c={};a.btConvexTriangleMeshShape=K;K.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);tg(c,b);};
            K.prototype.getLocalScaling=function(){return k(ug(this.a),m)};K.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);vg(d,b,c);};K.prototype.setMargin=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);wg(c,b);};K.prototype.getMargin=function(){return xg(this.a)};K.prototype.isCompound=function(){return !!yg(this.a)};K.prototype.getUserIndex=function(){return zg(this.a)};
            K.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ag(c,b);};K.prototype.getUserPointerAsInt=function(){return Bg(this.a)};K.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Cg(c,b);};K.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Dg(e,b,c,d);};K.prototype.getLocalBoundingSphere=function(){return Eg(this.a)};K.prototype.__destroy__=function(){Fg(this.a);};
            function L(b,c){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);this.a=Gg(b,c);h(L)[this.a]=this;}L.prototype=Object.create(z.prototype);L.prototype.constructor=L;L.prototype.b=L;L.c={};a.ccClosestRayResultCallback=L;L.prototype.getHitNormalWorld=function(){return k(Hg(this.a),m)};L.prototype.getHitPointWorld=function(){return k(Ig(this.a),m)};L.prototype.getCollisionShapePtr=function(){return Jg(this.a)};L.prototype.getClosestHitFraction=function(){return Kg(this.a)};
            L.prototype.reset=L.prototype.reset=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Lg(d,b,c);};L.prototype.hasHit=function(){return !!Mg(this.a)};L.prototype.get_m_rayFromWorld=L.prototype.f=function(){return k(Ng(this.a),m)};L.prototype.set_m_rayFromWorld=L.prototype.h=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Og(c,b);};Object.defineProperty(L.prototype,"m_rayFromWorld",{get:L.prototype.f,set:L.prototype.h});
            L.prototype.get_m_rayToWorld=L.prototype.g=function(){return k(Pg(this.a),m)};L.prototype.set_m_rayToWorld=L.prototype.i=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Qg(c,b);};Object.defineProperty(L.prototype,"m_rayToWorld",{get:L.prototype.g,set:L.prototype.i});L.prototype.__destroy__=function(){Rg(this.a);};
            function M(b,c,d,e,g,n,Q,Ia,Qa){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);g&&"object"===typeof g&&(g=g.a);n&&"object"===typeof n&&(n=n.a);Q&&"object"===typeof Q&&(Q=Q.a);Ia&&"object"===typeof Ia&&(Ia=Ia.a);Qa&&"object"===typeof Qa&&(Qa=Qa.a);this.a=Sg(b,c,d,e,g,n,Q,Ia,Qa);h(M)[this.a]=this;}M.prototype=Object.create(t.prototype);M.prototype.constructor=M;M.prototype.b=M;M.c={};a.btHeightfieldTerrainShape=M;
            M.prototype.setMargin=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Tg(c,b);};M.prototype.getMargin=function(){return Ug(this.a)};M.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Vg(c,b);};M.prototype.getLocalScaling=function(){return k(Wg(this.a),m)};M.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Xg(d,b,c);};M.prototype.isCompound=function(){return !!Yg(this.a)};
            M.prototype.getUserIndex=function(){return Zg(this.a)};M.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);$g(c,b);};M.prototype.getUserPointerAsInt=function(){return ah(this.a)};M.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);bh(c,b);};M.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);ch(e,b,c,d);};M.prototype.getLocalBoundingSphere=function(){return dh(this.a)};
            M.prototype.__destroy__=function(){eh(this.a);};function Un(){throw "cannot construct a VoidPtr, no constructor in IDL";}Un.prototype=Object.create(f.prototype);Un.prototype.constructor=Un;Un.prototype.b=Un;Un.c={};a.VoidPtr=Un;Un.prototype.__destroy__=function(){fh(this.a);};function Vn(b){b&&"object"===typeof b&&(b=b.a);this.a=void 0===b?gh():hh(b);h(Vn)[this.a]=this;}Vn.prototype=Object.create(f.prototype);Vn.prototype.constructor=Vn;Vn.prototype.b=Vn;Vn.c={};a.btDefaultCollisionConfiguration=Vn;
            Vn.prototype.__destroy__=function(){ih(this.a);};function Wn(b,c){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);this.a=void 0===b?jh():void 0===c?kh(b):lh(b,c);h(Wn)[this.a]=this;}Wn.prototype=Object.create(Hn.prototype);Wn.prototype.constructor=Wn;Wn.prototype.b=Wn;Wn.c={};a.btTriangleMesh=Wn;
            Wn.prototype.addTriangle=function(b,c,d,e){var g=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);void 0===e?mh(g,b,c,d):nh(g,b,c,d,e);};Wn.prototype.addTriangleIndices=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);oh(e,b,c,d);};Wn.prototype.getIndexedMeshArray=function(){return k(ph(this.a),Xn)};
            Wn.prototype.setScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);qh(c,b);};Wn.prototype.__destroy__=function(){rh(this.a);};function Yn(){throw "cannot construct a btCollisionConfiguration, no constructor in IDL";}Yn.prototype=Object.create(f.prototype);Yn.prototype.constructor=Yn;Yn.prototype.b=Yn;Yn.c={};a.btCollisionConfiguration=Yn;Yn.prototype.__destroy__=function(){sh(this.a);};function Ln(){this.a=th();h(Ln)[this.a]=this;}Ln.prototype=Object.create(f.prototype);
            Ln.prototype.constructor=Ln;Ln.prototype.b=Ln;Ln.c={};a.btPersistentManifold=Ln;Ln.prototype.getBody0=function(){return k(uh(this.a),u)};Ln.prototype.getBody1=function(){return k(vh(this.a),u)};Ln.prototype.getNumContacts=function(){return wh(this.a)};Ln.prototype.getContactPoint=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);return k(xh(c,b),H)};Ln.prototype.__destroy__=function(){yh(this.a);};function N(b){b&&"object"===typeof b&&(b=b.a);this.a=zh(b);h(N)[this.a]=this;}N.prototype=Object.create(x.prototype);
            N.prototype.constructor=N;N.prototype.b=N;N.c={};a.btBoxShape=N;N.prototype.setMargin=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ah(c,b);};N.prototype.getMargin=function(){return Bh(this.a)};N.prototype.setUnscaledHalfExtents=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ch(c,b);};N.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Dh(c,b);};N.prototype.getLocalScaling=function(){return k(Eh(this.a),m)};
            N.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Fh(d,b,c);};N.prototype.isCompound=function(){return !!Gh(this.a)};N.prototype.getUserIndex=function(){return Hh(this.a)};N.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ih(c,b);};N.prototype.getUserPointerAsInt=function(){return Jh(this.a)};N.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Kh(c,b);};
            N.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Lh(e,b,c,d);};N.prototype.getLocalBoundingSphere=function(){return Mh(this.a)};N.prototype.getImplicitShapeDimensions=function(){return k(Nh(this.a),m)};N.prototype.__destroy__=function(){Oh(this.a);};function Zn(b){b&&"object"===typeof b&&(b=b.a);this.a=Ph(b);h(Zn)[this.a]=this;}Zn.prototype=Object.create(Kn.prototype);Zn.prototype.constructor=Zn;
            Zn.prototype.b=Zn;Zn.c={};a.btCollisionDispatcher=Zn;Zn.prototype.setDispatcherFlags=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Qh(c,b);};Zn.prototype.getNumManifolds=function(){return Rh(this.a)};Zn.prototype.getManifoldByIndexInternal=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);return k(Sh(c,b),Ln)};Zn.prototype.__destroy__=function(){Th(this.a);};function O(b){b&&"object"===typeof b&&(b=b.a);this.a=void 0===b?Uh():Vh(b);h(O)[this.a]=this;}O.prototype=Object.create(l.prototype);
            O.prototype.constructor=O;O.prototype.b=O;O.c={};a.btCompoundShape=O;O.prototype.addChildShape=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Wh(d,b,c);};O.prototype.removeChildShape=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Xh(c,b);};O.prototype.removeChildShapeByIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Yh(c,b);};O.prototype.getNumChildShapes=function(){return Zh(this.a)};
            O.prototype.getChildShape=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);return k($h(c,b),l)};O.prototype.updateChildTransform=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);void 0===d?ai(e,b,c):bi(e,b,c,d);};O.prototype.setMargin=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ci(c,b);};O.prototype.getMargin=function(){return di(this.a)};
            O.prototype.setMaterial=function(b,c,d,e,g,n){var Q=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);g&&"object"===typeof g&&(g=g.a);n&&"object"===typeof n&&(n=n.a);void 0===e?ei(Q,b,c,d):void 0===g?fi(Q,b,c,d,e):void 0===n?gi(Q,b,c,d,e,g):hi(Q,b,c,d,e,g,n);};O.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ii(c,b);};O.prototype.getLocalScaling=function(){return k(ji(this.a),m)};
            O.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);ki(d,b,c);};O.prototype.isCompound=function(){return !!li(this.a)};O.prototype.getUserIndex=function(){return mi(this.a)};O.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ni(c,b);};O.prototype.getUserPointerAsInt=function(){return oi(this.a)};O.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);pi(c,b);};
            O.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);qi(e,b,c,d);};O.prototype.getLocalBoundingSphere=function(){return ri(this.a)};O.prototype.__destroy__=function(){si(this.a);};function $n(b,c){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);this.a=void 0===b?ti():void 0===c?ui(b):vi(b,c);h($n)[this.a]=this;}$n.prototype=Object.create(Jn.prototype);$n.prototype.constructor=$n;
            $n.prototype.b=$n;$n.c={};a.btDefaultMotionState=$n;$n.prototype.getWorldTransform=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);wi(c,b);};$n.prototype.setWorldTransform=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);xi(c,b);};$n.prototype.__destroy__=function(){yi(this.a);};
            function P(b,c,d,e,g){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);g&&"object"===typeof g&&(g=g.a);this.a=void 0===g?zi(b,c,d,e):Ai(b,c,d,e,g);h(P)[this.a]=this;}P.prototype=Object.create(Mn.prototype);P.prototype.constructor=P;P.prototype.b=P;P.c={};a.btHingeConstraint=P;
            P.prototype.setLimit=function(b,c,d,e,g){var n=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);g&&"object"===typeof g&&(g=g.a);void 0===g?Bi(n,b,c,d,e):Ci(n,b,c,d,e,g);};P.prototype.enableAngularMotor=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Di(e,b,c,d);};
            P.prototype.setAngularOnly=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ei(c,b);};P.prototype.enableMotor=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Fi(c,b);};P.prototype.setMaxMotorImpulse=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Gi(c,b);};P.prototype.setMotorTarget=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Hi(d,b,c);};
            P.prototype.setFrames=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Ii(d,b,c);};P.prototype.setAxis=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ji(c,b);};P.prototype.setUseReferenceFrameA=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ki(c,b);};P.prototype.enableFeedback=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Li(c,b);};P.prototype.getBreakingImpulseThreshold=function(){return Mi(this.a)};
            P.prototype.setBreakingImpulseThreshold=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ni(c,b);};P.prototype.getParam=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);return Oi(d,b,c)};P.prototype.setParam=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Pi(e,b,c,d);};P.prototype.__destroy__=function(){Qi(this.a);};
            function R(b,c,d,e){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);this.a=Ri(b,c,d,e);h(R)[this.a]=this;}R.prototype=Object.create(B.prototype);R.prototype.constructor=R;R.prototype.b=R;R.c={};a.btQuaternion=R;R.prototype.setValue=function(b,c,d,e){var g=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);Si(g,b,c,d,e);};
            R.prototype.x=R.prototype.x=function(){return Ti(this.a)};R.prototype.y=R.prototype.y=function(){return Ui(this.a)};R.prototype.z=R.prototype.z=function(){return Vi(this.a)};R.prototype.w=function(){return Wi(this.a)};R.prototype.setX=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Xi(c,b);};R.prototype.setY=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Yi(c,b);};R.prototype.setZ=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Zi(c,b);};
            R.prototype.setW=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);$i(c,b);};R.prototype.__destroy__=function(){aj(this.a);};function S(b,c){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);this.a=bj(b,c);h(S)[this.a]=this;}S.prototype=Object.create(x.prototype);S.prototype.constructor=S;S.prototype.b=S;S.c={};a.btConeShape=S;S.prototype.setRadius=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);cj(c,b);};
            S.prototype.setHeight=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);dj(c,b);};S.prototype.setConeUpIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ej(c,b);};S.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);fj(c,b);};S.prototype.getLocalScaling=function(){return k(gj(this.a),m)};S.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);hj(d,b,c);};S.prototype.isCompound=function(){return !!ij(this.a)};
            S.prototype.getUserIndex=function(){return jj(this.a)};S.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);kj(c,b);};S.prototype.getUserPointerAsInt=function(){return lj(this.a)};S.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);mj(c,b);};S.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);nj(e,b,c,d);};S.prototype.getLocalBoundingSphere=function(){return oj(this.a)};
            S.prototype.getImplicitShapeDimensions=function(){return k(pj(this.a),m)};S.prototype.__destroy__=function(){qj(this.a);};function T(){this.a=rj();h(T)[this.a]=this;}T.prototype=Object.create(p.prototype);T.prototype.constructor=T;T.prototype.b=T;T.c={};a.btBU_Simplex1to4=T;T.prototype.addVertex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);sj(c,b);};T.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);tj(c,b);};
            T.prototype.getLocalScaling=function(){return k(uj(this.a),m)};T.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);vj(d,b,c);};T.prototype.isCompound=function(){return !!wj(this.a)};T.prototype.getUserIndex=function(){return xj(this.a)};T.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);yj(c,b);};T.prototype.getUserPointerAsInt=function(){return zj(this.a)};
            T.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Aj(c,b);};T.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Bj(e,b,c,d);};T.prototype.getLocalBoundingSphere=function(){return Cj(this.a)};T.prototype.__destroy__=function(){Dj(this.a);};function U(b,c){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);this.a=Ej(b,c);h(U)[this.a]=this;}U.prototype=Object.create(t.prototype);
            U.prototype.constructor=U;U.prototype.b=U;U.c={};a.btStaticPlaneShape=U;U.prototype.getPlaneNormal=function(){return k(Fj(this.a),m)};U.prototype.setPlaneConstant=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Gj(c,b);};U.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Hj(c,b);};U.prototype.getLocalScaling=function(){return k(Ij(this.a),m)};
            U.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Jj(d,b,c);};U.prototype.isCompound=function(){return !!Kj(this.a)};U.prototype.getUserIndex=function(){return Lj(this.a)};U.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Mj(c,b);};U.prototype.getUserPointerAsInt=function(){return Nj(this.a)};U.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Oj(c,b);};
            U.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Pj(e,b,c,d);};U.prototype.getLocalBoundingSphere=function(){return Qj(this.a)};U.prototype.__destroy__=function(){Rj(this.a);};function ao(){throw "cannot construct a btActionInterface, no constructor in IDL";}ao.prototype=Object.create(f.prototype);ao.prototype.constructor=ao;ao.prototype.b=ao;ao.c={};a.btActionInterface=ao;
            ao.prototype.updateAction=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Sj(d,b,c);};ao.prototype.__destroy__=function(){Tj(this.a);};function bo(){throw "cannot construct a btOverlappingPairCache, no constructor in IDL";}bo.prototype=Object.create(f.prototype);bo.prototype.constructor=bo;bo.prototype.b=bo;bo.c={};a.btOverlappingPairCache=bo;bo.prototype.__destroy__=function(){Uj(this.a);};
            function m(b,c,d){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);this.a=void 0===b?Vj():void 0===c?_a445_1(b):void 0===d?_a445_2(b,c):Wj(b,c,d);h(m)[this.a]=this;}m.prototype=Object.create(f.prototype);m.prototype.constructor=m;m.prototype.b=m;m.c={};a.btVector3=m;m.prototype.x=m.prototype.x=function(){return Xj(this.a)};m.prototype.y=m.prototype.y=function(){return Yj(this.a)};m.prototype.z=m.prototype.z=function(){return Zj(this.a)};
            m.prototype.setX=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ak(c,b);};m.prototype.setY=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);bk(c,b);};m.prototype.setZ=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ck(c,b);};m.prototype.setValue=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);dk(e,b,c,d);};m.prototype.__destroy__=function(){ek(this.a);};
            function V(b){b&&"object"===typeof b&&(b=b.a);this.a=fk(b);h(V)[this.a]=this;}V.prototype=Object.create(x.prototype);V.prototype.constructor=V;V.prototype.b=V;V.c={};a.btSphereShape=V;V.prototype.setMargin=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);gk(c,b);};V.prototype.getMargin=function(){return hk(this.a)};V.prototype.setUnscaledRadius=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ik(c,b);};
            V.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);jk(c,b);};V.prototype.getLocalScaling=function(){return k(kk(this.a),m)};V.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);lk(d,b,c);};V.prototype.isCompound=function(){return !!mk(this.a)};V.prototype.getUserIndex=function(){return nk(this.a)};V.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ok(c,b);};
            V.prototype.getUserPointerAsInt=function(){return pk(this.a)};V.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);qk(c,b);};V.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);rk(e,b,c,d);};V.prototype.getLocalBoundingSphere=function(){return sk(this.a)};V.prototype.getImplicitShapeDimensions=function(){return k(tk(this.a),m)};V.prototype.__destroy__=function(){uk(this.a);};
            function co(){this.a=vk();h(co)[this.a]=this;}co.prototype=Object.create(f.prototype);co.prototype.constructor=co;co.prototype.b=co;co.c={};a.btDefaultCollisionConstructionInfo=co;co.prototype.__destroy__=function(){wk(this.a);};function W(){this.a=xk();h(W)[this.a]=this;}W.prototype=Object.create(t.prototype);W.prototype.constructor=W;W.prototype.b=W;W.c={};a.btEmptyShape=W;W.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);yk(c,b);};
            W.prototype.getLocalScaling=function(){return k(zk(this.a),m)};W.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Ak(d,b,c);};W.prototype.isCompound=function(){return !!Bk(this.a)};W.prototype.getUserIndex=function(){return Ck(this.a)};W.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Dk(c,b);};W.prototype.getUserPointerAsInt=function(){return Ek(this.a)};
            W.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Fk(c,b);};W.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);Gk(e,b,c,d);};W.prototype.getLocalBoundingSphere=function(){return Hk(this.a)};W.prototype.__destroy__=function(){Ik(this.a);};function J(){this.a=Jk();h(J)[this.a]=this;}J.prototype=Object.create(f.prototype);J.prototype.constructor=J;J.prototype.b=J;J.c={};
            a.btConstraintSetting=J;J.prototype.get_m_tau=J.prototype.T=function(){return Kk(this.a)};J.prototype.set_m_tau=J.prototype.qa=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Lk(c,b);};Object.defineProperty(J.prototype,"m_tau",{get:J.prototype.T,set:J.prototype.qa});J.prototype.get_m_damping=J.prototype.v=function(){return Mk(this.a)};J.prototype.set_m_damping=J.prototype.Z=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Nk(c,b);};
            Object.defineProperty(J.prototype,"m_damping",{get:J.prototype.v,set:J.prototype.Z});J.prototype.get_m_impulseClamp=J.prototype.C=function(){return Ok(this.a)};J.prototype.set_m_impulseClamp=J.prototype.ba=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Pk(c,b);};Object.defineProperty(J.prototype,"m_impulseClamp",{get:J.prototype.C,set:J.prototype.ba});J.prototype.__destroy__=function(){Qk(this.a);};function X(){throw "cannot construct a LocalShapeInfo, no constructor in IDL";}X.prototype=Object.create(f.prototype);
            X.prototype.constructor=X;X.prototype.b=X;X.c={};a.LocalShapeInfo=X;X.prototype.get_m_shapePart=X.prototype.S=function(){return Rk(this.a)};X.prototype.set_m_shapePart=X.prototype.pa=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Sk(c,b);};Object.defineProperty(X.prototype,"m_shapePart",{get:X.prototype.S,set:X.prototype.pa});X.prototype.get_m_triangleIndex=X.prototype.U=function(){return Tk(this.a)};
            X.prototype.set_m_triangleIndex=X.prototype.ra=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Uk(c,b);};Object.defineProperty(X.prototype,"m_triangleIndex",{get:X.prototype.U,set:X.prototype.ra});X.prototype.__destroy__=function(){Vk(this.a);};function Rn(){throw "cannot construct a btVector3Array, no constructor in IDL";}Rn.prototype=Object.create(f.prototype);Rn.prototype.constructor=Rn;Rn.prototype.b=Rn;Rn.c={};a.btVector3Array=Rn;Rn.prototype.size=Rn.prototype.size=function(){return Wk(this.a)};
            Rn.prototype.at=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);return k(Xk(c,b),m)};Rn.prototype.clear=Rn.prototype.clear=function(){Yk(this.a);};Rn.prototype.__destroy__=function(){Zk(this.a);};function eo(){throw "cannot construct a btConstraintSolver, no constructor in IDL";}eo.prototype=Object.create(f.prototype);eo.prototype.constructor=eo;eo.prototype.b=eo;eo.c={};a.btConstraintSolver=eo;eo.prototype.__destroy__=function(){$k(this.a);};
            function fo(b,c,d,e){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);this.a=al(b,c,d,e);h(fo)[this.a]=this;}fo.prototype=Object.create(Mn.prototype);fo.prototype.constructor=fo;fo.prototype.b=fo;fo.c={};a.btFixedConstraint=fo;fo.prototype.enableFeedback=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);bl(c,b);};fo.prototype.getBreakingImpulseThreshold=function(){return cl(this.a)};
            fo.prototype.setBreakingImpulseThreshold=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);dl(c,b);};fo.prototype.getParam=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);return el(d,b,c)};fo.prototype.setParam=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);fl(e,b,c,d);};fo.prototype.__destroy__=function(){gl(this.a);};
            function r(b){b&&"object"===typeof b&&(b=b.a);this.a=hl(b);h(r)[this.a]=this;}r.prototype=Object.create(u.prototype);r.prototype.constructor=r;r.prototype.b=r;r.c={};a.btRigidBody=r;r.prototype.getCenterOfMassTransform=function(){return k(il(this.a),v)};r.prototype.setCenterOfMassTransform=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);jl(c,b);};r.prototype.setSleepingThresholds=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);kl(d,b,c);};
            r.prototype.getLinearSleepingThreshold=function(){return ll(this.a)};r.prototype.setDamping=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);ml(d,b,c);};r.prototype.setMassProps=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);nl(d,b,c);};r.prototype.getLinearFactor=function(){return k(ol(this.a),m)};r.prototype.setLinearFactor=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);pl(c,b);};
            r.prototype.applyTorque=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ql(c,b);};r.prototype.applyForce=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);rl(d,b,c);};r.prototype.applyCentralForce=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);sl(c,b);};r.prototype.applyTorqueImpulse=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);tl(c,b);};
            r.prototype.applyImpulse=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);ul(d,b,c);};r.prototype.updateInertiaTensor=function(){vl(this.a);};r.prototype.getLinearVelocity=function(){return k(wl(this.a),m)};r.prototype.getAngularVelocity=function(){return k(xl(this.a),m)};r.prototype.setLinearVelocity=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);yl(c,b);};
            r.prototype.setAngularVelocity=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);zl(c,b);};r.prototype.getMotionState=function(){return k(Al(this.a),Jn)};r.prototype.getAngularFactor=function(){return k(Bl(this.a),m)};r.prototype.setAngularFactor=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Cl(c,b);};r.prototype.getAabb=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);Dl(d,b,c);};
            r.prototype.setGravity=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);El(c,b);};r.prototype.getFlags=function(){return Fl(this.a)};r.prototype.setFlags=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Gl(c,b);};r.prototype.wantsSleeping=function(){return !!Hl(this.a)};r.prototype.clearForces=function(){Il(this.a);};r.prototype.getTotalForce=function(){return k(Jl(this.a),m)};r.prototype.getTotalTorque=function(){return k(Kl(this.a),m)};r.prototype.clearState=function(){Ll(this.a);};
            r.prototype.getCollisionShape=function(){return k(Ml(this.a),l)};r.prototype.getActivationState=function(){return Nl(this.a)};r.prototype.setActivationState=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Ol(c,b);};r.prototype.forceActivationState=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Pl(c,b);};r.prototype.activate=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);void 0===b?Ql(c):Rl(c,b);};r.prototype.isActive=function(){return !!Sl(this.a)};
            r.prototype.isKinematicObject=function(){return !!Tl(this.a)};r.prototype.isStaticObject=function(){return !!Ul(this.a)};r.prototype.isStaticOrKinematicObject=function(){return !!Vl(this.a)};r.prototype.setRestitution=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Wl(c,b);};r.prototype.setFriction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Xl(c,b);};r.prototype.setRollingFriction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Yl(c,b);};
            r.prototype.setSpinningFriction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Zl(c,b);};r.prototype.getWorldTransform=function(){return k($l(this.a),v)};r.prototype.getCollisionFlags=function(){return am(this.a)};r.prototype.setCollisionFlags=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);bm(c,b);};r.prototype.setWorldTransform=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);cm(c,b);};
            r.prototype.setCollisionShape=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);dm(c,b);};r.prototype.setCcdMotionThreshold=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);em(c,b);};r.prototype.setCcdSweptSphereRadius=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);fm(c,b);};r.prototype.getUserIndex=function(){return gm(this.a)};r.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);hm(c,b);};
            r.prototype.setUserIndex2=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);im(c,b);};r.prototype.setIgnoreCollisionCheck=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);jm(d,b,c);};r.prototype.__destroy__=function(){km(this.a);};function Xn(){throw "cannot construct a btIndexedMeshArray, no constructor in IDL";}Xn.prototype=Object.create(f.prototype);Xn.prototype.constructor=Xn;Xn.prototype.b=Xn;Xn.c={};a.btIndexedMeshArray=Xn;
            Xn.prototype.size=Xn.prototype.size=function(){return lm(this.a)};Xn.prototype.at=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);return k(mm(c,b),Sn)};Xn.prototype.__destroy__=function(){nm(this.a);};function Y(b,c,d,e){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);this.a=om(b,c,d,e);h(Y)[this.a]=this;}Y.prototype=Object.create(w.prototype);Y.prototype.constructor=Y;Y.prototype.b=Y;Y.c={};
            a.ccDiscreteDynamicsWorld=Y;Y.prototype.setAllowSleep=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);pm(c,b);};Y.prototype.setDeactivationTime=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);qm(c,b);};Y.prototype.setNarrowPhaseMethod=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);rm(c,b);};Y.prototype.setAllowCcdPenetration=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);sm(c,b);};
            Y.prototype.setCcdCastCheckResponse=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);tm(c,b);};Y.prototype.getCcdTriggerRecorder=function(){return k(um(this.a),Qn)};Y.prototype.rayTest=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);vm(e,b,c,d);};
            Y.prototype.rayTestSingle=function(b,c,d,e,g,n){var Q=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);e&&"object"===typeof e&&(e=e.a);g&&"object"===typeof g&&(g=g.a);n&&"object"===typeof n&&(n=n.a);wm(Q,b,c,d,e,g,n);};Y.prototype.addCollisionObject=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);void 0===c?xm(e,b):void 0===d?ym(e,b,c):zm(e,b,c,d);};
            Y.prototype.removeCollisionObject=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Am(c,b);};Y.prototype.setContactBreakingThreshold=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Bm(c,b);};Y.prototype.setGravity=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Cm(c,b);};Y.prototype.getGravity=function(){return k(Dm(this.a),m)};
            Y.prototype.addRigidBody=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);void 0===c?Em(e,b):void 0===d?_a582_2(e,b,c):Fm(e,b,c,d);};Y.prototype.removeRigidBody=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Gm(c,b);};Y.prototype.addConstraint=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);void 0===c?Hm(d,b):Im(d,b,c);};
            Y.prototype.removeConstraint=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Jm(c,b);};Y.prototype.stepSimulation=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);return void 0===c?Km(e,b):void 0===d?Lm(e,b,c):Mm(e,b,c,d)};Y.prototype.addAction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Nm(c,b);};Y.prototype.removeAction=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Om(c,b);};
            Y.prototype.getFixedBody=function(){return k(Pm(this.a),r)};Y.prototype.__destroy__=function(){Qm(this.a);};function v(b,c){b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);this.a=void 0===b?Rm():void 0===c?_a591_1(b):Sm(b,c);h(v)[this.a]=this;}v.prototype=Object.create(f.prototype);v.prototype.constructor=v;v.prototype.b=v;v.c={};a.btTransform=v;v.prototype.setIdentity=function(){Tm(this.a);};v.prototype.setOrigin=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Um(c,b);};
            v.prototype.setRotation=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);Vm(c,b);};v.prototype.getOrigin=function(){return k(Wm(this.a),m)};v.prototype.getRotation=function(){return k(Xm(this.a),R)};v.prototype.getBasis=function(){return k(Ym(this.a),Nn)};v.prototype.inverse=v.prototype.inverse=function(){return k(Zm(this.a),v)};v.prototype.op_mul=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);return k($m(c,b),v)};v.prototype.__destroy__=function(){an(this.a);};
            function Z(b){b&&"object"===typeof b&&(b=b.a);this.a=bn(b);h(Z)[this.a]=this;}Z.prototype=Object.create(x.prototype);Z.prototype.constructor=Z;Z.prototype.b=Z;Z.c={};a.btCylinderShape=Z;Z.prototype.setMargin=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);cn(c,b);};Z.prototype.getMargin=function(){return dn(this.a)};Z.prototype.updateProp=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);en(e,b,c,d);};
            Z.prototype.setLocalScaling=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);fn(c,b);};Z.prototype.getLocalScaling=function(){return k(gn(this.a),m)};Z.prototype.calculateLocalInertia=function(b,c){var d=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);hn(d,b,c);};Z.prototype.isCompound=function(){return !!jn(this.a)};Z.prototype.getUserIndex=function(){return kn(this.a)};Z.prototype.setUserIndex=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);ln(c,b);};
            Z.prototype.getUserPointerAsInt=function(){return mn(this.a)};Z.prototype.setUserPointerAsInt=function(b){var c=this.a;b&&"object"===typeof b&&(b=b.a);nn(c,b);};Z.prototype.getAabb=function(b,c,d){var e=this.a;b&&"object"===typeof b&&(b=b.a);c&&"object"===typeof c&&(c=c.a);d&&"object"===typeof d&&(d=d.a);on(e,b,c,d);};Z.prototype.getLocalBoundingSphere=function(){return pn(this.a)};Z.prototype.getImplicitShapeDimensions=function(){return k(qn(this.a),m)};Z.prototype.__destroy__=function(){rn(this.a);};
            (function(){function b(){a.BT_CONSTRAINT_ERP=sn();a.BT_CONSTRAINT_STOP_ERP=tn();a.BT_CONSTRAINT_CFM=un();a.BT_CONSTRAINT_STOP_CFM=vn();a.PHY_FLOAT=wn();a.PHY_DOUBLE=xn();a.PHY_INTEGER=yn();a.PHY_SHORT=zn();a.PHY_FIXEDPOINT88=An();a.PHY_UCHAR=Bn();}Ja?b():Ga.unshift(b);})();this.Ammo=a;


              return Ammo.ready
            }
            );
            })();
            module.exports = Ammo;
            });

            const isWasm = false;
            const wasmBinaryURL = '';

            const Ammo = exports('dS', {});
            function waitForAmmoInstantiation(wasmBinary) {
              const ammoClosureThis = {};

              if (typeof wasmBinary !== 'undefined') {
                {
                  Ammo.wasmBinary = wasmBinary;
                }
              }

              return new Promise((resolve, reject) => {
                ammo.call(ammoClosureThis, Ammo).then(() => {
                  resolve();
                });
              });
            }

            (function (_waitForAmmoInstantiation) {
              const isWasm$1 = _waitForAmmoInstantiation.isWasm = isWasm;
              const wasmBinaryURL$1 = _waitForAmmoInstantiation.wasmBinaryURL = wasmBinaryURL;
            })(waitForAmmoInstantiation || (waitForAmmoInstantiation = exports('gd', {})));

        }
    };
});
//# sourceMappingURL=instantiated-5fda9a87.js.map
